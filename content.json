{"meta":{"title":"才刚的博客","subtitle":"记录点点滴滴","description":"也许不能描绘将来，但愿记录此刻美好","author":"lcg","url":"https://618dt.github.io","root":"/"},"pages":[{"title":"我的相册","date":"2022-02-28T12:26:27.342Z","updated":"2022-02-28T12:26:27.342Z","comments":true,"path":"blog/album/index.html","permalink":"https://618dt.github.io/blog/album/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-23T10:39:52.165Z","updated":"2021-11-23T10:39:52.165Z","comments":true,"path":"404.html","permalink":"https://618dt.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-03-02T04:44:14.009Z","updated":"2022-03-02T04:44:14.009Z","comments":true,"path":"blog/about/index.html","permalink":"https://618dt.github.io/blog/about/index.html","excerpt":"","text":"关于小站关于我 2021-11-23 将主题改为了volantis增加了valine评论系统 2021-10-30 利用hexo+github搭建了静态博客使用的主题是简洁大方的next 2021-02-26 购买了域名www.gamest.link利用阿里云服务器,WP以及宝塔面板搭建了第一个博客由于服务器到期网站作废 我的名字:***兴趣爱好:音乐,电影,篮球;我所擅长:熟悉Java, Mybatis, Spring, SpringMVC, SpringCloud等单词的拼写;熟悉计算机的基本操作:如开机,重启等;我的缺点:不愿意说出自己的缺点(╹▽╹);自我评价:计算机类专业大三在读,虽然很菜,但热爱开源,热爱技术;希望能够在互联网上学到更多的技术,并且运用这些技术解决有挑战的问题;座右铭:桃李不言,下自成蹊"},{"title":"所有分类","date":"2022-02-23T11:51:24.384Z","updated":"2021-11-23T10:37:51.892Z","comments":true,"path":"blog/categories/index.html","permalink":"https://618dt.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-11-23T10:38:05.824Z","updated":"2021-11-23T10:38:05.823Z","comments":true,"path":"blog/tags/index.html","permalink":"https://618dt.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"医点通项目介绍","slug":"预约挂号平台项目","date":"2022-02-22T22:18:00.000Z","updated":"2022-03-04T04:16:58.274Z","comments":true,"path":"p/ea75.html","link":"","permalink":"https://618dt.github.io/p/ea75.html","excerpt":"","text":"一、项目简介与特点1.项目简介​ ◇医点通预约挂号系统是一项便民服务系统,一点即通,方便患者挂号就医! ​ ◇项目开发笔记 ​ ◇项目完整代码 2.项目特点 友好的代码结构及注释，便于阅读及二次开发 实现前后端分离，请求接口封装，错误码统一处理 前端采用Element-ui框架，极大的提高了开发效率 引入swagger文档支持，方便编写API接口文档 项目采用分布式架构，每个子项目可独立部署，扩展灵活，易于维护 使用NoSQL型数据库，将医院等不需要经常写操作的信息存储在MongoDB中，提高数据的查询速度 使用SpringCloudGateway进行统一网关校验和请求转发，并解决跨域问题3.项目业务流程◇项目业务流程如图： 二、项目模块介绍1.项目模块组成◇如下图所示，整个项目（appointment-parent）由多个子项目（service,common等）聚合而成，每个子项目各是一个独立可部署的JavaWeb项目（可以放到Tomcat中运行），各项目通过SpringCloud实现项目间服务调用，使得整个项目可以实现分布式部署。这种架构是分布式Java项目常采用的架构模型。◇其中common模块包括了项目所需的基础工具类，如全局异常类，统一返回结果状态信息类，Redis配置类，service模块所需的服务类等。hospital-manage是医院系统模块。service是各个微服务的父模块，包含了cmn数据字典服务，医院服务，短信服务，订单服务等。service_client模块包含了远程服务提供者提供者的服务接口。service_gateway是网关模块，配置有请求的统一转发，请求过滤等信息。 2.项目服务架构◇项目微服务架构图如下 三、项目主要技术1.前端技术◇Vue.js：是一套用于构建用户界面的渐进式JavaScript框架。 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。◇Element-ui：网站快速成型工具，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。◇Nuxt.js：基于 Vue.js 的轻量级应用框架,可用来创建服务端渲染 (SSR) 应用,也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特性。 2.后端技术2.1 开发框架◇SpringBoot：简化spring的搭建和开发过程的全新框架。◇MyBatis-Plus：一个MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 2.2 数据库◇MongoDB：一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。◇MySQL：关系型数据库。◇Redis：一个基于内存的高性能key-value数据库。 2.3 SpringCloud微服务◇Nacos：使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务的发现、管理、共享、组合更加容易。◇Gateway：为微服务架构提供一种简单而有效的统一的API路由管理方式。◇Feign：一个声明式的Web服务客户端，使用Feign可使得Web服务客户端的写入更加方便。 2.4 其他◇消息中间件RabbitMQ：一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。◇Api接口文档工具Swagger：一款RESTFUL接口的文档在线自动生成+功能测试功能软件。 四、项目主要功能1.用户模块1.1 登录注册以及认证◇用户首页，可以根据医院名称进行模糊查询，输入文字后可根据文字模糊查询出医院列表显示在下拉框中，点击可跳转至医院页面进行预约挂号。◇用户注册功能，可以使用邮箱和微信登录。◇登录成功后默认用户名为邮箱号，需要进行实名认证才能挂号。◇用户实名认证功能，通过填写姓名，证件信息以及证件照方式进行实名认证，由平台管理员进行认证审批。 1.2 用户就诊人管理◇用户就诊人管理，用户能够对就诊人进行基本的增删改查操作。◇添加就诊人的相关信息。◇实现省市区三级联动下拉框以便就诊人选择住址 1.3 预约挂号功能◇预约挂号功能，能够根据自身情况选择对应的医院科室进行预约挂号。◇点击剩余按钮后进入确认挂号页面，选择就诊人进行预约挂号。◇当点击确认挂号后能够收到邮件提醒，预约成功后不进行支付可以直接取消。◇预约成功跳转到待支付页面。◇使用微信支付◇支付成功后订单状态变为已支付。◇支付成功后取消预约能够进行全额退款，取消预约后也会有邮件提醒。 2.平台管理模块2.1 医院设置管理功能◇查看医院设置列表；能够进行分页显示，以及按医院名称，医院编号条件查询；医院设置即对平台上的医院进行相关信息的设置，如医院的api基础路径，用于和医院系统交互；医院方的联系人等；以及对医院的锁定删除等功能。◇医院设置添加◇医院设置修改，点击医院设置列表的修改操作就会跳转到编辑页面，并将数据回填。◇医院列表◇查看医院详情◇点击排班可以按日期、科室显示相关排班信息。 2.2 数据字典◇数据字典树形懒加载 2.2 用户管理功能◇用户列表◇用户审批列表◇用户信息查看 2.3 订单查看及统计功能◇平台能够查看所有的订单信息并且对订单数据进行统计。 3.医院系统模块◇医院设置功能;设置医院的编码、医院签名和统一预约挂号平台的基础路径；医院签名用于和挂号平台进行校验，基础路径即调用平台相关的接口路径。◇医院信息及上传医院信息功能，通过JSON数据的方式上传医院信息；若要修改医院信息，在医院编号不变的情况下重新添加数据即可。◇科室列表与上传科室功能；上传科室的方式也是通过JSON数据上传。◇医院排班列表以及上传排班功能和前面类似。 五、项目运行1.虚拟机◇启动虚拟机，在虚拟机中运行nacos、redis、mongoDB，rabbitMQ； 12345678910111213141516171819202122232425262728#启动nacos,目录:cd /usr/local/Nacos/nacos/bin[root@master bin]# sh startup.sh -m standalone/usr/java/jdk8u282-b08/bin/java -Xms512m -Xmx512m -Xmn256m -Dnacos.standalone=true -Djava.ext.dirs=/usr/java/jdk8u282-b08/jre/lib/ext:/usr/java/jdk8u282-b08/lib/ext:/usr/local/Nacos/nacos/plugins/cmdb:/usr/local/Nacos/nacos/plugins/mysql -Xloggc:/usr/local/Nacos/nacos/logs/nacos_gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -Dnacos.home=/usr/local/Nacos/nacos -Dloader.path=/usr/local/Nacos/nacos/plugins/health -jar /usr/local/Nacos/nacos/target/nacos-server.jar --spring.config.location=classpath:/,classpath:/config/,file:./,file:./config/,file:/usr/local/Nacos/nacos/conf/ --logging.config=/usr/local/Nacos/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288nacos is starting with standalonenacos is starting，you can check the /usr/local/Nacos/nacos/logs/start.out#启动redis,目录:cd /usr/local/redis-5.0.0/bin[root@master bin]# ./redis-server redis.conf1917:C 20 Feb 2022 18:06:36.715 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1917:C 20 Feb 2022 18:06:36.715 # Redis version=5.0.0, bits=64, commit=00000000, modified=0, pid=1917, just started1917:C 20 Feb 2022 18:06:36.715 # Configuration loaded#启动mongoDB和rabbitMQ#启动docker 任意目录[root@master bin]# systemctl start docker#进入mongoDB[root@master bin]# docker exec -it mymongo /bin/bashroot@d9a024b9bffc:/# mongo&gt; show dbsadmin 0.000GBappointment_hosp 0.001GBconfig 0.000GBlocal 0.000GBtest 0.000GB&gt; #rabbitmq[root@master bin]# docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:managementa4f4c63a827bc83627289f42cada49f12f8d2d7c69af07be80e74ca12cb4ab0a#docker ps -a 查看容器列表; docker start xxxxxx --启动已经建立的容器号[root@master bin]# ◇如果Xshell突然连接不上虚拟机查看22端口是否放行 123456789101112#启动防火墙[root@master bin]# systemctl start firewalld#查看端口8848是否放行,no表示未放行[root@master bin]# firewall-cmd --query-port=20/tcpno#放行8848端口[root@master bin]# firewall-cmd --add-port=20/tcp --permanentsuccess#重启防火墙服务[root@master bin]# firewall-cmd --reloadsuccess[root@master bin]# ◇或者是因为使用任务管理器强制退出VM时，导致虚拟机网络配置被重置，需要重新配置网络；具体方法见Centos7虚拟机安装，本机的配置文件为ens32； 2.后端项目◇运行service模块中各个子模块的启动类；运行hospital-manage模块的启动类；◇解决端口占用(在cmd中) 123456789#查看占用端口的进程号C:\\Users\\ASUS&gt;netstat -ano|findstr &quot;8201&quot; TCP 0.0.0.0:8201 0.0.0.0:0 LISTENING 16488 TCP [::]:8201 [::]:0 LISTENING 16488#查看进程详情tasklist|findstr 16488#终止进程 /F 指定强制终止进程,/T 终止指定的进程和由它启用的子进程C:\\Users\\ASUS&gt;taskkill /pid 16488 /F成功: 已终止 PID 为 16488 的进程。 3.前端项目◇启动命令:npm run dev 六、BUG修改1.用户前端页面报错◇打开用户前端页面报错如下，◇报错原因，因为在用户前端的首页index.vue中数据是异步渲染的，报错是因为没有获取到数据，检查后发现是因为后台网关服务模块没有启动； 2.阿里云oss上传文件◇获取不到阿里云oss上传文件的url，需要设置跨域规则； 3.请求医院接口报错◇原因，医院系统的端口为9998；在数据库中将端口改为9998即可； 4.调用OrderMapper接口方法报错◇在统计预约挂号信息时，service-order模块报错如下，提示找不到OrderMapper； 12org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.lcg.appointment.order.mapper.OrderMapper.selectOrderCount ◇当仔细比对相关路径后，发现还是报错；查看博客发现是因为mybatis的配置文件默认应当放入resource目录下，但是这里将配置文件放在了java目录下，所以无法导出配置文件，进而在target文件夹中没有mapper的配置文件； ◇解决方法，需要手动配置资源过滤，让它把java目录下的properties和xml等配置文件的过滤开启，使它们能够被导出，统一在service模块下的pom.xml配置文件中开启过滤； 12345678910111213141516171819202122232425262728&lt;!--在build中配置resource,来防止资源导出失败问题--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; ◇配置好后，clean一下service-order模块◇然后重新启动order模块，可以看到mapper配置文件存在了 5.Feign调用报错◇Feign调用时报错，需要在统计模块中远程调用订单模块接口获取订单列表，测试时发现如下错误； 12feign.codec.DecodeException: Type definition error: [simple type, class com.baomidou.mybatisplus.core.metadata.IPage]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.baomidou.mybatisplus.core.metadata.IPage` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information at [Source: (PushbackInputStream); line: 1, column: 1] ◇报错原因，feign返回复杂对象时需要有无参构造函数，而在MyBatis-Plus中，IPage是接口，而Page是其实现类，所以解决方法是将IPage接口对象转换为Page。 123456789@PostMapping(&quot;inner/&#123;page&#125;/&#123;limit&#125;&quot;)public Page&lt;OrderInfo&gt; OrderList(@PathVariable Long page, @PathVariable Long limit, @RequestBody OrderQueryVo orderQueryVo) &#123; //设置分页参数:页号,每页记录数 Page&lt;OrderInfo&gt; pageParam = new Page&lt;&gt;(page,limit); IPage&lt;OrderInfo&gt; pageModel = orderService.selectPage(pageParam, orderQueryVo); /*远程服务调用需要返回Page类型*/ BeanUtils.copyProperties(pageModel,pageParam); return pageParam;&#125;","categories":[{"name":"Java开发","slug":"Java开发","permalink":"https://618dt.github.io/categories/Java%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://618dt.github.io/tags/%E9%A1%B9%E7%9B%AE/"}],"author":"LCG"},{"title":"Dubbo入门","slug":"Dubbo","date":"2022-02-22T22:10:00.000Z","updated":"2022-02-28T13:45:16.361Z","comments":true,"path":"p/2bc.html","link":"","permalink":"https://618dt.github.io/p/2bc.html","excerpt":"","text":"课程介绍 初识Dubbo RPC介绍 Dubbo工作原理 案例实操：项目编写 整合Dubbo和Zookeeper 实现服务间调用 初始DubboDubbo是什么◇轻量级、高性能的RPC框架◇并不是一个微服务的全面解决方案◇以java语言而出名，但也拓展到了其他语言Dubbo现状◇全称Apache Dubbo◇使用公司：网易云音乐、微店、考拉、滴滴等；Dubbo主要历程◇09年由阿里开发，后面捐给Apache；RPC介绍◇RPC – 远程过程调用◇早期单机时代：IPC(Inter-Process Communication)；单机里面各个进程间相互通信，A程序可以调用B程序；◇网络时代：把IPC扩展到网络上，即RPC；通过网络调用其他主机上的程序；◇RPC框架能够使调用其他机器上的程序像调用本地的程序一样方便；◇常见的RPC框架：Dubbo、新浪的Montan、Facebook的ThriftHTTP和RPC对比◇类似于普通话和方言的关系；即RPC一般用于企业内部，而HTTP用于企业和企业之间，如与银行的通信；HTTP相比于RPC有了很多协议规定，因此在企业内部使用RPC效率更高；◇传输效率：RPC可以自己定制请求，可以让总体传输的内容变少，传输效率更高；HTTP请求会包含一些与传输信息无用的内容，效率较低；◇性能消耗，HTTP耗时较多，主要在于序列化和反序列化的耗时；◇负载均衡：RPC一般都自带负载均衡策略；HTTP一般借助其他组件(如Nginx)实现负载均衡；Dubbo工作原理◇如下图，左边的Provider是服务提供者，而右边Consumer是服务使用者；消费者通过上方的Registry注册中心获取到服务的地址；下面的Monitor监控中心用来监控消费者调用某服务多少次等信息；生产者运行在容器中，可以把Provider和Contanier理解为用来提供服务的一个整体；◇数字代表运行顺序；最开始生产者要在容器中启动，启动完毕后就把自己注册到注册中心上去；然后消费者去中心拿到注册信息，对服务可以采用订阅(subscribe)的形式，即一旦服务有更新，注册中心会通知(notify)消费者；消费者拿到服务地址后，就可以去调用(invoke)服务了，在调用的时候会有负载均衡的策略，选一台服务器或者一个实例调用，如果调用失败就会选择另外一台；消费者和生产者都会定期的把服务调用的数据上传到监控中心； 1234561. 服务容器负责启动，加载，运行服务提供者2. 服务提供者在启动时，向注册中心注册自己提供的服务3. 服务消费者在启动时，向注册中心订阅自己所需的服务4. 注册中心返回服务提供者地址列表给消费者5. 从提供者地址列表中，选一台提供者进行调用6. 定期发送一次统计数据到监控中心 ◇各个模块的说明如下表 项目演示◇新建Maven项目dubbo-practice创建两个子模块：生产者和消费者◇引入相关依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.lcg&lt;/groupId&gt; &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;dubbo-practice&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt;&lt;!--此标签表示在pom文件中的一个属性, 相当于定义变量--&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--这里定义了spring-boot和dubbo的版本 --&gt; &lt;spring-boot.version&gt;2.1.12.RELEASE&lt;/spring-boot.version&gt; &lt;dubbo.version&gt;2.7.4.1&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;!-- 这里用$引用了上面定义的版本号 --&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-bom&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;exclusions&gt;&lt;!--排除依赖,Dubbo需要排序一些依赖以避免冲突 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 生产者◇引入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Dubbo Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Zookeeper dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Web 功能 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySQL connector, 需要与 MySQL 版本对应 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MyBatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ◇application.properties配置文件 12345678910111213141516171819202122232425demo.service.version=1.0.0 #服务版本#server.port=8081 //注释掉端口号,因为该服务不需要对外网提供spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/course?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=truespring.datasource.username=rootspring.datasource.password=123456logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;spring.application.name=course-list#dubbo协议dubbo.protocol.name=dubbodubbo.protocol.port=-1 #-1表示随机找一个端口号#dubbo注册dubbo.registry.address=zookeeper://127.0.0.1:2181#注册格式: 用户根目录/项目名dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache#驼峰命名转换mybatis.configuration.map-underscore-to-camel-case=true#指定dubbo服务包的位置dubbo.scan.base-packages=com.lcg.producer.service.impl ◇创建课程实体类◇由于生产者不是一个web项目，只对内部进行服务提供，所以不需要创建Controller；◇创建课程列表服务接口及其实现类 12345678910111213141516package com.lcg.producer.service.impl;import org.apache.dubbo.config.annotation.Service;/** * 描述： 课程列表服务实现类 */@Service(version = &quot;$&#123;demo.service.version&#125;&quot;)//指定版本,引用配置文件中的版本public class CourseListServiceImpl implements CourseListService &#123; @Autowired CourseMapper courseMapper; public List&lt;Course&gt; getCourseList() &#123; return courseMapper.findValidCourses(); &#125;&#125; ◇启动类 12345678910/** * 描述：是一个Dubbo服务,注解使用@EnableAutoConfiguration */@EnableAutoConfigurationpublic class DubboProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboProducerApplication.class, args); &#125;&#125; 消费者◇创建新的模块◇依赖和生产者类似◇application.properties配置文件 1234567891011121314demo.service.version=1.0.0server.port=8084 #由于消费者调用服务后可能会向外网提供服务,所以打开端口#数据库和日志的配置...#应用名spring.application.name=course-price#dubbo协议dubbo.protocol.name=dubbodubbo.protocol.port=-1#dubbo注册dubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache ◇新建实体类◇新建服务接口及其实现类 12345678910111213141516171819202122232425262728293031323334353637383940import org.apache.dubbo.config.annotation.Reference;/** * 描述： 课程 价格服务 */@Servicepublic class CoursePriceServiceImpl implements CoursePriceService &#123; @Autowired CoursePriceMapper coursePriceMapper; //引用生产者的课程列表服务,使用dubbo的@Reference注解,而不是@Autowired @Reference(version = &quot;$&#123;demo.service.version&#125;&quot;) CourseListService courseListService; @Override public CoursePrice getCoursePrice(Integer courseId) &#123; return coursePriceMapper.findCoursePrices(courseId); &#125; @Override public List&lt;CourseAndPrice&gt; getCoursesAndPrice() &#123; List&lt;CourseAndPrice&gt; courseAndPriceList = new ArrayList&lt;&gt;(); List&lt;Course&gt; courseList = courseListService.getCourseList(); for (int i = 0; i &lt; courseList.size(); i++) &#123; Course course = courseList.get(i); if (course != null) &#123; CoursePrice price = getCoursePrice(course.getCourseId()); if (price != null &amp;&amp; price.getPrice() &gt; 0) &#123; CourseAndPrice courseAndPrice = new CourseAndPrice(); courseAndPrice.setId(course.getId()); courseAndPrice.setCourseId(course.getCourseId()); courseAndPrice.setName(course.getName()); courseAndPrice.setPrice(price.getPrice()); courseAndPriceList.add(courseAndPrice); &#125; &#125; &#125; return courseAndPriceList; &#125;&#125; ◇controller类拼接两张表 12345678910111213/** * 描述：CoursePriceController */@RestControllerpublic class CoursePriceController &#123; @Autowired CoursePriceService coursePriceService; @GetMapping(&#123;&quot;/coursesAndPrice&quot;&#125;) public List&lt;CourseAndPrice&gt; getcoursesAndPrice() &#123; return coursePriceService.getCoursesAndPrice(); &#125;&#125; ◇启动类 12345678910/** * 描述： Spring Boot启动类 */@SpringBootApplication //注解和生产者不一样public class DubboConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboConsumerApplication.class, args); &#125;&#125; ◇运行项目前先启动Zookeeper；然后启动生产者，最后启动消费者； 总结◇dubbo可以自动检查zk和依赖的服务◇不要忘记dubbo.scan.base-packages配置，且服务实现类的注解service是来自于dubbo的；​","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://618dt.github.io/tags/Dubbo/"}],"author":"LCG"},{"title":"Zookeeper入门","slug":"Zookeeper","date":"2022-02-21T22:10:00.000Z","updated":"2022-02-28T13:45:16.365Z","comments":true,"path":"p/4c0f.html","link":"","permalink":"https://618dt.github.io/p/4c0f.html","excerpt":"","text":"周课介绍◇Zookeeper的下载，配置与运行◇数据结构node与常用命令◇Watcher机制和权限acl介绍◇使用Zookeeper的java原生客户端和Curator进行开发◇RPC调用，在Dubbo架构下各服务的关系◇整合Dubbo和Zookeeper◇完成Dubbo开发案例◇线程进阶面试◇分布式、微服务面试◇Spring Cloud、Zookeeper的理解 理解Zookeeper为什么需要Zookeeper◇用起来像单机但是又比单机更可靠；比如一个数据库的集群，数据库通常有一个master，负责写入数据；还有一个slave，负责读，这样使得系统更可靠；但是，由于有多个机器，要在写的时候找到对应的机器写入，读的时候也要对应；因此，哪些机器是写的，哪些机器是读的信息以及哪个是master，哪个是slave的信息都需要保存下来，保存到某一个系统中，这个系统专门对外提供这样的信息；初始的设计就是将消息通过键值对的形式保存到内存中，形成一个单机；◇但是在分布式中，一旦提供上述信息的单机宕机了，整个系统也会受到影响；为了解决这个问题，就见上面的单机升级为集群的方式，即同一个单机复制多份，以提高可靠性；但是，如果信息发生了变化，在单机中修改是很容易的，而在集群中由于有多个单机，修改某一个单机后，也需要同步到其他单机上去；规定当信息还没同步完成时，不对外提供服务；◇Zookeeper能够尽可能的将同步的时间压缩的足够短，以至于像在单机中修改一样； Zookeeper介绍◇Zookeeper最早诞生于雅虎的一个研究小组，当时雅虎的研究人员发现雅虎的大型服务有需要一个系统来进行分布式协调；但是这些协调系统都有单点问题，与是研究人员决定开发一个无单点问题的分布式协调框架，好让开发人员的精力集中在处理业务逻辑上；◇Zookeeper是开源的高性能的分布式应用协调系统，一个高性能的分布式数据一致性解决方案 5大特点◇顺序一致性；Zookeeper分为客户端和服务端，作为客户端而言，会将一些消息按顺序发送到服务端，那么对于服务端而言，也应按顺序去执行；◇原子性；即一系列的操作要么全部完成，要么都不完成；◇单一视图；无论我们的客户端连接的是哪一个Zookeeper服务器，所看到的内容都是一致的；◇可靠性；即我们给某一个节点写入数据，那么这个数据就会一直保存，并且不会改变；除非对此数据进行了其他操作；◇及时性，Zookeeper能保证在客户端所接受的一定的时间段内从服务器读取到信息； 集群架构◇架构图◇在多个Server中选出一个Leader，客户端的连接可以分散到不同的Server，但是发送的请求都交由Leader统一处理；当LeaderServer出现故障宕机后，剩下的Server会去争当Leader，即便后面恢复，也还是服从于新的leader； Zookeeper和CAP关系◇CAP：Consistency一致性、Availability可用性、Partition tolerance分区容错性◇Zookeeper选择了CP；能得到一致的数据结果，同时系统对网络具备容错性；但是它不能保证每次服务请求的可用性； Zookeeper的作用◇分布式服务注册与订阅；◇统一配置文件；如下图，有四个客户端，他们都会watch一个Zookeeper的中间节点，而这个节点正好保存了数据库的配置信息；当配置信息需要改变的时候，Zookeeper会发消息通知客户端；这样就不需要客户端主动去向服务中心查询最新的配置信息，因为一旦配置信息没有变化的话，会浪费很多请求资源；◇生成分布式唯一ID；每次如果我们需要一个新的ID，Zookeeper就会去创建一个持久的顺序节点(如下图所示)，节点会带有一个唯一的编号，作为分布式唯一ID；◇Master节点选举；如下图模拟竞争的场景，客户端A、B、C都想竞争为Master，那么谁先请求到我们的Zookeeper，谁就是Master；即三者都执行创建master节点的命令，谁先创建成功后，后面的就无法再创建；◇分布式锁；在jvm中为了保证对文件的有序访问，比如往文件中写入数据，是不能同时写的，否则会造成混乱；为了保证线程安全，通常会加锁，对资源进行互斥同步；但是在分布式系统中，这些锁都会失效，因为它们分布在不同的机器，不同的jvm中；这时候就需要分布式锁来对不同的客户端进行互斥访问； Zookeeper的安装、配置Linux下安装◇安装 1234wget https://downloads.apache.org/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1-bin.tar.gztar zxvf apache-zookeeper-3.6.0-bin.tar.gzcd apache-zookeeper-3.6.0-bincp conf/zoo_sample.cfg conf/zoo.cfg ◇配置 12345vi conf/zoo.cfg把内容修改为：tickTime=2000 //时间单元dataDir=/var/lib/zookeeper //默认是tmp,会被定期清理,修改后以持久化保存数据clientPort=2181 //客服端去连接服务端使用的端口 ◇启动，需要在apache-zookeeper-3.6.0-bin目录下； 1./bin/zkServer.sh star ◇停止 1./bin/zkServer.sh stop Windows下进行安装◇下载Zookeeper：网址 https://zookeeper.apache.org/releases.html 下载3.6.0版本；◇解压 ；然后修改zoo.cfg配置文件： 将 conf 下的 zoo_sample.cfg 复制一份改名为 zoo.cfg ； 注意几个重要位置：dataDir=./ #临时数据存储的目录（可写相对路径）clientPort=2181 #zookeeper 的端口号◇修改完成后启动 zookeeper，运行 zkServer.cmd 节点znode(基本数据模型)节点介绍◇树结构◇类似于文件结构；每个节点保存路径信息和其他属性信息； 节点性质◇树形结构，也可以理解为linux的文件目录◇每一个节点都是znode，里面可以包含数据，也可以有子节点◇点分为永久节点和临时节点（session失效，也就是客户端断开后，临时节点消失）◇每个znode都有版本号，每当数据变化，版本号会累加(乐观锁)◇删除或修改节点，版本号不匹配的话(版本号已过时),会报错；◇每个节点存储的数据不宜过大，几k即可；◇节点可以设置权限，来限制用户的访问◇Zookeeper保证读和写都是原子操作，且每次读写操作都是对数据的完整读取或完整写入； 节点类型◇节点的类型在创建时就得指定，并且之后不可修改；◇持久节点，除了自己删除，否则一直存在◇临时节点，依赖于客户端的会话，客户端和服务端连接之后可以创建临时节点；如果这个连接断了，临时节点会自动删除，当然也可以手动删除临时节点；利用临时节点可以很方便的进行集群管理；比如说每一个Zookeeper的节点就代表一个服务的实例，假设过一会儿此服务宕机了，那么就应该自动的删除此实例；◇顺序节点，持久节点以及临时节点都可以是顺序的或者非顺序的；如果我们创建的节点是顺序节点，则会加上一个10位的数字；利用顺序节点就可以创建唯一的ID； 节点属性◇dataVersion；数据版本号，每次对节点进行set操作(对节点内容进行设置，更新)的时候，dataVersion都会自动增加1，只要进行操作就会+1,即便set的值还是原来的；◇cversion；子节点版本号，子节点发生变化，cversion就会+1；◇aclVersion； 权限控制列表版本号，当权限变化后，+1； 常用命令基础命令◇启动 ./bin/zkServer.sh start◇启动之后查看状态：./bin/zkServer.sh status 12345/usr/bin/javaZooKeeper JMX enabled by defaultUsing config: /home/lcg/0/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfgClient port found: 2181. Client address: localhost.Error contacting service. It is probably not running. 说明没有运行成功，有可能是Linux中没有安装jdk；或者是没有关闭防火墙；防火墙相关命令： 123firewall-cmd --state #查看防火墙状态systemctl stop firewalld.service #关闭防火墙systemctl disable firewalld.service #开机不启动防火墙 还是报错的话，查看日志文件/logs/zookeeper-root-server-master.out则，有可能是端口占用问题，在配置文件zoo.cfg中增加admin.serverPort=没有被占用的端口号；◇连接到server： ./bin/zkCli.sh -server 127.0.0.1:2181；连接本机直接用./bin/zkCli.sh；Ctrl+Z退出连接；◇连接到server后，help可以查看Zookeeper的常用命令； 12345678910111213141516171819202122232425262728ZooKeeper -server host:port cmd args addWatch [-m mode] path # optional mode is one of [PERSISTENT, PERSISTENT_RECURSIVE] - default is PERSISTENT_RECURSIVE addauth scheme auth close config [-c] [-w] [-s] connect host:port create [-s] [-e] [-c] [-t ttl] path [data] [acl] delete [-v version] path deleteall path [-b batch size] delquota [-n|-b] path get [-s] [-w] path getAcl [-s] path getAllChildrenNumber path getEphemerals path history listquota path ls [-s] [-w] [-R] path printwatches on|off quit reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*] redo cmdno removewatches path [-c|-d|-a] [-l] set [-s] [-v version] path data setAcl [-s] [-v version] [-R] path acl setquota -n|-b val path stat [-w] path sync path version ◇查看节点 ls path; eg: ls / 可以查看根目录有哪些节点；◇查看节点状态: stat /； 12345ctime //创建时间mtime //修改时间ephemeralOwner =0x0 //表示永久节点dataLength //数据长度numChildren //子节点数 ◇查看节点的数据和状态 get◇创建节点 create; create [-s] [-e] [-c] [-t ttl] path [data] [acl] #[]里的表示可选； 高级命令◇create -s /lcg0 #创建顺序节点lcg0；注意不支持一次性创建多个节点，如create /lcg0/lcg01◇可以看到，如前面所说，每创建一个顺序节点，就会自带十位的编号； 12345678[zk: 127.0.0.1:2188(CONNECTED) 4] create -s /aCreated /a0000000002[zk: 127.0.0.1:2188(CONNECTED) 5] create -s /aCreated /a0000000003[zk: 127.0.0.1:2188(CONNECTED) 6] create -s /aCreated /a0000000004[zk: 127.0.0.1:2188(CONNECTED) 7] create -s /aCreated /a0000000005 ◇同一个父亲的节点都是按照顺序增加的；a和b是两个父节点，非顺序的，它们分别创建顺序的子节点 123456789101112[zk: 127.0.0.1:2188(CONNECTED) 9] create /aCreated /a[zk: 127.0.0.1:2188(CONNECTED) 10] create /bCreated /b[zk: 127.0.0.1:2188(CONNECTED) 11] create -s /a/aaCreated /a/aa0000000000[zk: 127.0.0.1:2188(CONNECTED) 12] create -s /b/bbCreated /b/bb0000000000[zk: 127.0.0.1:2188(CONNECTED) 13] create -s /a/abCreated /a/ab0000000001[zk: 127.0.0.1:2188(CONNECTED) 14] create -s /b/baCreated /b/ba0000000001 ◇创建临时节点：create -e◇set 更新命令：set [-s] [-v version] path data； -v表示指定版本号更新，版本号需要匹配才能更新；◇删除命令：delete [-v version] path ；有子节点的话先删除子节点； Watcher机制介绍◇可以理解为触发器、监督者；如下图，当我们的客户端向Zookeeper注册一个触发器之后(通常用来监听节点的变化)，Zookeeper就会在合适的时机给我们一个通知；而这个时机由我们自己决定，如节点的删除事件，修改事件等等；这个触发是一次性的；当然利用Apache的客户端可以设置永久性的；◇使用场景：统一资源配置；比如我们有很多个客户端，它们都把redis的ip和端口号信息存在了Zookeeper上；想要知道信息的变化，通过watcher机制，当信息变化后Zookeeper就会通知到客户端； Watcher事件类型 ACL◇ access control list 权限控制◇ 它使用权限位来允许/禁止对节点及其所作用域的各种操作◇ ACL仅与特定的znode有关，与子节点无关◇ ACL通过Scheme来进行具体的权限设置；格式： [scheme采用的权限机制:id用户:permissions权限组合字符串]◇scheme有五种选择：– world, 说明id为anyone即代表所有用户都可以访问；– auth，认证登录，需要指定用户并且提供登录密码；– digest，和auth相似，只不过加密采用密文加密；– ip， 设置一个ip段，允许特定ip访问；–super，拥有超级权限◇权限字符串crdwa：–c，即Create权限，只能创建子节点；–r，Read权限–d，Delete，删除子节点–w，Write，修改数据–a，Admin，拥有所有权限，并且可以分配修改该节点的权限；◇权限使用场景：给不同的节点设置不同的权限；–区分开发/测试/运维环境，防止误操作；开发人员一般权限较低，测试人员较高，权限最大的就是运维人员；–可以针对不同IP而产生具体的配置，更安全； 项目实现利用ZK原生的Java的API◇新建一个maven项目zk-practice◇引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; ◇新建api包，然后创建ZKConnect类连接服务端 12345678910111213141516171819202122232425262728293031package com.lcg.zkjavaapi;/** * 描述： 连接到ZK服务端，打印连接状态 */public class ZKConnect implements Watcher &#123; public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;//服务器地址 public static final Integer TIMEOUT = 5000;//设置超时时限为5s public static void main(String[] args) throws IOException, InterruptedException &#123; /** * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。 * connectString：服务器的IP+端口号，比如127.0.0.1:2181 * sessionTimeout：超时时间 * watcher：通知事件；可以在本类中通过实现Watcher接口并重写方法来完成; */ (服务器地址,超时时限,watcher) ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKConnect()); System.out.println(&quot;客户端开始连接ZK服务器了&quot;); System.out.println(zk.getState());//打印连接状态 Thread.sleep(2000);//2s钟后再次打印 System.out.println(zk.getState()); &#125; @Override public void process(WatchedEvent event) &#123;//重写Watcher接口的process方法; System.out.println(&quot;收到了通知&quot; + event); &#125;&#125; ◇配置日志文件log4j.properties 12345log4j.rootLogger=INFO, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;HH:mm:ss&#125; %p %c&#123;2&#125;: %m%n ◇对节点的操作类 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 描述： 演示对节点的操作，包含创建、读取、删除等。 */public class ZKOperator implements Watcher &#123; public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;; public static final Integer TIMEOUT = 5000; public static void main(String[] args) throws IOException, InterruptedException, KeeperException &#123; ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKOperator()); System.out.println(&quot;客户端开始连接ZK服务器了&quot;); System.out.println(zk.getState()); Thread.sleep(2000); /** * 四个参数： * path:创建的路径 * data：存储的数据,是Byte类型; * acl：权限,这里选择开放 * createMode：永久、临时、顺序,这里创建持久节点 */ zk.create(&quot;/lcg-create-node&quot;, &quot;lcg&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT); //获取节点(路径,watcher,stat) byte[] data = zk.getData(&quot;/lcg-create-node&quot;, null, null); System.out.println(new String(data));//打印节点值,需要转换类型 //修改节点(路径,修改后的值,版本号) zk.setData(&quot;/lcg-create-node&quot;, &quot;LCG&quot;.getBytes(), 1); //删除节点 String ctx = &quot;删除成功&quot;; //(节点,版本,回复类,ctx对象); delete方法将节点删除后会将 //对象ctx的值传到DeleteCallBack里面,并且由DeleteCallBack去执行方法 zk.delete(&quot;/lcg-create-node&quot;, 0, new DeleteCallBack(), ctx); Thread.sleep(2000);//给一个调用DeleteCallBack()的方法的时间,否则程序过早停止来不及打印 &#125; @Override public void process(WatchedEvent event) &#123; &#125;&#125; ◇新建反馈包，创建类用于执行操作后的回复,这里以删除操作为例； 12345678910111213141516package com.lcg.zkjavaapi.callback;import org.apache.zookeeper.AsyncCallback.VoidCallback;/** * 描述： 删除后运行的方法 * 实现VoidCallback接口,并重写方法 */public class DeleteCallBack implements VoidCallback &#123; @Override public void processResult(int rc, String path, Object ctx) &#123; System.out.println(&quot;删除节点&quot; + path); System.out.println((String)ctx);//类型转换为String类型; &#125;&#125; ◇创建类处理Watcher事件； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.lcg.zkjavaapi;/** * 描述： 和节点相关：判断是否存在，获取数据，加上watch */public class ZKGetNode implements Watcher &#123; public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;; public static final Integer TIMEOUT = 5000; //使方法在一定的时间进行等待,并且在适当的时候让它继续运行; private static CountDownLatch countDownLatch = new CountDownLatch(1); public static void main(String[] args) throws IOException, InterruptedException, KeeperException &#123; ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKGetNode()); System.out.println(&quot;客户端开始连接ZK服务器了&quot;); System.out.println(zk.getState()); Thread.sleep(2000); System.out.println(zk.getState()); Stat exists = zk.exists(&quot;/lcg&quot;, false);//存在的状态(路径,watcher:false即不加监听) if (exists != null) &#123; System.out.println(&quot;节点的版本为：&quot; + exists.getVersion()); &#125;else &#123; System.out.println(&quot;该节点不存在&quot;); &#125; //获取数据(路径,watcher,stat),当watcher设置为true后,即给此节点设置了监听器 //监听器会用process来执行相关操作的回复,根据监听事件的类型给出不同的回复 //这样,当我们在控制台中或者别处修改了该节点后,在程序中就会打印出数据被改变的通知 zk.getData(&quot;/lcg&quot;, true, null); //因为process执行的时间和主线程并不是同步的,所以需要等process执行完毕后才能放行主线程 //以便终止我们的程序,前面的sleep方法也可以做到类似效果; countDownLatch.await();//等待 &#125; @Override public void process(WatchedEvent event) &#123; //EventType有多个类型,如改变、删除等待 if (event.getType() == EventType.NodeDataChanged) &#123; System.out.println(&quot;数据被改变&quot;); countDownLatch.countDown(); &#125; System.out.println(&quot;收到了通知&quot; + event); &#125;&#125; 利用Apache Curator◇原生的API的缺点：–不支持连接超时后的自动重连–Watcher注册一次后会失效◇利用Apache Curator解决上述问题，且使API更加简单易用，提供了工具类；◇引入新的依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; ◇新建包，存放使用Curator的操作类 123456789101112131415161718192021222324252627282930313233343536package com.lcg.curator;/** * 描述： 用Curator来操作ZK */public class CuratorTests &#123; public static void main(String[] args) throws Exception &#123; String connectString = &quot;127.0.0.1:2181&quot;;//地址 String path = &quot;/curator2&quot;; //重试策略(1000毫秒,3次以内) RetryPolicy retry = new ExponentialBackoffRetry(1000, 3); CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry); client.start();//连接 /*监听事件*/ client.getCuratorListenable().addListener((CuratorFramework c, CuratorEvent event) -&gt; &#123; switch (event.getType()) &#123; case WATCHED: WatchedEvent watchedEvent = event.getWatchedEvent();//获取监听事件 if (watchedEvent.getType() == EventType.NodeDataChanged) &#123;//判断类型 System.out.println(new String(c.getData().forPath(path))); &#125; &#125; &#125;); String data = &quot;test&quot;; String data2 = &quot;test2&quot;; //创建节点,withMode指定节点类型,forPath指定路径以及数据; client.create().withMode(CreateMode.PERSISTENT).forPath(path, data.getBytes()); byte[] bytes = client.getData().watched().forPath(path); System.out.println(new String(bytes)); client.setData().forPath(path, data2.getBytes());//修改 client.delete().forPath(path); Thread.sleep(2000); &#125;&#125;","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://618dt.github.io/tags/Zookeeper/"}],"author":"LCG"},{"title":"SpringCloud开发入门","slug":"SpringCloud入门","date":"2022-02-21T12:35:00.000Z","updated":"2022-02-28T13:45:16.363Z","comments":true,"path":"p/8a2d.html","link":"","permalink":"https://618dt.github.io/p/8a2d.html","excerpt":"","text":"课程安排 Spring Cloud简介 项目整体设计 课程列表模块开发 课程价格模块开发 服务注册与发现Eureka 服务间调用Feign 负载均衡Ribbon 熔断器Hystrix 网关Zuul 整体测试 项目总结 Spring Cloud简介◇ 成熟的微服务框架，定位为开发人员提供工具，以快速构建分布式系统◇核心组件 项目整体设计接口设计◇课程列表◇单个课程价格◇整合课程列表和价格；首先会通过远程调用获取整个课程列表，然后遍历课程，补充课程价格； 系统数据流向 数据库设计◇课程表course◇课程价格表course_price 项目基础开发◇选择Spring Initalizr项目◇因为是多个模块，所以删除掉src目录；◇右键新建一个module，选择maven；项目名：course-service；然后在course-service里面将src删除，并新建一个模块，course-list,Parent选择course-service；同样的方法在course-service下创建新模块course-price; course-list模块◇配置course-list的pom.xml文件，增加相关依赖和插件 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ◇在course-list模块中新建包com.lcg.course,新建应用入口类CourseListApplication； 123456789101112131415package com.lcg.course;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 项目启动类 */@SpringBootApplicationpublic class CourseListApplication &#123; public static void main(String[] args) &#123; //启动项目 SpringApplication.run(CourseListApplication.class, args); &#125;&#125; ◇在course-list的resources目录下新建application.properties进行基础配置 12345678server.port=8081spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/course?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=truespring.datasource.username=rootspring.datasource.password=123456logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;mybatis.configuration.map-underscore-to-camel-case=truespring.application.name=course-list ◇新建entity包，创建实体类Course;注意实体类需要接入Serializable接口并实现tostring方法以实现序列化；◇新建service包，创建接口CourseListService，然后创建其实现类◇和数据库打交道也需要Mapper类；创建dao包，新建CourseMapper接口； 1234567@Mapper@Repositorypublic interface CourseMapper &#123; @Select(&quot;SELECT * FROM course WHERE valid = 1&quot;) List&lt;Course&gt; findValidCourses();&#125; ◇新建controller包，创建CourseListController类 1234567891011121314/** * 描述： CourseListController课程列表Controller */@RestControllerpublic class CourseListController &#123; @Autowired CourseListService courseListService; @GetMapping(&quot;/courses&quot;) public List&lt;Course&gt; courseList() &#123; return courseListService.getCourseList(); &#125;&#125; course-price模块◇配置文件pom与course-list相同；◇新增各个包◇新建mapper类根据课程id查询课程价格 12345678910/** * 描述： 课程价格Mapper类 */@Mapper@Repositorypublic interface CoursePriceMapper &#123; @Select(&quot;SELECT * FROM course_price WHERE course_id = #&#123;courseId&#125;&quot;) CoursePrice findCoursePrice(Integer courseId);&#125; Eureka介绍◇Eureka(服务注册与发现)是Netflix的核心子模块；主要作用是用于定位服务；有了它以后，只需要使用服务的标识符就可以访问到该服务了；其他服务可以使用Eureka的客户端来连接到Eureka的服务端，并且维持心跳链接；这样Eureka可以维护各个模块的实时信息；一个新的服务也可以通过Eureka来找到组件的各个服务的地址；◇为什么需要服务注册与发现；如果没有服务注册与发现，我们开发B服务，需要使用到A服务，那么就需要在B服务中配置A服务的IP地址以便访问；但是如果A服务的IP地址变化，我们在B服务中的配置也要相应的改变，所以就会造成难以维护；◇服务提供者把自己的服务地址提供到服务注册中心，当调用者调用该服务时，通过服务注册中心查询到最新的服务地址进行调用； Eureka架构◇Eureka Server and Eureka Client◇最先启动的就是服务注册中心。然后服务提供者启动，它会去找到配置在服务注册中心的地址，然后把服务内容注册上去；可以进行更新，注销服务等操作；然后就是消费者调用服务，首先会在服务注册中心得到注册表(Get Registry)，拿到最新的服务信息，然后远程调用服务；(注意不是通过服务注册中心调用服务)◇集群架构◇服务注册中心为了提高容灾能力，有多个节点(服务器)；服务提供者可以在不同的服务器节点注册，但注册信息时共享的，消费者找到任一节点即可； 引入Eureka◇新建模块eureka-server◇引入依赖 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-course-practice&lt;/artifactId&gt; &lt;groupId&gt;com.imooc&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 模块名及描述信息 --&gt; &lt;name&gt;course-eureka-server&lt;/name&gt; &lt;description&gt;Spring Cloud Eureka&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ◇对于spring-cloud的版本，各个模块都应该统一，所以在最外层的pom文件中增加配置spring-cloud版本 123456789101112&lt;!--标识Spring Cloud的版本--&gt; &lt;dependencyManagement&gt;&lt;!--依赖管理--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR5&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;!--类型--&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;!--范围，导入时生效--&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; ◇配置文件application.properties 123456789spring.application.name=eureka-serverserver.port=8000eureka.instance.hostname=localhost#fetch-registry：获取注册表。不需要同步其他节点数据。eureka.client.fetch-registry=false#register-with-eureka代表是否将自己注册到Eureka Server，默认是true。eureka.client.register-with-eureka=false#服务提供的地址eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ ◇启动注解,创建启动类 12345678@EnableEurekaServer //标识Eureka服务的启动类@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; ◇输入:http://127.0.0.1:8000/ ;查看Eurea的默认管理界面 注册服务◇在course-list中，添加spring-cloud依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; ◇然后在application配置文件中增加eureka服务器连接的配置，这样course-list服务启动后就会自动的在服务注册中心进行注册 1eureka.client.service-url.defaultZone=http://localhost:8000/eureka/ ◇先启动eureka服务，然后启动course-list，然后查看服务注册中心页面◇可以看到我们的课程列表服务成功注册上去◇对于course-price服务也是一样的配置 Feign介绍◇使用此组件可以用来调用远程服务，就像调用本地服务一样方便；◇提供服务的生产者首先在服务注册中心进行注册，然后使用服务的消费者把服务注册中心的它能够调用的所有服务的地址获取到，然后就利用Feign去调用服务；如果不使用Feign的话，需要自己手写Http请求； 集成Feign◇引入依赖；因为是在cours-price中调用course-list服务，所以在course-price中进行相关依赖的引入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; ◇新建一个course-list的客户端接口 12345678/** * 课程列表的Feign客户端,需要参考调用服务的原来用法 */@FeignClient(&quot;course-list&quot;)public interface CourseListClient &#123; @GetMapping(&quot;/courses&quot;) List&lt;Course&gt; courseList();&#125; ◇Course引入course-list模块中的实体，这样pom文件会自动增加配置 123456&lt;dependency&gt; &lt;groupId&gt;com.lcg&lt;/groupId&gt; &lt;artifactId&gt;course-list&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; ◇注解；在course-price的启动类上增加@EnableFeignClients 注解◇调用上面创建的client，在CoursePriceController中新增方法 1234567@AutowiredCourseListClient courseListClient;@GetMapping(&quot;/courseInPrice&quot;)public List&lt;Course&gt; getCourseListInPrice(Integer courseId) &#123; List&lt;Course&gt; courses = courseListClient.courseList(); return courses;&#125; 负载均衡两种类型◇客户端负载均衡(Ribbon);◇服务端负载均衡(Nginx)；对于所有的请求，都应该先达到Nginx节点，有它进行分发转发；◇以上两个负载均衡可以同时存在的，比如一个大型服务，用户的请求就会先达到Nginx上；而Ribbon主要用于服务内部，即服务之间也会进行相互调用，就没有必要通过Nginx，直接采用Ribbon； 负载均衡策略◇RandomRule 表示随机策略，每次回随机进行调用◇RoundRobinRule 表示轮询策略，即周而复始的循环；这种策略可以比较好的平衡各个节点的压力；◇ResponseTimeWeightedRule加权， 根据每一个 Server 的平均响应时间动态加权◇如果要配置不同的负载均衡方式可以在application文件中对 Ribbon.NFLoadBalancerRuleClassName 进行设置； 12#在客户端course-price中指定模块course-list的负载均衡方式course-list.ribbon.NFLoadBanlancerRuleClassName=com.netflix.loadbalancer.RoundRobinRule 断路器为什么需要断路器◇我们在远程调用服务的时候，如果某一个服务出现了延迟，就会导致整体项目的延迟；如左下图，一个用户的请求依赖于多个服务，其中红色的代表出现了延迟；假设服务I的功能是找到用户信息，而其他是下单之类的功能；那么在没有得到用户信息之前，是无法进行下单的，这样一来用户请求就会卡在订单处；◇又或者如右下图，服务I服务于多个用户，当该服务出现延迟后，这些用户请求都会卡住，并且用户请求前面的服务的资源也得不到释放，比如前面的服务A是连接数据库的，而数据库的连接池有上限，若有大量用户卡在I处，但是用户的连接数不会释放，这样数据库就会资源耗尽，导致系统不可用；◇断路器的作用就是将出现故障的单元隔离开，防止其影响到其他单元进而导致整个系统不可用；如在淘宝双十一活动时如果下单业务出现故障，只是当前无法下单，而不会整个系统卡死； Hystrix◇Hystrix可以快速的构建一个断路功能；当某一个服务发生故障的时候我们会返回一个默认的响应，而不是长时间的让用户去等待，这样就不会让我们的线程去调用故障服务，又调用不通导致其占用的资源不能释放，避免在分布式系统中故障的蔓延； 编码实现断路器◇给course-price增加断路器功能；在pom中引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; ◇进行配置，开启断路器 1feign.hystrix.enabled=true ◇在启动类上增加@EnableCircuitBreaker注解，表示断路器◇因为是调用的课程列表服务，所以就在CourseListClient接口的注解中指明断路后执行的类 1234567//设置服务的value,以及指定断路器实现类@FeignClient(value = &quot;course-list&quot;,fallback = CourseListClientHystrix.class )@Primary //即当同类型的bean有多个的时候,手动的设置去注入哪一个(实现接口的类也算一个bean)public interface CourseListClient &#123; @GetMapping(&quot;/courses&quot;) List&lt;Course&gt; courseList();&#125; ◇断路实现类 12345678910/** * 断路器实现类,出错返回一个空的课程列表 */@Componentpublic class CourseListClientHystrix implements CourseListClient &#123; @Override public List&lt;Course&gt; courseList() &#123; return Collections.emptyList(); &#125;&#125; ◇关闭course-list服务就能够模拟断路； 整合两个服务◇course-price模块中新增实体类 123456789/** * 课程与价格的融合类 */public class CourseAndPrice implements Serializable &#123; Integer id; Integer courseId; String name; Integer price;&#125; ◇service中新增方法及其实现；得到课程价格对象 12//接口方法List&lt;CourseAndPrice&gt; getCourseAndPrice(); –实现 1234567891011121314151617181920@Override public List&lt;CourseAndPrice&gt; getCourseAndPrice() &#123; List&lt;Course&gt; courses = courseListClient.courseList(); List&lt;CourseAndPrice&gt; courseAndPrices = new ArrayList&lt;&gt;(); //遍历得到的课程 for (Course course:courses) &#123; if (course != null) &#123; //拿到的不为空的课程,根据课程的id查询到它的价格 CoursePrice coursePrice = getCoursePrice(course.getCourseId()); CourseAndPrice courseAndPrice = new CourseAndPrice(); //进行课程和价格的拼接 courseAndPrice.setPrice(coursePrice.getPrice()); courseAndPrice.setName(course.getName()); courseAndPrice.setCourseId(course.getCourseId()); courseAndPrice.setId(course.getId()); courseAndPrices.add(courseAndPrice); &#125; &#125; return courseAndPrices; &#125; ◇在course-price模块的控制器类中增加方法调用service服务 网关Zuul为什么需要网关◇签名校验、登录校验冗余问题；为了保证系统的安全就不得不在每一个模块中加入校验的逻辑，判断用户账号密码正确与否；如果没有网关去做统一的校验我们就得在每个模块都编写同样的校验代码，造成冗余；维护性也比较差；◇Spring Cloud Zuul是Spring Cloud中的一个组件，它会和Eureka进行整合，它本身是Eureka的一个client，会注册到Eureka上；有了Zuul以后，假设其端口号是8083，那么用户可以直接访问8083端口而不做模块的区分，然后网关去区分不同的模块，另一作用就是统一校验； Zuul介绍◇如上图，手机即代表用户；用户在访问的时候并不会直接访问到我们的服务，而是先访问到网关；网关在从服务注册中心获取到各个服务模块提前注册好的信息；这样网关就知道各个模块在哪里，然后对用户的请求进行正确的转发； 集成Zuul◇把Zuul注册到Eureka服务注册中心；需要新建一个模块course-zuul◇pom文件引入依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ◇新建启动类 1234567891011/** * 描述： 网关启动类 */@EnableZuulProxy@SpringCloudApplicationpublic class ZuulGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulGatewayApplication.class, args); &#125;&#125; ◇配置路由地址等信息 1234567891011121314151617spring.application.name=course-gatewayserver.port=9000#配置日志logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;mybatis.configuration.map-underscore-to-camel-case=true eureka.client.service-url.defaultZone=http://localhost:8000/eureka/#配置zuul的统一前缀zuul.prefix=/lcg #配置各个模块的前缀zuul.routes.course-list.path=/list/**#指定服务名zuul.routes.course-list.service-id=course-listzuul.routes.course-price.path=/price/**zuul.routes.course-price.service-id=course-price ◇访问course-list模块：127.0.0.1:9000/lcg/list即可； 利用网关实现过滤器◇ pre 过滤器在路由请求之前运行◇ route 过滤器可以处理请求的实际路由◇ post 路由请求后运行过滤器◇ error 如果在处理请求的过程中发生错误，则过滤器将运行◇新建包filter；然后新建两个过滤器；◇pre过滤器，这里用来记录请求的时间 123456789101112131415161718192021222324252627282930313233/** * 描述： 记录请求时间 */@Componentpublic class PreRequestFilter extends ZuulFilter &#123; @Override public String filterType() &#123; //过滤器的类型 return FilterConstants.PRE_TYPE; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; //是否启用过滤器,在这里也可以写一些逻辑对需要过滤的url进行过滤 return true; &#125; @Override public Object run() throws ZuulException &#123; //获取上下文 RequestContext currentContext = RequestContext.getCurrentContext(); //记录当前时间 currentContext.set(&quot;startTime&quot;, System.currentTimeMillis()); System.out.println(&quot;过滤器已经记录时间&quot;); return null; &#125;&#125; ◇post过滤器 12345678910111213141516171819202122232425262728293031323334/** * 描述： 请求处理后的过滤器 */@Componentpublic class PostRequestFilter extends ZuulFilter &#123; @Override public String filterType() &#123; return FilterConstants.POST_TYPE; &#125; //通过int值来定义过滤器的执行顺序,默认为0,数字越大,优先级越低 @Override public int filterOrder() &#123; //过滤器请求最后的位置(默认1000) - 1 即在它之前一点点的时机运行 return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; //获取上下文 RequestContext currentContext = RequestContext.getCurrentContext(); Long startTime = (Long) currentContext.get(&quot;startTime&quot;);//获取请求时间 long duration = System.currentTimeMillis() - startTime; String requestURI = currentContext.getRequest().getRequestURI();//获取uri System.out.println(&quot;uri:&quot; + requestURI + &quot;,处理时长：&quot; + duration); return null; &#125;&#125;","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://618dt.github.io/tags/SpringCloud/"}],"author":"LCG"},{"title":"微服务基础","slug":"微服务基础","date":"2022-02-20T07:10:00.000Z","updated":"2022-02-28T13:45:16.366Z","comments":true,"path":"p/1b72.html","link":"","permalink":"https://618dt.github.io/p/1b72.html","excerpt":"","text":"周课介绍◇微服务的基本概念、设计与拆分原则◇微服务和Spring Cloud的关系◇微服务常见的组件和功能◇课程查询案例基本介绍、系统架构设计和接口设计◇分模块构建Spring Cloud项目◇完成课程列表、课程价格服务开发◇课程服务整合，服务注册与发现◇整合Feign实现服务间调用◇网关的集成与开发，并接入服务◇引入服务的熔断与降级，并进行实操演练 微服务基础介绍要点 什么是微服务 微服务的特点 微服务优缺点 微服务的两大门派 springcloud和dubbo 微服务拆分 微服务扩展 微服务重要模块 单体应用的缺点◇单体应用架构图◇部署效率低下；单体应用的代码会越来越多，依赖也越来越多；pom文件会特别长，则导致部署时间变长；◇团队协作开发成本高◇系统高可用性差；因为最后所有功能都会部署到同一个包里面，且共用一个进程；那么如果一个功能出现问题很有可能整个系统出现问题； 什么是服务化◇ 把传统的单机应⽤中通过JAR包依赖产⽣的本地⽅法调⽤，改造成通过RPC、HTTP产⽣的远程⽅法调⽤◇ 把模块从单体应⽤中拆分出来，独⽴成⼀个服务部署◇ 模块就可以独⽴开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合 从单体到微服务架构◇单体到微服务的架构图 什么是微服务◇一种架构风格◇开发单个应用作为一系列小型服务的套件，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信， 这通常是HTTP资源API。◇这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署◇这些服务的集中式管理做到了最小化（例如docker相关技 术），每一种服务都可以通过不同的编程语言进行编写，并且可以使用不同的数据存储技术。 微服务的特点◇组件以服务形式来提供◇产品而不是项目◇轻量级通信、独立进程◇分散治理、去中心化治理◇容错性设计◇会带来团队的组织架构的调整；如有原来水平团队变成垂直的团队，微服务下一个业务就有整套技术人员； 微服务优缺点优点◇服务简单、便于学习和上手，相对易于维护◇独立部署，灵活扩展◇技术栈丰富，包括开发工具，数据库，中间件等；缺点◇运维成本过高◇接口可能不匹配;因为以前我们进行本地方法调用的时候，不会出现接口不匹配的问题，在本地可以直接查看接口的返回类型；但变成微服务之后，假设我们都不知道对方的代码，只能通过简单的描述，就有可能造成接口不匹配；◇代码可能重复◇架构复杂度提高 ◇在不同系统复杂度的情况下单体应用(Monolith)和微服务应用(Microservice)的优势区别 微服务的两大门派介绍◇Spring Cloud：众多子项目；比如说像网关、配置中心、智能路由等等；◇dubbo：高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡， 以及服务自动注册和发现 ；◇dubbo提供的能力只是Spring Cloud的一部分子集◇Dubbo中无是指不提供该功能，但可以通过其他框架组合实现；比如说在Dubbo中分布式配置功能可以采用百度的disconf或者淘宝的diamond实现；利用京东开源的Hydra实现服务跟踪；当当开源的Elastic-Job实现批量任务等等； 通信协议对比◇Dubbo基于RPC，Spring Cloud基于REST◇RPC 服务提供方与调用方接口依赖方式太强◇RPC服务对平台敏感，难以简单复用◇ 效率RPC更高 文档质量对比◇ Dubbo的文档可以说在国内开源框架中算是一流的，提供了中文与英文两种版本◇ Spring Cloud文档体量大，更多的是偏向整合，更深入的使用方法还是需要查看其整合组件的详细文档 总结◇Dubbo诞生于阿里系，其他组件不够全面；而Spring Cloud专注于企业级的微服务框架，开发便利；生态上Spring Cloud更强大；◇Dubbo就像组装电脑，有很高的自由度，但是需要承担兼容性的风险；Spring Cloud相当于品牌机，保证了一套系统的稳定性；◇需要根据自身的研发水平和所处阶段选择 微服务拆分什么时候进行服务化拆分◇第一阶段的主要目标是快速开发和验证想法，即采用单体应用模式快速开发应用上线；◇进一步增加更多的新特性来吸引更多的目标用户◇同时进行开发的人员超过10人(视业务大小决定人数)，这个时候就该考虑进行服务化拆分 不适合拆分的情况◇小团队，技术基础比较薄弱◇流量不高，压力小，业务变化也不大；比如企业内部的系统，虽然功能多，但是只是企业内部员工使用，流量不是很高；◇对延迟很敏感的低延迟高并发系统；对于微服务而言，延迟是很高的，因为各个模块间的调用是通过网络通信完成的； 服务化拆分的两种姿势◇纵向拆分；按照业务维度去拆分，比如说关联程度比较近的拆分为一个微服务，功能比较独立的拆分为一个微服务；如社交APP，评论功能是一个微服务，消息通知是一个微服务，个人主页是一个微服务；◇横向拆分；按照公共领域拆分；比如说上面的评论，消息通知，个人主页都有公共的需求，都需要用到用户模块；则把用户服务作为一个横向拆分出来，并且把功能提供给各个模块，这样一来用户服务就得到了大量的复用；◇结合业务综合分析 微服务扩展服务扩展◇ x 轴-水平复制；就是单体应用的典型扩展方式，把整个系统作为一个整体重新部署几套然后在前面加几个负载均衡器即可；水平复制往往效果不好，而且造成资源浪费；◇ y 轴-功能解耦 ；即指微服务的拆解，效率比X轴的维度高；◇ z 轴-数据分区 ；在我们系统过大后，存储空间可能不足；所以就需要进行数据库的拆分； 自动按需扩展◇ 根据CPU负载程度、特定时间（比如周末）、消息中间件的队 列长度、业务具体规则、预测等来决定是否扩展◇ 自动分配一个新的服务实例，提高可用性◇ 提高了可伸缩性（双11之后，自动减少服务器）◇ 具有最佳使用率，节约成本 微服务重要模块◇服务描述；我们服务提供方需要把自己的服务描述出来，比如是什么类型的服务，接口是什么类型等等；◇注册中⼼；服务提供方需要到注册中心进行注册；◇服务框架；采用什么协议（TCP、UDP），传输的方式是同步还是异步，数据是否需要压缩等等内容由服务框架进行统一；◇负载均衡；服务提供方有很多个，需要有负载均衡技术；◇熔断和降级；保证整体的可用性，不因某一个服务瘫痪导致整个系统故障；◇网关；当服务增多之后，用户是不可能每一个请求达到不同的地址上去，需要一个统一的网关接收用户的请求，然后进行分发；具有统一转换，权限控制等功能；","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://618dt.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"author":"LCG"},{"title":"RabbitMQ入门","slug":"消息队列RabbitMQ","date":"2022-02-20T04:10:00.000Z","updated":"2022-02-28T13:45:16.367Z","comments":true,"path":"p/ef1a.html","link":"","permalink":"https://618dt.github.io/p/ef1a.html","excerpt":"","text":"课程简介 初识RabbitMQ，使用Erlang语言； RabbitMQ的安装和启动 RabbitMQ管理后台 实战案例演示 交换机工作模式 fanout、direct、topic、headers Spring Boot整合RabbitMQ RabbitMQRabbitMQ简介◇核心思想：接收并转发消息。你可以把它想象成一个邮局◇producer：消息的生产者(发送者)，◇queue：保存P发过来的消息，队列可以无限延长，存储多个P的信息，同时也被多个消费者消费；◇consumer：消费者，从q中获取详细 RabbitMQ的特点◇开源、跨语言◇Erlang语言编写，一般用在通信行业，性能良好；◇应用广泛◇社区活跃、API丰富 消息队列什么叫消息队列◇消息队列是一种先进先出的结构；Enqueue&amp;Dequeue； 消息队列的特性◇业务无关，不需要考虑上层业务的逻辑，只做好消息转发即可；◇FIFO，先进先出◇容灾，对于接收的消息可以进行持久化处理，即存储下来，即便出现服务器故障，也可以在恢复服务后找到还每出队的消息；◇性能 为什么要用消息队列◇系统解耦，在没有使用消息中间件的时候我们的消息发送是直接调用模块的方法，但是在模块比较多的时候，会调用很多模块，增加系统复杂性，而消息通过消息队列来进行转发能够有效解耦；◇异步调用；假设我们有一个链路，从A调用B，调用C再调用D,因为每一个步骤都是需要时间的，所以整个链路下来花的时间较多，不过很多步骤是可以异步的；异步即我告诉你要做这件事然后不等你做完我就可以直接返回了；同步的话需要等你做完之后我才能返回；比如说点外卖的时候，作为用户我下单以后平台系统要做的事情很多，比如通知店家，骑手等；对于用户而言，不需要考虑这些系统要处理的事，所以通过消息来完成异步的调用；即当用户下单以后，系统将消息发送到消息中间件中，然后就返回消息给用户，让用户知道下单成功；然后MQ会对消息进行分发，通知商家、骑手接单，支付模块收款等；◇流量削峰；有时候我们的请求量会突然上升，就叫做出现了流量高峰；消息队列会把这些大量的请求存储在队列里面，然后以我们能够接受的速度发送给我们；相当于对高流量做一下缓冲； AMQP协议◇ Advanced Message Queuing Protocol◇左侧的publisher即对应生产者，Consumer对应消费者；右边一大块是指RabbitMQ的服务器(Server)；Virtual host虚拟主机，一个RabbitMQ可以给很多的完全独立的用户提供服务，那么每一个用户就可以利用虚拟主机来划分，它们之间是互不影响的；在虚拟主机里面有一个Exchange,是交换机的意思；交换机会与下面的消息队列MQ连通，它们是一个绑定的关系； RabbitMQ核心概念◇RabbitMQ的整体架构图◇Server：服务◇connection：与server建立连接◇ channel：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道◇ message：消息，在RabbitMQ中消息由properties(对消息进行额外的修饰，如消息的优先级，队列的延迟或者消息的其他属性)和body(消息的实体)组成◇ virtual host：虚拟主机，作用是顶层隔离，比如说有A、B两个项目，必须先指定把消息投递到A还是B，也就是说投递到A的虚拟主机还是B的虚拟主机，这是最顶层的隔离然后才会包含后面交换机的内容。同一个虚拟主机下，不能有重复的交换机和queue，如果是不同的虚拟主机，则可以有相同的交换机和queue；◇ Exchange：交换机，接收生产者的消息的，然后根据指定的路由器去把消息转发到所绑定的队列上◇ binding：绑定交换机和队列◇ routing key：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由◇ queue：队列，消费者只需要监听队列来消费消息，不需要关注消息来自于哪个Exchange◇ Exchange和Message Queue存在着绑定的关系，一个 Exchage可以绑定多个消息队列 消息的流转过程◇最开始是生产者产生一个消息，然后放到Exchange中去，Exchange下有三个MQ，在绑定的时候需要指定一个路由键；假设Exchange和Qi使用的路由键是Ki；那么在生产者发送消息的时候就需要指定一个路由键，比如说消息的路由键是K1，那么Exchange就把消息发送给Q1(左起第一个队列)；对于消费者而言，会监听消息，一旦MQ中有了从交换机发送过来的消息消费者就会提取到消息并且进行后续的处理； RabbitMQ的安装和启动安装Erlang语言◇方法一：安装erlang-rpm包，该包经过RabbitMQ官方处理，去掉了一些无用的依赖； 1234567891011121314151617181920212223242526#配置源vim /etc/yum.repos.d/rabbitmq_erlang.repo #在配置文件中 [rabbitmq-erlang] name=rabbitmq-erlang baseurl=https://dl.bintray.com/rabbitmq-erlang/rpm/erlang/22/el/7 gpgcheck=1 gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc repo_gpgcheck=0 enabled=1#:wq退出保存#进行清理yum clean all#下载所需要的缓存yum makecache#进行安装yum install erlang#确认源是&quot;rabbitmq_erlang&quot; Y#确认安装 Y#查看版本erl -version#进入语言环境erlctrl+c退出 ◇方法二：使用Erlang Solutions源安装完整的版本；◇方法三： 使用EPEL(“Extra Packages for Enterprise Linux”)进行安装， 版本可能不合适 ； 安装RabbitMQ123456789101112#导入密钥rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc#下载rpm安装包：wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.2/rabbitmq-server-3.8.2-1.el7.noarch.rpm#如果速度比较慢，就用：wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.2/rabbitmq-server-3.8.2-1.el7.noarch.rpm#下载完成后，安装：yum install rabbitmq-server-3.8.2-1.el7.noarch.rpm#一路Y#如果出现解压错误，说明下载了多次，用ls -la看一下有几个文件，#如果有多个安装包，要把多余的删掉，把正确的改名为rabbitmq-server-3.8.2-1.el7.noarch.rpm，再执行yum install来安装 启动RabbitMQ◇RabbitMQ常用命令 12345678910111213#启动RabbitMQsystemctl start rabbitmq-server#看看端口有没有起来，查看状态rabbitmqctl status #要检查RabbitMQ服务器的状态，请运行：systemctl status rabbitmq-server#开启web管理界面rabbitmq-plugins enable rabbitmq_management#停止RabbitMQrabbitmqctl stop#设置开机启动systemctl enable rabbitmq-server RabbitMQ管理后台◇启动管理后台： rabbitmq-plugins enable rabbitmq_management◇新建用户: rabbitmqctl add_user admin password //用户名：admin；密码：password;可自定义◇设置用户权限: rabbitmqctl set_user_tags admin administrator //将admin用户设为管理员◇浏览器登录管理后台： ip+默认端口15672; 192.168.222.133:15762;◇Info下的disc表示RabbitMQ默认采用磁盘存储；交换机是RabbitMQ默认生成的；◇在Admin界面添加用户：Add a user； Montioring：可以登录控制台，也可以看到RabbitMQ的相关节点信息，如进程数，内存使用情况等等；但新建用户，创建管理员这些就没有权限；None：权限最低，就是普通的生产者，消费者；◇默认会有一个虚拟主机；点击虚拟主机的name可以给虚拟主机添加管理员用户； 案例演示新建项目◇创建maven项目，命名为rabbitmq◇导入依赖 1234567891011121314&lt;dependencies&gt; //rabbitmq客户端依赖 &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.8.0&lt;/version&gt; &lt;/dependency&gt; //记录日志的依赖 &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.29&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ◇新建helloworld包，创建类Send； 123456789101112131415161718192021222324252627282930313233343536package helloworld;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/*hello world 的发送类，连接到RabbitMQ服务端，然后发送一条消息，最后退出*/public class Send &#123; //指定队列名字,在接收的时候也要使用此队列 private final static String QUEUE_NAME = &quot;hello&quot;; public static void main(String[] argv) throws Exception &#123; //创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置 RabbitMQ 地址,即服务端IP;用户名;密码 factory.setHost(&quot;xxx.xx.xxx.xxx&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;password&quot;); //建立连接 Connection connection = factory.newConnection(); //获得信道 Channel channel = connection.createChannel(); //声明队列(队列名，队列是否需要持久，是否独有，是否自动删除，参数填null即可) //持久即服务重启后是否还保存此队列，独有即此队列是否仅被当前连接使用 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //发布消息 String message = &quot;Hello World!&quot;; //(交换机&#x27;这里忽略&#x27;，路由键：队列名，消息配置：null，消息体：需要声明编码方式) 忽略交换机名字的话,RabbitMQ会使用默认的交换机根据队列的名字QUEUE_NAME作为路由键进行查找 channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;发送了消息：&quot; + message); //关闭连接 channel.close();//关闭信道 connection.close();//关闭连接 &#125;&#125; ◇创建接收消息类Recv 1234567891011121314151617181920212223242526272829303132333435363738394041package helloworld;import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import java.io.IOException;//接收消息并打印，持续运行public class Recv &#123; private final static String QUEUE_NAME = &quot;hello&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;xxx.xx.xxx.xxx&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;password&quot;); //建立连接 Connection connection = factory.newConnection(); //获得信道 Channel channel = connection.createChannel(); //声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(&quot;开始接收消息&quot;); //消费信息(队列名，是否自动确认收到，处理消息函数) channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) &#123; //收到信息后会执行的函数 @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)//重写handleDelivery方法 throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;);//实例化消息 System.out.println(&quot;收到消息：&quot; + message); &#125; &#125;); &#125;&#125; 多个消费者◇创建新的包workqueues,新建NewTask类发送多个消息 1234567891011121314151617181920212223242526272829package workqueues;//任务由所耗时，多个任务public class NewTask &#123; private static final String TASK_QUEUE_NAME = &quot;task_queue&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); //factory.setHost(&quot;localhost&quot;);若是在本机的话，不需要设置用户名和密码 factory.setHost(&quot;xxx.xx.xxx.xxx&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;password&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); //构建多个消息 for (int i = 0; i &lt; 10; i++) &#123; String message; message = i + &quot;....&quot;; //发送消息 channel.basicPublish(&quot;&quot;, TASK_QUEUE_NAME, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;); &#125; channel.close(); connection.close(); &#125;&#125; ◇创建Worker类接收消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package workqueues;import com.rabbitmq.client.*;import java.io.IOException;//接收前面的批量消息public class Worker &#123; private static final String TASK_QUEUE_NAME = &quot;task_queue&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;xxx.xx.xxx.xxx&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;password&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); //声明队列 channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); //System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;); System.out.println(&quot;开始接收消息&quot;); channel.basicConsume(TASK_QUEUE_NAME, true, new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;收到了消息&quot;+message); try &#123; doWork(message); &#125; finally &#123; System.out.println(&quot;消息处理完毕&quot;); &#125; &#125; &#125;); &#125; /*执行任务方法;定义消费特点:如果字符为&quot;.&quot;则处理时间为1s,这样设计为后续消息区分做铺垫*/ private static void doWork(String task) &#123; for (char ch : task.toCharArray()) &#123;//遍历字符数组 if (ch == &#x27;.&#x27;) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException _ignored) &#123; Thread.currentThread().interrupt(); &#125; &#125; &#125; &#125;&#125; ◇上述方法处理消息会比较慢，我们可以在执行一个worker类，即让两个worker去接收消息；需要先进行配置:Edit Configurations-&gt;Allow parallerl run(允许并行执行); 这样两个worker就会平均的接收消息，即有10条消息，每个消费者会接收到5条；◇下面考虑每条消息的处理时间不同的情况如何合理的给worker分配压力；◇在发送消息的时候修改为 123456789101112for (int i = 0; i &lt; 10; i++) &#123; String message; if(i%2==0)&#123; message = i + &quot;....&quot;; &#125;else&#123; message = String.valueOf(i);//把int类型的i字符串化; &#125; //发送消息 channel.basicPublish(&quot;&quot;, TASK_QUEUE_NAME, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;); &#125; ◇在这种情况下，如果运行两个worker的话，就会造成双方压力不同；那么如何实现公平派遣呢？◇实现公平派遣需要加入消息确认机制，让RabbitMQ知道这个消息处理完毕，然后再去分配新任务；◇对消费者进行改造 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package workqueues;import com.rabbitmq.client.*;import java.io.IOException;//接收前面的批量消息public class Worker &#123; private static final String TASK_QUEUE_NAME = &quot;task_queue&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;xxx.xx.xxx.xxx&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;password&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); //声明队列 channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); //System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;); System.out.println(&quot;开始接收消息&quot;); channel.basicQos(1);//在消费消息之前,设置希望处理的消息数量 //消费消息,将自动确认接收改为false channel.basicConsume(TASK_QUEUE_NAME, false, new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;收到了消息&quot;+message); try &#123; doWork(message); &#125; finally &#123; System.out.println(&quot;消息处理完毕&quot;); //确认接收完消息(模板,是否同时确认多个消息) channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125; &#125;); &#125; /*执行任务方法;定义消费特点:如果字符为&quot;.&quot;则处理时间为1s,这样设计为后续消息区分做铺垫*/ private static void doWork(String task) &#123; for (char ch : task.toCharArray()) &#123;//遍历字符数组 if (ch == &#x27;.&#x27;) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException _ignored) &#123; Thread.currentThread().interrupt(); &#125; &#125; &#125; &#125;&#125; 交换机工作模式fanout模式◇ fanout：广播，这种模式只需要将队列绑定到交换机上即可， 是不需要设置路由键的◇最左侧是一个P，即生产者；然后是X交换机；由于是fanout模式，只要绑定了这些队列，后续凡是送到这个交换机X的消息X都会分发到与其绑定的队列中；比如说，我们有两个程序，第一个程序是负责发送日志消息，第二个负责接收；假设日志需要保存到文件中也需要打印到屏幕上，则有多处地方使用了日志消息，即形成了一对多的关系，则使用fanout模式的交换机；代码演示◇新建fanout包，在包下创建EmitLog日志类 123456789101112131415161718192021222324package fanout;//发送日志信息public class EmitLog &#123; //定义交换机的名字 private static final String EXCHANGE_NAME = &quot;logs&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); //声明交换机(交换机名字,交换机类型) channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); String message = &quot;info: Hello World!&quot;; //发送消息 channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;发送了消息&quot;+message); channel.close(); connection.close(); &#125;&#125; ◇创建接收类ReceiveLogs，有多个接收者去接收一样的消息;对于日志而言，只对当前发生的事感兴趣，对以前的日志没有必要保存，有很高的时效性，可能保存不超过3天就删除了；那么我们可以创建全新的空队列，让RabbitMQ自动生成队列的名字，并且此队列是非持久的，会自动删除的；即当接收者不复存在的时候，队列也会被删除，来节省我们的空间；如下图所示◇执行多个ReceiveLogs模拟多个消费者 12345678910111213141516171819202122232425262728293031323334package fanout;import com.rabbitmq.client.*;import java.io.IOException;public class ReceiveLogs &#123; private static final String EXCHANGE_NAME = &quot;logs&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); //通过getQueue()方法可以得到一个非持久的空队列 String queueName = channel.queueDeclare().getQueue(); //将队列绑定到交换机上,路由键为空; channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;); System.out.println(&quot;开始接收消息&quot;); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;收到消息&quot; + message); &#125; &#125;; //消费消息 channel.basicConsume(queueName, true, consumer); &#125;&#125; direct模式◇ direct：直接，根据 RoutingKey 匹配消息路由到指定的队列◇应用场景：比如对于日志而言，为了节省空间我们不一定要把所有的日志都存储下来，我们的日志会分为不同的等级，磁盘只存储error类型的日志；那么这样就不能再使用fanout的交换机，因为这样它会把所有日志无差别的保存下来；我们的要求是只存储error类型日志，但是需要打印全部类型的日志到前台；即对应不同的消费者接受不一样的消息；◇允许把相同的路由键绑定到不同的消息队列中，如下图◇在实际的生产中，C1接受error类型用于存储，C2接受所有类型用于打印，如下图代码演示◇新建包direct包，创建EmitLogDirect日志类 123456789101112131415161718192021222324252627282930313233343536package direct;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.Connection;import com.rabbitmq.client.Channel;public class EmitLogDirect &#123; private static final String EXCHANGE_NAME = &quot;direct_logs&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); String message = &quot;Hello World!&quot;; String severity = &quot;info&quot;; channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(&quot;UTF-8&quot;)); severity = &quot;warning&quot;; channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;发送了消息&quot; + message + &quot;等级为:&quot;+severity); severity = &quot;error&quot;; channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;发送了消息&quot; + message + &quot;等级为:&quot;+severity); channel.close(); connection.close(); &#125;&#125; ◇新建接收者类ReceiveLogsDirect1 1234567891011121314151617181920212223242526272829303132333435363738package direct;import com.rabbitmq.client.*;import java.io.IOException;public class ReceiveLogsDirect1 &#123; private static final String EXCHANGE_NAME = &quot;direct_logs&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); //生成一个随机的临时的queue String queueName = channel.queueDeclare().getQueue(); //一个交换机同时绑定三个queue channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;); channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;); channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;); System.out.println(&quot;开始接收消息&quot;); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;收到消息&quot;+message); &#125; &#125;; channel.basicConsume(queueName, true, consumer); &#125;&#125; ◇创建接收类ReceiveLogsDirect2，只接收error类型的日志； topic模式◇ topic：生产者指定 RoutingKey 消息根据消费端指定的队列通过模糊匹配的方式进行相应转发；◇*可以代替一个单词，#可以代替0个或者多个单词；◇上图有三个维度：速度，颜色，种类；Q1对颜色为橙色的动物都感兴趣；Q2对种类为兔子的感兴趣以及有关懒惰动物的一切；代码演示◇新建包topic,创建类EmitLogTopic发送消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package topic;public class EmitLogTopic &#123; private static final String EXCHANGE_NAME = &quot;topic_logs&quot;; public static void main(String[] argv) &#123; Connection connection = null; Channel channel = null; try &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); connection = factory.newConnection(); channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String message = &quot;Animal World&quot;; //数组来表示不同类型的动物 String[] routingKeys = new String[9]; routingKeys[0] = &quot;quick.orange.rabbit&quot;; routingKeys[1] = &quot;lazy.orange.elephant&quot;; routingKeys[2] = &quot;quick.orange.fox&quot;; routingKeys[3] = &quot;lazy.brown.fox&quot;; routingKeys[4] = &quot;lazy.pink.rabbit&quot;; routingKeys[5] = &quot;quick.brown.fox&quot;; routingKeys[6] = &quot;orange&quot;;//测试单个属性 routingKeys[7] = &quot;quick.orange.male.rabbit&quot;;//增加无关属性male routingKeys[8] = &quot;lazy.orange.male.rabbit&quot;; for (int i = 0; i &lt; routingKeys.length; i++) &#123; channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;发送了&quot;+message+&quot;路由键为:&quot;+routingKeys[i]); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; &#125; &#125;&#125; ◇新建接收者ReceiveLogsTopic1 12345678910111213141516171819202122232425262728293031323334353637package topic;import com.rabbitmq.client.*;import java.io.IOException;public class ReceiveLogsTopic1 &#123; private static final String EXCHANGE_NAME = &quot;topic_logs&quot;; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String queueName = channel.queueDeclare().getQueue(); //指定routingKey String routingKey = &quot;*.orange.*&quot;; channel.queueBind(queueName, EXCHANGE_NAME, routingKey); System.out.println(&quot;开始接收消息&quot;); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;收到消息:&quot;+message+&quot;路由键为:&quot;+envelope.getRoutingKey()); &#125; &#125;; channel.basicConsume(queueName, true, consumer); &#125;&#125; ◇创建第二个接收者 12345String routingKey1 = &quot;*.*.rabbit&quot;;channel.queueBind(queueName, EXCHANGE_NAME, routingKey1);String routingKey2 = &quot;lazy.#&quot;;channel.queueBind(queueName, EXCHANGE_NAME, routingKey2); headers模式◇ headers：根据发送消息内容中的 headers 属性来匹配 Spring Boot整合RabbitMQ◇创建两个SpringBoot项目；Add as Maven Project；一个Consumer，一个Producer； 生产者◇对配置文件进行修改；把springboot版本改为2.2.2.1；引入RabbitMQ所需的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; ◇配置生产者的application.properties文件 12345678server.port=8080spring.application.name=producerspring.rabbitmq.addresses=&#x27;ip地址&#x27;:5672spring.rabbitmq.username=adminspring.rabbitmq.password=passwordspring.rabbitmq.virtual-host=/spring.rabbitmq.connection-timeout=15000 超时时间 ◇新建一个配置类(声明交换机，队列等) 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lcg.springbootrabbitmqproducer;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 描述： rabbitmq配置类 */@Configurationpublic class TopicRabbitConfig &#123; @Bean public Queue queue1() &#123; return new Queue(&quot;queue1&quot;);//队列 &#125; @Bean public Queue queue2() &#123; return new Queue(&quot;queue2&quot;); &#125; @Bean TopicExchange exchange() &#123; return new TopicExchange(&quot;bootExchange&quot;);//交换机 &#125; @Bean Binding bingdingExchangeMessage1(Queue queue1, TopicExchange exchange) &#123; //交换机和队列绑定 return BindingBuilder.bind(queue1).to(exchange).with(&quot;dog.red&quot;); &#125; @Bean Binding bingdingExchangeMessage2(Queue queue2, TopicExchange exchange) &#123; return BindingBuilder.bind(queue2).to(exchange).with(&quot;dog.#&quot;); &#125;&#125; ◇发送消息类 123456789101112131415161718192021222324252627package com.lcg.springbootrabbitmqproducer;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * 描述： 发送消息 */@Component//把普通的java对象实例化到spring容器中，相当于配置文件中的&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;public class MsgSender &#123; @Autowired private AmqpTemplate rabbitmqTemplate;//引入Amqp协议 public void send1() &#123; String message = &quot;This is message 1, routing key is dog.red&quot;; System.out.println(&quot;发送了：&quot;+message); this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;, &quot;dog.red&quot;, message); &#125; public void send2() &#123; String message = &quot;This is message 2, routing key is dog.black&quot;; System.out.println(&quot;发送了：&quot;+message); this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;, &quot;dog.black&quot;, message); &#125;&#125; ◇增加测试类 12345678910111213141516171819202122package com.lcg.springbootrabbitmqproducer;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass SpringBootRabbitmqProducerApplicationTests &#123; @Autowired MsgSender msgSender; @Test public void send1() &#123; msgSender.send1(); &#125; @Test public void send2() &#123; msgSender.send2(); &#125;&#125; 消费者◇更改springboot版本，引入RabbitMQ依赖；◇增加配置，和生产者一样的配置内容，但是端口不一样，这里改为8081◇新建类Receiver1接收消息 12345678910111213141516171819package com.lcg.springbootrabbitmqconsumer;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;/** * 描述： 消费者1 */@Component@RabbitListener(queues = &quot;queue1&quot;) //利用注解指定队列public class Receiver1 &#123; @RabbitHandler public void process(String message) &#123; System.out.println(&quot;Receiver1: &quot; + message); &#125;&#125; ◇Receiver2绑定queue2​","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://618dt.github.io/tags/RabbitMQ/"}],"author":"LCG"},{"title":"Nginx入门","slug":"Nginx","date":"2022-02-20T02:10:00.000Z","updated":"2022-02-28T13:45:16.362Z","comments":true,"path":"p/e129.html","link":"","permalink":"https://618dt.github.io/p/e129.html","excerpt":"","text":"介绍1.Nginx介绍2.Nginx的安装3. 常用命令讲解和演示4.配置文件讲解5.场景实战：搭建一个静态的Nginx服务6.总结 Nginx介绍Nginx是什么、适用场景◇HTTP的反向代理服务器◇正向代理；指的是普通的代理转发，在我们的客户端和服务器之间加了一个代理服务器；作为客户端，会将消息传到代理服务器上，而代理服务器将客户端的请求进行转发；代理服务器提供安全功能，代理服务器拥有一个防火墙，可以使客户端拥有其不具备的安全检测的功能；可以通过代理服务器隐藏自身的信息；◇反向代理；反向代理通常位于服务端中；指我们客户端去访问的时候，不直接访问到我们所要访问的服务器，而是在这些服务器之前加一个统一的反向代理服务器，对于客户端而言，访问的服务器信息是看不到的；反向代理服务器除了和代理服务器一样提供安全功能外，还有一个功能是在后端多个服务器之间提供负载均衡，或者是对比较慢的服务器提供缓存，把经常访问的内容缓存到代理服务器中；◇Nginx的作用正是反向代理 ◇正向+反向代理◇动态静态资源分离 作为后端服务器需要给前端提供一些资源，但这些资源可能包含了逻辑代码也可能包含css静态资源；对于静态资源，其实没有必要由我们后台服务器去提供，不进行分离的话访问会变慢； 静态资源无需经过Tomcat，Tomcat只负责处理动态请求，这样访问速度就会提高；如后缀为gif的时候，Nginx会直接获取到当前请求的文件并返回； Nginx本身就是一个静态资源服务器；比如我们只有静态资源的时候，如个人主页，公司简介这些都可以作为静态资源网站去实现，就可以直接使用Nginx作为服务器； Nginx的优点◇高并发、高性能◇可扩展性好, Nginx的第三方生态圈非常丰富；◇高可靠性，即Nginx可以在服务器上不断的运行，长达数年之久；用户直接访问到Nginx；◇热部署，不停止服务的情况下对自身进行升级或修改完善；◇开源、可商用 Nginx的安装◇Linux的安装 12345678910111213141516171819202122232425262728yum install yum-utils#新建文件输入源信息;vim /etc/yum.repos.d/nginx.repo#以下就是配置信息: [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true#查看源,stable代表稳定版本,yum list | grep nginx#开始下载,版本选择第一个稳定的版本yum install nginx 1:1.16.1-1.el7.ngxy确认下载y确认验证#检查是否安装成功nginx -vwhereis nginx ◇Windows不推荐安装，因为服务器通常不是Windows下的； 常用命令讲解和演示◇启动命令: /usr/sbin/nginx◇查看是否启动成功,查看进程判断：ps -aux |grep nginx或直接访问nginx的网站80端口◇nginx -h //查看主要命令◇-c 读取指定配置文件 1234cd /etc/nginx //查看配置文件lsnginx -s stop //如果前面有启动的话，先关闭再指定配置文件nginx -c /etc/nginx/nginx.conf //指定配置文件为nginx.conf ◇-t 测试，主要用来测试配置文件是否正确nginx -t //进行测试◇在nginx启动后，也可以用上面这个命令查看nginx的配置文件是哪一个；◇-v 简要版本信息； -V 详细版本信息；◇where is 或者 ps aux|grep nginx //找到正在运行的nginx的路径◇-s 信号 12345stop //立即停止quit //优雅停止,不在接收新的请求，但会将已经送达的请求处理完再关闭reload //重启:先检查配置文件的有效性，无效的话不会重启；有效的话就会启动一个新的进程，直到旧的 进程把它的任务处理完毕后，再让旧进程退出；reopen //更换日志文件,即日志过长的话,新建一个文件用来记录日志 配置文件讲解配置文件语法◇以 ; 结尾◇ {}组织多条指令◇include 引入◇用 #注释◇$ 变量 配置文件讲解◇nginx.conf 1234567891011121314151617181920212223242526272829303132333435363738# 运行用户，默认是nginxuser nginx;# nginx进程数,一般设置为和cpu核数一样worker_processes 1;# 全局错误日志路径error_log /var/log/nginx/error.log warn;# 进程pid路径pid /var/run/nginx.pid;events &#123;# 最大连接数 worker_connections 1024;&#125;# 设置http服务器http &#123; include /etc/nginx/mime.types; default_type application/octet-stream;# 设置日志的格式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;# 访问日志的路径 access_log /var/log/nginx/access.log main;# 开启高效传输模式 sendfile on; #tcp_nopush on;# 长连接超时时间，单位是秒 keepalive_timeout 65;#传输时是否压缩，压缩的话需要解压，但是传的大小就小了 #gzip on;#加载其他的配置文件，形成一带多的内容 include /etc/nginx/conf.d/*.conf;&#125; ◇ etc/nginx/conf.d/default.conf 1234567891011121314151617server &#123; listen 80; #端口号 server_name localhost; #服务器名字 access_log /var/log/nginx/host.access.log main; location / &#123; #/路径 root /usr/share/nginx/html/; #默认转发的路径 index index.html index.htm; #默认主页 &#125; error_page 500 502 503 504 /50x.html; #错误请求页面 location = /50x.html &#123; #/50x.html路径 root /usr/share/nginx/html; #当路径想要请求某些错误文件的时候，会转发到此地址 &#125;&#125; 场景实战搭建一个静态文件的Nginx服务◇上传网页文件到服务器(在本地主机的终端执行) 12#-r表示上传文件夹，上传文件夹静态网页的所有内容则直接在后面+/; root后面加上上传的地址scp -r /文件的路径/静态网页/ root@服务器的ip地址(198.xxx) :/usr/share/nginx/web/ ◇查看是否上传成功 ：ls、cat◇打开配置文件并进行修改 1234567891011# vim /etc/nginx/conf.d/default.conf#主要修改location的部分 location / &#123; root /usr/share/nginx/web/; #将html改为web index index.html index.htm; &#125; location = /50x.html &#123; root /usr/share/nginx/web; #也改成web &#125; ◇重启nginx 12nginx -t #测试配置文件是否正确nginx -s reload #重启","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://618dt.github.io/tags/Nginx/"}],"author":"LCG"},{"title":"Docker应用","slug":"Docker应用","date":"2022-02-20T01:39:00.000Z","updated":"2022-02-28T13:45:16.360Z","comments":true,"path":"p/e1be.html","link":"","permalink":"https://618dt.github.io/p/e1be.html","excerpt":"","text":"简介 基本概念、用途、核心思想 Docker的组成、架构、重要概念 Docker的安装 第一个Docker容器 运行Nginx镜像，并访问到Docker容器内部 制作自己的Docker容器，dockerfile实战 Docker的基本概念、用途、核心思想Docker应用广泛◇京东618：15万个Docker实例，所有业务全部容器化；◇蘑菇街等等Docker是什么？◇ Docker是一个用来装程序及其环境的容器，属于Linux容器的 一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux容器解决方案。◇在之前其实更多的是对一个程序进行打包，比如只把jar包上传到服务器上 ；但是Docker不仅打包程序，还将程序所需要的环境依赖一起打包；◇通过简单的接口就可以和Docker进行交互，将程序及其环境放入Docker容器中；为什么需要Docker◇没有Docker之前：环境配置的难题，如程序在本机可运行但到了其他主机无法正常运行；◇虚拟机来解决配置难题，但是虚拟机资源占用很多，且虚拟机运行的是一整套操作系统；使用虚拟机之前还需要用户登录之类的步骤，而这些步骤对于我们应用程序运行来讲都不是必须的；且虚拟机启动较慢；◇Docker的基础-Linux容器；Linux容器和虚拟机不一样，仅仅是对进程进行隔离，即在正常运行的进程外面套一个保护层；相比于虚拟机，Linux容器启动更快、占用资源更少，体积更小；Docker的用途◇提供统一的环境◇提供快速拓展、弹性伸缩的云服务；如当双十一来的时候需要快速扩展服务器；◇防止其他用户的进程把服务器资源占用过多；比如说，在宿舍使用同一个共享网络时，一个在打游戏而另一个在看电影占了大部分网络资源，就会造成游戏网络卡；当服务器跑两个不同的服务时，一个服务陷入死循环，就有可能把CPU全部占满，或者是由于其他问题导致占取大量服务器资源，导致正常的服务无法运行；那么通过Docker能够很好的解决；每一个Docker运行一个服务，来进行服务间的隔离；Docker的特点◇标准化：运输方式（把程序和环境从一个机器运到另一个机器的方式）标准化存储方式 (程序和环境的存储)标准化；API接口标准化（不需要Tomcat等应用的命令，都标准化了）◇灵活：即使是最复杂的应用也可以集装箱化；◇轻量级：容器利用并共享主机内核；◇便携式：可以在本地构建，部署到云，并放在任何地方运行；Docker带来的好处◇开发团队得到和好处，可以完全的控制我们的运行环境；降低开发风险，因为开发的应用程序会在同一个镜像运行；◇如下图，左侧是我们的容器对象，这个镜像会被推到镜像仓库中；测试人员会对程序进行各种测试，而这些测试都是基于同一个镜像实现的； Docker的组成、架构、重要概念◇整体架构图◇DOCKER_HOST可以理解为Docker服务，最左侧是指我们的客户端；客户端会连接到Docker服务并进行一系列操作；docker build、docker pull、docker run即前面所提到的API接口，利用这些统一的API去对Docker进行操作；最右侧就是我们的镜像仓库；这个仓库有各种各样的镜像；作为Docker服务，需要什么类型的镜像就从镜像仓库中获取，然后对镜像生成Container(容器)；◇三者关系 image镜像◇镜像本质是一系列文件；◇Linux存储技术：联合文件系统，UnionFS；可以把不同的目录挂到同一个虚拟系统下；把多个文件夹或者是多个文件集合起来，通过这种方式实现文件的分层；◇下图就描绘了Docker镜像分层的情况；最下面一层是操作系统的引导；Debian是一种操作系统，再网上就是我们自己的应用；◇上一层是以下一层作为基础的；最终多层共同组成了一个文件系统；不同的镜像可能有相同的底层(如操作系统，JDK)等； 容器◇镜像类似于java中的类，而容器就是实例；◇在java中有很多很多的类，比如说我们自己写的一个person类，有两个属性：姓名和年龄；在没有实例化类之前，这些属性都是固定的；如前面的镜像分层图：最上面一层有一个writeable，表示可写的；说明在镜像中只有最上层可写，其它层都是只读的；这是因为底层环境需要完整性，所以不可写，而对于一些环境的配置却需要修改，所以容器就在镜像的最上层创建了一个可读可写的系统；这样在程序运行的时候如果要写镜像里的文件就会写在最上层；比如说我修改了系统的一个文件，而此文件本身是属于Apache的，那么就有可能有两份这个文件(一个在最上层，一个在Apache环境层)；容器在找这个文件的时候，会先从最上层开始找，如果最上层没有就会往下一层找，找到之后由于之前对于Apache的文件进行了修改，所以实际上这个修改就是将该文件复制到最上层，那么最上层就有了一个已经修改过的副本；因此容器的这一层是可以修改的，而镜像是不可以修改的；只不过我们在把镜像运行起来(实例化)之后，上面会增加一个可读可写的层；◇同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰； 仓库◇构建镜像的目的就是让别人的电脑拥有和自己本地项目一样的运行环境；仓库作为我们镜像传输的中转站；◇Docker官方仓库hub.docker.com◇仓库的备选方案：https://c.163yun.com/hub/#/m/home/◇仓库有公有和私有两种； client和deamon◇client：提供给用户一个终端，用户输入Docker提供的命令来管理本地或者远程的服务器；◇deamon：服务端守护进程，接收Client发送的命令并执行相应的操作； Docker的安装◇Linux (Centos)◇安装命令： 123456789101112131415161718192021222324252627282930313233343536373839#进入管理员权限su root#查看版本cat /etc/redhat-release#配置国内yum源,wget是从网络上获取资源,/etc/yum.repos.d 是放入资源的地址,CentOS-Base.repo是源的基础配置文件,将这个文件替换为来自国内阿里云的C7版本的配置文件;wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#清理原来的软件源yum clean all#读取新的软件源yum makecache#卸载旧版本,下面全部复制即可yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#更新yumyum check-update #查看哪些需要更新yum update #执行更新#安装Docker所需的软件包yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2#使用以下命令来设置稳定的存储库sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#查看Docker可以安装的版本yum list docker-ce --showduplicates | sort -r#安装指定的版本yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io#Docker是服务器----客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动systemctl start docker #systemctl是linux中关于服务的命令,执行后开启Docker服务而不会有提示#安装完成后，运行下面的命令，验证是否安装成功docker version #查看版本#或者docker info 第一个Docker容器◇下载镜像：docker pull [OPTIONS] NAME[:TAG] //TAG代表一个标记；◇docker images [OPTIONS] [REPOSITORY[:TAG]] //显示本机有哪些镜像,[]代表可选项◇执行docker pull hello-world命令 12345Using default tag: latest //使用默认的taglatest: Pulling from library/hello-world //路径2db29710123e: Pull complete Digest: sha256:37a0b92b08d4919615c3ee023f7ddb068d12b8387475d64c622ac30f45c29c51Status: Downloaded newer image for hello-world:latest ◇执行docker images 12REPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest feb5d9fea6a5 6 weeks ago 13.3kB ◇运行镜像：docker run [OPTIONS] IMAGE [COMMAND] [ARG…]◇执行命令 docekr run hello-world 1234567891011121314151617181920Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ ◇Client 执行docker run hello-world命令，Docker daemon收到命令后就会在images中找到hello-world这个镜像（前提是已经从仓库中将该镜像下载到本地了）,然后生成实例容器，最后将hello-world的信息打印到终端； 运行Nginx镜像访问到Docker容器内部◇前台，后台；◇拉取Nginx镜像: docker pull hub.c.163.com/library/nginx:1.13.0◇运行镜像：docker run hub.c.163.com/library/nginx：1.13.0◇在另一个控制台中，查看容器列表：docker ps◇如果要停止运行镜像，则按Ctrl+C；或者：docker stop 容器ID◇后台运行Nginx镜像：docker run -d hub.c.163.com/library/nginx:1.13.0◇另一个终端，进入容器内部：docker exec [OPTIONS] CONTAINER COMMAND [ARG…]// i的意思是让我们的容器输入有效，t表示分配一个终端，那么it的意思就是把容器内部的终端映射到我们当前的终端，这样我们在这个窗口输入的命令就会到创建容器的那个窗口去；后面跟着的是容器id，而且容器的id不一定要全部输入，一般输入前几位能够区分其他容器就行了；bash对应COMMAND，意思是启动终端，执行以后会发现开头的提示符已经改变；变为root@a5cef18b0d8f:/# ，说明进入了容器内部；eg：docker exec -it a5cef18b0d8f bash◇进入容器内部后就可以执行以下命令，如 touch 1//新建名为1的文件； ls查看文件列表；◇root@a5cef18b0d8f:/# which nginx //查看nginx的目录◇exit //退出并关闭容器 Docker的网络模式三种模式◇Bridge；最常用的一种模式；相当于在Docker容器里面和外面的宿主机搭建了一座桥，容器和外部是独立的，使用这座桥进行连接；◇Host；这种模式下容器不会获得独立的网络，而是和主机使用同一个网络；◇None；即无网络连接 实操◇端口映射：对于Bridge模式，有可能内部和外部的端口不一致，这时候就需要进行端口映射；◇访问nginx内部；◇docker run -d -p 8088:80 hub.c.163.com/library/nginx:1.13.0 //表示在本机的8080端口映射到容器的80端口◇然后ps查看容器列表时可以看到PORTS将映射关系也打印了出来；◇在宿主机上查看端口是否生效了: netstat -na|grep 8088◇在浏览器上访问ip地址+8088如果是阿里云服务器的话还需要进行网络安全组的配置才能进行访问；即添加安全组规则，方向：入方向；端口范围：8088；授权对象：0.0.0.0/0(表示所有的IP都可以访问)；其他均默认◇访问成功页面：◇docker run -d -P hub.c.163.com/library/nginx:1.13.0//这里会吧容器内部的所有端口都进行映射，即随机产生一个宿主机的端口来对容器内部端口进行映射；当然Nginx只有80一个端口； 制作自己的Docker容器dockerfile作用◇dockerfile就是用来告诉docker我们要怎么制作镜像，制作镜像的每一个步骤是什么；即dockerfile是用来配置镜像的；我们制作镜像往往是在已有的镜像上去添砖加瓦，加上个性化的配置形成我们自己的镜像； 使用dockerfile的好处◇使用dockerfile来描述我们的环境有以下好处：可以把文件放在版本控制之下，这样我们对于环境所做的修改就可以被追踪到，总是知道一个程序运行在什么样的环境之下；而且，有了这个dockerfile之后，我们可以知道程序的运行需要什么样的环境，里面装了哪些软件，怎么配置的；通过dockerfile来维护环境而不是自己配置的话，可以保证该文件始终是新的，这样如果有新的同事加入后，只需要看这个文件就了解到项目的配置情况； 写自己的dockerfile◇FROM alpine:latest //创建一个新的镜像，FROM后是一个基础的镜像；alpine是专门针对Docker来做的一个极小型的Linux环境；◇MAINTAINER lcg// 表示这个镜像的维护者；◇CMD echo ‘hello my dockerfile’//终端中打印’’里的语句；◇具体步骤 123456789101112cd /roottouch Dockerfilevim Dockerfile在Dockerfile中： 按i进入编辑模式FROM alpine:latestMAINTAINER lcgCMD echo &#x27;hello lcg&#x27;Esc退出编辑模式；键入:wq 保存;cat Docekrfile 查看文件//下面制作镜像;-t指定名字; .代表就在当前路径下创建docker build -t hello_docker .docker images//查看镜像是否创建成功 ◇运行镜像 docker run hello_docker 查看终端是否打印信息；","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://618dt.github.io/tags/Docker/"}],"author":"LCG"},{"title":"分布式基础","slug":"分布式基础","date":"2022-02-20T01:19:00.000Z","updated":"2022-02-28T13:45:16.366Z","comments":true,"path":"p/38b2.html","link":"","permalink":"https://618dt.github.io/p/38b2.html","excerpt":"","text":"介绍 什么是分布式 分布式的作用 分布式和单体结构的对比 CAP定理 集群、分布式、微服务的区别 什么是分布式◇权威定义： 利用物理架构形成多个自治的处理元素，不共享主内存，但是通过发送信息合作。——Leslie Lamport◇饭店厨师的例子；一个顾客(用户)来到饭店(网站服务器)点餐；对于顾客而言，只需要点菜；对于饭店而言，尽可能准确地满足顾客的要求；如上菜时间短(性能好)，菜品卫生(系统安全), 添加调料(系统拓展性好)， 营业时间24小时(系统高可用);这些服务在顾客数量不多的时候能够尽可能满足，所以请了一个厨师(单体系统)来复制洗菜，炒菜等等；但由于顾客数量增多，那么一个厨师忙不过来；所以聘请多个厨师，但厨师的任务任然是洗菜，炒菜等，当顾客多的时候，哪个厨师空闲，就安排那个厨师干活；在计算机中的例子就是集群部署，将一个单体系统部署到不同的服务器上去；但是，这样的话厨师执行的任务多了，无法专注于某一个领域，因此，术业有专攻，根据不同的任务聘请不同的工人：洗菜工，配菜师，炒菜师；◇ 实际项目的演进过程一个项目，大而全多台机器，部属同样的应用，即每台服务器上的代码一样；但实际上这是一种资源的浪费，因为不是每一个系统的使用频率都比较高；分布式：权限系统、员工系统、请假系统 分布式的作用为什么需要分布式◇实际工作中的痛点：工程臃肿、测试，上线繁琐、开发效率低；单体应用的问题◇应用代码耦合严重，功能扩展难◇新需求开发交互周期长，测试工作量大◇新加入的开发人员需要很长时间才能熟悉系统◇升级维护也很困难(改动任何一点地方都有升级整个系统)◇系统性能提升艰难，可用性低，不稳定分布式的好处◇增大系统容量◇加强系统可用◇因为模块化，所以系统模块重用度更高◇因为软件服务模块被拆分，开发和发布速度可以并行而变得更快◇系统扩展性更高◇团队协作流程也会得到改善◇技术升级分布式和单体结构的对比 CAP定理 CAP的重要性 CAP理论是什么？ 分区容错 一致性 可用性 CAP怎么选择？CAP的重要性◇是分布式系统设计中最基础最关键的理论；它指明分布式不可能同时满足CAP这三个条件；CAP理论是什么C（Consistency，一致性）：读操作是否总能读到前一个写操作的结果A（Availability，可用性）：非故障节点应该在合理的时间内作出合理的响应（不是错误或超时的响应），但是可能不是最新的数据P（Partition tolerance，分区容错性）：当出现网络分区现象后，系统能够继续“履行职责”， 尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。◇三者只能选其二◇分区容错(P)：指结点之间通信可能出错；且分区容错是不可避免的；◇一致性(C);一个内容被改变后，第二个人能读到这种改变；如：client(客户)发消息给服务器G1，将v0改为v1;并且G1给client一个返回说明更改成功；然后client去读取服务器G2的与G1保存的相同参数v的值，如果返回的是v0的话，说明G2与G1不一致，没有达到一致性；为了让G1和G2保持一致性，他们之间是需要发送消息来保持同步的；◇可用性(A); 非故障节点应该在合理的时间内作出合理的响应（不是错误或超时的响应)，但是可能不是最新的数据,因为如果一致性不能保证的话就拿不到最新的数据； CAP怎么选择◇火车票；如果火车票很紧张，抢票的人很多，那这个时候售票系统就需要保持一致性；如果不保持一致性的话，就会导致两个人购买了同一张票；◇银行转账；我们在跨行转账的时候在一致性上可以有延迟，但一定能够成功转账，所以银行转账系统需要保证可用性；◇由于P即分区容错一定存在，所以只能有两种选择：CP或者AP；◇在什么场合，可用性高于一致性？比如一个网站需要更新，可以让一些用户使用老版本，一些用户使用新版本，这种一致性可以慢慢达到，但是必须保证可用性，即用户都能够访问到网站；◇根据具体的业务场景进行选择； 集群、分布式、微服务的区别集群和分布式的区别◇集群：同一个业务，部署在多个服务器上◇集群的多个服务器可以没有通信，但分布式不同的服务器之间需要互相通信；◇分布式：一个业务分拆多个子业务，部署在不同的服务器上 集群和微服务的区别◇集群：分散压力◇微服务：分散能力 分布式和微服务的区别◇分布式是系统部署方式，是物理上的架构◇微服务是架构设计方式，是一种逻辑上的架构◇微服务是一种架构设计方式，把一个大的服务拆分成一个小的服务，每个小的服务只有一个功能，能够独立开发，测试以及部署，服务之间通过通信进行调用；◇微服务是通过分布式实现的；","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://618dt.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"author":"LCG"},{"title":"ThreadLocal","slug":"ThreadLocal","date":"2022-02-20T00:19:00.000Z","updated":"2022-02-28T13:45:16.364Z","comments":true,"path":"p/4b81.html","link":"","permalink":"https://618dt.github.io/p/4b81.html","excerpt":"","text":"简介 两大使用场景典型场景1◇每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）多个线程共享同一个静态工具类是有风险的，所以需要使用ThreadLocal来帮每一个线程制作一个独享的对象，让线程和线程之间拥有的工具类对象是不同的实例；◇每个线程需要一个独享的对象；每个Thread内有自己的实例副本，不共享；例如：教材只有一本，一起做笔记有线程安全问题，而复印后没问题； ◇SimpleDateFormat的进化之路；两个线程分别用自己的SimpleDateFormat；一共有两个线程，都需要去打印日期，所以都需要使用到SimpleDateFormat这个工具类； 12345678910111213141516171819202122232425262728293031/** * 描述： 两个线程打印日期 */public class ThreadLocalNormalUsage00 &#123; public static void main(String[] args) &#123; //第一个线程 new Thread(new Runnable() &#123; @Override public void run() &#123; String date = new ThreadLocalNormalUsage00().date(10);//10s以后的时间是多少 System.out.println(date); &#125; &#125;).start(); //第二个线程 new Thread(new Runnable() &#123; @Override public void run() &#123; String date = new ThreadLocalNormalUsage00().date(104707); System.out.println(date); &#125; &#125;).start(); &#125; public String date(int seconds) &#123; //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时 Date date = new Date(1000 * seconds); SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); return dateFormat.format(date); &#125;&#125; ◇如果当需求变成了1000个，那么必然要用线程池(否则消耗内存太多)； 12345678910111213141516//固定10个数量的线程池public static ExecutorService threadPool = Executors.newFixedThreadPool(10);public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 1000; i++) &#123; int finalI = i; threadPool.submit(new Runnable() &#123; @Override public void run() &#123; String date = new ThreadLocalNormalUsage02().date(finalI); System.out.println(date); &#125; &#125;); &#125; threadPool.shutdown();//关闭线程池&#125; ◇1000个任务新建了1000个SimpleDateFormat对象，这样开销太大了；优化代码，不需要每一个任务都新建SimpleDateFormat对象；即在外部创建一个静态的SimpleDateFormat对象，每一次执行任务时直接使用，而不新建； 123456static SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);public String date(int seconds) &#123; //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时 Date date = new Date(1000 * seconds); return dateFormat.format(date); &#125; ◇但是这样就会出现前面提到过的线程安全问题，导致会出现打印出相同的时间(我们的目的是没一次打印的时间都会增加1s)；即当所有的线程都共用同一个SimpleDateFormat对象就有可能产生线程安全；◇尝试利用加锁的方法来解决线程安全问题；锁应该加在危险的代码行，即return dateFormat.format(date)处；这样就能避免多个线程共同使用SimpleDateFormat对象； 123456String s = null;//类锁synchronized (ThreadLocalNormalUsage04.class) &#123; s = dateFormat.format(date);&#125;return s; ◇通过加锁的方式能够有效避免多个线程共同使用SimpleDateFormat对象；但是这样的方法会导致线程使用对象时排队，这样效率就比较低;那么，更好的解决方案是使用ThreadLocal；即给每一个线程内部使用一个df(dateformate)；线程池有十个线程，那就创建十个dateformate对象； 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 描述：利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存 */public class ThreadLocalNormalUsage05 &#123; public static ExecutorService threadPool = Executors.newFixedThreadPool(10); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 5; i++) &#123; int finalI = i; threadPool.submit(new Runnable() &#123; @Override public void run() &#123; String date = new ThreadLocalNormalUsage05().date(finalI); System.out.println(date); &#125; &#125;); &#125; threadPool.shutdown(); &#125; public String date(int seconds) &#123; //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时 Date date = new Date(1000 * seconds);// 利用get()方法获取dateFormat对象// 相当于前面的SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal2.get(); return dateFormat.format(date); &#125;&#125;//创建线程安全的对象class ThreadSafeFormatter &#123; //创建静态的ThreadLocal,即想调用就调用 public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123;//重写初始化函数 return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; &#125;; /*使用lambda表达式重写函数*/ public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal2 = ThreadLocal .withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));&#125; 典型场景2◇每个线程内需要保存全局变量（例如在拦截器中获 取用户信息），可以让不同方法直接使用，避免参数传递的麻烦；◇实例：当前用户信息需要被线程内所有方法共享；一个比较繁琐的解决方案是把user作为参数层层传递，从service-1传到service-2，再传到service-3，以此类推，但这样做会导致代码冗余且不易维护；◇设想直接给一个全局的用户信息，每一次想要用的时候直接调用就行了；这种想法也是不可取的，因为在这种场景下，每个请求对应着不同的用户；那么又设想使用UserMap，来保存登录用户的信息；如下图，第一个方法生成user对象放到UserMap中，后面的方法需要用时就往里面取；◇但是，这样一来就会产生新的问题：usermap是很有可能被多个线程同时使用的，必须保证线程安全；◇当多个线程同时工作是，我们需要保证线程安全，可以用synchroized,也可以用ConcurrentHashMap,但无论用什么，都会对性能有所影响；◇更好的办法是使用ThreadLocal，这样无需synchronized,可以在不影响性能的情况下，也无需层层传递参数，就可以达到保存当前线程对应的用户信息的目的；用ThreadLocal保存一些业务内容(用户权限信息、从用户系统获取到的用户名、user ID等)；这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的；◇在线程生命周期内，都通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象(例如user对象)作为参数传递的麻烦；◇与场景一不同，这里强调的是同一个请求内(同一个线程内)不同方法间的共享；不需要重写initialValue()方法，但是必须手动调用set()方法；◇代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 描述： 演示ThreadLocal用法2：避免传递参数的麻烦 */public class ThreadLocalNormalUsage06 &#123; public static void main(String[] args) &#123; new Service1().process(&quot;&quot;); &#125;&#125;//用来设置用户信息;class Service1 &#123; public void process(String name) &#123; User user = new User(&quot;张珊&quot;); UserContextHolder.holder.set(user); new Service2().process(); &#125;&#125;class Service2 &#123; public void process() &#123; User user = UserContextHolder.holder.get(); System.out.println(&quot;Service2拿到用户名：&quot; + user.name); new Service3().process(); &#125;&#125;class Service3 &#123; public void process() &#123; User user = UserContextHolder.holder.get(); System.out.println(&quot;Service3拿到用户名：&quot; + user.name); &#125;&#125;//持有用户信息的类;class UserContextHolder &#123; //这里不需要重写initialValue方法; public static ThreadLocal&lt;User&gt; holder = new ThreadLocal&lt;&gt;();&#125;//用户实体类class User &#123; String name; public User(String name) &#123; this.name = name; &#125;&#125; ◇如下图，第一个线程进来之后执行service-1，会将user信息设置进去；然后service-2,3,4就可以直接获取；同样对于第二个请求(对应第二个线程)来讲，也是用1设置信息，2,3,4来读取 总结ThreadLocal的两个作用 让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象） 在任何方法中都可以轻松获取到该对象◇根据共享对象的生成时机不同，选择initialValue或set来保存对象；◇例如，在场景一中，使用initialValue；在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制；◇在场景二中，使用set；因为如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制(在上例中的拦截器生成的用户信息)；因此使用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用；使用ThreadLocal带来的好处◇达到线程安全◇不需要加锁(线程之间的对象是独立的)，提高执行效率◇更高效地利用内存、节省开销 --相比于每个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销 ◇免去传参的繁琐 -- 不需要每次都传同样的参数 -- ThreadLocal使得代码耦合度更低，更优雅 主要方法介绍◇**T initialValue( )：初始化 ；①该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get的时候，才会触发 ；②当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本 initialValue方法③ 通常，每个线程最多调用一次此方法，但如果已经调用了remove()来删除后，再调用get()，则可以再次调用此方法④ 如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象。◇void set(T t)：为这个线程设置一个新值◇T get( )：得到这个线程对应的value。如果是首次调用 get()，则会调用initialize来得到这个值◇void remove( )**：删除对应这个线程的值；如：UserContextHolder.holder.remove(); 图解ThreadLocal原理◇搞清楚 搞清楚Thread，ThreadLocal以及 ThreadLocalMap三者之间的关系◇每个Thread对象中都持有一个ThreadLocalMap成员变量◇一个ThreadLocalMap存储很多ThreadLocal，这是因为一个线程可能有多个ThreadLocal对象；◇get方法； get方法是先取出当前线程的ThreadLocalMap ；然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入 ； 取出map中属于本ThreadLocal的value ；◇注意：这个map以及map中的key和value都是保存在线程中的，而不是保存在ThreadLocal中；◇ initialValue方法 – 没有默认实现– 如果要用initialValue方法，需要自己实现– 通常使用匿名内部类的方式实现◇ remove方法用来删除保存的自定义对象；这里要注意的是，从线程中获取到的ThreadLocalMap对象是包含了很多个ThreadLocal的，但需要删除的只是当前的ThreadLocal对象，所以使用this引用作为参数执行m.remove()方法； ThreadLocalMap 类◇ThreadLocalMap类，也就是Thread.threadLocals◇ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[] table，可以认为是一个 map，键值对：◇键：这个ThreadLocal◇值：实际需要的成员变量，比如User或者 SimpleDateFormat对象◇类似于HashMap的结构，但是遇到冲突的解决方法和HashMap不同；在HashMap中使用拉链法和红黑树来解决冲突；◇而在ThreadLocalMap中采用线性探测法，也就是如果发生冲突，就继续找下一个空位置而不是用链表拉链； 两种使用场景殊途同归◇通过源码分析可以看出，setInitialValue和直接set最后都是利用map.set()方法来设置值◇也就是说，最后都会对应到ThreadLocalMap的一个Entry，只不过是起点和入口不一样 内存泄漏◇什么是内存泄漏：某个对象不再有用，但是占用的内存却不能被回收◇泄露有两种情况：ThreadLocal的泄露和key的泄露◇key的泄漏：ThreadLocalMap中的Entry(即键值对)继承自 WeakReference，是弱引用 12345678910//ThreadLocal部分源码 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ◇弱引用的特点：如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收;我们平常的赋值如Object value; value=v都是强引用；◇由于Value是强引用，则会导致内存的泄露；◇ThreadLocalMap 的每个Entry 都是一个对key的弱引用，同时， 每个 Entry 都包含了一个对value的强引用◇正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了◇但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收，因为有以下的调用链： Thread→ ThreadLocalMap→ Entry（key为null）→ Value◇因为value和Thread之间还存在这个强引用链路，所以导致value 无法回收，就可能会出现OOM◇JDK已经考虑到了这个问题，所以在set, remove, rehash方法中会扫描key为null的Entry，并把对应的value设置为null，这样value对象就可以被回收；如下面ThreadLocal中resize()方法的源码，它会判断如果k==null的话，就将其value也置空； 12345678910111213141516171819202122private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; ◇但是如果一个ThreadLocal不被使用，那么实际上set, remove, rehash方法也不会被调用，如果同时线程又不停止，那么调用链就一直存在，那么就导致了value的内存泄漏◇那么如何避免内存泄漏呢？答案是使用阿里规约；◇ 调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal之后，应该调用remove方法；如在场景二中假设最后一个service3使用完ThreadLocal后，调用remove方法； 1234567class Service3 &#123; public void process() &#123; User user = UserContextHolder.holder.get(); System.out.println(&quot;Service3拿到用户名：&quot; + user.name); UserContextHolder.holder.remove(); &#125;&#125; 空指针异常◇代码示例 123456789101112131415161718192021222324public class ThreadLocalNPE &#123; ThreadLocal&lt;Long&gt; longThreadLocal = new ThreadLocal&lt;Long&gt;(); public void set() &#123; longThreadLocal.set(Thread.currentThread().getId()); &#125; public long get()&#123; return longThreadLocal.get(); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; ThreadLocalNPE threadLocalNPE = new ThreadLocalNPE(); //threadLocalNPE.set(); System.out.println(threadLocalNPE.get()); &#125; &#125;); //执行线程 t1.start(); &#125;&#125; 以上代码没有set而是自己get，就会抛出空指针异常；但是，如果将get方法的返回值类型有long改为Long，就会打印出null，而不报空指针异常；这是因为我们的泛型指定的是Long包装类型的长整形，而返回类型是基本类型的长整型，它就会做一下装箱拆箱，这样一来在装箱拆箱过程中尝试将get得到到对象转回基本类型long；由于对象是空的，所以在转换的时候抛出空指针异常；即空指针异常的问题通常是由于转换不当造成的；","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://618dt.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"LCG"},{"title":"线程池","slug":"线程池","date":"2022-02-19T23:19:00.000Z","updated":"2022-02-28T13:45:16.368Z","comments":true,"path":"p/e2.html","link":"","permalink":"https://618dt.github.io/p/e2.html","excerpt":"","text":"多线程与分布式课程介绍◇线程池的基本使用、特点、注意点◇ThreadLocal的基本使用，原理和注意事项◇分布式基础、核心概念◇docker的下载、安装和基本命令◇独立制作docker容器◇Nginx的安装、基本使用和常用命令◇使用Nginx搭建文件服务◇消息队列RabbitMQ的核心概念queue、message和exchange◇RabbitMQ的四种交换机模式◇Spring Boot整合RabbitMQ案例 线程池-治理线程的最大法宝◇线程池的自我介绍◇创建和停止线程池◇常见线程池的特点和用法◇任务太多、怎么拒绝？◇钩子方法，给线程池加点料◇实现原理、源码分析◇使用线程池的注意点 线程池的自我介绍◇线程池的重要性，工作、面试◇什么是”池” –软件中的”池”，可以理解为计划经济；资源是有限的，需要合理分配线程；◇如果不使用线程池，每个任务都新开一个线程处理；多个任务的话用for循环创建线程；◇创建线程的方式 123456789101112131415package threadpool;//每个任务创建一个线程public class EveryTaskThread&#123; public static void main(String[] args)&#123; Thread thread = new Thread(new Task()); thread.start();//启动线程 &#125; static class Task implements Runnable&#123;//创建一个任务 @Override public void run()&#123; //重写run方法 System.out.pringln(&quot;执行任务&quot;); &#125; &#125;&#125; 12345678910111213141516//循环创建public class ForLoop&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;10;i++)&#123; Thread thread = new Thread(new Task()); thread.start();//启动线程 &#125; &#125; static class Task implements Runnable&#123;//创建一个任务 @Override public void run()&#123; //重写run方法 System.out.pringln(&quot;执行任务&quot;); &#125; &#125;&#125; ◇如果任务数量过于庞大，使用上面的方法显然开销太大了；我们希望有固定数量的线程，来执行者1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题； 为什么要使用线程池◇问题一：反复创建线程开销大◇问题二：过多的线程会占用太多内存◇解决以上两个问题的思路 • 用少量的线程——避免内存占用过多 • 让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗 线程池的好处◇加快响应速度◇合理利用CPU和内存◇统一管理 线程池适合应用的场合◇服务器接收到大量请求时，使用线程池技术是非常合适的，它可 以大大减少线程的创建和销毁次数，提高服务器的工作效率◇实际上，在开发中，如果需要创建5个以上的线程，那么就可以使 用线程池来管理 创建线程池◇线程池构造方法的参数◇线程池应该手动创建还是自动创建 ，手动创建更加灵活；◇线程池里的线程数量设定为多少比较合适？◇停止线程池的正确方法 线程池构造方法的参数 参数中的corePoolSize和maxPoolSize◇corePoolSize指的是核心线程数 线程池在完成初始化后，默认情况下，线程池中并没有任何线程,线程池会等待有任务到来时,再创建新线程去执行任务◇最大量maxPoolSize 在核心线程数的基础上，额外增加的线程数的上限 corePoolSize和maxPoolSize◇从左开始看，当任务进来后就会创建线程一直到达到Current size后；任务会依次使用初始化时的核心线程数来执行任务，一般情况不会突破这个数量；如果任务过多，就会存储到队列中去，等核心线程有剩余后再出队去处理；如果队列满了，并且核心线程数量都在被使用，这样线程池就会在核心线程数的基础上增加新的线程来处理任务，线程数量最多扩展到Max pool size； 添加线程规则 如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。 如果线程数等于（或大于）corePoolSize但少于 maximumPoolSize，则将任务放入队列。 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务。 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。◇是否需要增加线程的判断顺序是： • corePoolSize • workQueue • maxPoolSize 举例说明◇线程池：核心池大小为5，最大池大小为10，队列为100。◇因为线程中的请求最多会创建5个，然后任务将被添加到队列 中，直到达到100。当队列已满时，将创建最新的线程 maxPoolSize，最多到10个线程，如果再来任务，就拒绝。增减线程的特点 通过设置corePoolSize和maximumPoolSize 相同，就可以创建固定 大小的线程池。 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。 通过设置maximumPoolSize为很高的值，例如 Integer.MAX_VALUE， 可以允许线程池容纳任意数量的并发任务。 只有在队列填满时才创建多于corePoolSize的线程，如果使用的是无 界队列（例如LinkedBlockingQueue），那么线程数就不会超过 corePoolSize。 keepAliveTime◇如果线程池当前的线程数多于corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止 ThreadFactory 用来创建线程◇新的线程是由ThreadFactory创建的，默认使用 Executors.defaultThreadFactory()◇创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。◇如果自己指定ThreadFactory，那么就可以改变线程名、线程 组、优先级、是否是守护线程等。◇通常使用默认的ThreadFactory就可以了 工作队列◇有3种最常见的队列类型： 直接交接：SynchronousQueue ；如果任务不是特别多的话，只是把任务通过这个队列进行简单的中转，交到线程去处理的话就可以使用该队列；这个队列本身内部是没有容量的，里面不能存储任务，任务过多的话就不能够缓冲，所以使用时要把初始线程数设置大一点； 无界队列：LinkedBlockingQueue ；无界队列不会被塞满，使用无界队列可以防止流量突增带来的影响；但也有风险：比如说我们任务处理的速度跟不上任务提交的速度，那么无界队列的任务会越来越多可能会造成内存浪费或者内存溢出(OOM)异常； 有界的队列：ArrayBlockingQueue ;可以设置队列的大小；线程池应该手动创建还是自动创建◇手动创建更好，因为这样可以更加明确线程池的运行规则，避免资源耗尽的风险◇ 自动创建线程池（即直接调用JDK封装好的构造方法） 可能带来哪些问题？◇newFixedThreadPool • 容易造成大量内存占用，可能会导致OOM 1234567891011121314151617181920212223242526package threadpool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//演示如何创建newFixedThreadPool 线程池public class TestClass &#123; public static void main(String[] args) &#123; //线程数量固定为4，使用无限大的队列 ExecutorService executorService = Executors.newFixedThreadPool(4); for (int i = 0; i &lt; 1000; i++) &#123; executorService.execute(new Task()); &#125; &#125;&#125;//创建任务class Task implements Runnable&#123; public void run() &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread()); &#125;&#125; ◇为了便于演示，应该将累成设置的小一点: 在编辑运行中设置VM options：-Xmx8m -Xms8m 1234567891011121314151617181920212223/** * 描述： 演示newFixedThreadPool出错的情况 */public class FixedThreadPoolOOM &#123; private static ExecutorService executorService = Executors.newFixedThreadPool(1); public static void main(String[] args) &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; executorService.execute(new SubThread()); &#125; &#125;&#125;class SubThread implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000000000);//一直在睡眠中,即任务一个都不能执行;这样能有效的将队列填满 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ◇newSingleThreadExecutor • 当请求堆积的时候，可能会占用大量的内存 123456789//单个线程，只有一个线程的线程池；核心数量和最大数量都设置为1;public class SingleThreadExecutor &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 1000; i++) &#123; executorService.execute(new Task()); &#125; &#125;&#125; ◇newCachedThreadPool 可以缓存线程池 ；特点：具有自动回收多余线程的功能(时间是60s)◇使用了直接交换的队列，线程池设置的线程最大数为整形的最大值； • 弊端在于第二个参数maximumPoolSize被设置为了 Integer.MAX_VALUE，这可能会创建数量非常多的线程， 甚至导致OOM 1ExecutorService executorService = Executors.newCachedThreadPool(); ◇newScheduledThreadPool；支持定时及周期性任务执行的线程池； • 原因和newCachedThreadPool一样 1234ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);//设置核心数量//threadPool.schedule(new Task(), 5, TimeUnit.SECONDS);//任务,延迟时间,时间单位//开始执行与1s,然后每隔3S执行一次threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS); ◇正确的创建线程池的方法：根据不同的业务场景，设置线程池参数 ；◇以上4种线程池的构造方法的参数 线程池里的线程数量设定为多少比较合适？◇CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。◇耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一 般会大于CPU核心数很多倍 参考Brain Goetz推荐的计算方法： 线程数=CPU核心数*（1+平均等待时间/平均工作时间） 阻塞队列分析◇FixedThreadPool和SingleThreadExecutor的Queue是LinkedBlockingQueue? 是因为由于线程数量是有限的，所以不得不用一个很大甚至无限大的队列来存储任务；◇CachedThreadPool使用的Queue是SynchronousQueue？ SynchronousQueue队列内部是不存储的，而刚好CachedThreadPool的线程数量很多，不需要队列来存储任务；◇ScheduledThreadPool来说，它使用的是延迟队列 DelayedWorkQueue◇workStealingPool是JDK1.8加入的；该线程池和之前的都有很大不同，适用于能够产生子任务的任务；如二叉树的遍历；该线程池拥有窃取能力，即线程之间会进行合作；用它执行的任务最好不要加锁，这样更加高效的进行并行执行；执行的顺序不能保障；实际开发中很少用到； 停止线程池停止线程池的正确方法1、shutdown；实际上运行该方法后线程池不一定停止，这个方法事实上只是初始化关闭的过程；因为在线程池被关闭的时候有线程中正在被执行的任务和在存储队列中的任务；所以不是一个命令想停就停的；shutdown方法执行后即通知要关闭线程池，然后拒绝所有新的任务，但线程池会把正在执行的以及还在队列中等待的任务执行完后才关闭；2、isShutdown ；判断线程池是否停止，并不是完全停止，而是指是否执行了shutdown方法； 12345678910111213public class ShutDown &#123; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 1000; i++) &#123; executorService.execute(new ShutDownTask()); &#125; Thread.sleep(1500);//休眠1.5s System.out.println(executorService.isShutdown());//判断是否停止 executorService.shutdown();//停止线程池 System.out.println(executorService.isShutdown()); executorService.execute(new ShutDownTask());//添加新任务 &#125;&#125; 可以看出，在成功执行shutdown方法后，添加新任务会出现异常，但原先正在执行或者在等待中的任务会被执行；3、isTerminated ;用来判断线程是否完全终止，即线程池里的任务是否执行完毕；4、awaitTermination；用来测试在一段时间内线程池是否会完全关闭；返回只有三种情况，在返回之前该方法是阻塞的：①所有任务都执行完毕；②达到等待的时间；③等待过程中被中断 1executorService.awaitTermination(3L, TimeUnit.SECONDS);//(时间,时间单位) 5、shutdownNow ；立刻关闭线程池，用中断的信号触发正在执行的任务；而在队列里的任务直接加入列表中作为返回对象返回； 1List&lt;Runnable&gt; runnableList = executorService.shutdownNow(); 任务太多，怎么拒绝？◇拒绝时机1.当Executor关闭时，提交新任务会被拒绝。2.以及当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时 四种拒绝策略◇AbortPolicy；直接抛出异常，终端可以得知任务未提交成功◇DiscardPolicy；将任务丢弃，但不通知到终端；◇DiscardOldestPolicy ；丢弃最旧的任务，腾出空间存放新提交的任务◇CallerRunsPolicy ；让提交任务的线程去执行任务，优点是避免任务损失、可以降低提交任务的速度； 钩子方法，给线程池加点料◇每个任务执行前后增加执行钩子函数能够起到暂停恢复线程池的作用；◇日志、统计◇代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 演示每个任务执行前后放钩子函数 */public class PauseableThreadPool extends ThreadPoolExecutor &#123; //为了保证布尔值的并发修改是安全的，给其上一把锁； private final ReentrantLock lock = new ReentrantLock(); //休眠线程 private Condition unpaused = lock.newCondition(); private boolean isPaused;//标记位，线程池是否暂停； public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); &#125; public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory); &#125; public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler); &#125; public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); &#125; @Override protected void beforeExecute(Thread t, Runnable r) &#123; super.beforeExecute(t, r); lock.lock(); try &#123; while (isPaused) &#123;//是暂停 unpaused.await();//休眠线程 &#125; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; //暂停方法 private void pause() &#123; lock.lock(); try&#123; isPaused=true; &#125;finally &#123; lock.unlock(); &#125; &#125; //恢复方法 public void resume() &#123; lock.lock(); try &#123; isPaused=false; unpaused.signalAll();//唤醒所有线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //新建线程池 PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); Runnable runnable = new Runnable()&#123; @Override public void run() &#123; System.out.println(&quot;线程被执行&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for (int i = 0; i &lt; 1000; i++) &#123; pauseableThreadPool.execute(runnable); &#125; Thread.sleep(1500); pauseableThreadPool.pause();//暂停线程池 System.out.println(&quot;线程池已被暂停&quot;); Thread.sleep(1500); pauseableThreadPool.resume();//恢复线程池 System.out.println(&quot;线程池已恢复&quot;); &#125;&#125; 线程池实现原理、源码分析◇线程池组成部分• 线程池管理器• 工作线程• 任务队列• 任务接口（Task) Executor家族◇线程池、ThreadPoolExecutor、ExecutorService、Executor、 Executors等这么多和线程池相关的类，都是什么关系？◇关系如下图，△代表继承；◇Executor是一个接口，只有一个方法， void execute()用来执行；◇ExecutorService也是一个接口，继承了Executor；增加了shutdown等方法；◇Executors是一个工具类，有很多方法用来创建各种线程池等； 线程池实现任务复用的原理◇核心：相同的线程执行不同任务；线程池对线程进行了包装，不需要重复的启动线程；只是启动已有的固定数量的线程即可；在线程池中的线程，不同于普通的线程，它里面的Run方法会不停的检测有没有新的任务进来，有的话就会执行任务的run方法，也就是把这些任务串联起来；线程池让这些固定的线程从任务队列中把任务取出来并且执行；◇源码分析：runWorker()方法； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final void runWorker(Worker w) &#123; // 获取当前线程对象的引用 Thread wt = Thread.currentThread(); // 获取worker的firstTask Runnable task = w.firstTask; // 获取完之后把worker的firstTask置为null 防止下次获取到 w.firstTask = null; // 初始化worker的state = 0, exclusiveOwnerThread = null 解锁 w.unlock(); // 如果发生异常 当前线程突然退出 该值为true boolean completedAbruptly = true; try &#123; // 如果firstTask获取getTask能获取到任务 则进行内层逻辑, 如果getTask返回null则循环退出了就要 while (task != null || (task = getTask()) != null) &#123; /* * worker设置独占锁 * shutdown 时会判断当前worker的状态，根据独占锁的状态来判断worker是否在处理任务是否工作 */ w.lock(); /* * 3个判断 * 1、runStateAtLeast(ctl.get(), STOP)为真说明当前状态大于等于STOP 此时需要给他一个中断信号 * 2、wt.isInterrupted()查看当前是否设置中断状态如果为false则说明为设置中断状态 * 3、Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP) 获取当前中断状态且清除中断状态 * 这个判断为真的话说明当前被设置了中断状态(有可能是线程池执行的业务代码设置的，然后重置了)且当前状态变成了大于等于STOP的状态了 * * 整个判断为真的两种情况 * 1、如果当前线程大于等于STOP 且未设置中断状态 整个判断为true 第一个runStateAtLeast(ctl.get(), STOP)为true !wt.isInterrupted()为true * 2、第一次判断的时候不大于STOP 且当前设置了中断状态(Thread.interrupted()把中断状态又刷新了) 且设置完了之后线程池状态大于等于STOP了 * Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP) 为true !wt.isInterrupted()为true * * 结合if判断里面的代码来看 * 也就是说如果线程池状态大于等于STOP则设置当前线程的中断状态 * 如果线程池状态小于STOP则清除中断状态 */ if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) // 设置中断状态 wt.interrupt(); try &#123; // 钩子方法留给子类实现 beforeExecute(wt, task); try &#123; // task可能是FutureTask或者普通Runnable/Callable接口实现类 task.run(); // 钩子方法 留给子类实现 afterExecute(task, null); &#125; catch (Throwable ex) &#123; afterExecute(task, ex); throw ex; &#125; &#125; finally &#123; // 局部task设置为null task = null; // 完成数量加1 w.completedTasks++; // 使用unlock 释放独占锁 w.unlock(); &#125; &#125; // getTask的返回为null 会走到这行 表示这次不是异常退出 completedAbruptly = false; &#125; finally &#123; /* * 执行线程退出逻辑 * 如果completedAbruptly是true说明是task.run()方法有异常 先catch后又抛了出来 在执行完了w.unlock();走到了这里 * 如果是false则说明是拿不到任务走到了这里 */ processWorkerExit(w, completedAbruptly); &#125;&#125; 线程池状态 使用线程池的注意点◇避免任务堆积◇避免线程数过度增加◇排查线程泄漏，即任务结束后线程却回收不了 线程工厂线程工厂为线程设置了如下内容： 默认名字（pool-线程池自增编号-thread-线程的自增编号） 非守护线程 默认优先级 默认线程组","categories":[{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://618dt.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"LCG"},{"title":"SpringBoot入门","slug":"SpringBoot入门","date":"2022-02-09T22:19:00.000Z","updated":"2022-02-23T13:33:00.281Z","comments":true,"path":"p/e10.html","link":"","permalink":"https://618dt.github.io/p/e10.html","excerpt":"","text":"前期准备课程简介1.Spting Boot概述2.Spring Boot版本介绍3.新建Spring Boot项目演示(官网和IDEA两种) 软件版本Java 1.8.0_171（大版本一致）MySQL 8.0.12（大版本一致）Maven 3.3.9（大版本一致）Spring Boot 2.2.1（版本需要严格一致） Spring Boot诞生历史◇Spring的缺点：配置过于繁琐◇Spring Boot开发团队: Pivotal Spring Boot简介◇简化初始搭建以及开发过程◇不再需要定义样板化的配置◇快速应用开发领域 Spring、Spring MVC、Spring Boot◇Spring最初利用IOC和AOP解耦◇按照这种模式搞了MVC框架◇写很多样板代码很麻烦，就有了Spring Boot◇Spring Cloud是在Spring Boot基础上诞生的； Spring Boot核心特点◇开箱即用：对于spring需要Tomcat等一系列配置，而springboot不需要；◇约定优于配置，在开发中遵守某种约定； Spring Boot版本介绍◇CURRENT，代表最新的GA版本◇GA，General Availability（正式发布版本),面向大众的，功能完美并且稳定；◇SNAPSHOT，版本会被修改◇如何选择版本？选择GA版本，不一定要最新的； Spring Boot 项目开发官网构建◇Spring官网 来进行开发；选择maven-&gt;选择springboot版本-&gt;填写工程名-&gt;选择jar包-&gt;增加springweb依赖-&gt;Explore(预览)-&gt;Generate(生成)；◇打开IDEA，点击import Project(引入项目),将刚才下载好的项目解压并进入文件夹点击open-&gt;选择Maven-&gt;勾选Import Maven projects automatically-&gt;next-&gt;finish;可以看到会生成一个启动类xxxApplication,这个启动类最好不要随意更改位置； IDEA集成◇IDEA集成的Spring Initializr◇新建项目-&gt;选择Spring Initializr-&gt;选择java版本1.8-&gt;Default-&gt;next-&gt;填写项目Group等信息;◇选择springboot版本以及web依赖 项目结构解析◇Spring Boot的基础结构共三个文件：入口(启动类)、配置文件(放在resources文件夹下)、测试入口(在test文件夹下)◇生成的Application和ApplicationTests类都可以直接运行来启动当前创建的项目;◇对于pom.xml文件修改springboot的版本为:2.2.1.RELEASE 案例演示◇新建一个ParaController类 12345678910111213141516171819202122232425262728293031323334353637383940package com.lcg.springboottest;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * 演示各种传参形式 */@RestController //有Restful能力的Controllerpublic class ParaController &#123; @GetMapping(&quot;/test01&quot;) public String firstRequest() &#123; return &quot;第一个Spring Boot接口&quot;; &#125; //@RequestParam注解会在请求参数中找到num这个参数并进行绑定 //访问 /test02?num=6 @GetMapping(&quot;/test02&quot;) public String requestParam(@RequestParam Integer num) &#123; return &quot;test02: num=&quot;+num; &#125; /*从路径中获取参数num * 访问test03/6*/ @GetMapping(&quot;/test03/&#123;num&#125;&quot;) public String pathParam(@PathVariable(&quot;num&quot;) Integer num) &#123; return &quot;test03:num=&quot;+num; &#125; @GetMapping(&#123;&quot;/multi01&quot;,&quot;/multi02&quot;&#125;)//多url的情况 public String multiUrl(@RequestParam Integer num) &#123; return &quot;multi:num=&quot;+num; &#125; @GetMapping(&#123;&quot;/test04&quot;&#125;) //required= false表示不是必须传参，并设置默认参数为0； public String test04(@RequestParam(required= false,defaultValue = &quot;0&quot;) Integer num) &#123; return &quot;test04: num=&quot;+num; &#125;&#125; Web项目的三层结构◇Controller 做一些简单的逻辑判断◇Service 对业务逻辑进行抽象，封装保持Controller的简洁;◇Dao 一般用于和数据库的交互，增删改查之类； 配置文件的两种写法◇application.propertiesenvironments.dev.url=http://gamest.linkenvironments.dev.name=Developer 12server.port=8081 //配置端口server.servlet.context-path=/first //配置项目统一路径前缀 ◇yml写法：分层级，冒号后需要空格；好处是前面的前缀相同的话可以直接并列； 1234environments: dev: url:http://gamest.link name:Developer ◇两种写法的转换网站 进行自定义配置◇利用value注解配置属性 123456789101112131415161718//配置文件中school.grade=3school.classnum=6 -----------------------------------------------------------------------//控制器中 /** 演示读取配置的控制器*/@RestControllerpublic class PropertiesController &#123; @Value(&quot;$&#123;school.grade&#125;&quot;) //进行与配置文件的绑定,按住ctrl然后鼠标放在上面会有配置提示 Integer grade; @Value(&quot;$&#123;school.classnum&#125;&quot;) Integer classnum; @GetMapping(&quot;/grade&quot;) public String gradeClass() &#123; return &quot;年级：&quot;+grade+&quot;班级：&quot;+classnum; &#125;&#125; ◇配置类 123456789101112131415161718192021222324252627282930package com.lcg.springboottest;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/** * School配置类 */@Component@ConfigurationProperties(prefix = &quot;school&quot;) //设置属性的前缀public class SchoolConfig &#123; Integer grade; Integer classnum; public Integer getGrade() &#123; return grade; &#125; //需要有get和set方法spring才能从配置文件中注入数据进来 public void setGrade(Integer grade) &#123; this.grade = grade; &#125; public Integer getClassnum() &#123; return classnum; &#125; public void setClassnum(Integer classnum) &#123; this.classnum = classnum; &#125;&#125; ◇读取配置类的方法 12345678910111213141516171819package com.lcg.springboottest;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * 读取配置类 */@RestControllerpublic class ConfigController &#123; @Autowired //自动引入 SchoolConfig schoolConfig; @GetMapping(&quot;/grade&quot;) public String gradeClass() &#123; return &quot;年级：&quot;+schoolConfig.grade+&quot;班级：&quot;+schoolConfig.classnum; &#125;&#125; Service和DAO的编写数据库的创建◇新建数据库springstu存储学生信息；◇建立学生表，包含了id，姓名 项目依赖与配置◇引入mybatis依赖 123456789101112&lt;!--mybatis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis的mysql连接池依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; ◇数据库的配置 1234spring.datasource.username=rootspring.datasource.password=www.LCG.comspring.datasource.url=jdbc:mysql://localhost:3306/springstu?useUnicode=true&amp;amp;\\ characterEncoding=UTF-8 ◇创建实体类◇创建controller 12345678910@RestControllerpublic class StudentController &#123; @Autowired StudentService studentService; @GetMapping(&quot;/student&quot;) public String student(@RequestParam(required = false,defaultValue = &quot;1&quot;) Integer num) &#123; Student student = studentService.findStudent(num); return &quot;学生学号:&quot;+student.getNum()+&quot;学生姓名：&quot;+student.getName(); &#125;&#125; ◇创建service 123456789@Servicepublic class StudentService &#123; @Autowired StudentMapper studentMapper; public Student findStudent(Integer id) &#123; return studentMapper.findById(id); &#125;&#125; ◇创建Mapper接口 123456@Mapper @Repository //用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理public interface StudentMapper &#123; @Select(&quot;select * from students where id = #&#123;id&#125;&quot;) Student findById(Integer id);&#125; ◇springboot整合mybatis的项目示例参考链接","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://618dt.github.io/categories/Spring/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://618dt.github.io/tags/SpringBoot/"}],"author":"LCG"},{"title":"项目实现-后台","slug":"书评网-后台","date":"2022-02-07T03:45:00.000Z","updated":"2022-02-23T13:33:01.453Z","comments":true,"path":"p/28f1.html","link":"","permalink":"https://618dt.github.io/p/28f1.html","excerpt":"","text":"富文本编辑器wangEditor简介◇基于javascript与css开发的Web富文本编辑器，类似于word可以进行图文混排的工具； 使用方法◇下载wangEditor的js文件，在test.ftl页面中进行引用；◇基本使用方法写入和读取 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;#--引用wangEditor--&gt; &lt;script src=&quot;/resources/wangEditor.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;button id=&quot;btnRead&quot;&gt;读取内容&lt;/button&gt; &lt;button id=&quot;btnWrite&quot;&gt;写入内容&lt;/button&gt;&lt;/div&gt;&lt;#--使用div容器来显示富文本编辑器--&gt;&lt;div id=&quot;divEditor&quot; style=&quot;width: 800px;height:600px&quot;&gt;&lt;/div&gt;&lt;script&gt; var E = window.wangEditor;//获取对象 var editor = new E(&quot;#divEditor&quot;);//完成富文本编辑器初始化 editor.create();//创建富文本编辑器，显示在页面上 //为按钮绑定单击事件，因为没有引入jquery，所以使用原生的document； document.getElementById(&quot;btnRead&quot;).onclick = function () &#123; var content = editor.txt.html();//获取编辑器现有的html内容 alert(content); &#125;; //写入,可以看出和jQuery的语法很像,html无参则为读取，有参则为写入 document.getElementById(&quot;btnWrite&quot;).onclick = function () &#123; var content = &quot;&lt;li style=&#x27;color:red&#x27;&gt;李凭中国弹箜篌&lt;/li&gt;&quot;; editor.txt.html(content); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现图书管理功能图片上传功能◇在训练素材中将后台页面图书管理页复制到项目中，放在ftl/management目录下(与前台进行区别),并重命名为book.ftl;◇book.ftl部分代码 123456789101112131415161718192021//显示新增图书对话框 function showCreate()&#123; //弹出&quot;新增图书&quot;对话框 layui.layer.open(&#123; id: &quot;dlgBook&quot;, title: &quot;新增图书&quot;, type: 1, content: $(&#x27;#dialog&#x27;).html(), area: [&#x27;820px&#x27;, &#x27;730px&#x27;], //宽，高 resize: false &#125;) //初始化wangEditor editor = new wangEditor(&#x27;#dlgBook #editor&#x27;); editor.customConfig.uploadImgServer = &#x27;/management/book/upload&#x27;;//设置图片上传地址 editor.customConfig.uploadFileName = &#x27;img&#x27;;//设置图片上传参数，在springmvc接收时会用到 editor.create();//创建wangEditor layui.form.render(); //LayUI表单重新渲染 $(&quot;#dlgBook #optype&quot;).val(&quot;create&quot;);//设置当前表单提交时提交至&quot;create&quot;新增地址 &#125;; ◇新建子包management并重建controller类以显示后台管理页面以及后面的交互；◇wangEditor官方文档对上传图片功能的介绍；◇在pom.xml中增加底层的文件上传依赖;对于springmvc底层上传依赖于Apache的commons-fileupload组件 123456&lt;!-- Spring MVC文件上传底层依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; ◇然后在applicationContext.xml中配置激活springmvc的文件上传功能 1234&lt;!-- 激活Spring MVC 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;&lt;/bean&gt; ◇在controller中开发文件上传功能 123456789101112131415161718192021222324//这里的地址要和book.ftl中设置的文件上传地址/management/book/upload一致/*MultipartFile用于接收文件,前面注解里的参数要和前面设置的上传参数一致* 原生的request用来获取发布路径*/@PostMapping(&quot;/upload&quot;)@ResponseBodypublic Map upload(@RequestParam(&quot;img&quot;) MultipartFile file, HttpServletRequest request) throws IOException &#123; /*这行代码在运行时执行，即在web应用发布以后才执行，所以实际得到的路径是在 * 工程发布的目录下(即out/artifacts/xxx_Web_expload)的路径,而不是webapp下的*/ String uploadPath = request.getServletContext().getResource(&quot;/&quot;).getPath() + &quot;/upload&quot;; //生成文件名,利用SimpleDateFormat生成毫秒级文件名，以防止命名冲突 String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date()); //文件扩展名，来自原始文件,所以将原始文件进行字符串的截取,从最后一次出现&quot;.&quot;开始截取剩余的字符串 String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;)); //利用transferTo()(另存为方法)将上传的文件报存到我们指定的目录中;new File（）新建文件 file.transferTo(new File(uploadPath+fileName+suffix)); //按照wangEditor的要求组织返回结果 Map result = new HashMap(); result.put(&quot;errno&quot;, 0);//0,代表服务器处理正常 //data要求是数组，所以新建一个数组,而上传的文件可以直接访问，所以返回的data填上其访问地址 result.put(&quot;data&quot;,new String[]&#123;&quot;/upload/&quot;+fileName+suffix&#125;); return result;&#125; ◇图片上传成功返回的json字符串◇指定的目录下 图书新增功能◇图书封面的第一张作为封面在前台展示；如果没有增加图片就提交的话弹出提示增加图片作为封面；◇提交后发送至后台的数据◇在BookService中书写相关接口及接口实现类，然后在MBookController中用前台传来的参数进行调用；◇我们看到发送后台的数据没有评分，图书封面，评论的信息，所以还需要我们在controller中进行补全；那么如何从description描述的html文本中将第一幅图作为图书封面呢？◇jsoup是一款java html解析器，利用jsoup可以将第一张图片截取出来； 1234567891011121314151617181920212223242526package com.lcg.reader.controller.management;@PostMapping(&quot;/create&quot;) @ResponseBody public Map createBook(Book book)&#123; Map result = new HashMap(); try &#123; book.setEvaluationQuantity(0);//补全评论数量 book.setEvaluationScore(0f);//补全评分 /*利用jsoup进行html的解析*/ Document doc = Jsoup.parse(book.getDescription()); //选中图书详情中所有的img标签,然后获取第一个 Element img = doc.select(&quot;img&quot;).first(); //获取当前元素指定的属性值,作为图片是在img标签中存在于src这个属性中的; String cover = img.attr(&quot;src&quot;); book.setCover(cover);//补全图书封面 bookService.createBook(book); result.put(&quot;code&quot;,&quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); &#125; catch (BussinessException e) &#123; e.printStackTrace(); result.put(&quot;code&quot;,e.getCode()); result.put(&quot;msg&quot;, e.getMsg()); &#125; return result; &#125; 后台图书分页 ◇layui的数据列表在初始化以后会利用ajax向服务器发送请求来自动获取分页数据；即发起一个请求，该请求附带了page和limit两个参数，如图(表示查询第一页数据，每页显示10条)；这两个参数只有在layui数据表格开启分页后才会显示;◇下面针对这个请求网址来实现图书分页查询；◇在开发前台的时候我们已经在BookService中创建了分页功能方法paging,参数为图书分类，排序方法，页数，每页几行4个参数；对于前面两个参数，如果想要进行忽略的话设置为null即可；基于paging方法进行后台查询功能的开发； 123456789101112131415161718192021package com.lcg.reader.controller.management;@GetMapping(&quot;/list&quot;)@ResponseBodypublic Map list(Integer page, Integer limit) &#123; if (page == null) &#123;//容错处理，设置为空时的默认值 page = 1; &#125; if (limit == null) &#123; limit = 10; &#125; //调用前面创建的分页方法获取图书分页对象 IPage&lt;Book&gt; iPage = bookService.paging(null, null, page, limit); //按Layui的数据规范书写返回数据 Map result = new HashMap(); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); result.put(&quot;data&quot;, iPage.getRecords());//当前页面数据 result.put(&quot;count&quot;, iPage.getTotal());//未分页时记录总数 return result;&#125; 图书修改功能◇作为图书修改功能需要和服务器建立两次通信：第一次是点击修改按钮的时候需要把要修改的图书信息进行返回，回填到修改框中；第二次是点击提交时将修改后的数据发送到后台；◇book.ftl修改部分的代码 123456789101112131415161718192021222324252627282930313233//obj对应点击的&quot;修改&quot;按钮对象 function showUpdate(obj)&#123; //弹出&quot;编辑图书&quot;对话框 layui.layer.open(&#123; id: &quot;dlgBook&quot;, //指定div title: &quot;编辑图书&quot;, //标题 type: 1, content: $(&#x27;#dialog&#x27;).html(), //设置对话框内容,复制自dialog DIV area: [&#x27;820px&#x27;, &#x27;730px&#x27;], //设置对话框宽度高度 resize: false //是否允许调整尺寸 &#125;) var bookId = $(obj).data(&quot;id&quot;); //获取&quot;修改&quot;按钮附带的图书编号 $(&quot;#dlgBook #bookId&quot;).val(bookId); //为表单隐藏域赋值,提交表单时用到 editor = new wangEditor(&#x27;#dlgBook #editor&#x27;); //初始化富文本编辑器 editor.customConfig.uploadImgServer = &#x27;/management/book/upload&#x27; //设置图片上传路径 editor.customConfig.uploadFileName = &#x27;img&#x27;; //图片上传时的参数名 editor.create(); //创建wangEditor $(&quot;#dlgBook #optype&quot;).val(&quot;update&quot;); //设置当前表单提交时提交至&quot;update&quot;更新地址 //发送ajax请求,获取对应图书信息 $.get(&quot;/management/book/id/&quot; + bookId , &#123;&#125; , function(json)&#123; //文本框回填已有数据 $(&quot;#dlgBook #bookName&quot;).val(json.data.bookName);//书名 $(&quot;#dlgBook #subTitle&quot;).val(json.data.subTitle); //子标题 $(&quot;#dlgBook #author&quot;).val(json.data.author);//作者 $(&quot;#dlgBook #categoryId&quot;).val(json.data.categoryId); //分类选项 editor.txt.html(json.data.description); //设置图文内容 layui.form.render();//重新渲染LayUI表单 &#125; , &quot;json&quot;) &#125; ◇MBookController中增加两个方法：数据查询和数据修改;◇在进行数据修改操作时，正确的方法为：先查询出原始数据，然后在原始数据上进行相应的更改； 1234567891011121314151617181920212223242526272829303132333435363738394041//获取数据进行回填 @GetMapping(&quot;/id/&#123;id&#125;&quot;) //与前台保持一致的路径变量 @ResponseBody public Map selectById(@PathVariable(&quot;id&quot;) Long bookId) &#123; Book book = bookService.selectById(bookId); Map result = new HashMap(); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); result.put(&quot;data&quot;, book);//data在前端对应的是book数据，这里要和前面保持一致 return result; &#125; @PostMapping(&quot;/update&quot;) @ResponseBody public Map updateBook(Book book) &#123; Map result = new HashMap(); try &#123; /*这里注意不能直接对book进行更新，因为从前台传入过来的book对象中没有评分以及评论数量的信息 * 需要根据前台传入的book通过id进行查询获取到原始的Book记录后才能进行更新操作*/ Book rawBook = bookService.selectById(book.getBookId());//原始(未编辑前)的记录 rawBook.setAuthor(book.getAuthor()); rawBook.setBookName(book.getBookName()); rawBook.setSubTitle(book.getSubTitle()); rawBook.setCategoryId(book.getCategoryId()); rawBook.setDescription(book.getDescription()); //获取封面 Document doc = Jsoup.parse(book.getDescription()); Element img = doc.select(&quot;img&quot;).first(); String cover = img.attr(&quot;src&quot;); rawBook.setCover(cover);//设置封面 //并且修改要基于原始的rawBook，这样不容易出错 bookService.updateBook(rawBook); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); //result.put(&quot;data&quot;, book); 更新不需要返回数据，数据通过其他方法在前端显示 &#125; catch (BussinessException e) &#123; e.printStackTrace(); result.put(&quot;code&quot;, e.getCode()); result.put(&quot;msg&quot;, e.getMsg()); &#125; return result; &#125; 图书删除功能◇删除的请求◇注意，在删除图书的同时，也应该将用户对该图书的阅读状态以及评论进行级联删除； 123456789101112131415161718192021@Service(&quot;bookService&quot;)@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)public class BookServiceImpl implements BookService &#123; @Resource private BookMapper bookMapper; @Resource private MemberReadStateMapper memberReadStateMapper; @Resource private EvaluationMapper evaluationMapper; @Transactional public void deleteBook(Long bookId) &#123; bookMapper.deleteById(bookId); /*构造条件删除某一本图书的所有阅读状态*/ QueryWrapper&lt;MemberReadState&gt; mrsQueryWrapper = new QueryWrapper&lt;MemberReadState&gt;(); mrsQueryWrapper.eq(&quot;book_id&quot;, bookId);//即删除的where book_id = bookId memberReadStateMapper.delete(mrsQueryWrapper); QueryWrapper&lt;Evaluation&gt; evaluationQueryWrapper = new QueryWrapper&lt;Evaluation&gt;(); evaluationQueryWrapper.eq(&quot;book_id&quot;, bookId); evaluationMapper.delete(evaluationQueryWrapper); &#125;&#125; 后台首页◇在训练素材中把后台首页复制到项目中◇在management包下新增ManagementController类，即后台系统的管理控制器;提供了后台系统的通用功能：默认首页的显示等等； 总结开发整体思路◇基于MVC开发理念：逐级调用方法; 开发注意避坑◇注意注解不要写在接口里面；◇显示首页logo的时候，我直接把图片命名为logo.png结果前台无法显示，报404错误，然后改为gamest_logo.png后可以显示，猜想可能和一些框架的命名有冲突导致的； 待完善的地方◇项目开发的很简陋，还有很多带完善的地方；◇用户评论回复功能、用户个人信息查看功能、图书的搜索功能、用户密码修改功能等等；","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"SSM开发项目","slug":"Spring/SSM开发项目","permalink":"https://618dt.github.io/categories/Spring/SSM%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://618dt.github.io/tags/SSM/"}],"author":"LCG"},{"title":"项目实现-前台","slug":"书评网-前台","date":"2022-02-07T02:19:00.000Z","updated":"2022-02-23T15:05:07.026Z","comments":true,"path":"p/aeec.html","link":"","permalink":"https://618dt.github.io/p/aeec.html","excerpt":"","text":"本周学习内容简介◇讲解Spring/Spring MVC/Mybatis(SSM)整合配置过程◇讲解MyBatis-Plus敏捷开发插件的用法◇开发javaweb应用”书评网”◇由于篇幅有限，项目的全部代码见gamest-reader 主要知识点◇SSM整合配置◇Mybatis-Plus配置与应用◇Boostrap UI框架入门◇Kaptcha验证码组件使用◇富文本编辑器wangEditor◇Spring Task任务调度 SSM整合的意义什么是整合◇整合通过Spring IoC容器管理第三方框架对象,让多框架形成整体◇Spring/Spring MVC/MyBatis是业内最主流的框架搭配◇SSM配置与使用是所有Java工程师必须掌握的技能 SSM整合三阶段◇Spring与Spring MVC环境配置◇Spring与MyBatis的整合配置◇整合其他组件:声明式事务/日志/任务调度/… Spring与Spring MVC环境配置◇依赖spring-webmvc 123--pom.xml文件&lt;!--Freemarker--&gt;&lt;!-- Jackson --&gt; ◇配置DispatcherServlet –web.xml文件◇启用Spring MVC注解模式 –applicationContext.xml文件◇配置请求与响应字符集 –applicationContext.xml文件◇配置FreeMarker模板引擎 –applicationContext.xml文件◇配置Json序列化组件 –applicationContext.xml文件 Spring与MyBatis整合配置◇Spring的整合其核心目的是通过spring去管理其他组件或框架的核心对象，让这些对象之间形成一个整体；◇创建数据库gamest_reader◇依赖mybatis-spring及驱动 –pom.xml文件◇配置数据源与连接池 –applicationContext.xml文件◇配置SqlSessionFactory –applicationContext.xml文件◇配置Mapper扫描器 –applicationContext.xml文件◇创建mybatis-config.xml 整合其他组件◇配置logback日志输出 ，新建logback.xml文件，日志组件会自动识别；◇声明式事务配置 ;引入依赖spring-jdbc后，事务的依赖spring-tx也会自动被引入，在applicationContext中配置声明式事务◇整合junit单元测试 MyBatis-PlusMyBatis-Plus简介◇ MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具◇ 自动实现Mapper CRUD操作,极致提高数据库开发效率◇ MP在MyBatis 的基础上只做增强不做改变◇MyBatis-Plus官网 MyBatis-Plus整合三部曲◇pom引入mybatis-plus依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt; ◇Spring XML更改配置SqlSessionFactory实现类◇mybatis-config.xml增加MP分页插件(plugin) 1234&lt;plugins&gt; &lt;!-- 配置MyBatis-Plus分页插件 --&gt; &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt; MyBatis-Plus开发三部曲◇创建实体类，实体类中的属性需要与数据库中表的字段保持一致,基于@Table/@TableId/@TableField进行与表的自动映射◇创建Mapper接口继承BaseMapper,创建Mapper XML◇开发时注入Mapper对象,通过内置API实现CRUD(增删改查)操作 MyBatis-Plus核心注解◇@TableName - 将实体类与表名映射◇@TableId - 说明对应属性是表的主键 ,Tabled(type=IdType.AUTO)，type即设置主键的生成方式，IdType.AUTO表示使用数据库底层的自增主键来完成数据的插入；◇@TableField - 设置属性与列名(字段)的对应关系 ，如果字段名与属性名相同或者符合驼峰命名转换规则，则TableField可省略 BaseMapper接口核心API◇在所有的Mapper文件中都要实现BaseMapper接口，BaseMapper是由Mybatis-plus提供的核心父接口，在实现的时候需要加入泛型说明定义的实体是哪一个例如BaseMapper&lt;test&gt;；当我们继承自接口以后，实现增删改查直接使用继承的方法就行了，如果需要自定义增删改查方法的话，方法名不应与父接口的方法产生混淆； 案例分析与数据库建表案例分析◇最核心的数据是图书信息，包含了书名、作者、描述等等；◇作为网站，也会内置会员部分，也就是用户；而围绕着会员与图书会衍生出两个状态信息：阅读状态和评论； 数据库建表◇围绕着上面分析的五个数据，可以建立五张表◇图书表◇会员表 ◇评价表◇阅读状态表◇分类表◇额外建立一张user表用于后台管理 实现图书列表页面◇将训练素材里的三个基础文件目录粘贴到项目的webapp目录下◇images包含了前端页面的图片信息◇resources包含了一系列js、css组件◇upload是文件上传的目录，在程序运行时所有远程上传的图片都会保存于此；◇将素材里的首页.html文件复制到项目的WEB-INF\\ftl路径下，并将文件名改为index.ftl；◇前端的UI框架由Bootstrap来实现 Bootstrap◇Bootstrap是全球最受欢迎的前端组件库,由推特(TWitter)开源◇Bootstrap用于开发响应式布局、移动设备优先的WEB项目◇Bootstrap提供完整的HTML、CSS 和 JS 开发工具集◇Boostrap中文网 显示图书类别◇queryWrapper即条件构造器，按条件对数据库进行查询;◇具体步骤为创建类别实体-&gt;创建Mapper接口-&gt;创建与接口对应的xml-&gt;创建service接口-&gt;为接口创建实现类（这里要在service包下创建一个子包impl，专门用来存放接口的实现类）impl.CategoryServiceImpl-&gt;在该实现类中实现查询方法，并进行事务管理◇实现类实现了接口的方法，因此在使用查询数据时，直接给接口注入数据，然后用接口的方法进行查询；◇完成上面的实现后就要进入Controller开发环节,创建一个BookController，在这个控制器中完成一系列url与方法的绑定；在该类的showXXX方法是将数据展示到页面，通常返回一个mav来进行数据的传递；因此创建showIndex（）方法来显示图书分类信息；◇完成showXXX方法后进入ftl文件中 实现图书分页◇首先创建图书实体类Book-&gt;创建接口-&gt;接口对应的xml文件-&gt;service接口（图书的分页查询属于业务逻辑类，在service中实现）-&gt;生成service的实现类(快捷键：选中类然后Alt+Enter)◇基于Mybatis-plus的分页查询：核心方法为selectPage()； 1234567891011121314151617package com.lcg.reader.service.impl;import *@Service(&quot;bookService&quot;)@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)public class BookServiceImpl implements BookService &#123; @Resource private BookMapper bookMapper; public IPage&lt;Book&gt; paging(Integer page, Integer rows) &#123; //分页信息：哪一页，每页的记录数 Page&lt;Book&gt; p = new Page&lt;Book&gt;(page, rows); //条件构造器，为空表示没有条件 QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;(); //参数为分页信息，条件构造器 IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper); return pageObject; &#125;&#125; ◇其原理为SELECT COUNT(1) FROM book查询出未分页前的所有图书总数，然后根据总数除以每页记录数求出一共有多少页；然后再SELECT book_id,book_name,sub_title,author,cover,description,category_id,evaluation_score,evaluation_quantity FROM book LIMIT ?,? //两个问号分别代表本次查询的其实位置和终止位置 Ajax动态加载图书信息◇在BookController类中新增图书查询方法selectBook;◇修改index.ftl文件进行动态渲染，在其&lt;head&gt;内部增加javascript块&lt;script&gt;用来发送ajax和BookController中的/books进行交互，需要引入jquery；◇如何将book中的信息填充到页面中？因为所有的操作都是通过JavaScript来完成的，所以不能够像freemarker一样直接在页面中加入freemarker标签来完成服务器端的渲染；而是需要利用JavaScript动态的将这些分页信息组织成html插入到当前页面中；而html的实现使用拼接字符串来完成；◇但是如果页面信息很多的话，通过拼接字符串的方法显然不现实；需要使用js的模板引擎来完成复杂页面的构建工作； Art-Template 腾讯JS模板引擎◇上述说到，利用字符串拼接来实现html对于复杂页面不太好；那么可以利用JS模板引擎来对复杂的html进行模板化；◇官网http://aui.github.io/art-template/◇应用数据的时候 {{}} 里的名字要和ajax返回数据的属性名一致◇创建的模板 12345678910111213141516171819202122232425262728&lt;#--定义js模板,type说明script中内容的类型,id设置为tpl--&gt;&#123;% raw %&#125; &lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt; &lt;#--看ajax返回数据的时候的属性名和 &#123;&#123;&#125;&#125; 里的一致--&gt; &lt;a href=&quot;/book/&#123;&#123;bookId&#125;&#125;&quot; style=&quot;color: inherit&quot;&gt;&lt;#--每一块超链接都对应了图书的详细信息--&gt; &lt;div class=&quot;row mt-2 book&quot;&gt; &lt;div class=&quot;col-4 mb-2 pr-2&quot;&gt; &lt;#--图书封面--&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;&#123;&#123;cover&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-8 mb-2 pl-0&quot;&gt; &lt;h5 class=&quot;text-truncate&quot;&gt;&#123;&#123;bookName&#125;&#125;&lt;/h5&gt;&lt;#--图书名称--&gt; &lt;#--作者--&gt; &lt;div class=&quot;mb-2 bg-light small p-2 w-100 text-truncate&quot;&gt;&#123;&#123;author&#125;&#125;&lt;/div&gt; &lt;#--图书子标题--&gt; &lt;div class=&quot;mb-2 w-100&quot;&gt;&#123;&#123;subTitle&#125;&#125;&lt;/div&gt; &lt;p&gt;&lt;#--评分信息--&gt; &lt;span class=&quot;stars&quot; data-score=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; title=&quot;gorgeous&quot;&gt;&lt;img alt=&quot;1&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img alt=&quot;2&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img alt=&quot;3&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img alt=&quot;4&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img alt=&quot;5&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&lt;input name=&quot;score&quot; type=&quot;hidden&quot; value=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; readonly=&quot;&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationScore&#125;&#125;&lt;/span&gt; &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationQuantity&#125;&#125;人已评&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;/script&gt;&#123;% endraw %&#125; 实现发评分插件◇Jquery评分插件raty◇引用raty的css和js 12&lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/raty/lib/jquery.raty.css&quot;&gt;&lt;script src=&quot;./resources/raty/lib/jquery.raty.js&quot;&gt;&lt;/script&gt; ◇将评价部分的静态部分星星图片删除，即删除&lt;img&gt;标签 实现加载更多◇点击加载更多时显示下一页的数据；则要设置一个数据域：nextpage用于保存下一页的页号是多少；◇在javascript块中新增点击事件； 1234567891011121314151617181920212223242526272829303132333435363738394041/*定义一个加载更多函数 标志位isReset表示重置*/&#123;% raw %&#125; function loadMore(isReset) &#123; if (isReset == true) &#123; $(&quot;#nextPage&quot;).val = 1; &#125; var nextPage = $(&quot;#nextPage&quot;).val(); $.ajax(&#123; url : &quot;/books&quot;, data : &#123;p:nextPage&#125;, type : &quot;get&quot;, dataType : &quot;json&quot;, success: function (json) &#123; console.info(json); var list = json.records; for (var i = 0; i &lt; list.length; i++) &#123; var book = json.records[i]; var html = template(&quot;tpl&quot;, book); $(&quot;#bookList&quot;).append(html); &#125; $(&quot;.stars&quot;).raty(&#123;readOnly:true&#125;); /*如果当前页小于总页数,则显示点击更多按钮*/ if(json.current &lt; json.pages)&#123; $(&quot;#nextPage&quot;).val(parseInt(json.current) + 1); $(&quot;#btnMore&quot;).show();//显示组件 $(&quot;#divNoMore&quot;).hide();//隐藏组件 &#125;else&#123; $(&quot;#btnMore&quot;).hide();//显示组件 $(&quot;#divNoMore&quot;).show();//隐藏组件 &#125; &#125; &#125;) &#125;//绑定加载更多按钮单击事件 $(function () &#123; $(&quot;#btnMore&quot;).click(function () &#123; loadMore(); &#125;); &#125;);&#123;% endraw %&#125; 多条件分页查询◇实现的第一个步骤：当我吗点击查询条件的连接后需要将其高亮显示；第二，在点击之后根据所选的条件在后台进行动态查询；◇在按钮单击事件中对category进行捕获然后设置单击事件； 123456/*.category是进行类选择*/ $(&quot;.category&quot;).click(function () &#123; $(&quot;.category&quot;).removeClass(&quot;highlight&quot;);//移除原先所拥有的高亮css $(&quot;.category&quot;).addClass(&quot;text-black-50&quot;);//设置为灰色 $(this).addClass(&quot;highlight&quot;);//设置当前点击的为高亮 &#125;); ◇修改service进行数据联动，在paging方法中增加两个参数categoryId, order;然后在其实现类中进行条件的判断； 123456789101112131415161718192021public IPage&lt;Book&gt; paging(Long categoryId,String order,Integer page, Integer rows) &#123; //分页信息：哪一页，每页的记录数 Page&lt;Book&gt; p = new Page&lt;Book&gt;(page, rows); //条件构造器，为空表示没有条件 QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;(); if (categoryId != null &amp;&amp; categoryId != -1) &#123; //设置条件为分类的id ,查询等于指定字段的数据 queryWrapper.eq(&quot;category_id&quot;, categoryId); &#125; if (order != null) &#123; if (order.equals(&quot;quantity&quot;)) &#123; //设置条件按照指定的字段进行降序排序 queryWrapper.orderByDesc(&quot;evaluation_quantity&quot;); &#125; else if (order.equals(&quot;score&quot;)) &#123; queryWrapper.orderByDesc(&quot;evaluation_score&quot;); &#125; &#125; //参数为分页信息，条件构造器 IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper); return pageObject; &#125; ◇然后在controller调用paging方法处进行修改，增加两个参数 123456789@GetMapping(&quot;/books&quot;) @ResponseBody public IPage&lt;Book&gt; selectBook(Long categoryId,String order,Integer p) &#123; if (p == null) &#123; p=1; &#125; IPage&lt;Book&gt; iPage = bookService.paging(categoryId,order,p,5);//默认每页显示5条数据 return iPage; &#125; ◇以上方法设置完后，需要把前台的分类和排序数据传到控制器中；即在index.ftl中进行设置，点击不同的超链接或者span后，给对应的隐藏域进行赋值；其中使用到了自定义属性，data-* ；◇最后进行数据的查询，需要修改发送请求的方法（在loadMore中），在发送请求的数据data中附加分类和排序信息，在点击选择类别、排序规则的点击事件中增加loadMore方法，并将是否重置设置为true，因为每一次点击选择类别或排序方法的时候就相当于重新进行查询，那自然是重第一页进行的； 图书详情页实现主页面◇在训练素材中将详情页复制到项目中，并改为detail.ftl；◇在BookService接口中开发新的查询方法，根据图书编号查询图书对象；并完成其实现类；在本项目中使用面向接口编程的思想，所以每一个service都有接口及其实现类；◇接下来实现controller，在controller中根据index.ftl提供的url(book/id)进行相应的绑定； 123456789&#123;% raw %&#125;@GetMapping(&quot;/book/&#123;id&#125;&quot;)//路径变量用&#123;&#125;包裹 public ModelAndView showDetail(@PathVariable(&quot;id&quot;)Long id) &#123; Book book = bookService.selectById(id); ModelAndView mav = new ModelAndView(&quot;/detail&quot;); mav.addObject(&quot;book&quot;, book); return mav; &#125;&#123;% endraw %&#125; ◇当我们运行后，会发现js、css等未加载；F12查看NetWork选择all，会发现有css、js的请求为404；点击查看发现路径是localhost/book/resources/bootstrap/bootstrap.css，这是因为我们使用了相对路径，而相对路径是基于目前我们url所在的路径(localhost/book)之后进行附加；所以我们访问的资源错误，则应该改为绝对路径来开发(在这里去掉 . 即可) 实现评论列表◇首先创建评论的实体类Evaluation；◇创建EvaluationMapper；◇创建evaluation.xml◇创建EvaluationService，并完成其实现类；◇进入BookController中修改showDetail方法，使其得到evaluationList对象，并添加到mav中◇在detail.ftl中对evaluationList进行遍历显示；◇由于评论列表需要显示用户名，所以需要增加用户的实现类以及Mapper等等；然后在Evaluation实体类中增加关联对象 12345//设置关联对象 @TableField(exist = false)//说明book属性在数据库表中没有对应的字段,不会参与到sql自动生成 private Book book; @TableField(exist = false) private Member member; ◇在EvaluationService接口的实现类中进行获取每一条评论的用户信息的实现； 1234567891011121314151617public List&lt;Evaluation&gt; selectByBookId(Long bookId) &#123; //获取图书对象 Book book = bookMapper.selectById(bookId); QueryWrapper&lt;Evaluation&gt; queryWrapper = new QueryWrapper&lt;Evaluation&gt;(); queryWrapper.eq(&quot;book_id&quot;, bookId); queryWrapper.eq(&quot;state&quot;, &quot;enable&quot;); queryWrapper.orderByDesc(&quot;create_time&quot;); List&lt;Evaluation&gt; evaluationList = evaluationMapper.selectList(queryWrapper); for (Evaluation eva : evaluationList) &#123; /*遍历每一个评论列表，然后根据评论列表的memberId在数据库中查询member对象 * 再把查到的对象赋值给Evaluation类里面关联的对象Member*/ Member member = (Member) memberMapper.selectById(eva.getMemberId()); eva.setMember(member); eva.setBook(book); &#125; return evaluationList; &#125; ◇获取每一条评论的图书信息和获取用户信息类似，只不过每一个图书下面有许多评论，而每一条评论和其评论者是一 一对应的；因此图书对象的获取放在循环外面； 开发验证码功能Kaptcha验证码组件◇Kaptcha是谷歌开源的可高度配置的实用验证码生成工具◇通过Kaptcha可阻拦大多数机器人脚本操作◇Kaptcha典型应用于注册、登录、重要信息提交等用户交互 Kaptcha使用步骤◇Kaptcha配置验证码生成参数◇开发KapatchaController生成验证码图片◇将前台输入验证码与session保存的验证码进行比对 Kaptcha的配置及使用◇pom.xml加载依赖 123456&lt;!-- Kaptcha验证码组件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt; ◇applicationContext.xml进行配置 123456789101112131415161718192021&lt;!-- 配置Kaptcha --&gt;&lt;bean id=&quot;kaptchaProducer&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt; &lt;property name=&quot;config&quot;&gt; &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;&lt;!--该bean不需要id，只需要指明类--&gt; &lt;constructor-arg&gt;&lt;!--构造参数--&gt; &lt;props&gt; &lt;!--验证码图片不生成边框--&gt; &lt;prop key=&quot;kaptcha.border&quot;&gt;no&lt;/prop&gt; &lt;!-- 验证码图片宽度为120像素 --&gt; &lt;prop key=&quot;kaptcha.image.width&quot;&gt;120&lt;/prop&gt; &lt;!-- 验证码图片字体颜色为蓝色 --&gt; &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt; &lt;!-- 每个字符最大占用40像素 --&gt; &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/prop&gt; &lt;!-- 验证码包含4个字符 --&gt; &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; ◇创建新的控制器KaptchaController 123456789101112131415161718192021222324252627282930313233public class KaptchaController &#123; /*引用Producer接口*/ @Resource private Producer kaptchaProducer;//这里的属性名需要和配置的beanId一致; /*参数为原生的http请求和响应对象 * 这样书写，把原生的对象放在参数列表中，则会在运行时由springIOC容器将当前的请求与 * 响应对象动态的注入到对应的参数中*/ @GetMapping(&quot;/verify_code&quot;) public void createVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; //设置响应过期时间,0为立即过期 response.setDateHeader(&quot;Expires&quot;,0); /*设置缓存控制;因为每一次要求生成的验证码都是全新的；所以需要把浏览器的缓存都进行清空 *no-store不存储 no-cache不缓存 must-revalidate必须重新校验*/ response.setHeader(&quot;Cache-Control&quot;, &quot;no-store,no-cache,must-revalidate&quot;); //处于兼容性考虑，平时一般用不到 response.setHeader(&quot;Cache-Control&quot;,&quot;post-check=0,pre-check=0&quot;); response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);//以上三行都是设置浏览器不缓存任何图片数据 response.setContentType(&quot;image/png&quot;);//返回类型为图片 //生成验证码字符文本 String verifyCode = kaptchaProducer.createText(); //将验证码放到会话(Session)中 request.getSession().setAttribute(&quot;kaptchaVerifyCode&quot;,verifyCode); System.out.println(&quot;验证码为：&quot; + request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;)); //创建验证码图片,返回为二进制的图片 BufferedImage image = kaptchaProducer.createImage(verifyCode); /*用getOutputStream方法向浏览器输出二进制文件(如图片等)*/ ServletOutputStream out = response.getOutputStream(); //将图片以png形式写入out输出流中 ImageIO.write(image, &quot;png&quot;, out); out.flush();//立即输出 out.close();//关闭输出流 &#125;&#125; 实现用户注册功能◇将训练素材的注册页复制到项目中并改名为register.ftl；◇创建用户控制器类 12345678@Controllerpublic class MemberController &#123; @GetMapping(&quot;/register.html&quot;)/*这里的后缀可写可不写*/ public ModelAndView showRegister() &#123; //没有数据传到前台，因此直接return return new ModelAndView(&quot;/register&quot;); &#125;&#125; ◇实现点击验证码图片刷新功能 123456789101112//重新发送请求,刷新验证码 function reloadVerifyCode()&#123; //attr设置组件属性（属性名，属性值） /*ts代表timestamp(时间戳),get请求容易被浏览器缓存起来,所以有可能 * 点击图片后尽管执行了代码但图片还是原来的，则增加时间戳使每次get请求的url不一样*/ $(&quot;#imgVerifyCode&quot;).attr(&quot;src&quot;, &quot;/verify_code?ts=&quot; + new Date().getTime()); &#125;//点击事件，点击验证码图片刷新验证码 $(&quot;#imgVerifyCode&quot;).click(function () &#123; reloadVerifyCode(); &#125;); 验证码校验◇在register页面中发送ajax请求◇在Member控制器中进行接收 12345678910111213141516171819/*因为无论哪一个web应用框架都是基于底层的Servlet进行实现，所以这里我们 * 可以直接将原生的HttpServletRequest对象写入参数中进行使用*/ @PostMapping(&quot;/register&quot;)//ajax采用post方式提交的 @ResponseBody //直接进行序列化的响应返回 public Map register(String vc, String username, String password, String nickname, HttpServletRequest request) &#123; //获取当前会话中的kaptchaVerifyCode属性的值(即验证码) String verifyCode = (String) request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;); /*验证码校验,返回result Map对象*/ Map result = new HashMap(); //没有写入验证码||后台没有产生验证码||忽略大小写比对验证码 if (vc == null||verifyCode == null||vc.equalsIgnoreCase(verifyCode)) &#123; result.put(&quot;code&quot;,&quot;VC01&quot;); result.put(&quot;msg&quot;, &quot;验证码错误&quot;); &#125;else&#123; result.put(&quot;code&quot;,&quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); &#125; return result; &#125; 实现业务逻辑◇新增MemberService接口，定义createMember()方法用于创建新的用户；完成其实现类，在实现类中注入mapper用于查询；◇在service下创建子包exception然后新增一个异常类BussinessException，用来处理我们注册登录等相关异常;◇在pom.xml中增加加密/解密组件，用来对密码进行加密;创建utils工具包，在其下创建MD5Utils类； 1234567891011public class MD5Utils &#123; public static String md5Digest(String source, Integer salt) &#123; char[] ca = source.toCharArray();//获取到字符数组 for (int i = 0; i &lt; ca.length; i++) &#123; ca[i] = (char) (ca[i] + salt);//对原始字符串的每一位字符加盐混淆 &#125; String target = new String(ca);//再将字符数组转换为原始字符串 String md5 = DigestUtils.md5Hex(target);//MD5摘要 return md5; &#125;&#125; ◇用户注册底层逻辑 1234567891011121314151617181920212223242526272829/** * 会员注册,创建新的会员 * * @param username 用户名 * @param password 密码 * @param nickname 昵称 * @return 新的会员对象 */ public Member createMember(String username, String password, String nickname) &#123; QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;Member&gt;(); queryWrapper.eq(&quot;username&quot;, username); List&lt;Member&gt; memberList = memberMapper.selectList(queryWrapper); //判断用户名是否已存在 if (memberList.size()&gt;0) &#123; //抛出我们自定义的异常 throw new BussinessException(&quot;M01&quot;, &quot;用户名已存在&quot;); &#125; Member member = new Member(); member.setUsername(username); member.setNickname(nickname); //生成小于1000的随机数加上1000相当于随机的4位数用来当作盐值； int salt = new Random().nextInt(1000) + 1000; String md5 = MD5Utils.md5Digest(password, salt); member.setSalt(salt); member.setPassword(md5); member.setCreateTime(new Date()); memberMapper.insert(member); return member; &#125; ◇在MemberController中注入memberService进行用户注册功能的完善； 12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class MemberController &#123; @Resource private MemberService memberService; @GetMapping(&quot;/register.html&quot;)/*这里的后缀可写可不写*/ public ModelAndView showRegister() &#123; return new ModelAndView(&quot;/register&quot;); &#125; /*因为无论哪一个web应用框架都是基于底层的Servlet进行实现，所以这里我们 * 可以直接将原生的HttpServletRequest对象写入参数中进行使用 在register方法中的参数必须和前台的一致，这样才能将前台的数据传递到方法的参数中； */ @PostMapping(&quot;/register&quot;)//ajax采用post方式提交的 @ResponseBody //直接进行序列化的响应返回 public Map register(String vc, String username, String password, String nickname, HttpServletRequest request) &#123; //获取当前会话中的kaptchaVerifyCode属性的值(即验证码) String verifyCode = (String) request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;); /*验证码校验,返回result Map对象*/ Map result = new HashMap(); //没有写入验证码||后台没有产生验证码||忽略大小写比对验证码 if (vc == null||verifyCode == null||vc.equalsIgnoreCase(verifyCode)) &#123; result.put(&quot;code&quot;,&quot;VC01&quot;); result.put(&quot;msg&quot;, &quot;验证码错误&quot;); &#125;else&#123; try &#123; //创建用户 memberService.createMember(username, password, nickname); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); &#125; catch (BussinessException e) &#123; e.printStackTrace(); result.put(&quot;code&quot;, e.getCode()); result.put(&quot;msg&quot;, e.getMsg()); &#125; &#125; return result; &#125;&#125; 实现用户登录◇加载登录页.html改为login.ftl◇在MemberService中增加检查登录的方法checkLogin(返回对象为Member):根据前台传来的用户名拿到整个用户对象，然后根据对象里的salt值和前台传来的密码进行MD5摘要，比对生成的md5字符串是否和对象里的密码一致；◇service里的业务逻辑代码写好后需要在控制器中进行调用;在控制器中创建方法checkLogin,返回对象为Map，因为需要与前台交互； 1234567891011121314151617181920212223242526/*这里采用session,session比request的范围更广,用来保存页面的用户信息*/ @ResponseBody @PostMapping(&quot;/login&quot;) public Map checkLogin(String username, String password, String vc, HttpSession session) &#123; String verifyCode = (String) session.getAttribute(&quot;kaptchaVerifyCode&quot;); Map result = new HashMap(); if (vc == null||verifyCode == null||vc.equalsIgnoreCase(verifyCode)) &#123; result.put(&quot;code&quot;,&quot;VC01&quot;); result.put(&quot;msg&quot;, &quot;验证码错误&quot;); &#125;else&#123; try &#123; //先进行验证码的比对，然后校验登录的用户信息，信息不正确的话会自动抛出异常 Member member = memberService.checkLogin(username, password); //保存登录用户的信息，在首页中进行展现 session.setAttribute(&quot;loginMember&quot;, member); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); &#125; catch (BussinessException e) &#123; e.printStackTrace(); result.put(&quot;code&quot;, e.getCode()); result.put(&quot;msg&quot;, e.getMsg()); &#125; finally &#123; &#125; &#125; return result; &#125; ◇如果发现if语句没有执行,一定要仔细检查条件是否正确； 用户交互功能阅读状态变更◇阅读状态的变更只能选择想看和看过其一；◇为阅读状态创建实体类MemberReadState;然后创建相关的Mapper接口及xml；◇在MemberService接口中实现用户的交互功能，新增方法selectMemberReadState()，用来查询传入的两个参数用户与图书是否有阅读状态；◇查询阅读状态方法执行的时机: 当我们跳转到图书详情页面时；因此修改BookController.showDetail（）方法，增加session参数用来获取当前用户的信息； 123456789101112131415@GetMapping(&quot;/book/&#123;bid&#125;&quot;)//路径变量用&#123;&#125;包裹,即将index中book/后的bookId定义为id; public ModelAndView showDetail(@PathVariable(&quot;bid&quot;)Long id, HttpSession session) &#123; Member member = (Member) session.getAttribute(&quot;loginMember&quot;); ModelAndView mav = new ModelAndView(&quot;/detail&quot;); if (member != null) &#123; //获取会员阅读状态 MemberReadState memberReadState = memberService.selectMemberReadState(member.getMemberId(), id); mav.addObject(&quot;memberReadState&quot;, memberReadState); &#125; Book book = bookService.selectById(id); List&lt;Evaluation&gt; evaluationList = evaluationService.selectByBookId(id); mav.addObject(&quot;book&quot;, book); mav.addObject(&quot;evaluationList&quot;, evaluationList); return mav; &#125; ◇由于用户的阅读状态很有可能为空，所以我们要在detail详情页面的script块中增加javascript语句进行相应的判断; 123456789/*页面就绪函数，书写freemarker的脚本*/ $(function () &#123; &lt;#if memberReadState ??&gt;//存在阅读状态 /*利用JavaScript的属性选择器，‘*’表示所有名为data-read-state且值为&#x27;&#x27;的属性 * 并将该属性设置为高亮，那么就可以将对应的想看或者看过的按钮设置为高亮显示了 * 这里的值是后台通过mav传过来的*/ $(&quot;*[data-read-state=&#x27;$&#123;memberReadState.readState&#125;&#x27;]&quot;).addClass(&quot;highlight&quot;); &lt;/#if&gt; &#125;); ◇更新会员阅读状态，即点击相应的按钮实现交互功能；◇首先需要在detail页面中进行用户是否登录的判断,只有用户登录了才能进行相应的交互；在刚才的页面就绪函数中添加判断语句； 1234567891011&lt;#if !loginMember ??&gt;/*如果用户没有登录*//*选择拥有data-read-state这个自定义属性的标签，而不管自定义属性的值是多少*/$(&quot;*[data-read-state]&quot;).click(function () &#123; /*通过id选择bootstrap的对话框,然后根据其对话框函数执行show(显示)动作*/ $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);&#125;)//将写短评以及点赞等功能进行相应的登录控制,这里利用组合选择减少代码$(&quot;#btnEvaluation,*[data-evaluation-id]&quot;).click(function () &#123; $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);&#125;)&lt;/#if&gt; ◇在MemberService中新增方法写入阅读状态;◇在控制器中进行调用并与前台交互； 123456789101112131415@PostMapping(&quot;/update_read_state&quot;)@ResponseBodypublic Map updateReadState(Long memberId, Long bookId, Integer readState) &#123; Map result = new HashMap(); try &#123; memberService.updateMemberReadState(memberId, bookId, readState); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); &#125; catch (BussinessException e) &#123; e.printStackTrace(); result.put(&quot;code&quot;, e.getCode()); result.put(&quot;msg&quot;, e.getMsg()); &#125; return result;&#125; ◇在页面中发送ajax进行处理； 123456789101112131415161718192021222324252627282930313233343536&lt;#if loginMember ??&gt;$(&quot;*[data-read-state]&quot;).click(function () &#123; var readState = $(this).data(&quot;read-state&quot;);//获取当前点击按钮的自定义属性的值； /*ajax方法的简化形式四个参数为 (发送的地址，发送的参数列表,处理函数（用来处理服务器返回的数据）,服务器返回的数据类型)*/ $.post(&quot;/update_read_state&quot;,&#123; memberId:$&#123;loginMember.memberId&#125;, bookId:$&#123;book.bookId&#125;, readState:readState &#125;,function (json)&#123; if (json.code == &quot;0&quot;) &#123; //将原有高亮的css全部清除，让两个按钮回到默认的状态 $(&quot;*[data-read-state]&quot;).removeClass(&quot;highlight&quot;); /*通过拼接字符串的方式选择刚才点击的那个按钮*/ $(&quot;*[data-read-state=&#x27;&quot; + readState + &quot;&#x27;]&quot;).addClass(&quot;highlight&quot;); &#125; &#125;,&quot;json&quot;) //ajax一般写法 $.ajax(&#123; url:&quot;/update_read_state&quot;, data:&#123;memberId:$&#123;loginMember.memberId&#125;,bookId:$&#123;book.bookId&#125;,readState:readState&#125;, type:&quot;post&quot;, dataType:&quot;json&quot;, success: function (json) &#123; if (json.code == &quot;0&quot;) &#123; //将原有高亮的css全部清除，让两个按钮回到默认的状态 $(&quot;*[data-read-state]&quot;).removeClass(&quot;highlight&quot;); /*通过拼接字符串的方式选择刚才点击的那个按钮*/ $(&quot;*[data-read-state=&#x27;&quot; + readState + &quot;&#x27;]&quot;).addClass(&quot;highlight&quot;); &#125; &#125; &#125;)&#125;);&lt;/#if&gt; ◇一点小坑这里的一个小坑，由于忘记设置了主键注解，导致后面在更新阅读状态的时候发现只有没有任何阅读状态的时候 点击阅读状态会生效；但当切换阅读状态的时候发现请求报500错误，一开始以为是前台的问题，但想着增加阅读状态没问题 只有修改阅读状态才有问题，以为是后台修改语句的问题，所以检查了后台的业务逻辑，却发现修改语句没有问题，然后慢慢的 查看日志发现updateById的sql语句是where null = ?才发现可能是忘记了实体类中主键的设置图书写短评◇点击事件弹出写短评的对话框，并加载评分组件；点击提交按钮后边向后台发送数据；◇memberService中新增写短评的方法，并完成其实现类，在controller中进行调用与前台交互◇图书短评的回复功能暂时不开发； 短评点赞◇短评功能只显示短评获得的点赞数量;◇在MemberService中进行短评点赞功能，新增方法enjoy();◇这里发现的一个新bug：就是自己新写的短评然后进行点赞会报错，查看DEBUG:value of type ‘java.lang.String’ to required type ‘java.lang.Long’;说明我们写评论的时候，id值太大了导致系统认为应该是一个字符串而不是Long，这里的原因是使用mybatis-plus增加评论时，ID直接从2000多开始；解决方法是把数据库表删除，然后将主键的自动增长取消，保存；然后设置主键自动增长，保存；最后在前台写入评论，在数据库表中发现id从1开始了（非常玄学）; Spring-Task定时任务介绍◇Spring Task是Spring 3.0后推出的定时任务模块◇Spring Task的职责是按周期后台自动执行任务◇Spring Task可利用Cron表达式实现灵活的定时处理 Cron表达式实例◇本质是七位的字符串，分别对应秒分…年；◇在大多数情况下只需要前六位就可以了◇ 0代表具体的数字，放在秒这个位置上即表示时间是0秒的时候对应的任务自动执行，*代表任意的时间点；关于具体的日期和星期是互斥的，二者选其一，忽略的用?，则第一行的六位表达式(省略了年)具体含义为任一年，任一月、日、时、分的0秒；◇0-5表示每小时的前5分钟， 0,30表示第0秒和第30秒； 子查询◇ifnull表示为空时设置默认值(此处设置为0) 12345update book b SET evaluation_score = ( select ifnull(avg(score),0) from evaluation where book_id = b.book_id and state=&quot;enable&quot;),evaluation_quantity=( select ifnull(count(*),0) from evaluation where book_id = b.book_id and state=&quot;enable&quot;) ◇现在我们来完成自动执行上面的sql语句；◇mybatis-plus对于简单的sql语句可以直接继承父类，但是对于上面这种复杂的sql语句还是的在mapper中的xml文件里定义；如： 12345678910&lt;!--如果命名空间里的接口中没有方法定义，则mapper标签下也无子标签--&gt;&lt;mapper namespace=&quot;com.lcg.reader.mapper.BookMapper&quot;&gt; &lt;update id=&quot;updateEvaluation&quot;&gt; update book b SET evaluation_score = ( select ifnull(avg(score),0) from evaluation where book_id = b.book_id and state=&quot;enable&quot;),evaluation_quantity=( select ifnull(count(*),0) from evaluation where book_id = b.book_id and state=&quot;enable&quot;) &lt;/update&gt;&lt;/mapper&gt; ◇然后在接口中进行定义 1234567public interface BookMapper extends BaseMapper&lt;Book&gt; &#123; /** * 更新图书评分、评价数量 */ public void updateEvaluation();&#125; ◇然后在service接口中增加方法 1public void updateEvaluation(); ◇在接口实现类中具体实现 1234567 /*既然只是调用bookMapper提供的方法，为什么不直接在前台调用呢？ * 这是因为我们基于MVC的按层逐级调用，禁止从controller直接调用mapper的方法来 * 进行与数据库的操作,中间必须经过service；遵循这样的开发规范，会使程序维护更加轻松*/@Transactionalpublic void updateEvaluation() &#123; bookMapper.updateEvaluation(); &#125; ◇那么下面如何让updateEvaluation()方法每分钟调用一次呢？那就需要使用spring-Task模块了，该模块包含在spring-context中 在前面我们已经加载了，所以不需要额外引入jar包；◇在applicationContext.xml文件中开启定时任务的注解模式; 12&lt;!-- 开启Spring Task定时任务的注解模式--&gt;&lt;task:annotation-driven/&gt; ◇在reader下创建一个子包：task(任务)，创建一个类ComputeTask(计算任务) 12345678910111213141516171819202122package com.lcg.reader.task;import com.lcg.reader.service.BookService;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import javax.annotation.Resource;/** * 完成自动计算任务 */@Component //组件注解，当一个类不好确定是service还是controller时增加该注解让spring进行管理public class ComputeTask &#123; @Resource private BookService bookService; //任务调度,每分钟0秒的时候执行一次 @Scheduled(cron=&quot;0 * * * * ?&quot;) public void updateEvaluation() &#123; bookService.updateEvaluation(); System.out.println(&quot;已更新所有图书评分&quot;); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"SSM开发项目","slug":"Spring/SSM开发项目","permalink":"https://618dt.github.io/categories/Spring/SSM%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://618dt.github.io/tags/SSM/"}],"author":"LCG"},{"title":"SpringMVC拦截器","slug":"SpringMVC拦截器","date":"2022-02-06T12:19:00.000Z","updated":"2022-02-23T13:33:00.283Z","comments":true,"path":"p/b7ed.html","link":"","permalink":"https://618dt.github.io/p/b7ed.html","excerpt":"","text":"拦截器-Interceptor◇拦截器(Interceptor)用于对URL请求进行前置/后置过滤◇Interceptor与Filter用途相似,但实现方式不同◇Interceptor底层就是基于Spring AOP面向切面编程实现 HandlerInterceptor接口◇preHandle - 前置执行处理 ；即一个请求产生以后，还没有进controller之前先要执行preHandle，对这个请求进行预制处理◇postHandle - 目标资源已被Spring MVC框架处理 ；即内部方法return之后，但是并没有产生响应文本之前执行◇afterCompletion - 响应文本已经产生；即响应文本产生之后执行，例如如果我们返回的是对象时，当对象进行JSON序列化以后就代表响应文本已经产生； 拦截器开发流程◇项目见interceptor Maven依赖servlet-api◇在pom.xml中增加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!--作为我们Tomcat的最终运行环境，它是自带servlet-api这个jar包的 如果在我们进行打包发布的时候，将当前的依赖也放在war包中，会与Tomcat的 jar包造成冲突；因此需要scope设置范围provided,表示只有在开发、编译时 才会引用;当进行打包、最终使用的时候这个jar会被排除在外;--&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 实现HandlerInterceptor接口◇新增interceptor包，其下开发的都是拦截器类；创建一个java类MyInterceptor 123456789101112131415161718/*该类需要实现HandlerInterceptor接口的三个方法* 选择接口-&gt;Code-&gt;Implement Methods-&gt;全选方法-&gt;OK*/public class MyInterceptor implements HandlerInterceptor &#123; /*如果返回为true，就将请求送达给后面的拦截器或者控制器；返回false，则当前的请求会被阻止直接 * 产生响应返回客户端;*/ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(request.getRequestURL()+&quot;准备执行&quot;); return true; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(request.getRequestURL()+&quot;目标处理成功&quot;); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(request.getRequestURL()+&quot;响应内容已产生&quot;); &#125;&#125; applicationContext配置过滤地址◇进行配置 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;!--配置要对哪些路径进行拦截，/**表示所有路径--&gt; &lt;!--指明哪个类对拦截的URL进行处理--&gt; &lt;bean class=&quot;com.lcg.restful.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ◇运行结果 浏览器输入http://localhost:8080/restful/persons 1234http://localhost:8080/restful/persons准备执行RestfulController.findPersons() - return listhttp://localhost:8080/restful/persons目标处理成功http://localhost:8080/restful/persons响应内容已产生 拦截器使用细则◇当我们输入http://localhost:8080/client.html地址后，查看后台会发现除了client的信息还有其他地址的信息；这是因为作为原始的client.html在这里每一次发送localhost这个url的时候其本质都是通过Tomcat调用springmvc的解析功能来获取对应的资源，因为这些资源都符合”/**”的规则而被拦截；作为拦截器，不受_&lt;**mvc:default-servlet-handler**/&gt;这个配置的控制；如果希望这些静态资源不受拦截器所拦截，需要额外的设置标签；&lt;**mvc:exclude-mapping path=”/**.ico”**/&gt;_； 12345&lt;!--排除一系列静态资源--&gt;&lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt;&lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt;&lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt;&lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt; ◇由于今天资源有许多，如果都用exclude-mapping的配置方式会显得过于麻烦；其实在大多数时候我们的静态资源并不是直接存放在我们webapp的根路径上，而是在webapp目录下创建额外的目录如resources(资源)，并且在该资源目录下创建js、css、image等静态资源按目录进行保存；那么这样的话我们可以直接配置&lt;**mvc:exclude-mapping path=”/resoutces/**”**/&gt;就能够将所有静态资源进行排除；◇如果一个请求被多个拦截器拦截的话，会按照什么顺序呢？我们再增加一个拦截器，interceptor-1，并且进行配置，配置方法和第一个拦截器一样；当我们运行后，结果如下 1234567http://localhost:8080/restful/persons准备执行http://localhost:8080/restful/persons准备执行-1RestfulController.findPersons() - return listhttp://localhost:8080/restful/persons目标处理成功-1http://localhost:8080/restful/persons目标处理成功http://localhost:8080/restful/persons响应内容已产生-1http://localhost:8080/restful/persons响应内容已产生 ◇可以发现，准备执行时顺序按照我们的配置顺序执行，而后面却反了过来；通过图示我们来进行说明；◇多Interceptor执行顺序 ，其中前置请求就是preHandle 开发”用户流量”拦截器◇所谓用户流量就是在用户访问我们应用时自动的收集一些底层信息:如访问的时间、网址，用户使用的浏览器、系统、ip等；◇我们在前面的项目interceptor中进行开发；在拦截器包中新建一个拦截器类 访问历史拦截器AccessHistoryInterceptor；在所有请求在被处理之前要被该拦截器所记录，所以该拦截器为前置处理；所以实现preHandle方法，又因为不涉及到任何请求阻断，所以直接return true；通常拦截器所记录的数据我们用日志文件进行保存；◇引入依赖 123456&lt;!--引入日志依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; ◇配置日志文件，新增logback.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;&lt;!--根节点--&gt; &lt;!--定义一个向控制台书写日志的追加器appender--&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt;&lt;!--输出日志的格式--&gt; &lt;!--定义格式:线程名 产生日志时间 日志级别 产生日志的类&#123;包名长度限制&#125;--&gt; &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--RollingFileAppender表示生成按天滚动的日志,该输出器向文件中进行写入，以天为单位； --&gt; &lt;appender name=&quot;accessHistoryLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!--rollingPolicy表示滚动策略,TimeBasedRollingPolicy表示按照时间进行滚动--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--日志文件的保存路径 %d表示产生日期--&gt; &lt;fileNamePattern&gt;G:/logs/history.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;debug&quot;&gt;&lt;!--定义当前输出级别最低为debug--&gt; &lt;appender-ref ref=&quot;console&quot;/&gt;&lt;!--引用定义的追加器--&gt; &lt;/root&gt; &lt;!--配置拦截器类的日志,指定使用定义的accessHistoryLog追加器, additivity=&quot;false&quot;表示不叠加，即只向文件中输入日志 而不打印在控制台中--&gt; &lt;logger name=&quot;com.lcg.restful.interceptor.AccessHistoryInterceptor&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;accessHistoryLog&quot;/&gt;&lt;!--引用--&gt; &lt;/logger&gt;&lt;/configuration&gt; ◇拦截器开发 12345678910111213141516171819202122232425package com.lcg.restful.interceptor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class AccessHistoryInterceptor implements HandlerInterceptor &#123; /*利用LoggerFactory的get方法得到logger日志对象*/ private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class); public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; StringBuilder log = new StringBuilder(); log.append(request.getRemoteAddr());//用户地址 log.append(&quot;|&quot;);//分隔符 log.append(request.getRequestURL());//用户访问的URL地址 log.append(&quot;|&quot;); log.append(request.getHeaders(&quot;user-agent&quot;));//用户浏览器环境 logger.info(log.toString()); return true; &#125;&#125; ◇拦截器配置 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.lcg.restful.interceptor.AccessHistoryInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; Spring MVC处理流程◇所有请求首先由DispactherServlet进行拦截，然后把请求交由springmvc处理；◇DispactherServlet拦截后的第一步就是查找Handler，Handler也叫处理器，查找Handler的任务由处理器映射器来完成，即通过当前的URL得到执行链；作为HandlerMapper只会获取执行链，而不会对其进行处理；执行链的处理由中央处理器向处理器适配器来发起执行请求，然后由HandlerAdapter根据Handler的类型(可能是一个拦截器或者控制器)去执行对应的方法；执行方法后会返回一个对象(例如MAV)，被HandlerAdapter接收，然后返回给中央处理器；中央处理器会去选择与之对应的视图解析器来进行视图对象的创建，视图会随着处理完返回给中央处理器，当中央处理器拿到对象以后就会将模板和从处理器适配器得到的数据进行渲染，得到最终的html返回给浏览器； 执行链◇如果Handler类型为拦截器，HandlerAdapter首先会执行前置处理方法，之后请求向后送；","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"SpringMVC基础","slug":"Spring/SpringMVC基础","permalink":"https://618dt.github.io/categories/Spring/SpringMVC%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/tags/Spring/"}],"author":"LCG"},{"title":"RESTFUL风格的应用","slug":"RESTful风格的应用","date":"2022-02-06T07:30:00.000Z","updated":"2022-02-23T13:33:00.277Z","comments":true,"path":"p/cc19.html","link":"","permalink":"https://618dt.github.io/p/cc19.html","excerpt":"","text":"传统Web应用的问题◇上图描述了传统开发模式的流程，可知在这种模式下，我们客户端需要支持html的浏览器；但目前互联网的发展呈多元化，有微信小程序，APP等各种客户端；那么像这种客户端是不支持html的，那么我们希望这种客户端都能和后端通过html进行通信，该如何实现呢？这时一种全新的开发理念就出现了，即RESTful； REST与RESTful◇REST-表现层状态转换,资源在网络中以某种表现形式进行状态转移◇RESTful是基于REST理念的一套开发风格,是具体的开发规则◇RESTful传输数据如下图，客户端不再是标准的浏览器，并不拘泥于客户端必须是浏览器；当手机中有一个小程序向http://xxx.com/list这个url发送了一个请求，而这个请求发送到了web端的服务器，经过服务器处理以后，作为服务器返回的不再是html的文本，而是像JSON或XML这样的数组；即在RESTful开发风格中，服务器只返回数据，而这种数据以JSON或XML的方式体现，要求返回的数据不包含任何与展现的内容；具体的展现方式交由客户端处理；这样做的好处是后端工程师可以专注于后台开发，而数据的展现交给前端完成；即前后端分离； RESTful开发规范◇使用URL作为用户交互入口◇ 明确的语义规范(GET|POST|PUT|DELETE)；这里的语义规范是指在http发送请求的时候，例如get请求和post请求它们实现的含义是不同的；在我们日常开发中，常用的http发送的方式有四种，GET|POST|PUT|DELETE，在web环境下不支持后两种，这四种其实分别对应了查询|新增|更新|删除 的操作，也就是说同一个url在向服务器发送请求的时候，使用了不同的请求方式，则服务器的处理操作也是不同的；◇ 只返回数据(JSON|XML),不包含任何展现 ；默认使用JSON数据； RESTful命名要求◇uri在RESTful中是有明确用法的，需要书写正确；第一行说明我们要查询作者是Lily的文章；◇第二行错误是因为我不具有语义，即无法通过uri明白要干什么；而修改后的uri让我们知道是要查询id号为1的学生；RESTful可以把id号附加到uri中；◇第三行，在RESTful中强制要求所有的uri中出现的单词必须是名词，不能是动词；◇第四行，实际使用中如果uri的层级过多，会造成uri的管理混乱，同时造成维护不便；如果超过两级，通常将id进行参数化，书写为?id=1的形式；作为RESTful它里边所代表的资源是由最后一个名词决定的；所以这里查询id=1的名词是指作者而不是文章；◇第五行，RESTful建议最好在名词上区分单复数；一般复数形式用于查询；其他操作往往针对一个对象，通常采用单数形式； 开发RESTful Web应用服务器端◇创建maven项目restful，然后配置工程结构，配置Tomcat；◇配置各种xml文件；◇创建RestController控制器类 1234567891011@Controller@RequestMapping(&quot;/restful&quot;)public class RestfulController &#123; @GetMapping(&quot;/request&quot;) @ResponseBody public String doGetRequest()&#123; /*一个JSON格式的字符串，在其中增加key和value * 注意：双引号中如果包括双引号，要使用转义字符\\,将双引号写成\\&quot;*/ return &quot;&#123;\\&quot;message\\&quot;:\\&quot;返回查询结果\\&quot;&#125;&quot;; &#125;&#125; ◇这样，就完成了restful风格的开发，可以看出，restful并不是新技术，而是一种开发风格；那么如何将JSON字符串进行页面的展现呢？这就是前端的工作了；◇如果我们在页面运行过程中，想得到url返回的数据，可以使用ajax技术，ajax可以在页面中异步的与url发送请求，得到相应结果； 客户端◇现在我们开发一个客户端，与服务器端的restful进行交互◇将jQuery包复制到webapp目录下，因为待会需要使用jQuery的ajax函数，在http页面中向controller发起http请求；◇在webapp目录下创建客户端html页面；client.html； 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;RESTful实验室&lt;/title&gt;&lt;!--引入jquery--&gt; &lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;!--书写页面就绪函数,在页面加载完以后 直接用我们定义的按钮绑定单击事件,并书写事件函数--&gt; &lt;script&gt; $(function()&#123;//页面就绪函数 $(&quot;#btnGet&quot;).click(function () &#123;//单击事件函数 $.ajax(&#123;/*利用ajax函数向服务器端发送一个异步请求*/ url:&quot;/restful/request&quot;, //请求的url地址 type:&quot;get&quot;, //请求方式为get dataType:&quot;json&quot;,//说明服务器返回的数据类型为json /*success回调函数，能将字符串转换为json对象*/ success:function (json) &#123; /*绑定一个&lt;h1&gt;标签的id,然服务器返回的数据 * 填充到这个&lt;h1&gt;里边；text方法用于设置内部的文本 * json.message得到JSON中message的value(值)*/ $(&quot;#message&quot;).text(json.message); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--通过这个按钮利用ajax向服务器发送http请求--&gt; &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt; &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; ◇当我们运行Tomcat并在浏览器输入client.html的页面，点击按钮就会将服务器返回的数据展示在页面的&lt;h1&gt;标签上，如果出现了中文乱码，并且是在程序里创建了消息转换器解决中文时；我们可以按F12然后查看Network网络部分，再次点击按钮，查看request请求，查看Headers中Response Headers响应头部分，如下图，可以看看蓝标处的Context-Type；jequery通过ajax发送请求以后，返回的响应的类型不是我们设置的text/html,而且如果字符集不是utf-8的话，就会出现乱码问题；那么如果如果charset不是utf-8的话，该怎么做呢？我们可以在服务器端修改这个字符集，打开applicationContext配置文件将消息转换器增加配置； 1234567&lt;list&gt;&lt;!--原本设置的字符集只能针对text/html格式的--&gt;&lt;value&gt;text/html;charset=utf-8&lt;/value&gt;&lt;!--现在我们增加application/json格式的，通知客户端将数据用utf-8的字符集进行展示--&gt;&lt;value&gt;application/json;charset=utf-8&lt;/value&gt;&lt;/list&gt; RESTful不同操作◇作为restful还有一个重要特性，就是针对不同的请求来做不同的操作；如查询用get，新增用post，修改put，删除delete；那么在程序中是如何体现的呢？◇服务端方法,注意请求地址需要不同，否则会报500错误：There is already ‘restfulController’ bean method 123456789101112131415@RequestMapping(&quot;/request&quot;)@ResponseBodypublic String doPostRequest()&#123; return &quot;&#123;\\&quot;message\\&quot;:\\&quot;数据新增成功\\&quot;&#125;&quot;;&#125;@RequestMapping(&quot;/put&quot;)@ResponseBodypublic String doPutRequest()&#123; return &quot;&#123;\\&quot;message\\&quot;:\\&quot;数据更新成功\\&quot;&#125;&quot;;&#125;@RequestMapping(&quot;/delete&quot;)@ResponseBodypublic String doDeleteRequest()&#123; return &quot;&#123;\\&quot;message\\&quot;:\\&quot;数据删除成功\\&quot;&#125;&quot;;&#125; ◇客户端调用,只写了delete请求的，其他的请求是一样的实现方式，只是请求类型不一样 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;RESTful实验室&lt;/title&gt;&lt;!--引入jquery--&gt; &lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(&quot;#btnDelete&quot;).click(function () &#123; $.ajax(&#123; url:&quot;/restful/delete&quot;, type:&quot;delete&quot;, //可以是GET|POST|PUT|DELETE dataType:&quot;json&quot;, success:function (json) &#123; $(&quot;#message&quot;).text(json.message); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt; &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; RestController注解与路径变量◇上面的案例还有一些小问题，其一返回值我们使用的是字符串拼接完成的，如果是一个复杂对象或者大的集合就会显得很麻烦；那么如何优化JSON产生的过程呢？其二，在当前的应用中，我们每一个方法都固定写了 @ResponseBody这个注解来直接返回一个JSON字符串，那么有没有简单的方式，不用每一个方法上都进行这个注解呢；其三，在restful中允许uri出现id这样的数据，那么如何获取uri中像id这样的数据呢；◇解决第二个问题，我们只需要将原来类上的@Controller注解改为@RestController，这样就不需要在每个方法上面都添加@ResponseBody了；◇路劲变量即放在uri中的变量；如 POST /article/1 意思为提交id为1的文章，其中1就是一个变量称为路径变量；现在我们要创建一个全新的请求request，假设请求的id值为100的话，那么uri书写的样式为：POST /restful/request/100，那在服务器端怎么接收到这个100呢？因为100并不是我们请求得参数，而是uri中的一部分，好在springmvc给我们提供了路径变量的支持，我们只需要给@GetMapping注解中的uri增加对应的路劲变量名字即可，需要用大括号括起来；如@GetMapping(“/request/{rid}”)；前面我们定义了路径前缀/restful；在程序中的接收方法为：在方法中根据rid的属性设置一个Integer数字类型的参数,并且在参数前增加路劲变量的注解，并将上面增加的路径变量名字rid放在注解中，即方法写为：public String doPostRequest(@PathVariable(“rid”) Integer requestId)；◇controller方法部分 12345//Post /restful/request/100@RequestMapping(&quot;/request/&#123;rid&#125;&quot;)public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId)&#123; return &quot;&#123;\\&quot;message\\&quot;:\\&quot;数据新增成功\\&quot;,\\&quot;id\\&quot;:&quot;+requestId+&quot;&#125;&quot;;&#125; ◇客户端请求部分 123456789101112$(function()&#123; $(&quot;#btnPost&quot;).click(function () &#123; $.ajax(&#123; url:&quot;/restful/request/100&quot;, type:&quot;post&quot;, dataType:&quot;json&quot;, success:function (json) &#123; $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id); &#125; &#125;) &#125;)&#125;) 简单请求与非简单请求概念◇简单请求是指标准结构的HTTP请求,对应GET/POST请求◇ 非简单请求是复杂要求的HTTP请求,指PUT/DELETE、扩展标准请求◇ 两者最大区别是非简单请求发送前需要发送预检请求◇非简单请求图示◇预检请求可以让服务器预先处理，对于不符合要求的请求就会挡在外头实际的数据并不会发送，这样就可以减轻网络传输和服务器的压力了； 代码演示◇我们在简单请求post和非简单请求put上各加一个数据data，在发送的请求中我们附加查询字符串：”name=lily&amp;age=23”, 1data:&quot;name=lily&amp;age=23&quot;, ◇如果要接收一系列数据，最好新建一个实体对象；那么我们在实体包总成绩Person实体对象 1234567package com.lcg.restful.entity;public class Person &#123; private String name; private Integer age; ...&#125; ◇然后在控制器类中的post请求方法里增加实体对象的参数； 12345678910111213//Post /restful/request/100 @RequestMapping(&quot;/request/&#123;rid&#125;&quot;) public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person) &#123; System.out.println(person.getName()+&quot;:&quot;+person.getAge()); return &quot;&#123;\\&quot;message\\&quot;:\\&quot;数据新增成功\\&quot;,\\&quot;id\\&quot;:&quot; + requestId + &quot;&#125;&quot;; &#125; @RequestMapping(&quot;/put&quot;) public String doPutRequest(Person person) &#123; System.out.println(person.getName()+&quot;:&quot;+person.getAge()); return &quot;&#123;\\&quot;message\\&quot;:\\&quot;数据更新成功\\&quot;&#125;&quot;; &#125; ◇但是，作为非简单请求的put，不能像post一样直接进行参数的增加；这是因为springmvc最早是为网页提供服务的，而网页中只支持post和get两个简单请求，对于put和delete这种特殊请求是不支持的；但随着技术的发展，springmvc需要考虑到这种特殊请求，作为springmvc不能把这种特殊请求方式和简单请求进行相同的处理，因此springmvc为这种特殊请求提供了额外的表单内容过滤器；具体实现为，打开web.xml配置表单内容过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.FormContentFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 只有增加了这个filter，springmvc才能对put等特殊请求进行良好的支持； JSON序列化◇Apache提供的maven中央仓库地址下载jackson-core，jackson的核心组件；jackson是世界上使用频率高，效率号的JSON序列化组件，其核心组件2.9以前的版本与mysql使用时会有漏洞，所以我们使用2.9版本以后的组件；◇在pom.xml中增加jackson的依赖； 123456789101112131415161718&lt;!--jackson-core是最底层的核心包，不能独立运行--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--还需要引进databind(数据绑定,用以核心交互) 和annotations(注解,用以简化开发)--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; ◇当我们加载好jackson后，springmvc会自动利用其进行JSON的序列化，不需要额外的配置；◇在控制器类中增加findByPersonId()方法示例JSON序列化的使用方法 1234567891011121314151617181920212223242526272829303132/*在这里返回的并非字符串或者ModelAndView，而是一个实体对象 * 如果我们返回一个实体对象并且方法上设置为@ResponseBody或者类 * 上设置了@RestController那么springmvc就会自动的使用jackson * 对这个对象进行JSON序列化的输出,从而避免了手动拼接字符串的麻烦*/ @GetMapping(&quot;/person&quot;) public Person findByPersonId(Integer id)&#123; Person p = new Person(); if (id == 1) &#123; p.setName(&quot;莉莉&quot;); p.setAge(22); &#125; else if (id == 2) &#123; p.setName(&quot;张珊&quot;); p.setAge(20); &#125; return p; &#125;/*返回多个对象,当程序返回以后，list集合就会产生一个JSON数组，包含每一个JSON序列化后的对象*/ @GetMapping(&quot;/persons&quot;) public List&lt;Person&gt; findPersons()&#123; List list = new ArrayList(); Person p1=new Person(); p1.setName(&quot;lily&quot;); p1.setAge(22); Person p2=new Person(); p2.setName(&quot;leon&quot;); p2.setAge(23); list.add(p1); list.add(p2); return list; &#125; ◇启动后浏览器输入http://localhost:8080/restful/person?id=1，页面显示JSON字符串：{&quot;name&quot;:&quot;莉莉&quot;,&quot;age&quot;:22}输入http://localhost:8080/restful/persons，显示JSON数组：[{&quot;name&quot;:&quot;lily&quot;,&quot;age&quot;:22},{&quot;name&quot;:&quot;leon&quot;,&quot;age&quot;:23}]◇在客户端显示JSON对象数组； 123456789101112131415161718192021/*查询所有人员的函数*/ $(function () &#123; $(&quot;#btnPersons&quot;).click(function () &#123; $.ajax(&#123; url:&quot;/restful/persons&quot;, type:&quot;get&quot;, dataType:&quot;json&quot;, success: function (json) &#123; console.info(json);/*浏览器的控制台打印json信息*/ for (var i = 0; i &lt; json.length; i++) &#123; var p = json[i]; $(&quot;#divPersons&quot;).append(&quot;&lt;h2&quot;+p.name+&quot;-&quot;+p.age+&quot;h2&gt;&quot;) &#125; &#125; &#125;) &#125;) &#125;) &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt; &lt;!--将查询的人员放入下面的div中--&gt; &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt; ◇但是在时间处理上jackson做得并不理想；在Person中额外的增加日期属性birthday;并将人员的birthday设置为当前时间以便于演示；◇通过JSON对时间类型进行输出的时候，得到的是一串很长的数字，这个数字是从1970年到现在为止的毫秒数，而非具体的时间；因此jackson提供了内置的格式化注解@JsonFormat，可以将时间按指定格式进行输出；将该注解写在类的时间类型属性上； 123private Integer age;@JsonFormat(pattern =&quot;yyy-MM-dd HH:mm:ss&quot;)private Date birthday; 但这样又会出现问题，会发现时间与我们的正确时间不一致，相差了8个小时；因为jackson在对对象序列化的时候，对日期类型会按照伦敦天文台的时区作为起点，而北京时间和伦敦差了八个时区；具体的做法还需要修改注解，我们额外的增加timezone=”GMT+8”,即增加了八个时区，修改为@JsonFormat(pattern =“yyy-MM-dd HH:mm:ss”,timezone = “GMT+8”)； 浏览器的跨域访问浏览器的同源策略◇同源策略阻止从一个域加载的脚本去获取另一个域上的资源;即如果我们把client.html文件下载到桌面再用浏览器打开的话，就相当于一个域了(C:/Desktop/client.html)，所以无法访问原来的资源；◇只要协议、域名、端口有任何一个不同，都被当作是不同的域◇那么如何进行跨域访问呢？浏览器Console看到Access-Control-Allow-Origin就代表跨域了 同源策略示例◇第一个，域名、端口、协议都不同；第二个协议不同；第三个域名不同；第四个端口不同(默认网站端口为80)；第五个在本机测试的时候，localhost和127.0.0.1虽然从系统的层面上都指向了本机，但它们却是不同的域； HTML中允许跨域的标签◇&lt;img&gt; - 显示远程图片◇&lt;script&gt; - 加载远程js◇&lt;link&gt; - 加载远程css SpringMVC跨域访问CORS跨域资源访问◇CORS是一种机制,使用额外的HTTP头通知浏览器可以访问其他域◇URL响应头包含 Access-Control-*指明请求允许跨域 解决跨域访问的方法◇ @CrossOrigin－ Controller跨域注解 ，只是在当前controller中生效◇ mvc:cors - Spring MVC全局跨域配置◇在服务器的提供端(也就是接收请求的端)配置跨域; 12345678910//方法一//origins说明允许被哪些其他域名访问,可以写多个,也可以使用*表示所有域都可以进行访问,但不推荐/*@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)maxAge表示设置预检请求的缓存时间为3600秒maxAge参数说明我们可以将预检请求的处理结果进行缓存;如果在指定的缓存时间内，同样的请求在进行访问就可以不用再进行预检请求了;*/@CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;&#125;)public class RestfulController &#123;....&#125; ◇当我们查看Request Headers（请求头）时，会看到Sec-Fetch-Mode:cors 表明这是一个跨域访问； CORS全局配置◇打开applicationContext.xml配置文件进行设置； 12345678910&lt;mvc:cors&gt; &lt;!--子标签mvc：mapping 映射 path对应了当前应用的url地址; allowed-origins表示允许被哪些域名进行访问,可以进行多个域名的书写 max-age预检请求处理结果的缓存时间 --&gt; &lt;mvc:mapping path=&quot;/restful/**&quot; allowed-origins=&quot;http://localhost:8080,http://www.gamest.com&quot; max-age=&quot;3600&quot;/&gt;&lt;/mvc:cors&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"SpringMVC基础","slug":"Spring/SpringMVC基础","permalink":"https://618dt.github.io/categories/Spring/SpringMVC%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://618dt.github.io/tags/%E5%BC%80%E5%8F%91/"}],"author":"LCG"},{"title":"SpringMVC入门与数据绑定","slug":"SpringMVC入门与数据绑定","date":"2022-02-06T05:24:00.000Z","updated":"2022-02-23T13:33:00.284Z","comments":true,"path":"p/b016.html","link":"","permalink":"https://618dt.github.io/p/b016.html","excerpt":"","text":"周课介绍Spring MVC Restful开发风格 Spring MVC课程介绍◇Spring MVC入门 ◇Spring MVC数据绑定◇Restful开发风格 ◇Spring MVC拦截器 MVC到底是什么◇MVC是一种著名的架构模式；View就是我们通常说的界面部分，用于和用户进行交互，比如通过界面显示查询结果，提供表单等；而模型通常指的是数据，如果放在java代码里就是业务逻辑的部分；在MVC的设计理念中，如果前面视图中某个表格的数据来自于后端的Model中，并非视图通过java主动的调用model中的某一个方法来获取数据，而是要通过控制器；控制器相当于中介，作为控制器，是整个MVC架构中最核心的部分，其用途就是接收视图中所传入的数据，然后再根据数据调用后端的业务逻辑得到结果，再将后端得到的结果返回到视图中；◇Spring MVC是Spring体系的轻量级Web MVC框架◇Spring MVC的核心Controller控制器，用于处理请求，产生响应；在MVC中，界面是不允许直接访问后端的Model业务逻辑的，而是通过控制器作为一个中间者传递调用，这样的好处是让我们的界面和后端的java业务逻辑解耦，提高了程序的可维护性；◇Spring MVC基于Spring IOC容器运行，所有对象被IOC管理，提高了程序的健壮性与稳定性； Spring 5.x 版本变化◇Spring 5.x最低要求JDK8与J2EE 7(Servlet 3.1/Tomcat 8.5+)◇Spring 5.x支持JDK8/9,可以使用新特性◇Spring 5.x最重要的新特性支持响应式编程(即基于事件来的，当触发某一事件后就会在后端自动的执行某一段代码)作为响应式编程，是一种新的开发理念和风格； Spring MVC官方文档学习◇进入spring.io官网，project-&gt;spring-framework-&gt;Features-&gt;spring mvc 链接 IDEA环境下创建Maven WebApp◇打开idea-&gt;new-&gt;Maven-&gt;SDk:java1.8以上版本-&gt;next-&gt;GroupId:com.lcg-&gt;ArtifactId:first-springmvc-&gt;next-&gt;设置工程保存路径-&gt;finish-&gt;Enable Auto-Import（自动导入依赖）◇创建好以后，还需要进行如下设置使创建的标准maven工程具备web能力: 选中工程名称-&gt;File-&gt;Project Structure-&gt;Facets-&gt;+-&gt;web(进行web能力的嵌入)-&gt;选中工程名-&gt;OK-&gt;配置web描述符文件(web.xml)所存储的路径：first-springmvc\\src\\main\\webapp\\WEB-INF\\web.xml-&gt;勾选版本为3.1-&gt;设置存储页面的目录（就在上一项操作的下方）:src\\main\\webapp-&gt;下方设置默认上下文为:/-&gt;OK-&gt;是否创建目录：yes-&gt;Create Artifact（根据前面的设置自动配置运行的方式）-&gt;OK;◇在webapp目录下创建一个测试页面index.html;然后进行Tomcat的配置；右上角Add Configuration-&gt;Templates(配置一个模板): TomcatServer-&gt;Local-&gt;Application server(应用服务器)-&gt;configure-&gt;Tomcat Home:Tomcat的安装路径(apache-tomcat-8.5.40)-&gt;OK-OK; 模板配置好后，再次点击Add Configuration-&gt;+-&gt;Tomcat Server -&gt;Local-&gt;Deployment-&gt;+-&gt;Artifact-&gt;Application context:/-&gt;Server-&gt;On ‘Update’ action(说明在页面发生改变以后如何来生效，默认选项为Restart server即重启服务才会生效):改为Update classes and resources(说明在Tomcat启动过程中，如果idea中的页面代码发生变化不需要重启Tomcat，直接可以更新；这种方式称为热部署)-&gt;HTTP port（可以根据自己的需要修改端口，默认为8080）:80-&gt;OK; 这样就完成了web的配置； Spring MVC环境配置配置步骤1.Maven依赖spring-webmvc 12345678910111213141516//阿里云的仓库&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; //依赖环境 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.web.xml配置DispatcherServlet◇DispatchServlet是springmvc最重要的一个类，其作用就是对所有请求进行拦截；类似公司的前台一样，接待不同的客户，然后根据客户的需求向公司对应的部门请求处理； 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- DispatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--这里名字是可以自定义的，但一般约定如此--&gt; &lt;!--DispatchServlet是Spring MVC最核心的对象 DispatchServlet用于拦截Http请求， 并根据请求的URL调用与之对应的Controller方法， 来完成Http请求的处理--&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载applicationContext.xml 告诉DispatcherServlet在IOC容器启动时 加载哪一个目录下的哪个xml文件; classpath表示类路径 main\\resources下的xml文件会自动加载到类路径中--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--在Web应用启动时自动创建Spring IOC容器， 并初始化DispatcherServlet，以提高响应速度;如果没有这个配置， 则会在第一次访问url的时候进行容器的创建和初始化工作--&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--&quot;/&quot; 代表拦截所有请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.配置applicationContext的mvc标记 12345678910111213141516//声明部分//schema部分 &lt;!-- context:component-scan 标签作用 在Spring IOC初始化过程中,自动创建并管理com.lcg.springmvc及子包中 拥有以下注解的对象. @Repository @Service @Controller @Component --&gt; &lt;context:component-scan base-package=&quot;com.lcg.springmvc&quot;&gt;&lt;/context:component-scan&gt; &lt;!--启用Spring MVC的注解开发模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--将图片、js、css等静态资源排除在外(即不被拦截)，可提高执行效率--&gt; &lt;mvc:default-servlet-handler/&gt; 4.开发Controller控制器 1234567891011/*在配置文件中,context：component-scan所描述的包中包含了这个测试类* 因此增加Controller注解，所以在IOC容器初始化时会自动的将TestController* 初始化并由IOC容器所管理，且spring也自动该类是一个springmvc的控制器*/@Controllerpublic class TestController &#123; @GetMapping(&quot;/t&quot;)//用于将当前方法绑定某个get方式请求的url，比如localhost/t @ResponseBody //直接向响应提供字符串数据，不跳转页面 public String test()&#123; return &quot;SUCCESS&quot;; &#125;&#125; 5.在运行测试之前，还需要进行Tomcat的配置；因为一些底层依赖还没有加到当前的发布目录(WEB-INF)中，所以需要进行加入；具体做法为：右上角Edit Configuration-&gt;Deployment-&gt;编辑web exploded-&gt;将右侧的依赖全选，put到左边的目录中去-&gt;OK◇热部署状态下，如果修改了源码，只需要右键Reload Changed Classes（对类进行重新编译）则不要重启Tomcat； SpringMVC处理示意图◇打开浏览器输入网址以后，需要向服务器发送请求，假设请求发送的地址是：http://localhost/t；那么这个请求就会发送到本机的Tomcat上，而Tomcat自然启动了springmvc的应用，此时请求会被DispatcherServlet拦截，DispatcherServlet会在Controller中寻找哪个方法映射了t，则DispatcherServlet会知道使用test()方法来处理这个请求，然后请求进入test方法，并返回一个响应体; Spring MVC数据绑定◇什么是数据绑定：即springmvc中的controller控制器的某一个方法是如何与url进行绑定的，在前面的演示中我们使用了GetMapping这个注解进行绑定，那还有其他的方法吗？答案是肯定的； URL Mapping(URL映射)◇URL Mapping指将URL于Controller方法绑定◇通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务 URL Mapping注解◇@RequestMapping - 通用绑定◇@GetMapping - 绑定Get请求◇@PostMapping - 绑定Post请求 注解使用案例◇见firstspringmvc项目 12345678910111213@Controllerpublic class URLMappingController &#123; @GetMapping(&quot;/g&quot;) @ResponseBody public String getMapping()&#123; return &quot;This is get method&quot;; &#125; @PostMapping(&quot;/p&quot;) @ResponseBody public String postMapping()&#123; return &quot;This is post method&quot;; &#125;&#125; ◇以上代码运行后，当浏览器中输入/p时会出现405报错，因为直接在浏览器输入地址是get请求，而程序后端里”/p”映射的是post请求，出现了请求不一致的情况；那么如何处理post请求呢？可以通过html表单来完成post请求；于是修改index.htm，增加表单，并将提交的地址设置为”/p”，指明提交的方法为post； 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/p&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ◇通常RequestMapping 注解是放在类上面的，大多数情况下用于URL的全局设置；作为URL可能有多级结构，比如，要求URLMappingController所有的映射地址都是以/um作为前缀来进行访问，那么GetMapping和PostMapping都要在原来的映射地址前增加/um(如/um/p)，如果方法过多的话，都要这样进行一一设置，过于繁琐；而RequestMapping 放在类上就可以进行全局设置了，直接进行注解@RequestMapping (“/um”),这样，请求的地址必须在前面加入/um才能够访问成功；◇如果将RequestMapping 注解放在方法上，则不再区分get/post请求，但并不推荐这样使用；当然使用RequestMapping 注解也可以指定其请求方法，如@RequestMapping (value=”/g”, method=RequestMethod.GET) 接收请求参数◇在大多数情况下一个请求发过来的时候需要包含一些数据，这些数据大多以请求参数来体现的，比如说我们用户登录的时候需要输入用户名和密码，那么这些数据就会以post请求参数的形式发送到controller的方法中； 接收请求参数的常用方法◇使用Controller方法参数接收 1234567891011121314&lt;form action=&quot;/m1&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;username&quot;/&gt;&lt;input name=&quot;password&quot;/&gt;&lt;/form&gt;-------------------------------------------------------------- @PostMapping(&quot;/m1&quot;)@ResponseBody /*SpringMVC允许进行类型转换，如果在前面进行表单校验的时候 Password只允许输入数字，那向服务器提交以后，因为password 只是数字，所以可以强制转换为Long类型；因此在接收时，直接可以 将形参设置为Long类型，而不需手动转换*/public String post(String username , Long password)&#123; return username + &quot;:&quot; + password;&#125; ◇使用Java Bean接收数据 1234567891011&lt;form action=&quot;/m1&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;username&quot;/&gt;&lt;input name=&quot;password&quot;/&gt;&lt;/form&gt;----------------------------------------------------------------- @PostMapping(&quot;/m1&quot;)@ResponseBodypublic String post(User user)&#123; return user.getUsername() + &quot;:&quot; + user.getPassword();&#125; Controller方法◇html表单 12345&lt;form action=&quot;/p&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;&gt;&lt;br/&gt; &lt;input name=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; ◇controller 123456@PostMapping(&quot;/p&quot;) @ResponseBody public String postMapping(String username,String password)&#123; System.out.println(username+&quot;:&quot;+password); return &quot;submit success&quot;; &#125; ◇ 对于get请求如何接收请求参数呢？如localhost/g?managet_name=lily就是一个带有请求参数的get请求，在java中只有驼峰命名法，所以不能使用managet_name作为参数名来接收请求参数；则需要一个特殊的注解@RequestParam(“manager_name”),其放在接收请求的参数前，括号里面填写映射的地址，即请求参数名；作为请求中的manager_name这个参数在运行时会被动态的注入到managerName这个参数中 123456@GetMapping(&quot;/g&quot;)@ResponseBodypublic String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName)&#123; System.out.println(&quot;mangerName:&quot;+managerName); return &quot;This is get method&quot;;&#125; Java Bean方法◇假设表单有一百个输入项，那么问题来了，难道我们需要将这一百个参数都在controller的方法中列举出来吗？并且还需要将接收的一百个参数通过set方法进行对象的转化，这样做显然麻烦；为了解决这个问题，springmvc运行我们将前台输入的数据保存为指定的java bean，一步到位，完成了由数据到对象的转换工作；◇创建entity实体包，并在实体包下创建实体类User 1234567package com.lcg.springmvc.entity;public class User &#123; private String username; private Long password; //get&amp;ser方法;&#125; ◇controller 123456789/*在这里直接将实体类当做参数；springmvc会自动的创建对象 * 并且根据前面的请求结合参数名进行一一的赋值,在实体类中属性的 * 名字必须和前台的传入参数名保持一致*/ @PostMapping(&quot;/p1&quot;)//也要将表单请求提交的地址改为p1 @ResponseBody public String postMapping1(User user)&#123; System.out.println(user.getUsername()+&quot;:&quot;+user.getPassword()); return &quot;This is post method&quot;; &#125; ◇**public **String postMapping1(User user，String username)；这样会对user赋值，也会给username这个参数赋值；即不管参数中写了多少个username或者多少个实体对象，只要它们用于username这个属性或者参数，只要符合这个规则那么springmvc都会对其进行赋值； 综合训练：调查问卷◇像这种一次性选择多个数据的情况，在springmvc中如何进行处理呢？ 知识点◇利用数组或List接收请求中的复合数据◇利用@RequestParam为参数设置默认值◇使用Map对象接收请求参数及注意事项 URI绝对路径与相对路径◇所谓URI是统一资源标识符的意思，它包含我们平时使用的URL；◇假设左图是开发的某一个应用，我们访问的uri上下文假设叫project，而project包含如图的结构；右图表示在index.html中引用js文件使用的相对路径和绝对路径；右图错误的使用方法，以”/“开头，是一个绝对路径，但是并没有加上上下文路径，除非我们设置上下文为”/“根路径时才可以；◇相对地址的应用案例：当使用了相对路径以后，如果访问的页面地址为http://localhost:8080/[上下文路径]/form.html;那么当表单提交以后，其处理请求的地址为http://localhost:8080/[上下文路径]/apply，因为使用了相对路径，则不管前面的上下文路径设置的是什么，只需要保证我们的提交地址apply和当前的html在同一个层级上那么请求就会送达而不会产生404错误；通过使用相对路径可以降低我们对于web工程设置的依赖； 代码演示◇form.html略，详见项目form;◇对于我们的表单，包含了三种数据，前面两种都是单个数据，最后一种是复合数据(一次性会提交多个数据)，springmvc对复合数据的接收提供了两种方案，一种使用数组接收，另一种使用ArrayList进行接收；◇创建FormController类；使用数组进行接收复合数据 123456789101112131415 @PostMapping(&quot;/apply&quot;) @ResponseBody //假设value设置一个表单中不存在的n，如果我设置了value这个属性的话，那么以value为准，不再以name进行接收，而是value接收后再出入到name中 defaultValue即默认值；如果表单不存在的话， 默认值就是设置的ANON；由于表单中并不存在n这个参数，所以当我们提交的时候，即使填了名字 也会使用默认的value注入到参数name中；当然，如果我们设置value=&quot;name&quot;的话，由于表单中有name 这个参数，所以填了名字可以注入到apply的name参数中，而不填的话，就会使用默认值ANON注入； public String apply(@RequestParam(value = &quot;n&quot;,defaultValue = &quot;ANON&quot;)String name, String course, Integer[] purpose)&#123; System.out.println(name); System.out.println(course); for (Integer p : purpose) &#123; System.out.println(p); &#125; return &quot;SUCCESS&quot;; &#125; ◇前面提到我们的controller类中方法的参数名需要和请求的参数名一致，这样就会完成自动注入；但是，在我们的表单中，有很多都是进行匿名提交的，它并没有包含name参数，在这种情况下，name必然是一个空的对象，那么对于空的对象进行操作时，程序很可能报错；解决这一问题的方法是使用@RequestParam给参数设置默认值；◇如果使用List进行复合数据的接收，需要在参数前增加@RequestParam注解，这样springmvc才知道请求中的复合数据要被转换为List进行存储； 12345@PostMapping(&quot;/apply&quot;)@ResponseBodypublic String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose)&#123; //与上类似&#125; ◇对于一组结构化的数据，我们通常使用对象来进行接收；那么在对象情况下，这个List依然能够进行接收；我们额外的创建实体包，并创建表单对象类Form; 123456public class Form &#123; private String name; private String course; private List&lt;Integer&gt; purpose;//复合数据 ... &#125; 在控制器中新建方法使用对象来接收 12345@PostMapping(&quot;/apply&quot;)@ResponseBodypublic String apply(Form form)&#123; return &quot;SUCCESS&quot;;&#125; ◇当然，也可以使用Map来进行参数的接收，Map可以一次性接收表单项的结果，也得在方法参数前加上注解@RequestParam 123456@PostMapping(&quot;/apply&quot;)@ResponseBodypublic String apply(@RequestParam Map map)&#123; System.out.println(map); return &quot;SUCCESS&quot;;&#125; 但是，对于复合数据，Map是无法接收的，Map默认情况下只会保留复合数据中的第一个数据，其余都会丢失；​ 关联对象赋值◇关联对象赋值即在一个对象中引用了另一个对象，需要在这个被引用对象进行赋值的操作；◇复杂内容表单 123456用户名:&lt;input name=&quot;username&quot;&gt;密码: &lt;input name=&quot;password&quot;&gt;-------------------------------------- 姓名:&lt;input name=&quot;name&quot;&gt;身份证号:&lt;input name=&quot;idno&quot;&gt;过期时间:&lt;input name=&quot;expire&quot;&gt; ◇对于这张表单来说，包含了两个内容，一个是注册信息，一个是身份信息；对于这个表单来说，可以创建一个对象，然后通过springmvc自动对其进行赋值，但是这样做并不完美；如果按照严格的面向对象的设计方式对表单进行接收的话，需要创建两个类一个User类和一个身份类，并且用户类中包含身份类；◇用户类 123456public class User&#123; private String username; private String password; private IDcard idcard = new IDCard();//实例化关联对象，对象名为idcard //getter and setter ...&#125; ◇身份类 123456public class IDcard&#123; private String name; private String idno; private Date expire; //getter and setter ...&#125; ◇那么如何对这样的关联对象进行赋值呢？我们需要修改表单的属性名；将关联对象的的对象名(idcard)作为原有属性的前缀，这样通过springmvc接收数据的时候会自动的将三个属性按照名称对应关系依次进行赋值； 123456用户名:&lt;input name=&quot;username&quot;&gt;密码: &lt;input name=&quot;password&quot;&gt;------------------------------------------- 姓名:&lt;input name=&quot;idcard.name&quot;&gt;身份证:&lt;input name=&quot;idcard.idno&quot;&gt;过期时间:&lt;input name=&quot;idcard.expire&quot;&gt; 日期类型转换◇全世界各地对日期的表达方式是不一样的；欧美一般采用月日年的表达方式，而国内采用年月日的形式；我们如何接收程序中的日期数据并将其转换为日期对象呢？◇假设在注册用户的时候，需要提交注册时间(createTime)这个输入项，那么我们只需要在controller的方法中增加一个参数String createTime就可以了，但大多数的情况下，我们需要将字符串转换为日期对象，那么我们直接将参数改为Date createTime，程序运行时会产生日期格式不一致的问题，当我们输入2020-02-02时，会出现400的错误，一般400错误往往就是我们无法将数据转换为目标类型所致；因此我们需要手动转换才可以，但springmvc为我们早有准备，只需要在日期参数前加上@DateTimeFormat这个注解就行了，此注解用于按照指定的格式将前台接收的字符串转换为对应的date对象，在转换前需要指定其格式是什么，需要给此注解增加patten参数；如@DateTimeFormat(pattent=”yyyy-MM-dd”);注意这里的格式需要与前台输入的对象一致；◇在实体对象中，也要给日期属性增加注解，才能够完成Date类型的转换； 123private Long password;@DateTimeFormat(pattent=&quot;yyyy-MM-dd&quot;)private Date createTime; ◇如果对于大量的需要进行日期类型转换的参数，那么都要一 一 加上注解，则过于麻烦，为了解决这个问题，可以设置全局的默认时间转换机制；作为全局的日期转换机制，需要新建一个converter(转换器)包，其中保存的都是转换器，开发一个日期转换类MyDateConverter;对于日期转换器springmvc要求必须实现Converter接口，在接口中得实现两个泛型，String和Date因为我们是希望把前台的字符串转换为日期类型； 1234567891011public class MyDateConverter implements Converter&lt;String,Date&gt;&#123;//实现接口 public Date convert(String s)&#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//定义格式 try&#123; Date d = sdf.parse(s);//开始转换 return d; &#125;catch (ParseException e)&#123; return null; &#125; &#125;&#125; ◇作为当前的类，需要在applicationContext.xml中进行配置，让springmvc知道该类是一个转换类;配置方法如下： 1234567891011121314//下面的配置只是让springmvc知道有这个转换类要想和springmvc进行联动，还需要修改下面的driven配置，额外增加conversion-service属性，并将下面定义好的beanid放到这个属性中；&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;//增加bean进行定义，id可自行定义，但通常如下定义，class为转换服务的工厂类，其作用就是通知springmvc有哪些自定义的转换类&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt;//转换类定义的地方 &lt;set&gt;//作为converters这个属性，它是一个set集合，使用set标签进行描述 &lt;bean class=&quot;com.lcg.springmvc.converter.MyDateConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; ◇如果我们既配置了全局的转换类，又设置了注解，则springmvc会优先使用转换器类来进行转换而注解会被忽略掉，因此我们一般二者选其一使用；◇对于转换器类只有一种日期格式，那出现了特殊的日期格式要求怎么办呢？那么这时候我们就要对转换器输入的字符串的日期格式进行判断，来使用不同的日期格式进行解析 解决中文乱码Web应用的中文乱码由来◇Tomcat默认使用字符集ISO-8859-1,属于西欧字符集，不支持中文；◇解决乱码的核心是将ISO-8859-1转换为UTF-8◇Controller中请求与响应都需要设置UTF-8字符集 中文乱码的配置◇Get请求乱码 - server.xml增加URIEncoding属性◇Post请求乱码 - web.xml配置CharacterEncodingFilter◇Response响应乱码 - Spring配置StringHttpMessageConverter(消息转换器) 代码演示◇解决Get请求乱码，需要在文件夹中找到Tomcat的server.xml文件，本机的路径为F:\\JAVA\\Tomcat\\apache-tomcat-8.5.34\\conf\\server.xml；进行修改，在Connector port=”8080”处的代码后增加URIEncoding=”UTF-8” 1234&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; ◇在Tomcat8.0以后的版本，URIEncoding默认就是UTF-8，所以在8.0以后的版本不需要进行配置；◇解决Post请求乱码，需要在工程的web.xml中配置一个filter，filter是javabean的标准组件，用于对请求进行过滤；在这里name设置为字符集过滤，过滤类为有springmvc提供的字符编码过滤器 123456789101112131415&lt;!--配置过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt;&lt;!--配置参数--&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt;&lt;!--特殊需求下会用GBK--&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!--使过滤器生效,配置filter的映射地址--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--代表对所有的url进行拦截--&gt;&lt;/filter-mapping&gt; ◇解决响应中的中文乱码，需要在applicationContext配置文件中进行设置，在原有的启用注解的标签中增加消息转换器类，首先将原有的标签内容放开，然后在mvc：annotation-driven标签体中增加message-converters(用来设置消息的转换器)，在其下配置的转换器可以对响应中的消息进行调整，这里的converters是个复数，在其下增加一个bean，class为StringHttpMessageConverter(对于http响应中的文本进行转换，如何转换还需要bean下的配置) 1234567891011121314&lt;!--启用Spring MVC的注解开发模式 --&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt; &lt;mvc:message-converters&gt;&lt;!--增加消息转换器类--&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt;&lt;!--supportedMediaTypes代表支持的媒体类型，是一个集合，所以用list描述--&gt; &lt;!--在servlet中解决响应乱码如下配置 response.setContentType(&quot;text/html;charset=utf-8&quot;)--&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;&lt;!--用于说明响应输出对应的字符类型--&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 响应输出结果◇响应中产生结果主要有两种方式，一种是采用@ResponseBody注解直接产生响应文本显示在客户端浏览器上；另一种是ModelAndView对象，利用模板引擎渲染输出，也就是利用我们之前写好的JSP或者freemaker这样的模板引擎再结合数据动态渲染产生页面； @ResponseBody◇@ResponseBody直接产生响应体的数据，过程不涉及任何视图；◇@ResponseBody可产生标准字符串/JSON/XML等格式数据；◇@ResponseBody被StringHttpMessageConverter所影响 ModelAndView◇如果要在springmvc响应中进行页面展现的话，就需要使用这个ModelAndView对象；◇ModelAndView对象是指”模型(数据)与视图(界面)”对象◇通过ModelAndView可将包含数据对象与模板引擎进行绑定◇springmvc中默认的view是jsp，也可以配置其他的模板引擎◇页面展现的方法controller类中的showview方法； 123456@GetMapping(&quot;/view&quot;)/*映射地址*/public ModelAndView showView()&#123; /*jsp作为模板引擎*/ ModelAndView mav = new ModelAndView(&quot;/view.jsp&quot;); return mav;&#125; ◇view.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个视图页面&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; ◇这样，我们能够通过showview方法访问view.jsp的页面，但是，上面的代码我们通过url直接访问view.jsp也是可以的; 因此通过controller访问view.jsp的意义是为了完成数据的动态展现，所以假设我们需要将请求传来的用户编号，我们把数据查询出来得到一个user对象，然后在jsp中把user对象进行展现； 123456789101112131415@GetMapping(&quot;/view&quot;)/*映射地址*/public ModelAndView showView(Integer userId)&#123; /*jsp作为模板引擎*/ ModelAndView mav = new ModelAndView(&quot;/view.jsp&quot;); User user = new User(); if (userId == 1) &#123; user.setUsername(&quot;lily&quot;); &#125; else if (userId == 2) &#123; user.setUsername(&quot;smith&quot;); &#125; /*addObject的含义是在当前的请求中增加一个对象，对象的别名可以设置为u,第二个参数是 * 我们要存放的数据，该数据可以是一个java对象*/ mav.addObject(&quot;u&quot;,user); return mav;&#125; ◇修改jsp部分,通过EL表达式来进行数据的动态传入 123&lt;h1&gt;这是一个视图页面&lt;/h1&gt; &lt;hr&gt; &lt;h2&gt;Username:$&#123;u.username&#125;&lt;/h2&gt; 然后在浏览器中输入localhost/view?userId=1;会发现页面的展现的username为lily,将userId改为2则name变为Smith；数据是由controller中动态的查询产生，而界面由jsp动态渲染；通过这个例子可以看出springmvc模式设计的核心，mvc一直强调视图和模型解耦，有利于程序的维护； ModelAndView◇mav.addObject()方法设置的属性默认存放在当前请求中；◇默认ModelAndView使用请求转发(forward)至页面，请求转发就是把当前送给showview方法的请求原封不动的传递给view.jsp，即jsp和controller中的请求是同一个，而mav.addObject方法只是向当前的请求中存放数据；◇重定向使用new ModelAndView(“redirect:/index.jsp”)◇如果我们使用页面重定向，即将new ModelAndView(“redirect:/view.jsp”),那么我们的jsp页面将接收不到数据；因为重定向是controller通知客户端浏览器重新建立一个新的请求来访问view.jsp的地址；◇那么重定向使用的场景也有很多，例如那种需要调转的页面和当前请求中的数据没有关系的时候，比如在用户注册的时候，需要跳转到网站首页，那么网站首页就和用户注册的数据没有太大关系；◇ ModelAndView mav = new ModelAndView(“/view.jsp”)；也可写为 ModelAndView mav = new ModelAndView()；mav.setViewName(“/view.jsp”);如果/view.jsp去掉”/“的话，就代表相对地址，相对于我们当前的访问地址(在控制类上通过@RequestMapping(“/um”)设置的全局地址)，也就是说，去掉以后我们在浏览器访问到的页面是在程序中的webapp/um/view.jsp；而不是webapp/view.jsp；um文件夹是自己创建的，和RequestMapping设置的一致；◇如何利用String与ModelMap实现和ModelAndView一样的作用；如果没有数据需要传递的话，可以没有ModelMap对象参数； 1234567891011121314151617181920/*String与ModelMap* ModelMap对应模型数据，通过ModelMap向里设值可以给我们的页面提供数据* 方法直接返回string字符串* Controller方法返回String的两种情况* 1.方法被@ResponseBody注解描述，SpringMVC直接响应String字符串本身* 2.方法不存在@ResponseBody，则SpringMVC处理String指代的视图(页面)* *///@ResponseBody //直接向响应提供字符串数据，不跳转页面public String showView1(Integer userId, ModelMap modelMap) &#123; String view = &quot;/view.jsp&quot;;/*设置显示的页面*/ User user = new User(); /*模拟数据获取*/ if (userId == 1) &#123; user.setUsername(&quot;lily&quot;); &#125; else if (userId == 2) &#123; user.setUsername(&quot;smith&quot;); &#125; modelMap.addAttribute(&quot;u&quot;,user);/*与addObject的作用完全相同*/ return view;&#125; SpringMVC整合Freemarker三个步骤◇一般分为以下三步：**pom.xml引入依赖、启用Freemarker模板引擎、 配置Freemarker参数 **◇pox.xml引入freemarker的依赖,还要引入spring上下文的依赖包spring-context-support(该模块提供了spring对freemaker的整合支持类) 12345678910&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; ◇第二步需要通知springmvc我们要使用用Freemarker模板引擎，在applicationContext.xml中增加如下配置，其作用是通知springmvc我们的默认引擎有jsp改为了FreeMarkerViewResolver； 1234567&lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;!-- 设置响应输出，并解决中文乱码 --&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;&gt;&lt;/property&gt; &lt;!-- 指定Freemarker模板文件扩展名 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt; &lt;/bean&gt; ◇第三步，对Freemarker本身进行参数设置，定义一个bean，类指向Freemarker的配置类；注意第三步设置的UTF-8是在模板与数据绑定渲染过程中使用的字符集，而在上一步设置utf-8是指在渲染完成后，向客户端浏览器响应时，响应体中使用的字符集； 12345678910111213&lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;&lt;!--设置模板保存的目录；WEB-INF目录是无法被直接访问的，Tomcat无法直接解析freemarker 模板引擎，因此为了保证模板的安全，就需要把模板文件放在外侧无法访问的WEB-INF目录下 一般新增一个ftl文件用于存放freemarker文件--&gt;&lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;&lt;!--其他模板引擎设置--&gt;&lt;property name=&quot;freemarkerSettings&quot;&gt;&lt;props&gt;&lt;!--设置Freemarker脚本与数据渲染时使用的字符集--&gt;&lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;&lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; 代码示例◇首先按上面步骤进行配置◇在controller包中新增FreemarkerController类 12345678910111213141516171819202122package com.lcg.springmvc.controller;import com.lcg.springmvc.entity.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller@RequestMapping(&quot;/fm&quot;)public class FreemarkerController &#123; public ModelAndView showTest()&#123; /*只写/test,而不写扩展名是因为前面我们已经设置了扩展名为.ftl * &#x27;/&#x27;代表了根路径，而此时根路径并不是指webapp目录，而是我们定义的 * WEB-INF/ftl,在这里我们写的文件名为test，则应该在ftl目录下创建 * test.ftl文件*/ ModelAndView mav = new ModelAndView(&quot;/test&quot;); User user = new User(); user.setUsername(&quot;张珊&quot;); mav.addObject(&quot;u&quot;, user); return mav; &#125;&#125; ◇创建test.ftl模板文件，语法在前面的章节有讲 1&lt;h1&gt;$&#123;u.username&#125;&lt;/h1&gt; ◇因为引入了依赖，但是IDEA并不会将依赖发布，因此需要对发布的信息进行配置，即编辑Web exploded，加入新增的两个依赖，使其运行时能发布到Tomcat中；只要pom.xml配置文件中增加了新的依赖，都要编辑Web exploded◇在浏览器中输入:localhost/fm/test，即可出现张珊字样；​","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"SpringMVC基础","slug":"Spring/SpringMVC基础","permalink":"https://618dt.github.io/categories/Spring/SpringMVC%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/tags/Spring/"}],"author":"LCG"},{"title":"Spring JDBC与事务管理","slug":"SpringJDBC与事务管理","date":"2022-02-05T23:24:00.000Z","updated":"2022-02-23T13:33:00.282Z","comments":true,"path":"p/d79b.html","link":"","permalink":"https://618dt.github.io/p/d79b.html","excerpt":"","text":"课程介绍◇Spring JDBC与JdbcTemplate对象◇声明式事务与两种配置方式◇声明式事务七种事务传播行为 Spring JDBC简介◇Spring JDBC是Spring生态用于处理关系型数据库的模块◇Spring JDBC对JDBC API进行封装，极大简化开发工作量◇JdbcTemplate是Spring JDBC核心类，提供数据CRUD方法◇有Mybatis为什么还需要Spring JDBC？答：这两者面向的对象不一样，Mybatis封装程度较高，适合中小企业做软件的敏捷开发，让程序员可以快速的完成数据库的交互工作；但是封装程度高意味着执行效率较低；而Spring JDBC只是对原始的JDBC的API进行简单封装，执行效率较高； Spring JDBC的使用步骤◇Maven工程引入依赖spring-jdbc◇applicationContext.xml配置DataSource数据源◇在Dao注入JdbcTemplate对象,实现数据CRUD jdbcTemplate实现增删改查代码实现(jdbc/s01)◇由于代码过于繁多，因此不再展示。仅将代码中主要方法思路记下。具体代码见文件夹的项目； 执行查询◇核心配置文件pom.xml **加载底层依赖：spring-context, spring-jdbc, mysql-connector-java;◇新增实体类Employee实体成员和数据库保持一致。◇新增DaojdbcTemplate.queryForObject()方法的含义是进行指定的查询(查询单条语句)，将唯一返回的数据转换为对应的对象，第一个参数是sql语句，第二个参数是与sql语句对应的参数(如sql需要查询的属性)一般用new object数组实现，如new Object[]{“研发部”}；最后一个参数是new BeanPropertyRowMapper(Employee.class)，其中BeanPropertyRowMapper的含义是指将bean属性和每一行的列进行一一匹配，即从数据库记录到实体对象的转化；jdbcTemplate.query()方法用于查询复合数据，默认返回list集合，参数和queryForObject()方法一致；◇applicationContext.xml配置文件定义数据源，说明要连接哪一个数据库，用户名，密码等；配置JdbcTemplate以提供数据CRUD(增删改查)的API；为Dao注入JdbcTemplate对象，只有注入以后，我们的具体的业务方法才可以去掉用jdbcTemplate相应的API来完成数据库的增删改查操作；◇如果查询的字段没有与之对应的实体属性，该怎么办？答：使用jdbcTemplate**.queryForList()方法，将查询结果作为列表返回，同时将每一条数据按map对象进行包裹；该方法前两个参数和上述一致，但没有第三个参数；List中没一条数据都是一个Map对象，Map的Key是原始的字段名，Value是字段名所对应的数值；通过此方法，不过结果有没有对应的实体属性，都将其放入Map中，安装键值对的规则进行保存，每一个Map就对应着一条记录； 12 //将查询结果作为Map进行封装List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;); 执行插入◇插入的方法为**jdbcTemplate.**update()方法；第一个参数为sql语句，第二个为传入的参数(new Object[])；new Object[]的数据来源从实体类的get中将与之对应的属性进行提取； 1234567public void insert(Employee employee)&#123; String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;; //利用update方法实现数据写入操作 jdbcTemplate.update(sql,new Object[]&#123; employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate() &#125;); &#125; 执行更新◇更新的方法和插入方法一样；只不过SQL语句不同；update方法有一个返回值，代表执行本次sql语句所真实影响的数据条目； 12345public int update(Employee employee)&#123; String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;; int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;); return count;&#125; ◇测试用例 1234567@Testpublic void testUpdate()&#123; Employee employee = employeeDao.findById(8888); employee.setSalary(employee.getSalary() + 1000); int count = employeeDao.update(employee); System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);&#125; 执行删除◇执行删除的方法也是update； 1234public int delete(Integer eno)&#123; String sql = &quot;delete from employee where eno = ?&quot;; return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;); &#125; Spring事务管理什么是事务◇事务是以一种可靠的、一致的方式，访问和操作数据库的 程序单元◇ 通俗地说：要么把事情做完，要么什么都不做，不要做一半◇ 事务依赖于数据库实现,MySQL通过事务区作为数据缓冲地带 编程式事务◇编程式事务是指通过代码手动提交回滚事务的事务控制方法◇SpringJDBC通过TransactionManager事务管理器实现事务控制◇事务管理器提供commit/rollback方法进行事务提交与回滚 代码演示编程式事务(s01)◇需求分析：最近公司入职了十名新员工，需要将这十名新员工批量的导入到员工表当中，对于导入的要求，要么一次性全部导入，要么什么都不做；◇通过需求分析可知，需要通过事务来进行控制。业务逻辑的代码一般写在service包里，所以新增service；◇EmployeeService底层依赖于EmployeeDao；增加batchImport()方法，用于批量导入；利用for循环模拟十名员工；数据插入调用方法employeeDao.insert();Service写好后还要在applicationContext中进行配置，beanId为employeeService，class指向service类；属性注入employeeDao;但是，这样写的代码并不正确；因为通过打印日志可以看出这十个员工数据的插入并不是在同一事务中进行的。在pom.xml中加载日志组件logback-classic，Spring框架默认集成此组件；◇那么要怎么实现事务批量导入呢？作为编程式事务，需要配置bean对象，beanId为transactionManager，意为事务管理器，其用途就是控制事务的提交和回滚；class为org.springframework.jdbc.datasource.DataSourceTransactionManager; 基于数据源的事务管理器，需要绑定数据源；ref=”dataSource”；在需要进行事务控制的类里边进行transactionManager的注入；**private **DataSourceTransactionManager transactionManager;在生成get和set方法；然后在applicationContext配置文件的Service配置中注入事务管理器的bean: 1234&lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt; &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;&lt;/bean&gt; 作为batchImport需要进行事务管理，所以在此方法执行前增加事务默认的标准配置；开始一个事务，说明此段代码后的所有增删改查都进入了事务管理； 123456789101112131415161718192021222324252627public void batchImport()&#123; //定义了事务默认的标准配置 TransactionDefinition definition = new DefaultTransactionDefinition(); //开始(创建)一个事务,返回的对象为事务状态,事务状态说明当前事务的执行阶段 TransactionStatus status = transactionManager.getTransaction(definition); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; /*if (i == 3) &#123; throw new RuntimeException(&quot;意料之外的异常&quot;); &#125;*/ Employee employee = new Employee(); employee.setEno(8000 + i); employee.setEname(&quot;员工&quot; + i); employee.setSalary(4000f); employee.setDname(&quot;市场部&quot;); employee.setHiredate(new Date()); employeeDao.insert(employee); &#125; //提交事务,参数为status transactionManager.commit(status); &#125;catch (RuntimeException e)&#123; //出现异常，回滚事务 transactionManager.rollback(status); throw e;//可以捕获异常，也可以抛出异常，视具体业务而定 &#125;&#125; 通过事务，已经执行成功的sql语句并非直接修改在表中，而是在事务区内，当所有的事务都执行成功后才写入到数据表中，如果遇到异常则会进行回滚；◇编程式事务的优点：代码写在程序中，对程序员友好；缺点：存在人为的风险，产生数据不完整的情况； 声明式事务◇声明式事务指使用配置或注解，在不修改源码情况下通过配置形式自动实现事务控制，声明式事务的本质就是AOP环绕通知；◇ 当目标方法执行成功时,自动提交事务◇ 当目标方法抛出运行时异常时,自动事务回滚 配置过程◇配置TransactionManager事务管理器◇配置事务通知与事务属性◇为事务通知绑定PointCut切点(PointCut说明在哪个类哪个方法上应用通知) 代码演示声明式事务(s02)◇声明式事务直接在配置文件中配置即可◇applicationContext的配置第一步，和编程式一样需要配置事务管理器，绑定数据源；第二步，事务通知配置；需要新增命名空间:xmlns:tx=”http://www.springframework.org/schema/tx&quot;以及命名空间所对应的url的描述文件(xsd)得实际地址；以及AOP的命名空间(xmlns:aop=”http://www.springframework.org/schema/aop&quot;)和实际的xsd文件地址 12345http://www.springframework.org/schema/txhttps://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/aophttps://www.springframework.org/schema/aop/spring-aop.xsd 事务通知配置，决定哪些方法使用事务，哪些方法不使用事务，配置方法如下：propagation表示设置事务的传播行为，propagation=”REQUIRED”表示需要使用事务；read-only=”true”表示当前方法是只读的，propagation=”NOT_SUPPORTED”表示方法不支持事务； 123456789101112&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 --&gt; &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt; //其他选项，一律按如下实现 &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 第三步，定义切点作用范围，并关联到通知上 123456&lt;!--3. 定义声明式事务的作用范围--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt; //与通知关联 &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; 事务传播行为◇事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式◇XML：&lt;tx:method name=”…” propagation=”REQUIRED”/&gt;◇注解：@Transactional(propagation=Propagation.REQUIRED)◇如果还有大量的类似batchImport的批量任务需要开发，则可以创建一个专用于批量导入的服务类BatchService，类的方法可以有很多批量导入的方法；批量导入的服务执行入口放在EmployeeService服务类里边；需要为批量服务类进行bean配置以及注入； 123&lt;bean id=&quot;batchService&quot; class=&quot;com.imooc.spring.jdbc.service.BatchService&quot;&gt; &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;&lt;/bean&gt; 事务传播行为七种类型◇代码分析–EmployeeService类中的批量导入方法 12345678public void startImportJob()&#123; batchService.importJob1(); if(1==1)&#123; throw new RuntimeException(&quot;意料之外的异常&quot;); &#125; batchService.importJob2(); System.out.println(&quot;批量导入成功&quot;); &#125; –方法的配置情况 123&lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; ◇通过配置信息可以知道对于方法startImportJob()以及其里面嵌套的方法importJob1和2都是具有事务的；对于外侧的方法startImportJob在运行时会创建一个事务，而嵌套调用的importJob1和2在执行时发现外侧已经有了现成的事务，所以在运行时内侧的事务就会加入到外侧的事务中，也就意味着在执行start方法的时候，整体是在一个事务中完成的数据的增删改操作；如图所示，红色框为主方法的事务，蓝框为子方法的事务，因此当子方法1执行成功了，但子方法2执行前遇到了异常，总的事务也会进行回滚，导致方法1无法写入数据进数据库；◇如果我们期望无论是方法1还是方法2，只要方法执行成功，就能够成功写入数据库，彼此互不干扰，该如何实现呢？我们可以更改配置项，将原来的配置改为 123&lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;&lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; REQUIRES_NEW表示针对于两个子方法，在运行过程中都会产生新的事务；该方法执行过程如下图 注解配置声明式事务代码演示(s03)◇核心配置文件pom.xml与上面相同◇applicationContext.xml没有配置部分，然后利用component-scan来设置扫描的基本包是哪个；然后定义数据源，初始化JdbcTemplate,配置事务管理器，这三项是必须要配置的bean；最后启用注解形式声明式事务； 123456789101112131415161718&lt;!--数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt;&lt;!--JdbcTemplate--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- 启用注解形式声明式事务 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; ◇在Dao类中，利用@Resource完成对象的注入；◇在service中，使用@Service完成IOC容器的实例化，在service依赖的每一个dao上进行@Resource完成dao的注入;◇利用注解进行事务的配置，则只需将声明式注解@Transactional放在需要的类上,说明事务配置应用于当前类所有方法，默认事务传播为REQUIRED；也可以自行设置@Transactional(propagation = Propagation.REQUIRED);当然对于不同的方法，也可以进行不同的设置，只需在方法上进行注解配置即可；例如在查询的方法上选择不使用事务，并且只读； 1234567891011121314@Service//声明式事务核心注解//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED@Transactionalpublic class EmployeeService &#123; @Resource private EmployeeDao employeeDao; @Resource private BatchService batchService; @Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true) public Employee findById(Integer eno)&#123; return employeeDao.findById(eno); &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"Spring基础","slug":"Spring/Spring基础","permalink":"https://618dt.github.io/categories/Spring/Spring%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/tags/Spring/"}],"author":"LCG"},{"title":"Spring AOP面向切面编程","slug":"SpringAOP面向切面编程","date":"2022-02-05T09:24:00.000Z","updated":"2022-02-23T13:33:00.280Z","comments":true,"path":"p/7cef.html","link":"","permalink":"https://618dt.github.io/p/7cef.html","excerpt":"","text":"课程介绍◇ 介绍Spring AOP与相关概念名词◇ Spring AOP开发与配置流程◇ Spring 五种通知类型与应用场景 Spring中的可插拔组件技术◇假设软件模块A是系统的用户管理模块，B是系统的员工管理模块，这两个模块都有自己的各种各样的员工业务逻辑类，执行过程从上到下。要求：两个模块从上到下处理业务的过程中，都要进行权限过滤，只有拥有权限的用户才能进入对应的模块；实现方法：利用面向切面编程技术；所谓面向切面编程就是指在软件运行过程中，在执行前或者执行后都可以额外增加相应的扩展功能(称之为切面，Aspect)，如下图的权限切面和日志切面； Spring AOP◇Spring AOP - Aspect Oriented Programming 面向切面编程◇AOP的做法是将通用、与业务无关的功能抽象封装为切面类◇切面可配置在目标方法的执行前、后运行，真正做到即插即用◇在不修改源码的情况下对程序行为进行扩展 初识AOP编程◇业务背景：在工程中有员工和用户两个service及dao；现在需要在service和dao的方法执行之前在控制台打印它们各自执行的时间(不是指时间大小)，通过这些信息我们可以知道在一天什么时间段是应用程序负载最高的时刻；如果采用直接在执行方法前打印输出系统时间，由于程序有很多类，类中也有很多方法，所以这个方法过于繁琐，因此采用Spring AOP技术，在这些方法执行前进行拦截，先打印时间，然后再去执行方法内部的方法；具体项目见AOP/s01◇pom.xml核心配置 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aspectjweaver是Spring AOP的底层依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ◇创建aspect包，在其下创建MethodAspect类用于扩展功能编写 1234567891011121314151617181920212223242526272829303132333435package com.lcg.spring.aop.aspect;import org.aspectj.lang.JoinPoint;import java.text.SimpleDateFormat;import java.util.Date;//切面类public class MethodAspect &#123; //切面方法,用于扩展额外功能 //JoinPoint 连接点,通过连接点可以获取目标类/方法的信息 public void printExecutionTime(JoinPoint joinPoint)&#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;); String now = sdf.format(new Date()); String className = joinPoint.getTarget().getClass().getName();//获取目标类的名称 String methodName = joinPoint.getSignature().getName();//获取目标方法名称 System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName); Object[] args = joinPoint.getArgs();//获取到传入目标方法的参数 System.out.println(&quot;----&gt;参数个数:&quot; + args.length); for(Object arg:args)&#123; System.out.println(&quot;----&gt;参数:&quot; + arg); &#125; &#125; public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123; System.out.println(&quot;&lt;----返回后通知:&quot; + ret); &#125; public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123; System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage()); &#125; public void doAfter(JoinPoint joinPoint)&#123; System.out.println(&quot;&lt;----触发后置通知&quot;); &#125;&#125; ◇在applicationContext中配置（开头部分schema不同于以前的配置，需要添加一部分） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.lcg.spring.aop.dao.UserDao&quot;/&gt; &lt;bean id=&quot;employeeDao&quot; class=&quot;com.lcg.spring.aop.dao.EmployeeDao&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.lcg.spring.aop.service.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;employeeService&quot; class=&quot;com.lcg.spring.aop.service.EmployeeService&quot;&gt; &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt; &lt;/bean&gt; &lt;!-- AOP配置 --&gt; &lt;bean id=&quot;methodAspect&quot; class=&quot;com.lcg.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt;//此标签由AOP命名空间提供 &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt; &lt;!-- execution(public * com.lcg..*.*(..)) 说明切面作用在com.lcg包下的所有类的所有方法上 --&gt; &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.lcg..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt; &lt;!--只对所有Service类生效--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.lcg..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--只对所有返回值为String类型方法生效--&gt; &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.lcg..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt; &lt;!--对方法名进行约束 --&gt; &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.lcg..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt; &lt;!-- 对参数进行约束 --&gt; &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.lcg..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt; &lt;!-- 定义切面类 让IOC容器认为这个bean是一个切面类--&gt; &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!-- before前置通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt; &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;//pointcut-ref指向定义的切点; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; AOP关键概念Spring AOP与AspectJ的关系◇Eclipse AspectJ,一种基于Java平台的面向切面编程的语言◇Spring AOP使用了AspectJ切入点匹配功能◇Spring AOP利用代理技术实现对象运行时功能扩展 几个关键概念 AOP配置过程◇依赖Aspect ◇实现切面类和切面方法◇配置Aspect Bean ◇定义PointCut◇配置Advice JoinPoint核心方法 PointCut切点表达式◇完整方法的描述： public void com.lcg.service.UserService.createUser(形参1，形参2，…)◇切点表达式：execution(public * com.lcg .. * . * ( .. ) )◇ * - 通配符 .. - 包通配符 (..) - 参数通配符◇切点表达式的含义：去匹配com.lcg包下所有类的所有公用方法；◇(,)-代表两个参数； *可以替换为string 五种通知类型归纳 特殊的”通知” - 引介增强◇引介增强(IntroductionInterceptor)是对类的增强，而非方法◇引介增强允许在运行时为类目标增加新属性或方法◇引介增强允许在运行时改变类的行为，让类随运行环境动态变更 代码示例◇目标方法 123456789public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123; System.out.println(&quot;&lt;----返回后通知:&quot; + ret); &#125; public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123; System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage()); &#125; public void doAfter(JoinPoint joinPoint)&#123; System.out.println(&quot;&lt;----触发后置通知&quot;); &#125; ◇配置 12345678910&lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt; &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;!--返回后通知,returning表示哪个参数接收目标方法的返回值--&gt; &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;!--最后通知，目标方法运行后执行--&gt; &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; 详解环绕通知(Around Advice)利用AOP进行方法性能筛选◇案例背景，在实际工作中可能遇到这种情况：由于不断的数据累积，用户量的增大，可能会导致我们生产环境中系统越来越慢，那我们如何定位到是哪一个方法运行慢呢？解决方法：利用AOP技术在方法执行前以及执行后记录时间，两相减即为执行时长，把超过指定时长的方法输出到日志中去；但由于需要记录一前一后两个时间，所以采用环绕通知来实现； 代码示例(AOP/S02)◇切面类 123456789101112131415161718192021222324252627282930package com.lcg.spring.aop.aspect;import org.aspectj.lang.ProceedingJoinPoint;import java.text.SimpleDateFormat;import java.util.Date;public class MethodChecker &#123; ////ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行 public Object check(ProceedingJoinPoint pjp) throws Throwable &#123; try &#123; long startTime = new Date().getTime(); Object ret = pjp.proceed();//执行目标方法,返回的对象ret即为目标方法的返回值 long endTime = new Date().getTime(); long duration = endTime - startTime; //执行时长 if(duration &gt;= 1000)&#123; String className = pjp.getTarget().getClass().getName(); String methodName = pjp.getSignature().getName(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;); String now = sdf.format(new Date()); System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;); &#125; return ret;//返回 &#125; catch (Throwable throwable) &#123; System.out.println(&quot;Exception message:&quot; + throwable.getMessage()); throw throwable;//直接抛出异常 &#125; &#125;&#125; ◇配置 1234567&lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.lcg..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;aop:aspect ref=&quot;methodChecker&quot;&gt; &lt;!--环绕通知--&gt; &lt;aop:around method=&quot;check&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; ◇应用程序入口 1234567public class SpringApplication &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.createUser(); &#125;&#125; 利用注解配置Spring AOP代码示例(AOP/S03)◇pom.xml加载jar包，完成底层依赖；◇applicationContext配置文件增加注解相关的配置 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--组件扫描,初始化IoC容器--&gt; &lt;context:component-scan base-package=&quot;com.lcg&quot;/&gt; &lt;!--启用Spring AOP注解模式--&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; ◇将dao类以及service类进行上节课ioc注解相关的配置，如@Repository和@Service等◇切面类注解 1234567891011121314151617181920212223242526272829303132333435package com.lcg.spring.aop.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.text.SimpleDateFormat;import java.util.Date;@Component //标记当前类为组件@Aspect //说明当前类是切面类public class MethodChecker &#123; //环绕通知,参数为PointCut切点表达式 @Around(&quot;execution(* com.lcg..*Service.*(..))&quot;) //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行 public Object check(ProceedingJoinPoint pjp) throws Throwable &#123; try &#123; long startTime = new Date().getTime(); Object ret = pjp.proceed();//执行目标方法 long endTime = new Date().getTime(); long duration = endTime - startTime; //执行时长 if(duration &gt;= 1000)&#123; String className = pjp.getTarget().getClass().getName(); String methodName = pjp.getSignature().getName(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;); String now = sdf.format(new Date()); System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;); &#125; return ret; &#125; catch (Throwable throwable) &#123; System.out.println(&quot;Exception message:&quot; + throwable.getMessage()); throw throwable; &#125; &#125;&#125; 代理模式Spring AOP实现原理◇Spring基于代理模式实现功能动态扩展，包含两种形式◇目标类拥有接口，通过JDK动态代理实现功能扩展◇目标类没有接口，通过CGLib组件实现功能扩展 静态代理◇代理模式通过代理对象对原对象的实现功能扩展◇所谓代理模式，其核心理念是实现一个代理类，在代理类中持有最原始的委托类；代理类和委托类实现共同的接口；而客户通过代理类来完成所需的功能代码演示(AOP/S04)◇创建接口UserService 123public interface UserService &#123; public void createUser();&#125; ◇创建接口的实现类UserServiceImpl（委托类） 12345public class UserServiceImpl implements UserService&#123; public void createUser() &#123; System.out.println(&quot;执行创建用户业务逻辑&quot;); &#125;&#125; ◇案例背景：现在需要将方法执行的时间打印出来，在前面已经讲过Spring AOP技术来实现。但是在代理模式中如何实现呢？如果要实现这个功能的扩展就必须基于UserService接口创建对应的代理类，同时在代理类中去持有与之对应的具体实现；◇创建UserServiceProxy（代理类） 12345678910111213141516import java.text.SimpleDateFormat;import java.util.Date;//静态代理是指必须手动创建代理类的代理模式使用方式public class UserServiceProxy implements UserService&#123; //持有委托类的对象 private UserService userService ; //创建代理对象的时候，通过外侧传入某一个UserService的实现类为内部的委托类赋值，相当于持有委托类 public UserServiceProxy(UserService userService)&#123; this.userService = userService; &#125; public void createUser() &#123; System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;); userService.createUser(); &#125;&#125; ◇主程序（客户） 123456public class Application &#123; public static void main(String[] args) &#123; UserService userService = new UserServiceProxy(new UserServiceImpl()); userService.createUser(); &#125;&#125; ◇代理模式是可以嵌套使用的，因此在代理类的构造方法中参数为接口类的某一个实现而非具体的接口实现类UserServiceImpl；嵌套使用案例：再创建一个代理类，实现一些后置功能，然后在这个代理类中传入参数为另一个代理类的实现；**new **UserServiceProxy1(**new **UserServiceProxy(**new **UserServiceImpl()))因为参数不管是什么对象，只要实现了接口类即可；缺点：随着功能的不断扩大，每一个具体的实现类都至少拥有一个代理类，这种方式称为静态代理。 JDK动态代理◇静态代理与动态代理最显著的区别是静态代理必须手动创建代理类，而动态代理根据接口的结构运行时在内存中进行生成。代码实现（AOP/S05）◇EmployeeService接口 123public interface EmployeeService &#123; public void createEmployee();&#125; ◇EmployeeServiceImpl实现类 12345public class EmployeeServiceImpl implements EmployeeService &#123; public void createEmployee() &#123; System.out.println(&quot;执行创建员工业务逻辑&quot;); &#125;&#125; ◇创建ProxyInvocationHandler类，实现重要的接口InvocationHandler 123456789101112131415161718192021222324252627282930313233343536373839404142/** * InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强 * InvocationHandler实现类与切面类的环绕通知类似 */public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target;//目标对象 private ProxyInvocationHandler(Object target)&#123; this.target = target; &#125; /** * 必须实现这个invoke()方法 * 在invoke()方法对目标方法进行增强 * @param proxy 代理类对象 * @param method 目标方法对象 * @param args 目标方法实参 * @return 目标方法运行后返回值 * @throws Throwable 目标方法抛出的异常 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;); Object ret = method.invoke(target, args);//调用目标方法,相当于ProceedingJoinPoint.proceed() return ret; &#125; public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); ProxyInvocationHandler invocationHandler = new ProxyInvocationHandler(userService); //动态创建代理类 /*newProxyInstance方法基于接口动态创建代理类,三个参数（类加载器，类要实现的接口，如何对目标方法进行扩展）*/ UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), invocationHandler); userServiceProxy.createUser(); //动态代理,必须实现接口才可以运行 EmployeeService employeeService = new EmployeeServiceImpl(); EmployeeService employeeServiceProxy = (EmployeeService)Proxy.newProxyInstance(employeeService.getClass().getClassLoader(), employeeService.getClass().getInterfaces(), new ProxyInvocationHandler(employeeService)); employeeServiceProxy.createEmployee(); &#125;&#125; JDK动态代理解析◇CSDN参考链接◇Proxy是JDK反射包提供的类，其作用是根据已有接口来生成对应的代理类。 CGLib实现代理类◇CGLib是运行时字节码增强技术◇Spring AOP扩展无接口类使用CGLib◇AOP会运行时生成目标继承类字节码的方式进行行为扩展◇如下图，假设有一个最原始的Service类，类中有一个findById()方法;该Service类没有实现任何接口，因此无法实现JDK的动态代理。Spring会自动使用CGLib通过继承的方式来对类进行扩展。这个类是在jvm运行过程中自动生成的，生成规则是：原类名+$$+EnhancerByCGLIB","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"Spring基础","slug":"Spring/Spring基础","permalink":"https://618dt.github.io/categories/Spring/Spring%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/tags/Spring/"}],"author":"LCG"},{"title":"Spring Ioc容器与Bean管理","slug":"SpringIoc容器与Bean管理","date":"2022-02-04T23:24:00.000Z","updated":"2022-03-07T13:22:01.750Z","comments":true,"path":"p/ddb.html","link":"","permalink":"https://618dt.github.io/p/ddb.html","excerpt":"","text":"内容说明Spring loC Spring AOP Spring JDBC与声明式事务 课程介绍◇Spring快速入门 ◇Spring XML配置◇对象实例化配置 ◇依赖注入配置◇注解与Java Config ◇Spring 单元测试 Spring 快速入门生活中的烦恼◇苹果这个对象的控制权是由客户发起的，客户必须掌握所有对象的特征细节后才能做出选择； 现实中的商机◇客户将获取对象的权利交个水果摊老板，有老板替顾客做出选择； IoC控制反转◇IoC控制反转,全称Inverse of Control,是一种设计理念◇由代理人来创建与管理对象,消费者通过代理人来获取对象◇IoC的目的是降低对象之间直接耦合◇对象直接引用导致对象硬性关联，程序难以扩展维护◇ 加入IoC容器将对象统一管理，让对象关联变为弱耦合 DI依赖注入◇IoC是设计理念,是现代程序设计遵循的标准,是宏观目标◇DI(Dependency Injection)是具体技术实现,是微观实现◇DI在Java中利用反射技术实现对象注入(Injection) Spring官网 Spring的含义◇Spring可从狭义与广义两个角度看待◇狭义的Spring是指Spring框架(Spring Fremework)◇广义的Spring是指Spring生态体系 狭义的Spring框架◇Spring框架是企业开发复杂性的一站式解决方案◇Spring框架的核心是IoC容器与AOP面向切面编程◇Spring IoC负责创建与管理系统对象，并在此基础上扩展功能 广义的Spring生态体系 传统开发方式◇对象直接引用导致对象硬性关联，程序难以扩展维护 Spring IoC容器◇IoC容器是Spring生态的地基,用于统一创建与管理对象依赖 Spring IoC容器职责◇对象的控制权交由第三方统一管理(IoC控制翻转)◇利用Java反射技术实现运行时对象创建与关联(DI依赖注入)◇基于配置提高应用程序的可维护性与扩展性 Spring IoC初体验◇妈妈在早餐后给三个孩子分发餐后水果◇盘子里装有三个苹果: 红富士/青苹果/金帅◇孩子们口味不同: 莉莉喜欢甜的/安迪喜欢酸的/露娜喜欢软的 代码示例传统代码 –实体类 123456789101112131415public class Apple &#123; private String title; private String color; private String origin; ... &#125;public class Child &#123; private String name; private Apple apple; ... public void eat()&#123; System.out.println(name+&quot;吃到了&quot;+apple.getOrigin()+&quot;种植的&quot;+apple.getTitle()); &#125;&#125; –应用入口 12345678910111213public class Application &#123; public static void main(String[] args) &#123; Apple a1 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;); Apple a2 = new Apple(&quot;青苹果&quot;, &quot;绿色&quot;, &quot;中亚&quot;); Apple a3 = new Apple(&quot;金帅&quot;, &quot;黄色&quot;, &quot;中国&quot;); Child lily = new Child(&quot;莉莉&quot;, a1); Child andy = new Child(&quot;安迪&quot;, a2); Child luna = new Child(&quot;露娜&quot;, a3); lily.eat(); andy.eat(); luna.eat(); &#125;&#125; ◇缺点分析：①苹果的描述写死在代码中，若描述改变需要修改源代码；②对象的数量固定的，若要新增对象需要修改源代码，程序的可维护性，可扩展性不足；③对象是硬关联的，每个孩子喜欢的苹果不同则需要修改源码，比较死板； Spring Ioc◇加载配置 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ◇applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--在IoC容器启动时，自动有Spring实例化Apple对象，取名sweetApple放入到容器中--&gt; &lt;bean id=&quot;sweetApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt; &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;sourApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;&gt;&lt;/property&gt; &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;绿色&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;softApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;金帅&quot;&gt;&lt;/property&gt; &lt;property name=&quot;origin&quot; value=&quot;中国&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;黄色&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--孩子 --&gt; &lt;bean id=&quot;lily&quot; class=&quot;com.lcg.spring.ioc.entity.Child&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lily&quot;/&gt; &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;andy&quot; class=&quot;com.lcg.spring.ioc.entity.Child&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;andy&quot;/&gt; &lt;property name=&quot;apple&quot; ref=&quot;sourApple&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;luna&quot; class=&quot;com.lcg.spring.ioc.entity.Child&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;luna&quot;/&gt; &lt;property name=&quot;apple&quot; ref=&quot;softApple&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ◇应用接口 123456789101112131415public class SpringApplication &#123; public static void main(String[] args) &#123; //加载指定的配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class); System.out.println(sweetApple.getTitle()); //从IoC容器中提取beanId=lily的对象 Child lily = context.getBean(&quot;lily&quot;, Child.class); Child andy = context.getBean(&quot;andy&quot;, Child.class); Child luna = context.getBean(&quot;luna&quot;, Child.class); lily.eat(); andy.eat(); luna.eat(); &#125; ◇这样，通过Ioc容器，将程序代码转变为配置文本，维护性更好，让对象与对象之间有效的解耦 XML管理对象(Bean)三种配置方式◇基于XML配置Bean◇基于注解配置Bean◇基于Java代码配置Bean applicationContext.xml12345&lt;bean id=&quot;sweetApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt; &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;&lt;/bean&gt; XML方式创建IoC容器123//创建IoC容器并根据配置文件创建对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); Spring框架组成模块◇四层，核心为第二层 ApplicationContext实现类◇ClassPathXmlApplicationContext◇AnnotationConfigApplicationContext◇WebApplicationContext 实例化Bean的三种方式◇基于构造方法对象实例化◇基于静态工厂实例化◇基于工厂实例方法实例化 一、构造方法实例化对象 123456public Apple(String title,Stirng color,String origin)&#123; System.out.println(&quot;通过带参构造方法创建对象,&quot;+this); this.title=title; this.color=color; this.origin=origin;&#125; **1.利用构造方法参数名实例化 **◇如果对象不止一个构造函数，则按照对应的参数(个数，类型)来进行设置; 123456&lt;bean id=&quot;sweetApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt; &lt;!-- 没有constructor-arg则代表调用默认构造方法实例化 --&gt; &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士&quot;/&gt; &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt; &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;&lt;/bean&gt; 2.利用构造方法参数位置实例化 123456&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt; &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;红色&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; value=&quot;欧洲&quot;/&gt;&lt;/bean&gt; 二、工厂模式实例化对象 ◇创建工厂类。创建静态工厂类AppleStaticFactory,使得创建对象的代码被隐藏，主要目的是在ioc容器之外通过程序的形式组织对象；好处：可以在创建对象的过程中赋予额外的行为(如日志输出等), 123456789101112/** * 静态工厂通过静态方法创建对象，隐藏创建对象的细节 */public class AppleStaticFactory &#123; public static Apple createSweetApple()&#123; Apple apple = new Apple(); apple.setTitle(&quot;红富士&quot;); apple.setOrigin(&quot;欧洲&quot;); apple.setColor(&quot;红色&quot;); return apple; &#125;&#125; ◇在applicationContext.xml中配置 123&lt;!--利用静态工厂获取对象，加上工厂方法--&gt;&lt;bean id=&quot;apple4&quot; class=&quot;com.lcg.spring.ioc.factory.AppleStaticFactory&quot; factory-method=&quot;createSweetApple&quot;/&gt; 三、工厂实例：在ioc容器中对工厂进行实例化 ◇在factory中创建AppleFactoryInstance（苹果工厂实例） 12345678910111213/** * 工厂实例方法创建对象是指Ioc容器对工厂类进行实例化并调用相应的实例方法创建对象的过程 */public class AppleFactoryInstance &#123; public Apple createSweetApple()&#123; Apple apple = new Apple(); apple.setTitle(&quot;红富士&quot;); apple.setOrigin(&quot;欧洲&quot;); apple.setColor(&quot;红色&quot;); return apple; &#125;&#125; ◇在Ioc容器中进行实例化和使用 123&lt;!-- 利用工厂实例方法获取对象--&gt; &lt;bean id=&quot;factoryInstance&quot; class=&quot;com.lcg.spring.ioc.factory.AppleFactoryInstance&quot;/&gt; &lt;bean id=&quot;apple5&quot; factory-bean=&quot;factoryInstance&quot; factory-method=&quot;createSweetApple&quot;/&gt; 从IoC容器获取Bean123456//第一个参数BeanId，第二个Bean的实际类型Apple sweetApple = context.getBean(&quot;sweetApple&quot; , Apple.class);//或者单参数方法，进行强制转换Apple sweetApple = (Apple)context.getBean(&quot;sweetApple&quot;);//打印输出System.out.println(sweetApple.getTitle()); id与name属性相同点◇bean id与bean name都是设置对象在IoC容器中唯一标识◇两者在同一个配置文件中都不允许出现重复◇两者允许在多个配置文件中出现重复,新对象覆盖旧对象 id与name属性区别◇id要求更为严格,一次只能定义一个对象标识(推荐)◇name更为宽松,一次允许定义多个对象标识：name=apple1,apple2，…◇tips: id与name的命名要求有意义,按驼峰命名书写◇当没有id与name的bean默认使用类名全称作为bean标识 路径匹配表达式加载单个配置文件◇路径表达式用于加载配置文件 1234//创建IoC容器并根据配置文件创建对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);//参数即路径表达式 加载多个配置文件12345String[] configLocations = new String[]&#123;&quot;classpath:applicationContext.xml&quot; ,&quot;classpath:applicationContext-1.xml&quot;&#125;;ApplicationContext context = new ClassPathXmlApplicationContext(configLocations); 路径表达式 对象依赖注入◇依赖注入是指运行时将容器内对象利用反射赋给其他对象的操作,即将两个对象关联起来◇基于setter方法注入对象◇基于构造方法注入对象 利用setter实现静态数值注入123456&lt;bean id=&quot;sweetApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt;&lt;!--IoC容器自动利用反射机制运行时调用setXXX方法给属性赋值 --&gt; &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt; &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt; &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;&lt;/bean&gt; 利用setter实现对象注入12345&lt;bean id=&quot;lily&quot; class=&quot;com.lcg.spring.ioc.entity.Child&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt; &lt;!--利用ref注入依赖对象 --&gt; &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;//属性ref代表&quot;关联&quot;&lt;/bean&gt; IoC在实际项目中的应用◇创建两个配置文件applicationContext-dao.xml和applicationContext-service.xml供两名员工开发，前者主要有实习生来实现，因为比较简单，而后者是核心文件，需要有经验的工程师进行开发。◇创建BookDao接口 1234package com.lcg.spring.ioc.bookshop.dao;public interface BookDao &#123; public void insert();&#125; ◇创建BookImpl实现类 123456package com.lcg.spring.ioc.bookshop.dao;public class BookDaoImpl implements BookDao &#123; public void insert()&#123; System.out.println(&quot;向MySQL Book表插入一条数据&quot;); &#125;&#125; ◇创建BookService 12345678910111213141516171819package com.lcg.spring.ioc.bookshop.service;import com.lcg.spring.ioc.bookshop.dao.BookDao;public class BookService &#123; private BookDao bookDao; public void purchase()&#123; System.out.println(&quot;正在执行图书采购业务方法&quot;); bookDao.insert(); &#125; public BookDao getBookDao() &#123; return bookDao; &#125; public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; ◇配置applicationContext-dao.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.lcg.spring.ioc.bookshop.dao.BookDaoImpl&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; ◇配置applicationContext-service.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;bookService&quot; class=&quot;com.lcg.spring.ioc.bookshop.service.BookService&quot;&gt; &lt;!--两个开发人员以这种id=bookDao的约定方式来进行对象的关联 这样能够实现两者开发互不干扰，如果要进行换数据库的话，只需要 更改dao配置文件就行了 --&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 基于构造方法注入对象◇使用Child类的构造方法 1234public Child(String name,Apple apple)&#123; this.name=name; this.apple=apple;&#125; ◇在applicationContext.xml中进行配置 12345678910&lt;bean id=&quot;sourApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;&gt;&lt;/property&gt; &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;绿色&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;andy&quot; class=&quot;com.lcg.spring.ioc.entity.Child&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;安迪&quot;/&gt; //name表示参数，value表示赋值 //利用反射技术将sourApple苹果对象做为参数传入带参构造函数中 &lt;constructor-arg name=&quot;apple&quot; ref=&quot;sourApple&quot;/&gt; //ref用于关联sourApple&lt;/bean&gt; 注入集合对象 ◇注入List 12345678&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;property name=&quot;someList&quot;&gt; &lt;list&gt; &lt;value&gt;具体值&lt;/value&gt; &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; ◇ 注入Set 12345678&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;property name=&quot;someSet&quot;&gt; &lt;set&gt; &lt;value&gt;具体值&lt;/value&gt; &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/propery&gt;&lt;/bean&gt; ◇注入Map 12345678&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;property name=&quot;someMap&quot;&gt; &lt;map&gt;//子标签 &lt;entry key=&quot;k1&quot; value=&quot;v1&quot;&gt;&lt;/entry&gt;//每一个entry就相当于一个键值对 &lt;entry key=&quot;k2&quot; value-ref=&quot;beanId&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; ◇ 注入Properties （属性类型） 12345678&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;property name=&quot;someProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;//key和value必须是字符串 &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 案例-公司资产清单◇创建Computer类（作为公司资产） 1234567891011121314151617181920212223242526272829package com.lcg.spring.ioc.entity;public class Computer &#123; private String brand; private String type; private String sn; private Float price; public Computer() &#123; &#125; public Computer(String brand, String type, String sn, Float price) &#123; this.brand = brand; this.type = type; this.sn = sn; this.price = price; &#125; //...get&amp;set.. //重写toString方便程序演示 @Override public String toString() &#123; return &quot;Computer&#123;&quot; + &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, type=&#x27;&quot; + type + &#x27;\\&#x27;&#x27; + &quot;, sn=&#x27;&quot; + sn + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; ◇创建公司类 123456789101112131415161718192021package com.lcg.spring.ioc.entity;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Company &#123; private Set&lt;String&gt; rooms; private Map&lt;String,Computer&gt; computers; private Properties info; //...get&amp;set.. @Override public String toString() &#123; return &quot;Company&#123;&quot; + &quot;rooms=&quot; + rooms + &quot;, computers=&quot; + computers + &quot;, info=&quot; + info + &#x27;&#125;&#x27;; &#125;&#125; ◇applicationContext配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;c1&quot; class=&quot;com.lcg.spring.ioc.entity.Computer&quot;&gt; &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt; &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt; &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.lcg.spring.ioc.entity.Computer&quot;&gt; &lt;constructor-arg name=&quot;brand&quot; value=&quot;微星&quot;/&gt; &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt; &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389280012&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;3000&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.lcg.spring.ioc.entity.Computer&quot;&gt; &lt;constructor-arg name=&quot;brand&quot; value=&quot;华硕&quot;/&gt; &lt;constructor-arg name=&quot;type&quot; value=&quot;笔记本&quot;/&gt; &lt;constructor-arg name=&quot;sn&quot; value=&quot;9089380012&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;6000&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;company&quot; class=&quot;com.lcg.spring.ioc.entity.Company&quot;&gt; &lt;property name=&quot;rooms&quot;&gt; &lt;set&gt;//set集合不允许出现重复数据，会自动去重 &lt;value&gt;2001-总裁办&lt;/value&gt; &lt;value&gt;2003-总经理办公室&lt;/value&gt; &lt;value&gt;2010-研发部会议室&lt;/value&gt; &lt;value&gt;2010-研发部会议室&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;computers&quot;&gt; &lt;map&gt; &lt;!--方法一、使用value-ref，前提是bean c1已创建--&gt; &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!--方法二、使用内置bean，不用额外创建,但这个bean对象只能用于此处--&gt; &lt;entry key=&quot;dev-88173&quot;&gt; &lt;bean class=&quot;com.lcg.spring.ioc.entity.Computer&quot;&gt; &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt; &lt;constructor-arg name=&quot;type&quot; value=&quot;笔记本&quot;/&gt; &lt;constructor-arg name=&quot;sn&quot; value=&quot;1280258012&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;5060&quot;/&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt;//只允许字符串 &lt;prop key=&quot;phone&quot;&gt;010-12345678&lt;/prop&gt; &lt;prop key=&quot;address&quot;&gt;北京市朝阳区XX路XX大厦&lt;/prop&gt; &lt;prop key=&quot;website&quot;&gt;http://www.xxx.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 查看容器内对象获取对象◇如何查看容器内有多少对象，写在内部使用的bean不会产生beanID，即无法用此方法获取内部的bean 12//获取容器内所有beanId数组String[] beanNames = context.getBeanDefinitionNames(); ◇获取bean的类型、内容 123456for (String beanName:beanNames)&#123; System.out.println(beanName); //获取类型，首先传入参数beanName,返回object对象,再通过getClass得到类对象,然后得到类名 System.out.println(&quot;类型:&quot; + context.getBean(beanName).getClass().getName()); System.out.println(&quot;内容:&quot; + context.getBean(beanName)); &#125; ◇如果没有设置beanID，则默认为类的全名+#+数字序号，若要查看匿名的bean，只输入类的全名只显示第一个匿名的bean，想要具体输出哪一个匿名的bean需要+#+数字序号 1Computer c1 = context.getBean(&quot;com.lcg.spring.ioc.entity.Computer#2&quot;, Computer.class); bean scope属性◇bean scope属性用于决定对象何时被创建与作用范围◇bean scope配置将影响容器内对象的数量◇bean scope默认值singleton(单例),指全局共享同一个对象实例◇默认情况下bean会在IoC容器创建后自动实例化,全局唯一 scope用法123&lt;bean id=&quot;bookDao&quot; class=&quot;com.lcg.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot; scope=&quot;prototype&quot; /&gt; //增加scope bean scope属性清单◇bean scope有六个备选值 singleton单例示意图 singleton的线程安全问题◇用户1设置num=1，然后输出◇用户1设置num=1，过了几毫秒，用户2设置num=2，由于全局只有一个对象，所以num=2，且当用户1的输出时，会输出2 prototype多例示意图◇prototype在容器中多实例,占用更多资源,不存在线程安全问题 singleton与prototype对比 bean scope的实际应用◇对于某一个属性，如果在运行过程中是恒定不变的，就可以设置单例模式。◇创建UserDao 123456package com.lcg.spring.ioc.dao;public class UserDao &#123; public UserDao()&#123; System.out.println(&quot;UserDao已创建:&quot; + this); &#125;&#125; ◇创建UserService 123456789101112131415package com.lcg.spring.ioc.service;import com.lcg.spring.ioc.dao.UserDao;public class UserService &#123; private UserDao userDao; public UserService()&#123; System.out.println(&quot;UserService已创建:&quot; + this); &#125; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; System.out.println(&quot;调用setUserDao:&quot; + userDao); this.userDao = userDao; &#125;&#125; ◇applicationContext.xml配置文件 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.lcg.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.lcg.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ◇主程序入口 12345678910111213141516171819202122package com.lcg.spring.ioc;import com.lcg.spring.ioc.entity.Order;import com.lcg.spring.ioc.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringApplication &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); System.out.println(&quot;======IoC容器已初始化=======&quot;); /* 创建userDao UserDao userDao1 = context.getBean(&quot;userDao&quot;, UserDao.class); UserDao userDao2 = context.getBean(&quot;userDao&quot;, UserDao.class); UserDao userDao3 = context.getBean(&quot;userDao&quot;, UserDao.class);*/ UserService userService1 = context.getBean(&quot;userService&quot;, UserService.class); UserService userService2 = context.getBean(&quot;userService&quot;, UserService.class); UserService userService3 = context.getBean(&quot;userService&quot;, UserService.class); UserService userService4 = context.getBean(&quot;userService&quot;, UserService.class); &#125;&#125; bean的生命周期 细节调整◇prototype时对象创建与init-method延迟至执行业务 代码阶段◇prototype时对象不再受IoC容器管理,不会触发 destroy-method◇延迟加载lazy-init属性可让对象创建与初始化延迟到 执行代码阶段 生命周期在实战中的运用◇创建订单实体类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lcg.spring.ioc.entity;public class Order &#123; private Float price; private Integer quantity; private Float total; public Order()&#123; System.out.println(&quot;创建Order对象,&quot; + this); &#125; public void init()&#123; System.out.println(&quot;执行init()方法&quot;); total = price * quantity;//计算总价 &#125; public void pay()&#123; System.out.println(&quot;订单金额为:&quot; + total); &#125; public Float getPrice() &#123; return price; &#125; public void setPrice(Float price) &#123; System.out.println(&quot;设置price:&quot; + price); this.price = price; &#125; public Integer getQuantity() &#123; return quantity; &#125; public void setQuantity(Integer quantity) &#123; System.out.println(&quot;设置quantity:&quot; + quantity); this.quantity = quantity; &#125; public Float getTotal() &#123; return total; &#125; public void setTotal(Float total) &#123; this.total = total; &#125; public void destroy()&#123; System.out.println(&quot;释放与订单对象相关的资源&quot;); &#125;&#125; ◇配置order 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;order1&quot; class=&quot;com.lcg.spring.ioc.entity.Order&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt; &lt;property name=&quot;quantity&quot; value=&quot;1000&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ◇主程序 123456789101112131415161718package com.lcg.spring.ioc;import com.lcg.spring.ioc.entity.Order;import com.lcg.spring.ioc.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringApplication &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); System.out.println(&quot;======IoC容器已初始化=======&quot;); Order order1 = context.getBean(&quot;order1&quot;, Order.class); order1.pay(); //销毁IoC容器方法 ((ClassPathXmlApplicationContext) context).registerShutdownHook(); &#125;&#125; ◇运行结果 实现极简IoC容器◇创建实体类Apple 123456public class Apple &#123; private String title; private String color; private String origin; ...&#125; ◇创建配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans&gt; &lt;bean id=&quot;sweetApple&quot; class=&quot;com.lcg.spring.ioc.entity.Apple&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt; &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt; &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ◇创建接口 12345package com.lcg.spring.ioc.context;public interface ApplicationContext &#123; public Object getBean(String beanId);&#125; ◇核心配置文件部分代码 1234567891011121314151617181920212223&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- Dom4j是Java的XML解析组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Jaxen是Xpath表达式解释器 --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ◇创建类◇在Ioc容器初始化的过程中，遇到了对象实例化，就去调用Class.forName、newInstance方法来利用反射技术实现对象的创建;如果遇到了property这个标签，则利用Method对象实现方法的调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.lcg.spring.ioc.context;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;import java.io.File;import java.lang.reflect.Method;import java.net.URLDecoder;import java.util.HashMap;import java.util.List;import java.util.Map;public class ClassPathXmlApplicationContext implements ApplicationContext &#123; private Map iocContainer = new HashMap(); public ClassPathXmlApplicationContext()&#123; try&#123; //得到配置文件的地址 String filePath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath(); //使用URL解码 filePath = new URLDecoder().decode(filePath, &quot;UTF-8&quot;); SAXReader reader = new SAXReader(); //读取指定文件,所有的xml文件都会放在document中 Document document = reader.read(new File(filePath)); //按照xml格式依次读取,getRootElement()得到根节点, // selectNodes(&quot;bean&quot;)将所有根节点的bean标签获取 List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;); for(Node node : beans)&#123; Element ele = (Element)node; //读取属性 String id = ele.attributeValue(&quot;id&quot;); String className = ele.attributeValue(&quot;class&quot;); //forName(className)加载指定的类 Class c = Class.forName(className); Object obj = c.newInstance();//通过默认构造方法创建Apple类的实例 List&lt;Node&gt; properties = ele.selectNodes(&quot;property&quot;); //遍历属性 for(Node p : properties)&#123; Element property = (Element) p; //读取name及其对应的值 String propName = property.attributeValue(&quot;name&quot;); String propValue = property.attributeValue(&quot;value&quot;); //组织set方法，substring(1)代表从第二个字符将之后的所有字符串进行截取 String setMethodName = &quot;set&quot; + propName.substring(0,1).toUpperCase()+propName.substring(1); System.out.println(&quot;准备执行&quot; + setMethodName + &quot;方法注入数据&quot;); //通过getMethod方法调用 Method setMethod = c.getMethod(setMethodName, String.class); setMethod.invoke(obj,propValue);//通过setter方法注入数据 &#125; //将id和obj放入容器中，即ioc对刚才创建的对象赋予beanId进行管理 iocContainer.put(id,obj); &#125; System.out.println(iocContainer); System.out.println(&quot;IOC容器初始化完毕&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public Object getBean(String beanId)&#123; return iocContainer.get(beanId); &#125;&#125; ◇入口类 12345678910111213package com.lcg.spring.ioc;import com.lcg.spring.ioc.context.ApplicationContext;import com.lcg.spring.ioc.context.ClassPathXmlApplicationContext;import com.lcg.spring.ioc.entity.Apple;public class Application &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(); Apple apple = (Apple)context.getBean(&quot;sweetApple&quot;); System.out.println(apple); &#125;&#125; 基于注解配置IoC容器基于注解的优势◇摆脱繁琐的XML形式的bean与依赖注入配置◇基于”声明式”的原则,更适合轻量级的现代企业应用◇让代码可读性变得更好,研发人员拥有更好的开发体验 三类注解◇组件类型注解-声明当前类的功能与职责◇自动装配注解-根据属性特征自动注入对象◇元数据注解-更细化的辅助IoC容器管理对象的注解 四种组件类型注解◇语义注解是组件注解的细化 1234@Component 组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化@Controller 语义注解,说明当前类是MVC应用中的控制器类@Service 语义注解,说明当前类是Service业务服务类@Repository 语义注解,说明当前类用于业务持久层,通常描述对应Dao类 开启组件扫描◇regex表示排除扫描，即类名符合com.imooc.exl.*的正则表达式就不会被ioc容器进行实例化 代码示例◇创建applicationContext.xml，和传统的配置不一样,额外的增加了context命名空间 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- component-scan在IoC容器初始化时自动扫描四种组件类型注解并完成实例化 @Repository @Service @Controller @Component --&gt; &lt;context:component-scan base-package=&quot;com.lcg&quot;/&gt;&lt;/beans&gt; ◇剩余代码见项目s07； 两类自动装配注解◇自动装配注解即在ioc容器运行的过程中自动的为某个属性注入数据，推荐按名称装配◇在属性上方进行装配注解和在setXX方法上方进行都可以完成对象的注入，但是在属性上方进行装配Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值，不再执行set方法。如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入◇如果出现两个类(比方说不同的数据库)实现同一个接口,并且两个类都进行了语义注解(dao的注解为@Repository)，则在运行时会报错，因为出现了两个bean对象。在s07项目中Service类中进行了IUserDao的自动注解，但由于两个dao类都实现了IUserDao接口，则不知道选择哪一个。解决方法：①在userDao中去@Repository注解，这样userDao就不会被Ioc容器管理了；②引入额外的注解@Primary，表示如果出现多个bean对象的话，主要采用有此注解的；◇两个不同的Dao 12345678//组件类型注解默认beanId为类名首字母小写//beadId = userDao@Repositorypublic class UserDao implements IUserDao &#123; public UserDao() &#123; System.out.println(&quot;正在创建UserDao:&quot; + this); &#125;&#125; 1234567@Repository@Primarypublic class UserOracleDao implements IUserDao &#123; public UserOracleDao() &#123; System.out.println(&quot;正在创建UserOracleDao:&quot; + this); &#125;&#125; ◇因此，为了避免出现这种情况，一般采用按名称进行注入； 1234567891011121314151617181920212223package com.lcg.spring.ioc.service;import com.lcg.spring.ioc.dao.IUserDao;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class DepartmentService &#123; /** * 1. @Resource设置name属性,则按name在IoC容器中将bean注入 * 2. @Resource未设置name属性 * 2.1 以属性名作为bean name在IoC容器中匹配bean,如有匹配则注入 * 2.2 按属性名未匹配,则按类型进行匹配,同@Autowired,需加入@Primary解决类型冲突 * 使用建议:在使用@Resource对象时推荐设置name或保证属性名与bean名称一致(规范属性名) */// @Resource(name = &quot;userOracleDao&quot;) 设置userOracleDao为name属性// private IUserDao uDao; @Resource private IUserDao userDao; //这里属性名为userDao(规范属性名),以其作为name属性 public void joinDepartment()&#123; System.out.println(userDao); &#125;&#125; 元数据注解◇@Scope(“prototype”)//设置单例/多例,XML中 bean scope完全相同 _◇@PostConstruct //XML中bean init-method完全相同，即初始化方法◇@Value(“${metaData}”)//读取config.properties的metaData属性值_ @Value的读取属性文件◇@value参数书写格式为”${属性名}”◇config.properties应用程序的配置信息，基于字符串的键值对，需要在applicationContext中进行加载，加载语句为： 12&lt;!--通知Spring IoC容器初始化时加载属性文件--&gt;&lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt; ◇config.properties配置信息 123456metaData=lcg.com//数据库的连接属性，通过增加前缀connection来说明，在引用时也得书写完整字符串connection.driver=xxxxx connection.url=xxxconnection.username=xxxconnection.password=xxx ◇xml文件配置维护起来比较方便，但是不便于开发；而注解形式配置开发方便但维护的时候需要修改源代码◇示例代码 12345678910111213141516171819202122232425262728293031323334@Service@Scope(&quot;prototype&quot;)//设置单例/多例,XML中 bean scope完全相同public class UserService &#123; @Value(&quot;$&#123;metaData&#125;&quot;)//读取config.properties的metaData属性值 private String metaData; @Value(&quot;$&#123;connection.password&#125;&quot;) private String password; public UserService() &#123; System.out.println(&quot;正在创建UserService:&quot; + this); &#125; @PostConstruct //XML中bean init-method完全相同 public void init() &#123; System.out.println(&quot;初始化UserService对象,metaData=&quot; + metaData); &#125; //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值 //不再执行set方法 @Autowired private IUserDao udao;//private-&gt;public public IUserDao getUdao() &#123; return udao; &#125; /*@Autowired //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入 public void setUdao(UserDao udao) &#123; System.out.println(&quot;setUdao:&quot; + udao); this.udao = udao; &#125;*/&#125; 基于Java Config配置IoC容器基于Java Config的优势◇完全摆脱XML的束缚,使用独立Java类管理对象与依赖◇注解配置相对分散,利用Java Config可对配置集中管理◇可以在编译时进行依赖检查,不容易出错◇一般用于敏捷开发 Java Config核心注解◇项目演示见s08。◇使用config类代替xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lcg.spring.ioc;import com.lcg.spring.ioc.controller.UserController;import com.lcg.spring.ioc.dao.EmployeeDao;import com.lcg.spring.ioc.dao.UserDao;import com.lcg.spring.ioc.service.UserService;import org.springframework.context.annotation.*;@Configuration //指明当前类是一个配置类,用于替代applicationContext.xml@ComponentScan(basePackages = &quot;com.lcg&quot;)//进行扫描public class Config &#123; @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名 public UserDao userDao()&#123; UserDao userDao = new UserDao(); System.out.println(&quot;已创建&quot; + userDao); return userDao; &#125; @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名 @Primary public UserDao userDao1()&#123; UserDao userDao = new UserDao(); System.out.println(&quot;已创建&quot; + userDao); return userDao; &#125; @Bean //先按name尝试注入,name不存在则按类型注入 public UserService userService(UserDao udao , EmployeeDao employeeDao)&#123; UserService userService = new UserService(); System.out.println(&quot;已创建&quot; + userService); userService.setUserDao(udao); System.out.println(&quot;调用setUserDao:&quot; + udao); userService.setEmployeeDao(employeeDao); return userService; &#125; @Bean //&lt;bean id=&quot;xxx&quot; clas=&quot;xxx&quot;&gt; @Scope(&quot;prototype&quot;) public UserController userController(UserService userService)&#123; UserController userController = new UserController(); System.out.println(&quot;已创建&quot; + userController); userController.setUserService(userService); System.out.println(&quot;调用setUserService:&quot; + userService); return userController; &#125;&#125; ◇Java Config初始化方式 1234567891011public class SpringApplication &#123; public static void main(String[] args) &#123; //基于Java Config配置IoC容器的初始化 ApplicationContext context = new AnnotationConfigApplicationContext(Config.class); System.out.println(&quot;=========================&quot;); String[] ids = context.getBeanDefinitionNames(); for(String id : ids)&#123; System.out.println(id + &quot;:&quot; + context.getBean(id)); &#125; &#125;&#125; Spring单元测试Spring Test 测试模块◇Spring Test是Spring中用于测试的模块◇Spring Test对JUnit单元测试框架有良好的整合◇通过Spring Test可在JUnit在单元测试时自动初始化IoC容器 Spring与JUnit4整合过程◇Maven工程依赖spring-test◇利用@RunWith与@ContextConfiguration描述测试用例类◇测试用例类从容器获取对象完成测试用例的执行 代码演示 ◇核心配置pom.xml 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ◇applicationContext配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.lcg.spring.ioc.dao.UserDao&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ◇dao类(模拟功能) 12345public class UserDao &#123; public void insert()&#123; System.out.println(&quot;新增用户数据&quot;); &#125;&#125; ◇service类 12345678910111213141516public class UserService &#123; private UserDao userDao; public void createUser()&#123; System.out.println(&quot;调用创建用户业务代码&quot;); userDao.insert(); &#125; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; ◇测试用例类 123456789101112131415161718192021import com.lcg.spring.ioc.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;//将Junit4的执行权交由Spring Test模块,在测试用例执行前自动初始化IoC容器@RunWith(SpringJUnit4ClassRunner.class)//RunWith运行器//此注解说明要加载哪个配置文件,locations是一个数组,保存配置文件位置@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class SpringTestor &#123; @Resource private UserService userService;//进行属性的注入 @Test public void testUserService()&#123; userService.createUser();//在测试用例中进行调用 &#125;&#125; 总结与回顾◇Spring快速入门 ◇Spring XML配置◇对象实例化配置 ◇依赖注入配置◇注解与Java Config ◇Spring 单元测试","categories":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"Spring基础","slug":"Spring/Spring基础","permalink":"https://618dt.github.io/categories/Spring/Spring%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/tags/Spring/"}],"author":"LCG"},{"title":"Redis入门","slug":"Redis入门","date":"2022-02-03T00:55:00.000Z","updated":"2022-02-21T14:32:31.238Z","comments":true,"path":"p/d40.html","link":"","permalink":"https://618dt.github.io/p/d40.html","excerpt":"","text":"课程介绍◇Redis介绍与安装◇掌握在Java中操作Redis◇掌握Redis的常用命令与数据类型 Redis介绍◇Redis是Key-Value型NoSQL数据库 ,即每一个数据都有键和值；◇Redis将数据存储在内存中，同时也能持久化到磁盘◇Redis常用于缓存，利用内存的高效提高程序的处理速度 Redis特点◇ 速度快 ◇ 广泛的语言支持◇ 持久化 ◇ 多种数据结构◇ 主从复制 ◇ 分布式与高可用 Redis的安装与启动在Linux系统中安装Redis◇进入redis官网◇创建redis目录，安装gcc用于make编译◇安装命令 1234$ wget https://download.redis.io/releases/redis-5.0.2.tar.gz$ tar xzf redis-5.0.2.tar.gz$ cd redis-5.0.2$ make ◇启动redis: 在src目录中redis-server开启服务器；redis-cli进行客户端连接；◇[root@master redis-5.0.2]# ./src/redis-server redis.conf #启动命令 在Windows系统中安装Redis◇进入github下载◇点击releases，下载zip文件进行解压◇在终端(cmd)进入解压目录中，dir查看文件；◇安装命令：redis-server redis.windows.conf◇由于Windows的版本过旧，仅做学习使用； Redis的常用基本配置◇编辑redis.conf（配置文件）定位到136行，有一个daemonize（是否后台运行，守护进程)，改为yes即可进行守护；这样启动后，不会出现redis的logo并且启动会只要虚拟机运行，则redis一直提供服务；netstat -tulpn#查看系统占用的端口，进而查看redis是否运行；若要关闭redis，可以杀死进程或者利用客户端关闭；◇redis-cli即redis客户端，用来执行redis指令；进入方法：./src/redis-cli 退出命令：exit◇在客户端使用命令:ping 若出现PONG 则说明redis正常运行；关闭redis进程：./src/redis-cli shutdown◇在redis.conf文件可以使用vim命令修改相关配置；◇修改redis端口后需要指定端口进行连接， ./src/redis-cli -p 6380 #指定6380端口进行连接◇redis的数据库名字为数字0~15；如果觉得数据库数量不够用，可以在配置文件中设置，在大概186行出的databases进行修改;◇在配置文件的507行有个#requirepass foobared,说明默认密码是foobared，将注释取消，修改为12345。这样在使用redis时需要使用密码了。在启动后，输入命令：auth 12345即可◇在263行，有dir ./即数据的保存目录；dump.rdb就是redis的全量备份。 Redis通用命令◇示例 123456789./src/redis-cli -p 6379 #连接客户端auth 12345 #输入密码select 0 #选择0号数据库set name lily #在当前数据库中增加一个key=name,value=lily的数据get name #获取数据set name lee #会将前面的数据覆盖掉keys * #查询所有的keydbsize #显示当前数据库的数据总量del name #删除name这个key Redis数据类型◇ String - 字符串类型 ◇ Hash - Hash类型◇ List - 列表类型 ◇ Set - 集合类型◇ Zset - 有序集合类型 String 字符串类型 字符串命令 Hash键值类型◇Hash类型用于存储结构化数据 Hash 命令 List列表类型◇List列表就是一系列字符串的“数组”，按插入顺序排序◇List列表最大长度为2的32次方-1，可以包含40亿个元素 List 命令◇rpush listkey c b a - 右侧插入◇lpush listkey f e d - 左侧插入◇ d e f c b a◇rpop listkey - 右侧弹出◇lpop listkey - 左侧弹出 List 指令◇llen listkey - 获取长度◇lrange listkey 0 2◇lrange listkey 1 -1 获取子集 Set与Zset集合类型◇Set集合是字符串的无序集合，集合成员是唯一的◇Zset集合是字符串的有序集合，集合成员是唯一的 Java客户端-Jedis◇Jedis是Java语言开发的Redis客户端工具包◇Jedis只是对Redis命令的封装,掌握Redis命令便可轻易上手 Jedis使用演示◇编辑配置文件redis.conf，在88行处：protected-mode yes #是否开启保护模式，设置为no关闭，允许其他ip主机连接进来◇在69行处bind 127.0.0.1改为0.0.0.0表示任意ip主机都可以访问进来；◇设置防火墙放行6379端口：firewall-cmd –zone=public –add-port=6379/tcp –permanent; firewall-cmd –reload#重载◇查看redis服务器的IP地址◇Windows上下载jedis◇利用maven进行下载 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 在IDEA中创建maven工程◇JedisTestor 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class JedisTestor &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.132.144&quot; , 6379);//虚拟机IP地址，redis服务器端口号 try &#123; jedis.auth(&quot;12345&quot;);//输入密码 jedis.select(2); System.out.println(&quot;Redis连接成功&quot;); //字符串 jedis.set(&quot;sn&quot; , &quot;7781-9938&quot;); String sn = jedis.get(&quot;sn&quot;); System.out.println(sn); jedis.mset(new String[]&#123;&quot;title&quot; , &quot;婴幼儿奶粉&quot; , &quot;num&quot; , &quot;20&quot;&#125;); List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot; , &quot;title&quot; , &quot;num&quot;&#125;); System.out.println(goods); Long num = jedis.incr(&quot;num&quot;); System.out.println(num); //Hash jedis.hset(&quot;student:3312&quot; , &quot;name&quot; , &quot;张晓明&quot;); String name = jedis.hget(&quot;student:3312&quot; , &quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; studentMap = new HashMap(); studentMap.put(&quot;name&quot;, &quot;李兰&quot;); studentMap.put(&quot;age&quot;, &quot;18&quot;); studentMap.put(&quot;id&quot;, &quot;3313&quot;); jedis.hmset(&quot;student:3313&quot;, studentMap); Map&lt;String,String&gt; smap = jedis.hgetAll(&quot;student:3313&quot;); System.out.println(smap); //List jedis.del(&quot;letter&quot;); //将letter列表删除,否则后面会依次叠加 jedis.rpush(&quot;letter&quot; , new String[]&#123;&quot;d&quot; , &quot;e&quot; , &quot;f&quot;&#125;); jedis.lpush(&quot;letter&quot; , new String[]&#123;&quot;c&quot; , &quot;b&quot; , &quot;a&quot;&#125;); List&lt;String&gt; letter = jedis.lrange(&quot;letter&quot; , 0 , -1); jedis.lpop(&quot;letter&quot;); jedis.rpop(&quot;letter&quot;); letter = jedis.lrange(&quot;letter&quot;, 0, -1); System.out.println(letter); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; jedis.close(); &#125; &#125;&#125; 利用Jedis缓存数据◇创建实体类Good 12345678public class Goods &#123; private Integer goodsId; private String goodsName; private String description; private Float price; ...&#125; ◇创建缓存示例类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CacheSample &#123; public CacheSample()&#123; Jedis jedis = new Jedis(&quot;192.168.132.144&quot;); try &#123; List&lt;Goods&gt; goodsList = new ArrayList&lt;Goods&gt;(); //初始化模拟数据 goodsList.add(new Goods(8818, &quot;红富士苹果&quot;, &quot;&quot;, 3.5f)); goodsList.add(new Goods(8819, &quot;进口脐橙&quot;, &quot;&quot;, 5f)); goodsList.add(new Goods(8820, &quot;进口香蕉&quot;, &quot;&quot;, 25f)); jedis.auth(&quot;12345&quot;); jedis.select(3);//选择redis的三号数据库 //将每一个二进制存储的java对象序列化为json字符串以便redis存储 for (Goods goods : goodsList) &#123; String json = JSON.toJSONString(goods); System.out.println(json); String key = &quot;goods:&quot; + goods.getGoodsId(); jedis.set(key , json); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; jedis.close(); &#125; &#125; public static void main(String[] args) &#123; new CacheSample(); System.out.printf(&quot;请输入要查询的商品编号：&quot;); String goodsId = new Scanner(System.in).next(); Jedis jedis = new Jedis(&quot;192.168.132.144&quot;); try&#123; jedis.auth(&quot;12345&quot;); jedis.select(3); String key = &quot;goods:&quot; + goodsId; if(jedis.exists(key))&#123; String json = jedis.get(key); System.out.println(json); //json字符串转换为java对象 Goods g = JSON.parseObject(json, Goods.class); System.out.println(g.getGoodsName()); System.out.println(g.getPrice()); &#125;else&#123; System.out.println(&quot;您输入的商品编号不存在，请重新输入！&quot;); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; jedis.close(); &#125; &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux与Redis基础","slug":"Java数据库/Linux与Redis基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Linux%E4%B8%8ERedis%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://618dt.github.io/tags/Redis/"}],"author":"LCG"},{"title":"Linux基础和Java环境搭建","slug":"Linux基础和Java环境搭建","date":"2022-02-03T00:53:00.000Z","updated":"2022-02-21T14:32:31.233Z","comments":true,"path":"p/c40f.html","link":"","permalink":"https://618dt.github.io/p/c40f.html","excerpt":"","text":"内容简介◇Linux基础入门◇Linux进阶应用◇Redis应用入门 主要知识点◇介绍Linux与CentOS ◇讲解Linux基础命令◇yum应用安装与卸载 ◇CentOS的权限与系统安全◇Linux文本工具与命令 ◇部署OA项目至Linux服务器 操作系统什么是操作系统◇操作系统(Operating System)是应用程序运行的基础支撑环境◇操作系统作用是管理和控制计算机系统的硬件与软件资源◇Intel x86架构上常见的操作系统:Windows、Linux、Unix… Linux操作系统◇Linux是开源的基于Intel x86架构的类Unix多用户操作系统◇Linux是目前最主要的服务器端操作系统◇互联网大厂都在使用Linux作为服务器主要操作系统 Linux为什么受欢迎◇免费使用，自由传播 ◇支持多任务、多用户、多CPU◇高效而灵活 ◇兼容任意x86架构计算机◇强大易用的系统命令 ◇完整的应用软件生态 Linux发行版本◇Linux系统内核(kernel)提供了Linux操作系统的核心功能◇不同开发商在内核基础上扩展封装,形成了不同发行版本◇常见发行版：Red Hat Linux、CentOS、Ubuntu、SUSE… Linux发行版选择建议◇桌面系统:Ubuntu◇服务器操作系统: CentOS（免费）、Red Hat Linux（收费）◇特定需求: Debian(稳定性)、Fedora(新特性)、麒麟Linux(国产) CentOS - 社区企业操作系统简介◇基于Red Hat Enterprice Linux 的开源企业级Linux发行版本◇各版本CentOS都会获得十年的支持,与RHEL保持同步更新◇CentOS采用社区支持,同时修正了RHEL许多BUG CentOS版本选择◇CentOS 5/6 : 历史版本,已被淘汰◇CentOS 7 : 主流版本,稳定成熟,大多数服务器的首选版本◇CentOS 8 : 全新版本,基于最新内核,不排除存在漏洞隐患 安装CentOS 7.7CentOS 7 运行要求◇CPU : 1核,建议2核以上◇内存 : 1G,建议2G以上◇硬盘 : 预留20G可用空间 开启CPU虚拟化◇Ctrl+Alt+Delete打开任务管理器-&gt;性能-&gt;查看右下角虚拟化是否已启用◇若未启动,则应开启CPU虚拟化，由于电脑型号不同，具体方法可百度 安装VMware Workstation虚拟机◇在VMware中搭建CentOS Linux系统目录Linux倒挂树形目录结构◇”/“是所有目录的顶点,称为”根目录”◇不同目录下的数据可分布在不同磁盘,所有目录按规则组织与命名◇Linux也区分绝对路径与相对路径 常见系统目录 Linux远程管理SSH客户端 ◇SSH是专为远程登录和其他网络服务提供的安全性协议◇SSH分为两个不兼容版本1.x与2.x,默认通过SSH2.x连接◇基于SSH远程连接工具有很多,最常见的是Xshell与SecureCRT Xshell与Xftp◇Xshell是著名的Linux客户端,常用于在Windows下远程访问◇Xshell同时还支持Telent、RLogin、Serial等其他连接方式◇Xftp是Xshell配套组件，用于向服务器上传/下载文件 Xshell与Xftp安装与配置◇在官方网站安装个人版◇在虚拟机终端输入ifconfig查看虚拟机的ip地址◇新建xshell会话，连接后输入用户名和密码即可◇在Xshell顶部绿色的新建文件传输打开，可以进行文件的传输 Linux文件操作命令Linux命令格式◇命令 [参数选项] [文件或路径] Linux文件操作核心命令◇clear 清屏 ◇rmdir 删除空目录◇cd时输入某个路径的前一个字母后可以按Tab进行自动补全◇命令 –help可以查看命令的参数等相关信息◇mv 重命名格式：mv old.c new.c ;移动格式：mv old.c /xx/xx 也可以移动整个文件夹◇不要轻易使用rm -rf，这样会强制迭代删除而不进行询问，rm -r迭代删除进行询问 vim文本编辑器◇vi是Linux重要的文字编辑工具,vim是它的增强版◇vim用于在远程环境下用命令形式对文本进行在线编辑◇用法格式: vim [选项] [文件] vim三种模式◇普通模式:默认模式,文本只读,不可编辑◇编辑模式:编辑文本模式,普通模式按i键进入,Esc键退出◇命令模式:执行保存、搜索、退出等操作 vim重要快捷键 Linux文本工具常用文本工具 文件输入与输出◇文件输入：&lt; (重写) 或者 &lt;&lt; (追加) ◇文件输出：&gt; (重写) 或者 &gt;&gt; (追加)◇echo “xxxx” &gt;&gt; log.txt 将xxxx文本追加写入到log.txt文件中◇合并文件：cat hello.txt myname.txt &gt;&gt; full.txt◇tail full.txt –显示文件尾部内容; tail -n 2 full.txt –显示文件最后两行◇tail -f full.txt –动态监测文件末尾所产生的新行; ctrl+c退出◇grep lcg test.txt –查找test.txt文件中包含lcg字符串的文本行,字符串可以是正则表达式◇grep -v lcg test.txt –查找test.txt文件中不包含lcg字符串的文本行◇ll | grep -E “log[0-9]{1,5}.txt” –进行文件的筛选，查看所有日志文件 -E表示使用扩展正则表达式；{1,5}表示数字位数为1~5； 文件打包与压缩Linux压缩程序-gzip◇gzip是Linux系统的文件压缩程序◇gzip压缩包文件扩展名.gz◇大流量的网站默认都在使用gzip进行数据压缩传输 tar打包与压缩◇tar是Linux系统将多个文件打包和压缩的工具◇tar本质是打包软件，扩展名.tar◇tar可结合gzip或其他压缩工具实现打包压缩，扩展名.tar.gz◇压缩命令: tar zcvf tomcat.tar.gz /usr/local/tomcat◇解压缩命令: tar zxvf tomcat.tar.gz -C /usr/local/tomcat tar常用可选项 安装与卸载应用程序为CentOS安装应用程序◇在CentOS中安装第三方应用程序包含两种方式:◇rpm:Red Hat软件包管理器,相当于应用程序安装文件的执行者◇编译安装:用户自己从网站下载程序源码进行编译安装 yum与rpm的关系◇rpm安装过程中,需要用户自己解决依赖问题◇yum通过引入软件仓库,联网下载rpm包及依赖,并依次自动安装◇yum是rpm的前端程序,其目的就是简化rpm的安装过程 yum常用命令◇yum search 应用名 #在仓库中查询是否存在指定应用◇yum install -y 应用名 #全自动下载安装应用及其依赖◇yum info 应用名 #查看软件详细信息◇yum list installed 应用名 #查看已安装的应用程序◇rpm -ql 应用名 #查看安装后输出的文件清单◇yum remove -y 应用名 #全自动卸载指定应用 ，-y表示遇到询问都用y 编译方式安装编译方式安装应用程序◇如yum仓库未提供rpm,往往需要采用编译安装方式◇编译安装是指从应用官网下载源码后,对源码进行编译后使用◇编译命令: make #使用对应编译器对源码编译生成可执行文件 yum与编译安装比较 编译安装Redis◇利用xftp将下载好的压缩包文件上传到linux；然后解压；进入redis-4.0.14目录；安装gcc编译器：yum install -y gcc;◇有时候第一次make编译出错后，可能改变了原来的文件结构，因此纠正错误后下一次编译时需要将解压后的目录删除重新解压；当出现Hint: It’s a good idea to run ‘make test’ ;)时代表编译成功；◇编译安装后的应用程序redis-server存放在src中，在启动redis-server前需要加载上一级目录下的redis.conf配置文件;即启动命令为:./src/redis-server redis.conf 启动后ctrl+c退回命令状态 Linux进阶应用Linux系统管理命令◇使用ifconfig查看网卡ip◇netstat 查看网络端口号：netstat -tulpn 或 netstat -ano◇Recv-Q:接收队列；Send-Q:发送队列; LISTEN表示网络状态正在被监听;PID:进程编号；Program name创建网络连接的应用◇netstat 常用选项◇查看进程: ps -ef ，箭头处5412指PID；杀掉进程：kill -9 PID◇一般使用应用程序退出来关闭进程，而不是强制杀掉进程，因为可能造成数据丢失◇ps -ef | grep vim ; | 表示通道，即ps -ef查询产生的数据像通过通道一样送入到后一个指令 应用服务化简介◇ 应用服务化是指让应用程序以服务方式在系统后台运行◇ Linux系统对服务化应用进行统一管理◇ 服务管理命令：systemctl systemctl◇.pid文件用来保存进程编号◇将redis服务化，需要在/usr/lib/systemd/system目录下创建 vim redis.service；在文件中写入配置： 123456789101112131415[Unit]Description=RedisAfter=syslog.target network.target remote-fs.target nss-lookup.target #表示在这些服务启动以后才能启动redis[Service]Type=forking #forking代表后台运行PIDFile=/run/redis_6379.pid#说明启动时执行server，加载配置文件ExecStart=/home/lcg/0/redis-4.0.14/src/redis-server /home/lcg/0/redis-4.0.14/redis.conf#关闭,-s采用正常流程进行退出；-9表示强制退出ExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=True #为每一个服务设置私有的Tmp临时文件目录[Install]WantedBy=multi-user.target #将当前的redis服务分配到multi-user服务组上； ◇systemctl daemon-reload #对所有service进行重载;◇systemctl start redis #启动服务； systemctl status redis #查看状态 Linux用户与权限用户◇ Linux是多用户多任务系统,包含两个概念:用户与用户组◇ 用户与账户是同一概念,用于登录系统与区分资源权限◇ 用户让系统变的更安全,同时也保护了用户的个人数字资产 用户组◇ 用户组就是将用户分组,隶属用户自动拥有组权限◇ 一个用户可隶属于多个组,用户可任意切换当前组◇ 用户组的出现让用户权限管理变更轻松 用户与用户组常用命令◇分组：usermod -g [组名] [用户名]◇让用户拥有多个组： usermod -G [组名1],[组名2] [用户名];通过newgrp进行切换◇将用户连接系统: 打开-&gt;创建系统副本：然后用新建的用户密码登录◇groups #查看用户隶属于哪个组◇chown用法：chown [用户名]:[组名] [文件名] 项目内部文件权限管理实践文件权限代码表◇每个颜色表示一组，共三组；eg:drwxr-xr-x; 其中-代表没有对应属性，此处即没有w(完整的一组是rwx)◇在目录上r-x不允许写是指不准修改目录名 chmod命令◇ chmod 750: 组用户可读写，其他用户不允许访问◇ chmod 777: 所有用户拥有完整权限◇ chmod 700: 只有属主拥有完整权限◇chmod 750 dev-document/(文件名/) #示例操作， sudo超级管理员命令◇ sudo可以让普通用户拥有超级管理员的执行权限◇ 普通用户要进行经过超级管理员授权才能使用◇ 授权命令：visudo◇普通模式下输入：100gg 快速定位到100行,无法再屏幕上看到命令；在此处的root ALL-(ALL) ALL下增加一行：[用户名] ALL-(ALL) ALL 即可授权用户拥有sudo命令；第一个ALL代表用户可以从任意计算机进行连接；第二个ALL表示切换用户，最后一个ALL代表运行执行所有命令；◇:wq保存文件后，使用命令visudo -c进行文件的格式检查; CentOS7防火墙firewall什么是防火墙◇ 防火墙是借助硬件和软件对内外部网络环境的保护措施◇ CentOS 7基于firewall实现应用层防火墙,CentOS6基于iptables◇ firewall-cmd是firewall的核心命令 firwall-cmd◇ systemctl start|restart firewalld #启动防火墙◇ firewall-cmd –state | –reload #查看状态,重载防火墙◇ firewall-cmd –zone=public –permanent –add-port=8502/tcp 对外开放Tomcat◇解压apache-tomcat-9.0.34.tar.gz；进入apache-tomcat-9.0.34/bin目录启动startup.sh文件：./startup.sh◇增加放行端口：firewall-cmd –zone=public –permanent –add-port=8080/tcp #zone代表区域；permanent表示永久更改；将add改成remove即可去除端口;8000-9000可以用来进行端口范围的设置◇将防火墙进行重载 Bash Shell什么是Shellu Shell是一个用c语言编写的脚本解释器,是用户通过代码操作 Linux的桥梁u Shell脚本描述要执行的任务,完成系列复杂操作,文件通常以.sh后缀u Shell脚本通过Shell解释器执行,按解释器分类分为多种类型 Linux Shell 分类 一键发布Tomcat应用程序◇vim deploy_tomcat.sh创建脚本 12345678910echo &quot;准备下载Tomcat9&quot;wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.52/bin/apache-tomcat-9.0.52.tar.gzecho &quot;正在解压Tomcat9&quot;tar zxf apache-tomcat-9.0.52.tar.gzecho &quot;防火墙开放8080端口&quot;firewall-cmd --zone=public --permanent --add-port=8080/tcpfirewall-cmd --reloadecho &quot;启动Tomact&quot;cd ./apache-tomcat-9.0.52/bin./startup.sh ◇启动脚本文件：/bin/bash deploy_tomcat.sh;或./deploy.tomcat.sh 部署OA项目部署架构◇创建两个虚拟机CentosDB,CentosWEB，均最小化安装(不要图形界面);然后在界面输入: yum install -y net-tools.x86_64 #安装ifconfig等命令;◇使用Xshell进行远程连接； Centos安装MySQL8◇yum search mysql-community #查看是否安装了mysql社区版◇mkdir mysql #在/usr/local目录下新建目录存放mysql◇wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm #获取下载◇yum install -y wget #安装wget 命令◇yum localinstall -y mysql80-community-release-el7-3.noarch.rpm #从本地安装rpm文件◇以上只是安装了mysql的安装源，还没有完成mysql的安装；◇yum install -y mysql-community-server #进行安装 ctrl+c可以停止安装◇cd /var/cache/yum/x86_64/7/mysql80-community/packages/ #进入yum下载的缓存路径◇进入官网找到Mysql Red Hat Enterprise Linux/ Oracle Linux；选择系统版本Linux 7 X86_64； 下载RPM Bundle；然后将这一组rpm文件传到缓存路径中；此时重新执行yum install -y mysql-community-server命令；以此可解决跨国服务器下载缓慢问题；◇systemctl start mysqld #启动服务 systemctl status mysqld #查看服务状态◇systemctl enable mysqld #设置为开机启动 初始化MySQL8◇vi /var/log/mysqld.log #进入mysql日志 在第3~4行可以看到自动生成的密码◇mysql -uroot -p #输入密码进行登录◇alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘newpassword’(需要包含字母大小写以及数字，特殊符号，长度大于8位) 回车加上’;’ 即可修改，with mysql_native_password做与navicat的兼容考虑；◇默认的root用户只能从本机登录；use mysql #使用数据库； select host,user from user;#查询主机和用户◇update user set host=’%’ where user=’root’;#将root用户的host改为%,即任意设备都可以使用root用户连接mysql服务器; flush privileges #使刚才修改的权限立即生效◇exit #退出mysql◇放行3306端口并重载，使之能够远程访问mysql；◇打开Navicat，新建连接：主机即虚拟机的IP地址； 部署配置Web应用服务◇yum search jdk #查看仓库中包含哪些版本的jdk;openjdk表示开源jdk◇yum install -y java-1.8.0-openjdk #安装jdk◇java -version #查看◇安装Tomcat;◇将oa项目的war包传到虚拟机中，解压；◇将解压后的oa目录移动：mv lcg_oa ./apache-tomcat-9.0.34/webapps/◇进入webapps目录，vim ./lcg_oa/WEB-INF/classes/mybatis-config.xml(yum install vim-common#安装vim基础包，yum install vim-enhanced#安装增强包)◇/root全文查找，在连接字符串的地方进行调整；将localhost改为mysql服务器的IP地址，密码改为相应的密码◇回到上一层目录进行Tomcat的配置: vim ./conf/server.xml -&gt;搜索/8080-&gt;将端口改为80-&gt;按pagedown跳到最后-&gt;在Host标签上增加#将oa这个web应用映射的上下文路径指向根路径-&gt;:wq保存◇启动tomcat：./bin/startup.sh◇放行80端口，并重载◇在虚拟机DB中，屏蔽掉任意主机都能访问的3306端口；重载；◇firewall-cmd –permanent –zone=public –add-rich-rule=”rule family=”ipv4” source address=”web服务器的IP地址” port protocol=”tcp” port=”3306” accept” #-rich-rule利用规则放行端口，这样就能放行指定主机指定端口的访问;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux与Redis基础","slug":"Java数据库/Linux与Redis基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Linux%E4%B8%8ERedis%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://618dt.github.io/tags/Linux/"}],"author":"LCG"},{"title":"项目完整实现","slug":"项目实现","date":"2022-02-03T00:46:00.000Z","updated":"2022-02-21T14:32:31.244Z","comments":true,"path":"p/d371.html","link":"","permalink":"https://618dt.github.io/p/d371.html","excerpt":"","text":"动态显示功能菜单第一部分：实现底层◇sql语句 123456789101112-- 如何获取编号为 1的用户拥有哪些功能？SELECT DISTINCT n.* FROM sys_role_user ru, sys_role_node rn, sys_node n WHERE ru.role_id = rn.role_id AND rn.node_id = n.node_id AND user_id = 1 ORDER BY n.node_code ◇创建与数据库对应的Node节点类 123456789public class Node &#123; private Long nodeId; private Integer nodeType; private String nodeName; private String url; private Integer nodeCode; private Long parentId; ... &#125; ◇创建rbac.xml 1234567891011&lt;mapper namespace=&quot;rbacmapper&quot;&gt; &lt;!--获取用户编号对应的功能列表--&gt; &lt;select id=&quot;selectNodeByUserId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Node&quot;&gt; select distinct n.* from sys_role_user ru , sys_role_node rn , sys_node n where ru.role_id = rn.role_id and user_id = #&#123;value&#125; and rn.node_id = n.node_id order by n.node_code &lt;/select&gt;&lt;/mapper&gt; ◇创建dao对sql语句进行调用 1234567public class RbacDao &#123; public List&lt;Node&gt; selectNodeByUserId(Long userId) &#123; return (List)MybatisUtils.executeQuery( sqlSession -&gt; sqlSession.selectList( &quot;rbacmapper.selectNodeByUserId&quot;, userId)); &#125;&#125; ◇在UserService中进行dao的调用 12345private RbacDao rbacDao = new RbacDao();public List&lt;Node&gt; selectNodeByUserId(Long userId) &#123; List&lt;Node&gt; nodeList = rbacDao.selectNodeByUserId(userId); return nodeList; &#125; ◇进行测试 12345@Test public void selectNodeByUserId()&#123; List&lt;Node&gt; nodeList = userService.selectNodeByUserId(2l);//l表示长整型 System.out.println(nodeList); &#125; 第二部分：实现跳转◇更改LonginServlet增加返回项 1result.put(&quot;redirect_url&quot;, &quot;/index&quot;); ◇更改login.html用于接收新加的返回项 12//跳转urlwindow.location.href=json.redirect_url; ◇创建IndexServlet,并将index.html改为index.ftl 123456789101112131415@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)public class IndexServlet extends HttpServlet &#123; private UserService userService = new UserService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); User user = (User)session.getAttribute(&quot;login_user&quot;); List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId()); request.setAttribute(&quot;node_list&quot;,nodeList); request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request,response); &#125;&#125; ◇如何把在登录页面login的用户登录信息保存，并用于后面的功能区分？方法是使用范围更广的session对象即在LonginServlet中进行如下更改： 12345//调用业务逻辑User user = userService.checkLogin(username, password);HttpSession session = request.getSession();//向session存入登录用户信息,属性名:login_usersession.setAttribute(&quot;login_user&quot; , user); ◇修改index.ftl实现动态显示功能 123456789101112131415161718&lt;!--可折叠导航栏--&gt; &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt; &lt;#list node_list as node&gt; &lt;#if node.nodeType == 1&gt; &lt;!--父节点 模块 自定义属性：data-node-id--&gt; &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt; &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt; &lt;/li&gt; &lt;/#if&gt; &lt;#if node.nodeType == 2&gt; &lt;!--子节点 功能 自定义属性：data-parent-id--&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt; &lt;/dd&gt; &lt;/#if&gt; &lt;/#list&gt; &lt;/ul&gt; Xml配置下实现Mapper接口◇创建员工实体类 1234567public class Employee &#123; private Long employeeId; private String name; private Long departmentId; private String title; private Integer level;&#125; ◇创建dao接口 123public interface EmployeeDao &#123; public Employee selectById(Long employeeId);&#125; ◇创建mapper与接口对应 123456789... &lt;!--namespace与包名要一致--&gt;&lt;mapper namespace=&quot;com.lcg.oa.dao.EmployeeDao&quot;&gt; &lt;!--id与方法名对应 parameterType与方法参数类型一致 resultType与方法返回类型一致--&gt; &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Employee&quot;&gt; select * from adm_employee where employee_id = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; ◇创建员工service (getMapper的原理) 12345678910111213141516public class EmployeeService &#123; /** * 按编号查找员工 * @param employeeId 员工编号 * @return 员工对象，不存在时返回null */ public Employee selectById(Long employeeId) &#123; return (Employee) MybatisUtils.executeQuery(sqlSession-&gt;&#123; //匹配相关的Mapper,sql语句原理可网上搜getMapper //这里传入一个类对象后,就会得到一个可用的Dao接口 EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class); return employeeDao.selectById(employeeId); &#125;); &#125;&#125; ◇修改indexservlet 123456789101112131415161718192021222324@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)public class IndexServlet extends HttpServlet &#123; private UserService userService = new UserService(); private EmployeeService employeeService = new EmployeeService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); //得到当前登录用户对象 User user = (User)session.getAttribute(&quot;login_user&quot;); Employee employee = employeeService.selectById(user.getEmployeeId()); //获取登录用户可用功能模块列表 List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId()); //放入请求属性 request.setAttribute(&quot;node_list&quot;,nodeList); //放入session，范围更大,生命周期更长 session.setAttribute(&quot;current_employee&quot;,employee); //请求发至ftl进行展现 request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request,response); &#125;&#125; ◇修改首页 12&lt;!--用户信息--&gt;$&#123;current_employee.name&#125;[部门-$&#123;current_employee.title&#125;] ◇要想获取到部门，由于涉及到另外一张表，则按上面流程开发即可 基于MD5算法对密码进行加密MD5摘要算法◇MD5信息摘要算法广泛使用的密码散列函数◇MD5可以产生出一个128位的散列值用于唯一标识源数据◇项目中通常使用MD5作为敏感数据的加密算法 MD5特点◇压缩性,MD5生成的摘要长度固定◇抗修改,源数据哪怕有一个字节变化,MD5也会有巨大差异◇不可逆,无法通过MD5反向推算源数据 Apache Commons Codec◇Commons-Codec是Apache提供的编码/解码组件◇通过Commons-Codec可轻易生成源数据的MD5摘要◇MD5摘要方法: String md5 = DigestUtils.md5Hex(源数据)◇增加依赖并放入发布的工程中 使用方法◇增加依赖并放入发布的工程中 12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.14&lt;/version&gt;&lt;/dependency&gt; ◇新增工具类 12345public class MD5Utils &#123; public static String md5Digest(String source) &#123; return DigestUtils.md5Hex(source); &#125;&#125; ◇进行测试 1234@Testpublic void md5Digest() &#123; System.out.println(MD5Utils.md5Digest(&quot;test&quot;));&#125; 敏感数据”加盐”混淆◇防止MD5被通过穷举法解密◇加盐方法 123456789101112131415/** * 对源数据加盐混淆后生成MD5摘要 * @param source 源数据 * @param salt 盐值 * @return MD5摘要 */public static String md5Digest(String source, Integer salt) &#123; char[] ca = source.toCharArray();//字符数组 for (int i = 0; i &lt; ca.length; i++) &#123; ca[i] = (char)(ca[i] + salt); &#125; String target = new String(ca); String md5 = DigestUtils.md5Hex(target); return md5;&#125; ◇修改数据库sys_user表，添加salt字段,并将密码替换为加密后的MD5◇修改UserServlet 12345//对前台输入的密码加盐混淆后生成MD5，与保存在数据库中的MD5密码进行比对 String md5 = MD5Utils.md5Digest(password, user.getSalt()); if (!md5.equals(user.getPassword())) &#123; throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;); &#125; 实现注销功能◇即将保存在session中的用户登录信息清空◇创建servlet 1234567891011@WebServlet(name = &quot;LogoutServlet&quot;,urlPatterns = &quot;/logout&quot;)public class LogoutServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getSession().invalidate();//将当前会话清空 response.sendRedirect(&quot;/login.html&quot;); &#125;&#125; ◇修改index.ftl的注销按钮 12&lt;!--注销按钮--&gt; &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt; 开发多级审批流程请假流程 工作流程表设计 设计约束◇每一个请假单对应一个审批流程◇请假单创建后,按业务规则生成部门经理、总经理审批任务◇审批任务的经办人只能审批自己辖区内的请假申请◇所有审批任务”通过”,代表请假已经批准◇任意审批任务”驳回”操作,其余审批任务取消,请假申请被驳回◇请假流程中任意节点产生的操作都要生成对应的系统通知 新建数据库表◇请假单表◇处理流程表◇通知表 实现Dao与数据交互创建表的实体类◇LeaveForm.class◇ProcessFlow.class◇Notice.class 创建Dao接口◇LeaveFormDao 123456789public interface LeaveFormDao &#123; public void insert(LeaveForm form); public List&lt;Map&gt; selectByParams(@Param(&quot;pf_state&quot;) String pfState, @Param(&quot;pf_operator_id&quot;) Long operatorId); public LeaveForm selectById(Long formId); public void update(LeaveForm form);&#125; ◇ProcessFlowDao 1234567public interface ProcessFlowDao &#123; public void insert(ProcessFlow processFlow); public void update(ProcessFlow processFlow); public List&lt;ProcessFlow&gt; selectByFormId(Long formId);&#125; ◇NoticeDao 12345public interface NoticeDao &#123; public void insert(Notice notice); public List&lt;Notice&gt; selectByReceiverId(Long receiverId);&#125; 创建对应的mapper◇leave_form.xml 12345678&lt;mapper namespace=&quot;com.lcg.oa.dao.LeaveFormDao&quot;&gt; &lt;!--useGeneratedKeys是否使用自增主键；keyProperty实体中的主键；keyColumn数据库表中的主键--&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.oa.entity.LeaveForm&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;formId&quot; keyColumn=&quot;from_id&quot;&gt; INSERT INTO adm_leave_form( employee_id, form_type, start_time, end_time, reason, create_time, state) VALUES ( #&#123;employeeId&#125;, #&#123;formType&#125;, #&#123;startTime&#125;, #&#123;endTime&#125;, #&#123;reason&#125;, #&#123;createTime&#125;, #&#123;state&#125;) &lt;/insert&gt;&lt;/mapper&gt; ◇process_flow.xml 12345678910111213141516&lt;mapper namespace=&quot;com.lcg.oa.dao.ProcessFlowDao&quot;&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.oa.entity.ProcessFlow&quot; useGeneratedKeys=&quot;true&quot; keyColumn=&quot;process_id&quot; keyProperty=&quot;processId&quot;&gt; INSERT INTO adm_process_flow(form_id, operator_id, action, result, reason, create_time , audit_time , order_no , state,is_last) VALUES (#&#123;formId&#125;, #&#123;operatorId&#125;, #&#123;action&#125;, #&#123;result&#125;, #&#123;reason&#125;, #&#123;createTime&#125; , #&#123;auditTime&#125; , #&#123;orderNo&#125; , #&#123;state&#125; , #&#123;isLast&#125;); &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; UPDATE adm_process_flow SET form_id = #&#123;formId&#125;, operator_id = #&#123;operatorId&#125;, action = #&#123;action&#125;, result = #&#123;result&#125;, reason = #&#123;reason&#125;, create_time = #&#123;createTime&#125;, audit_time = #&#123;auditTime&#125;, order_no = #&#123;orderNo&#125;, state = #&#123;state&#125;, is_last = #&#123;isLast&#125; WHERE process_id = #&#123;processId&#125; &lt;/update&gt; &lt;select id=&quot;selectByFormId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; select * from adm_process_flow where form_id = #&#123;value&#125; order by order_no &lt;/select&gt;&lt;/mapper&gt; ◇notice.xml 12345678910&lt;mapper namespace=&quot;com.lcg.oa.dao.NoticeDao&quot;&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.oa.entity.Notice&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;noticeId&quot; keyColumn=&quot;notice_id&quot;&gt; INSERT INTO sys_notice( receiver_id, content, create_time) VALUES (#&#123;receiverId&#125;, #&#123;content&#125;, #&#123;createTime&#125;) &lt;/insert&gt; &lt;select id=&quot;selectByReceiverId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Notice&quot;&gt; select * from sys_notice where receiver_id = #&#123;value&#125; order by create_time desc limit 0,100 &lt;/select&gt;&lt;/mapper&gt; 开发请假申请功能前期准备◇EmployeeDao增加代码 123456/** * 根据传入员工对象获取上级主管对象 * @param employee 员工对象 * @return 上级主管对象 */ public Employee selectLeader(@Param(&quot;emp&quot;) Employee employee); ◇在employee.xml中增加对应的sql语句 12345678910111213&lt;select id=&quot;selectLeader&quot; parameterType=&quot;com.lcg.oa.entity.Employee&quot; resultType=&quot;com.lcg.oa.entity.Employee&quot;&gt; select * from adm_employee where &lt;if test=&quot;emp.level&amp;lt;7&quot;&gt; &lt;!--&#x27;&lt;&#x27;的转义--&gt; level = 7 and department_id = #&#123;emp.departmentId&#125; &lt;/if&gt; &lt;if test=&quot;emp.level == 7&quot;&gt; level = 8 &lt;/if&gt; &lt;if test=&quot;emp.level == 8&quot;&gt; employee_id = #&#123;emp.employeeId&#125; &lt;/if&gt; &lt;/select&gt; ◇新增业务常量，用来保存指定时间之类的数据 123public class BussinessConstants &#123; public static final int MANAGER_AUDIT_HOURS=36;//总经理请假审批时间阈值&#125; 创建service◇请假单流程服务LeaveFormService 12345678910111213141516public class LeaveFormService &#123; /** * 创建请假单 * * @param form 前端输入的请假单数据 * @return 持久化后的请假单对象 */ public LeaveForm createLeaveForm(LeaveForm form) &#123; //1.持久化form表单数据,8级以下员工表单状态为processing,8级(总经理)状态为approved //2.增加第一条流程数据,说明表单已提交,状态为complete //3.分情况创建其余流程数据 //3.1 7级以下员工,生成部门经理审批任务,请假时间大于72小时,还需生成总经理审批任务 //3.2 7级员工,生成总经理审批任务 //3.3 8级员工,生成总经理审批任务,系统自动通过 &#125;&#125; 创建控制器◇LeaveFormServlet 123456789101112131415161718192021222324252627@WebServlet(name = &quot;LeaveFormServlet&quot;,urlPatterns = &quot;/leave/*&quot;)public class LeaveFormServlet extends HttpServlet &#123; private LeaveFormService leaveFormService = new LeaveFormService(); private Logger logger = LoggerFactory.getLogger(LeaveFormServlet.class); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125; /** * 创建请假单 * @param request * @param response * @throws ServletException * @throws IOException */ private void create(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收各项请假单数据 ... //2. 调用业务逻辑方法 ... //3. 组织响应数据 ... &#125;&#125; 实现请假申请功能 ◇表单html文件部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; var layDate = layui.laydate; //Layui日期选择框JS对象 var layForm = layui.form; //layui表单对象 var $ = layui.$; //jQuery对象 //日期时间范围 layDate.render(&#123; elem: &#x27;#daterange&#x27; //表示将id为daterange的文本框渲染成日期选择框 ,type: &#x27;datetime&#x27; //日期+时间 ,range: true ,format: &#x27;yyyy年M月d日H时&#x27; ,done: function(value, start, end)&#123;//自动触发事件 //选择日期后出发的时间,设置startTime与endTime隐藏域,按照服务器要求的格式 var startTime = start.year + &quot;-&quot; + start.month + &quot;-&quot; + start.date + &quot;-&quot; + start.hours; var endTime = end.year + &quot;-&quot; + end.month + &quot;-&quot; + end.date + &quot;-&quot; + end.hours; console.info(&quot;请假开始时间&quot;,startTime); $(&quot;#startTime&quot;).val(startTime); console.info(&quot;请假结束时间&quot;,endTime); $(&quot;#endTime&quot;).val(endTime); &#125; &#125;); //表单提交时间,data.field由Layui提供可以获取表单所有数据，并封装成键值对 layForm.on(&#x27;submit(sub)&#x27;, function(data)&#123; console.info(&quot;向服务器提交的表单数据&quot;,data.field); $.post(&quot;/leave/create&quot;,data.field,function (json) &#123; console.info(json); if(json.code == &quot;0&quot;)&#123; /*SweetAlert2确定对话框*/ swal(&#123; type: &#x27;success&#x27;, html: &quot;&lt;h2&gt;请假单已提交,等待上级审批&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;).then(function (result) &#123;//点击确定后的触发事件 window.location.href=&quot;/forward/notice&quot;;//跳转到指定路径 &#125;); &#125;else&#123; swal(&#123; type: &#x27;warning&#x27;, html: &quot;&lt;h2&gt;&quot; + json.message + &quot;&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;); &#125; &#125;,&quot;json&quot;); return false; &#125;);&lt;/script&gt; ◇sweetalert官网,用来美化对话框◇新增控制器ForwardServlet，通用的页面跳转的servlet，可以支持跳转多个页面 123456789101112131415@WebServlet(name = &quot;ForwardServlet&quot;,urlPatterns = &quot;/forward/*&quot;)public class ForwardServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String uri = request.getRequestURI(); /** * /forward/form * /forward/a/b/c/form */ String subUri = uri.substring(1);// forward/form; forward/a/b/c/form String page = subUri.substring(subUri.indexOf(&quot;/&quot;));// /form; /a/b/c/form request.getRequestDispatcher(page+&quot;.ftl&quot;).forward(request,response); &#125;&#125; ◇将数据库node表的url填上◇修改index.ftl,将href改为${node.url} 1&lt;a href=&quot;$&#123;node.url&#125;&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt; 请假审批功能新增sql语句◇在leave_form.xml中新增查询，多个参数（工作流程任务状态；经办人）查询请假单，由于查询的字段来自不同的表，所以返回类型也是map而非某个实体类 12345678910&lt;select id=&quot;selectByParams&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;java.util.Map&quot;&gt; select f.* ,e.name , d.* from adm_leave_form f,adm_process_flow pf , adm_employee e , adm_department d where f.form_id = pf.form_id and f.employee_id = e.employee_id and e.department_id = d.department_id and pf.state = #&#123;pf_state&#125; and pf.operator_id = #&#123;pf_operator_id&#125;&lt;/select&gt; ◇在Dao中增加相应的接口对应 123//多个参数采用注解形式说明其在xml中的参数类型,名称须一致public List&lt;Map&gt; selectByParams(@Param(&quot;pf_state&quot;) String pfState, @Param(&quot;pf_operator_id&quot;) Long operatorId); 修改Service◇在LeaveFormService中新增方法用来获取请假单 12345678910111213/** * 获取指定任务状态及指定经办人对应的请假单列表 * @param pfState ProcessFlow任务状态 * @param operatorId 经办人编号 * @return 请假单及相关数据列表 */ public List&lt;Map&gt; getLeaveFormList(String pfState, Long operatorId) &#123; return (List&lt;Map&gt;) MybatisUtils.executeQuery(sqlSession-&gt;&#123; LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class); List&lt;Map&gt; formList = dao.selectByParams(pfState, operatorId); return formList; &#125;); &#125; ◇在Servlet中对service进行调用 12345678910111213141516171819202122232425if (methodName.equals(&quot;create&quot;)) &#123; this.create(request,response); &#125; else if (methodName.equals(&quot;list&quot;)) &#123; this.getLeaveFormList(request, response); &#125; /** * 查询需要审核的请假单列表 * @param request * @param response * @throws ServletException * @throws IOException */ private void getLeaveFormList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; User user = (User) request.getSession().getAttribute(&quot;login_user&quot;); List&lt;Map&gt; formList = leaveFormService.getLeaveFormList(&quot;process&quot;, user.getEmployeeId()); Map result = new HashMap(); //4个属性满足layUI数据表格的要求 result.put(&quot;code&quot;, &quot;0&quot;);//表示服务器端处理成功 result.put(&quot;msg&quot;, &quot;&quot;);//服务器返回的具体文本消息 result.put(&quot;count&quot;, formList.size());//所有数据的总数 result.put(&quot;data&quot;, formList);//显示的对象列表 String json = JSON.toJSONString(result); response.getWriter().println(json); &#125; 新增ftl文件用来审批◇部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;script&gt; var $ = layui.$; //将毫秒数转换为&quot;yyyy-MM-dd HH时&quot;字符串格式 function formatDate(time)&#123; var newDate = new Date(time); return newDate.getFullYear() + &quot;-&quot; + (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate() + &quot; &quot; + newDate.getHours() + &quot;时&quot;; &#125; // 将table渲染为数据表格 layui.table.render(&#123; elem : &quot;#grdFormList&quot; , //选择器 id : &quot;grdFormList&quot; , //id url : &quot;/leave/list&quot; , //ajax请求url page : false , //是否分页 true-是 false-否 cols :[[ //列描述 &#123;title : &quot;&quot; , width:70 , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;, // numbers代表序号列 &#123;field : &quot;create_time&quot; , title : &quot;申请时间&quot; , width : 150 , templet: function (d) &#123; //templet代表对数据进行加工后再显示 return formatDate(d.create_time) &#125;&#125;, &#123;field : &quot;form_type&quot; , title : &quot;类型&quot; , width : 100 , templet: function(d)&#123; switch (d.form_type) &#123; case 1: return &quot;事假&quot;; case 2: return &quot;病假&quot;; case 3: return &quot;工伤假&quot;; case 4: return &quot;婚假&quot;; case 5: return &quot;产假&quot;; case 6: return &quot;丧假&quot;; &#125; &#125;&#125;, &#123;field : &quot;department_name&quot; , title : &quot;部门&quot; , width : 100&#125;, &#123;field : &quot;name&quot; , title : &quot;员工&quot; , width : 100&#125;, &#123;field : &quot;start_time&quot; , title : &quot;起始时间&quot; , width : 150, templet: function (d) &#123; return formatDate(d.start_time) &#125;&#125;, &#123;field : &quot;end_time&quot; , title : &quot;结束时间&quot; , width : 150 , templet: function (d) &#123; return formatDate(d.end_time) &#125;&#125;, &#123;field : &quot;reason&quot; , title : &quot;请假原因&quot; , width : 350 &#125;, &#123;title : &quot;&quot; , width:150 ,type:&quot;space&quot; , templet : function(d)&#123; var strRec = JSON.stringify(d); console.info(&quot;请假单数据&quot;, strRec); //将请假单数据存放至data-laf属性中 return &quot;&lt;button class=&#x27;layui-btn layui-btn-danger layui-btn-sm btn-audit&#x27; data-laf=&quot; + strRec + &quot; &gt;审批&lt;/button&gt;&quot;; &#125;&#125; ]] &#125;) // 绑定每一行的审批按钮 $(document).on(&quot;click&quot; , &quot;.btn-audit&quot; , function()&#123; //初始化表单 $(&quot;#divDialog form&quot;)[0].reset(); $(&quot;#divDialog form form-item-value&quot;).text(&quot;&quot;); //获取当前点击按钮的请假单数据,回填至显示项 var laf = $(this).data(&quot;laf&quot;); $(&quot;#dname&quot;).text(laf.department_name); $(&quot;#name&quot;).text(laf.name); $(&quot;#startTime&quot;).text(formatDate(laf.start_time)); $(&quot;#endTime&quot;).text(formatDate(laf.end_time)); $(&quot;#reason&quot;).text(laf.reason); $(&quot;#formId&quot;).val(laf.form_id); //弹出layui对话框 layui.layer.open(&#123; type : &quot;1&quot; , //页面层 title : &quot;请假审批&quot; , //标题 content : $(&quot;#divDialog&quot;) , //指定对话框容器对象 area : [&quot;500px&quot; , &quot;400px&quot;] , //尺寸 end : function()&#123; //销毁后触发事件 $(&quot;#divDialog&quot;).hide(); &#125; &#125;) &#125;) /** * 提交审批数据 */ layui.form.on(&quot;submit(audit)&quot; , function(data)&#123; $.ajax(&#123; url : &quot;/leave/audit&quot;, //审核URL data : data.field , type : &quot;post&quot; , success: function (json) &#123; //关闭所有layui对话框 layui.layer.closeAll(); //显示处理结果 if(json.code == &quot;ok&quot;)&#123; swal(&#123; type: &#x27;success&#x27;, html: &quot;&lt;h2&gt;请假已审批完毕&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;).then(function (result) &#123; window.location.href=&quot;/forward/notice&quot;; &#125;); &#125;else&#123; swal(&#123; type: &#x27;warning&#x27;, html: &quot;&lt;h2&gt;&quot; + json.msg + &quot;&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;); &#125; &#125; &#125;) return false; &#125;)&lt;/script&gt; ◇出现错误：Page template not found可能是ftl文件没有找到；解决方法：重启Tomcat或者将ftl文件删除后重新创建再重启Tomcat 实现审批业务逻辑审批流程可能出现的三种情况①需要总经理审批的，中间节点处理完成，并且部门经理审批通过，则后续节点reday-&gt;process②中间节点有驳回，则后续所有节点变为cancel③如果当前节点是最后一个，无论审批通过还是拒绝，执行完以后整个流程都会结束，所有节点状态都变为complete，同时表单状态变为处理结果 代码实现–在process_flow.xml中新增查询语句，通过FormId查询所有的处理表单数据，并且新增更新语句，用来更新任务状态 12345678&lt;update id=&quot;update&quot; parameterType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; UPDATE adm_process_flow SET form_id = #&#123;formId&#125;, operator_id = #&#123;operatorId&#125;, action = #&#123;action&#125;, result = #&#123;result&#125;, reason = #&#123;reason&#125;, create_time = #&#123;createTime&#125;, audit_time = #&#123;auditTime&#125;, order_no = #&#123;orderNo&#125;, state = #&#123;state&#125;, is_last = #&#123;isLast&#125; WHERE process_id = #&#123;processId&#125; &lt;/update&gt; &lt;select id=&quot;selectByFormId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; select * from adm_process_flow where form_id = #&#123;value&#125; order by order_no &lt;/select&gt; –在接口中将刚才新增的两条查询语句的方法写上 123public LeaveForm selectById(Long formId);public void update(LeaveForm form); –在leave_form.xml在新增sql语句 1234567&lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt; select * from adm_leave_form where form_id = #&#123;value&#125; &lt;/select&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt; UPDATE adm_leave_form SET employee_id = #&#123;employeeId&#125; , form_type = #&#123;formType&#125;, start_time = #&#123;startTime&#125;, end_time = #&#123;endTime&#125;, reason = #&#123;reason&#125;, state = #&#123;state&#125; ,create_time = #&#123;createTime&#125; WHERE form_id = #&#123;formId&#125; &lt;/update&gt; –在LeaveForm中新增对应的方法 123public LeaveForm selectById(Long formId);public void update(LeaveForm form); –在LeaveFormService中新增方法，部分代码 123456789101112131415/** * 审核请假单 * @param formId 表单编号 * @param operatorId 经办人(当前登录员工) * @param result 审批结果 * @param reason 审批意见 */ public void audit(Long formId , Long operatorId , String result , String reason)&#123; MybatisUtils.executeUpdate(sqlSession-&gt;&#123; //1.无论同意/驳回，当前任务状态变更为complete //2.如果当前任务是最后一个节点，代表流程结束，更新请假单状态为对应的approve/refused //3.如果当前任务不是最后一个节点且审批通过，那下一个节点的状态：ready-&gt;process //4.如果当前任务不是最后一个节点且审批驳回，则后续所有任务状态变为cancel，请假单状态变为refused &#125;) &#125; 完整实现请假审批◇在LeaveFormServlet中新建方法用来处理审批操作 12345678910111213141516171819202122232425/** * 处理审批操作 * @param request * @param response * @throws ServletException * @throws IOException */ private void audit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String formId = request.getParameter(&quot;formId&quot;); String result = request.getParameter(&quot;result&quot;); String reason = request.getParameter(&quot;reason&quot;); User user = (User)request.getSession().getAttribute(&quot;login_user&quot;); Map mpResult = new HashMap(); try &#123; leaveFormService.audit(Long.parseLong(formId), user.getEmployeeId(), result, reason); mpResult.put(&quot;code&quot;, &quot;0&quot;); mpResult.put(&quot;message&quot;, &quot;success&quot;); &#125;catch(Exception e)&#123; logger.error(&quot;请假单审核失败&quot;,e); mpResult.put(&quot;code&quot;, e.getClass().getSimpleName()); mpResult.put(&quot;message&quot;, e.getMessage()); &#125; String json = JSON.toJSONString(mpResult); response.getWriter().println(json); &#125; ◇url绑定 123else if (methodName.equals(&quot;audit&quot;)) &#123; this.audit(request, response); &#125; ◇修改audit.ftl，新增dataType； 1234url : &quot;/leave/audit&quot;, //审核URL data : data.field , type : &quot;post&quot; , dataType :&quot;json&quot;, //服务器返回类型为json字符串 ◇将成功的判断条件由”ok”改为if(json.code == “0”){//0，代表成功，与后台一致◇将提示信息由html: **”“ **+ json.msg + ““,改为 json.**message ** 开发系统通知功能创建系统消息◇消息的触发时机：①当员工提交请假申请时；②当请假流程中间节点发生变化时◇部分代码–请假申请时 123456789 //String.format用于输出指定格式的字符串 String noticeContent = String.format(&quot;您的请假申请[%s-%s]已提交，请等待上机审批.&quot; ,sdf.format(form.getStartTime()), sdf.format(form.getEndTime()));noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));//存放数据库//通知部门经理审批noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot; ,employee.getTitle(),employee.getName(),sdf.format(form.getStartTime()) ,sdf.format(form.getEndTime())); noticeDao.insert(new Notice(dmanger.getEmployeeId(),noticeContent)); –审批直接完成时 12345678910111213141516171819202122232425262728//2.如果当前任务是最后一个节点，代表流程结束，更新请假单状态为对应的approve/refusedLeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);LeaveForm form = leaveFormDao.selectById(formId);SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH时&quot;);EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);Employee employee = employeeDao.selectById(form.getEmployeeId());//表单提交人信息Employee operator = employeeDao.selectById(operatorId);//任务经办人信息NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);if (process.getIsLast() == 1) &#123; form.setState(result);//approve|refused leaveFormDao.update(form); String strResult = null; if (result.equals(&quot;approve&quot;)) &#123; strResult = &quot;批准&quot;; &#125; else if (result.equals(&quot;refused&quot;)) &#123; strResult = &quot;驳回&quot;; &#125; String noticeContent = String.format(&quot;您的请假申请[%s-%s]%s%s已%s,审批意见:%S,审批流程已结束&quot; ,sdf.format(form.getStartTime()), sdf.format(form.getEndTime()) ,operator.getTitle(),operator.getName(),strResult,reason);//发给表单提交人的通知 noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent)); //发给审批人的通知 noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s]您已%s,审批意见:%s,审批流程已结束&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), strResult , reason); noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent)); –审批还需要总经理处理时 1234567891011121314151617181920212223242526272829303132333435363738394041424344//3.如果当前任务不是最后一个节点且审批通过 if (result.equals(&quot;approved&quot;)) &#123;//消息1: 通知表单提交人,部门经理已经审批通过,交由上级继续审批String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已批准,审批意见:%s ,请继续等待上级审批&quot; , sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()), operator.getTitle() , operator.getName(),reason);noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));//消息2: 通知总经理有新的审批任务String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()));noticeDao.insert(new Notice(readyProcess.getOperatorId(),noticeContent2));//消息3: 通知部门经理(当前经办人),员工的申请单你已批准,交由上级继续审批String noticeContent3 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已批准,审批意见:%s,申请转至上级领导继续审批&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason);noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent3)); &#125;else if(result.equals(&quot;refused&quot;)) &#123; //4.如果当前任务不是最后一个节点且审批驳回 for(ProcessFlow p:readyList)&#123; p.setState(&quot;cancel&quot;); processFlowDao.update(p); &#125; form.setState(&quot;refused&quot;); leaveFormDao.update(form); //消息1: 通知申请人表单已被驳回 String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已驳回,审批意见:%s,审批流程已结束&quot; , sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()), operator.getTitle() , operator.getName(),reason); noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1)); //消息2: 通知经办人表单&quot;您已驳回&quot; String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已驳回,审批意见:%s,审批流程已结束&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason); noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent2)); &#125; 显示系统消息◇在notice.xml中新增查询语句 123&lt;select id=&quot;selectByReceiverId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Notice&quot;&gt; select * from sys_notice where receiver_id = #&#123;value&#125; order by create_time desc limit 0,100 &lt;/select&gt; ◇在dao中进行定义 1public List&lt;Notice&gt; selectByReceiverId(Long receiverId); ◇新增NoticeService 12345678910111213141516/** * 消息服务 */public class NoticeService &#123; /** * 查询指定员工的系统消息 * @param receiverId * @return 最近100条消息列表 */ public List&lt;Notice&gt; getNoticeList(Long receiverId)&#123; return (List)MybatisUtils.executeQuery(sqlSession -&gt; &#123; NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class); return noticeDao.selectByReceiverId(receiverId); &#125;); &#125;&#125; ◇创建NoticeServlet向客户端返回数据 123456789101112131415161718192021@WebServlet(name = &quot;NoticeServlet&quot; , urlPatterns = &quot;/notice/list&quot;)public class NoticeServlet extends HttpServlet &#123; private NoticeService noticeService = new NoticeService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; User user = (User)request.getSession().getAttribute(&quot;login_user&quot;); List&lt;Notice&gt; noticeList = noticeService.getNoticeList(user.getEmployeeId()); Map result = new HashMap&lt;&gt;(); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;&quot;); result.put(&quot;count&quot;, noticeList.size()); result.put(&quot;data&quot;, noticeList); String json = JSON.toJSONString(result); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(json); &#125;&#125; ◇notice.ftl页面部分代码 12345678910111213141516171819&lt;script&gt; layui.table.render(&#123; elem : &quot;#grdNoticeList&quot; , id : &quot;grdNoticeList&quot; , url : &quot;/notice/list&quot; ,//请求数据的地址 page : false , cols :[[ &#123;field : &quot;&quot; , title : &quot;序号&quot; , width:&quot;10%&quot; , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;, &#123;field : &quot;create_time&quot; , title : &quot;通知时间&quot; , width : &quot;20%&quot; , templet: function (d) &#123; var newDate = new Date(d.createTime); return newDate.getFullYear() + &quot;-&quot; + (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate() + &quot; &quot; + newDate.getHours() + &quot;:&quot; + newDate.getMinutes() + &quot;:&quot; + newDate.getSeconds(); &#125;&#125;, &#123;field : &quot;content&quot; , title : &quot;通知内容&quot; , width : &quot;60%&quot;&#125; ]] &#125;)&lt;/script&gt; ◇修改index.ftl使用户一登录就能看到通知消息，即将首页内置框架绑定到notice上 1234&lt;!--主体部分采用iframe嵌入其他页面--&gt; &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt; &lt;iframe name=&quot;ifmMain&quot; src=&quot;/forward/notice&quot; style=&quot;...&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"OA系统项目","slug":"Java数据库/OA系统项目","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/OA%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"项目介绍及基础实现","slug":"项目介绍","date":"2022-02-03T00:44:00.000Z","updated":"2022-02-23T13:22:59.096Z","comments":true,"path":"p/2f49.html","link":"","permalink":"https://618dt.github.io/p/2f49.html","excerpt":"","text":"课程介绍◇需求说明与环境准备◇开发基于RABC的访问控制模块◇开发多级请假审批流程 办公自动化OA系统◇办公自动化系统(Office Automation)是替代传统办公的解决方案◇OA系统是利用软件技术构建的单位内部办公平台,用于辅助办公◇利用OA系统可将办公数据数字化,可极大提高办公流程执行效率，项目完整代码见oa 需求介绍◇办公OA系统要求采用多用户B/S架构设计开发◇HR为每一位员工分配系统账户,员工用此账户登录系统◇公司采用分级定岗,从1-8依次提升,不同岗位薪资水平不同◇6级(含)以下员工为业务岗,对应人员执行公司业务事宜◇7-8级为管理岗,其中7级为部门经理,8级为总经理◇业务岗与管理岗员工可用系统功能不同,要求允许灵活配置 需求介绍-请假流程◇公司所有员工都可以使用”请假申请”功能申请休假◇请假时间少于72小时,部门经理审批后直接通过◇请假时间大于72小时,部门经理审批后还需总经理进行审批◇部门经理只允许批准本部门员工申请◇部门经理请假需直接由总经理审批◇总经理提起请假申请,系统自动批准通过 搭建基础架构框架&amp;组件◇MySQL 8 ◇Mybatis 3.5◇Alibaba Druid ◇Servlet 3.1◇Freemarker 2.3 ◇LayUI 2.5 搭建数据库◇新建数据库lcg-oa，字符集选择utf8m4，排序规则默认 创建Maven工程◇新建maven项目oa，JDK选择1.8◇进行工程设置以便将项目发布到服务器上：File-&gt;Project Structure-&gt;Modules-&gt;+-&gt;Web-&gt;Path:改为oa\\src\\main\\webapp\\WEB-INF\\web.xml;version:3.1; Web Resource Directory:选中webapp目录-&gt;Create Artifact-&gt;OK◇配置Tomcat:在工具栏上点击Add Configuration-&gt;+-&gt;Tomcat Server-&gt;Local(用本地的Tomcat来运行)-&gt;勾选After lanuch自动打开浏览器-&gt;HTTP port :80-&gt;Deployment(运行部署配置)-&gt;+-&gt;Artifact-&gt;Application context(应用上下文):/ -&gt;Apply-&gt;OK-&gt;下方为弹出Web面板 配置文件◇pom.xml配置 123456789101112131415161718192021222324252627282930313233343536//使用阿里云镜像仓库提高下载速度 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;//项目依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; //阿里巴巴连接池 &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; //单元测试 &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; //集成日志 &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ◇mybatis核心配置文件：在resource目录下创建mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;!--开发环境配置--&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;!--事务管理器采用JDBC方式--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--利用Mybatis自带连接池管理连接 &lt;dataSource type=&quot;POOLED&quot;&gt;--&gt; &lt;!--MyBatis与Druid的整合--&gt; &lt;dataSource type=&quot;com.lcg.oa.datasource.DruidDataSourceFactory&quot;&gt; &lt;!--JDBC连接属性--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; //连接字符串lcg-oa是数据库名 value=&quot;jdbc:mysql://localhost:3306/lcg-oa ? useSSL=false&amp;amp; useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp; serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;www.LCG.com&quot;/&gt; &lt;!--连接池初始连接数--&gt; &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt; &lt;!--连接池最大连接数--&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; ◇java目录下创建com.lcg.oa.utils.MybatisUtils工具类用于对Mybatis进行加载，SessionFactory对象的创建等初始化工作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;import java.util.function.Function;public class MybatisUtils &#123; //利用static(静态)属于类不属于对象,且全局唯一 private static SqlSessionFactory sqlSessionFactory = null; //利用静态块在初始化类时实例化sqlSessionFactory static&#123; Reader reader = null; try&#123; reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125;catch(IOException e)&#123; //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者 throw new ExceptionInInitializerError(e); &#125; &#125; /** * 执行SELECT查询SQL * @param func 要执行查询语句的代码块 * @return 查询结果 *具体的查询交给Function实现，在进行查询之前对sqlSession进行了打开和自动关闭 *Function&lt;T,R&gt;函数式接口，对应一个输入且需要返回数据的功能代码 */ public static Object executeQuery(Function&lt;SqlSession,Object&gt; func)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; //apply方法用于返回函数执行的结果 Object obj = func.apply(sqlSession); return obj; &#125;finally &#123; sqlSession.close(); &#125; &#125; /** * 执行INSERT/UPDATE/DELETE写操作SQL * @param func 要执行的写操作代码块 * @return 写操作后返回的结果 */ public static Object executeUpdate(Function&lt;SqlSession,Object&gt; func)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(false); try &#123; Object obj = func.apply(sqlSession); sqlSession.commit(); return obj; &#125;catch (RuntimeException e)&#123; sqlSession.rollback(); throw e; &#125;finally&#123; sqlSession.close(); &#125; &#125;&#125; ◇解决问题；函数式接口需要jdk1.8版本以上，但maven中统一按照1.5版本进行编译，因此需要在pom.xml配置文件中进行相关设置；在build块中，用于描述当前程序构建的各种细节；在build块中对maven的编译插件进行设置 1234567891011121314151617&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!--利用Maven编译插件将编译级别提高至1.8,解决lambda表达式错误--&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;!--maven-compiler-plugin是Maven自带的编译插件--&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;configuration&gt; &lt;!--检查源码采用1.8规则,默认为1.5--&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!--按1.8规则生成字节码--&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ◇mybatis执行sql的时候要有对应的mapper.xml文件，并且在核心配置文件(mybatis-config.xml)中进行配置；在resource目录下创建mappers目录用于存放此类文件，在其中创建一个test.xml文件进行测试 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;sample&quot; resultType=&quot;String&quot;&gt; select &#x27;success&#x27; //不从任何表中获取数据，只是返回success字符串 &lt;/select&gt;&lt;/mapper&gt;//核心配置文件配置 &lt;mappers&gt; &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt; &lt;/mappers&gt;//测试类进行测试，引用lambada表达式public class MybatisUtilsTestor &#123; @Test public void testcase1()&#123; String result = (String)MybatisUtils.executeQuery(sqlSession-&gt;&#123; String out = (String)sqlSession.selectOne(&quot;test.sample&quot;); return out; &#125;); System.out.println(result); &#125; @Test public void testcase2()&#123; String result = (String) MybatisUtils.executeQuery( sqlSession -&gt; sqlSession.selectOne(&quot;test.sample&quot;)); System.out.println(result); &#125;&#125; 连接池设置◇oa目录下创建子包datasource，在其下创建类DruidDataSourceFactory(数据源工厂类)◇执行顺序：首先通过构造方法创建空的数据源对象，然后调用setProperties方法读取xml文件并对刚才实例化的数据源进行属性设置；如果在获取数据源的时候必须要进行额外操作，则应重写getDataSource方法 1234567891011121314151617181920212223242526import com.alibaba.druid.pool.DruidDataSource;import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;import javax.sql.DataSource;import java.sql.SQLException;public class DruidDataSourceFactory extends UnpooledDataSourceFactory &#123; public DruidDataSourceFactory()&#123; this.dataSource = new DruidDataSource(); &#125; /** * DataSource是javax.sql包提供的接口，用来说明所有的数据源都要实现这个接口 * DruidDataSource当然也实现了这个接口；这样，当需要更换数据库连接池时，只需要 * 实例化不同的DataSource实现类即可 * */ @Override//进行重写代码：code-&gt;override 是否进行重写视连接池的类型而定 public DataSource getDataSource() &#123; try &#123; ((DruidDataSource)this.dataSource).init();//初始化Druid数据源 &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; return this.dataSource; &#125;&#125; 整合Freemarker◇pom.xml增加依赖 1234567891011121314&lt;!--Freemarker依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.29&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet-api--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!--依赖只参与编译测试,不进行发布--&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; ◇web.xml进行配置servlet 12345678910111213141516171819&lt;servlet&gt; &lt;!--FreemakrerServlet用于读取解析ftl文件--&gt; &lt;servlet-name&gt;freemakrer&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;!-- 定义模板的存储路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--default_encoding用于设置读取ftl文件时采用的字符集,进而避免中文乱码的产生--&gt; &lt;param-name&gt;default_encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemakrer&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ◇在WEB-INF目录下创建ftl目录，然后将test.html移入并改为test.ftl (freemarker脚本) 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;LCG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;result&#125;&lt;/h1&gt;//数据库查询结果&lt;/body&gt;&lt;/html&gt; ◇在com.lcg.oa.test下创建一个TestServlet 123456789101112@WebServlet(name = &quot;TestServlet&quot;,urlPatterns = &quot;/test&quot;)//映射地址public class TestServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String result = (String)MybatisUtils.executeQuery(sqlSession-&gt;sqlSession.selectOne(&quot;test.sample&quot;)); request.setAttribute(&quot;result&quot;,request); //请求转发 request.getRequestDispatcher(&quot;test.ftl&quot;).forward(request,response); &#125;&#125; ◇在运行测试前还需进行相关设置：File-&gt;Project Structure-&gt;Artifacts-&gt;将右侧Maven资源全选右键-&gt;Put into-&gt;OK◇配置日志文件logback.xml 开发基于RBAC的权限控制模块RBAC-基于角色的访问控制◇Role-Based Access Control◇基于角色权限控制(RBAC)是面向企业安全策略的访问控制方式◇RBAC核心思想是将控制访问的资源(功能或者特定资料等)与角色(Role)进行绑定◇系统的用户(User)与角色(Role)再进行绑定,用户便拥有对应权限 RBAC底层设计 创建数据库表◇角色表，表名：模块名_具体表名 sys_role◇资源表sys_node◇关联表sys_role_node ◇其他表的创建(此处省略) 基于LayUI开发登录页LayUI前端框架◇官方网站◇在webapp目录下创建resources文件夹(用来存放web应用所有相关的引用资源) 将layui文件夹粘贴到其下 开发登录页面◇在webapp目录下新建login.html◇进行项目热部署：Tomcat-&gt;Edit Configurations-&gt;On ‘Update’ action:改为Update classes and resources-&gt;ok然后按shift+F9就能进行热部署了 开发后台与数据库交互◇创建实体类User◇创建sql语句的xml文件user.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;usermapper&quot;&gt; &lt;select id=&quot;selectByUsername&quot; parameterType=&quot;String&quot; resultType=&quot;com.lcg.oa.entity.User&quot;&gt; select * from sys_user where username = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; ◇每次增加mapper后必须到mybatis-config中进行配置 1&lt;mapper resource=&quot;mappers/user.xml&quot;/&gt; ◇创建dao完成与user表的交互 123456789101112public class UserDao &#123; /** * 按用户名查询用户表 * @param username 用户名 * @return User对象包含对应的用户信息,null则代表对象不存在 */ public User selectByUsername(String username)&#123; User user = (User)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;usermapper.selectByUsername&quot; , username)); return user; &#125;&#125; ◇创建Service 123456789101112131415161718192021public class UserService &#123; private UserDao userDao =new UserDao();//记得实例化，否则出现空指针异常 /** * 根据前台输入进行登录校验 * @param username 前台输入的用户名 * @param password 前台输入的密码 * @return 校验通过后,包含对应用户数据的User实体类 * @throws BussinessException L001-用户名不存在,L002-密码错误 */ public User checkLogin(String username,String password)&#123; User user = userDao.selectByUsername(username); if (user == null) &#123; //抛出用户不存在异常 throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;); &#125; if (!password.equals(user.getPassword())) &#123; throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;); &#125; return user; &#125;&#125; ◇自定义异常 123456789101112131415161718192021222324252627282930/** * 业务逻辑异常，继承自运行时异常 */public class BussinessException extends RuntimeException &#123; private String code;//异常编码，异常的以为标识 private String message;//异常的具体文本消息 public BussinessException(String code, String msg) &#123; super(code + &quot;:&quot; + msg); this.code=code; this.message=msg; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; ◇箭头指向需要测试的类名，Ctrl+Shift+T 生成测试用例类，将需要测试的方法进行勾选◇空指针异常：在出错代码处做一个断点，可以找出具体哪个对象为空，有时候出现空指针可能是对象没有实例化，在创建时new 类名()即可; 与前台联通◇创建控制器controller 1234567891011121314151617181920212223242526272829303132333435363738394041@WebServlet(name = &quot;LoginServlet&quot;, urlPatterns = &quot;/check_login&quot;)public class LoginServlet extends HttpServlet &#123; //日志文件 LoginServlet.class即LoginServlet类的类对象;(对象有实例对象和类对象两种) Logger logger = LoggerFactory.getLogger(LoginServlet.class); private UserService userService = new UserService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); //接收用户输入 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //保存输出的内容 Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); try &#123; //调用业务逻辑 User user = userService.checkLogin(username, password); //返回项 result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;message&quot;, &quot;success&quot;); &#125; catch (BussinessException e) &#123; logger.error(e.getMessage(), e); result.put(&quot;code&quot;, e.getCode()); result.put(&quot;message&quot;, e.getMessage()); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); //由于系统自带异常没有code，用e.getClass().getSimpleName()得到的类名来充当 result.put(&quot;code&quot;, e.getClass().getSimpleName()); result.put(&quot;message&quot;, e.getMessage()); &#125; //返回对应结果 String json = JSON.toJSONString(result); response.getWriter().println(json);//向客户端返回 &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; ◇pom.xml加载fastjson依赖，并加入发布的项目中 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; ◇修改login.html文件增加提交数据功能 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=&quot;oa-container&quot;&gt; &lt;h1 style=&quot;text-align: center;margin-bottom: 20px&quot;&gt;交通控股办公OA系统&lt;/h1&gt; &lt;form class=&quot;layui-form&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; lay-verify=&quot;required&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; lay-verify=&quot;required&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;!--lay-filter即layui专属的id，autocomple表示是否显示历史输入--&gt; &lt;button class=&quot;layui-btn layui-btn-fluid&quot; lay-submit lay-filter=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 表单提交事件 /*on代表捕捉事件，里面参数为submit即提交事件，login表示绑定哪个提交按钮才会触发这段代码*/ layui.form.on(&quot;submit(login)&quot; , function(formdata)&#123;//data参数包含了当前表单的数据 console.log(formdata); //发送ajax请求进行登录校验 layui.$.ajax(&#123; url : &quot;/check_login&quot;, data : formdata.field, //提交表单数据 type : &quot;post&quot;, dataType : &quot;json&quot; , success : function(json)&#123; console.log(json); if(json.code == &quot;0&quot;)&#123; //登录校验成功 layui.layer.msg(&quot;登录成功&quot;); &#125;else&#123; layui.layer.msg(json.message); &#125; &#125; &#125;) return false;//submit提交事件返回true则表单提交,false则阻止表单提交 &#125;)&lt;/script&gt; 开发功能首页12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;交通控股OA系统&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;&lt;/head&gt;&lt;body class=&quot;layui-layout-body&quot;&gt;&lt;!-- Layui后台布局CSS --&gt;&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt; &lt;!--头部导航栏--&gt; &lt;div class=&quot;layui-header&quot;&gt; &lt;!--系统标题--&gt; &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;交通控股OA系统&lt;/div&gt; &lt;!--右侧当前用户信息--&gt; &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt; &lt;li class=&quot;layui-nav-item&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt; &lt;!--图标--&gt; &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt; &lt;/span&gt; &lt;!--用户信息--&gt; 姓名[部门-职务] &lt;/a&gt; &lt;/li&gt; &lt;!--注销按钮--&gt; &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--左侧菜单栏--&gt; &lt;div class=&quot;layui-side layui-bg-black&quot;&gt; &lt;!--可滚动菜单--&gt; &lt;div class=&quot;layui-side-scroll&quot;&gt; &lt;!--可折叠导航栏--&gt; &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt; &lt;!--父节点--&gt; &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;模块1&lt;/a&gt; &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;1&quot;&gt;&lt;/dl&gt; &lt;/li&gt; &lt;!--子节点--&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能1&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能2&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt; &lt;/dd&gt; &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;模块2&lt;/a&gt; &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;2&quot;&gt;&lt;/dl&gt; &lt;/li&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能4&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能5&lt;/a&gt; &lt;/dd&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--主体部分采用iframe嵌入其他页面--&gt; &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt; &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;!--版权信息--&gt; &lt;div class=&quot;layui-footer&quot;&gt; Copyright © gamest. All Rights Reserved. &lt;/div&gt;&lt;/div&gt;&lt;!--LayUI JS文件--&gt;&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //将所有功能根据parent_id移动到指定模块下 layui.$(&quot;.function&quot;).each(function () &#123; var func = layui.$(this); var parentId = func.data(&quot;parent-id&quot;); layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func); &#125;) //刷新折叠菜单 layui.element.render(&#x27;nav&#x27;);&lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"OA系统项目","slug":"Java数据库/OA系统项目","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/OA%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"MyBaits进阶","slug":"MyBatis进阶","date":"2022-02-03T00:39:00.000Z","updated":"2022-02-21T14:32:31.236Z","comments":true,"path":"p/fb2c.html","link":"","permalink":"https://618dt.github.io/p/fb2c.html","excerpt":"","text":"MyBatis日志管理什么是日志◇日志文件是用于记录系统操作事件的记录文件或文件集合◇日志保存历史数据,是诊断问题以及理解系统活动的重要依据 SLF4j与Logback 代码示例​◇配置依赖 12345&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; ◇产生的日志(部分) 12320:53:41.109 [main] DEBUG goods.selectByTitle - ==&gt; Preparing: select * from t_goods where title = ? order by title desc 20:53:41.131 [main] DEBUG goods.selectByTitle - ==&gt; Parameters: &#x27;&#x27; or 1=1 or title=&#x27;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#x27;(String)20:53:41.298 [main] DEBUG goods.selectByTitle - &lt;== Total: 0 ◇自定义日志格式：在resource目录新建logback.xml文件 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!--ConsoleAppender是指在控制台输出日志 pattern指定日志输出格式，示例格式即 线程，时间，按5个字符右对齐，说明哪个类产生的日志(最多36字符超过压缩)，具体日志内容 换行 --&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 日志输出级别(优先级高到低): error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序运行的跟踪信息 --&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; MyBatis动态SQL ◇动态SQL是指根据参数数据动态组织SQL的技术 1234567891011&lt;select id=&quot;dynamicSQL&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com..Goods&quot;&gt;select * from t_goods&lt;where&gt;&lt;if test=&quot;categoryId != null&quot;&gt;and category_id = #&#123;categoryId&#125;&lt;/if&gt;&lt;if test=&quot;currentPrice != null&quot;&gt;and current_price &amp;lt; #&#123;currentPrice&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; ◇示例代码 12345678910111213141516171819202122232425262728293031323334&lt;select id=&quot;dynamicSQL&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods &lt;where&gt; &lt;if test=&quot;categoryId != null&quot;&gt; and category_id = #&#123;categoryId&#125; &lt;/if&gt; &lt;if test=&quot;currentPrice != null&quot;&gt; and current_price &amp;lt; #&#123;currentPrice&#125; //小于号转义符 &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; @Test public void testDynamicSQL() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Map param = new HashMap(); param.put(&quot;categoryId&quot;, 44); param.put(&quot;currentPrice&quot;, 500); //查询条件 List&lt;Goods&gt; list = session.selectList(&quot;goods.dynamicSQL&quot;, param); for(Goods g:list)&#123; System.out.println(g.getTitle() + &quot;:&quot; + g.getCategoryId() + &quot;:&quot; + g.getCurrentPrice()); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; MyBatis二级缓存缓存简介◇我们从数据库中查询到某一条数据后，因为业务的要求还需要这条数据，那么按照原始的方法就还需要在数据库中查询到该数据；因为MySql是将数据存放在硬盘上的，而硬盘的读取访问速度不是特别快；而且我们这里第一次获取和第二次获取记录的时候，都返回相同的数据；因此我们可以在第一次查询数据时，将该数据暂时保存到内存的某一个区域中，第二次查询时直接从内存的对应区域取出即可，因为内存的访问速度快，这样就能够提高查询的速度；在Mybatis中存在了两级缓存；◇ 一级缓存默认开启,缓存的数据范围为SqlSession会话，即在一次SqlSession会话中，对数据库中的某个数据进行重复读取，Mybatis就会利用到这个缓存来提高程序的处理速度；◇ 二级缓存手动开启,属于范围Mapper Namespace ，范围比SqlSession大的多； 缓存的范围 二级缓存运行规则◇二级开启后默认所有查询操作均使用缓存◇写操作使用commit提交时对该namespace缓存强制清空，保证商品一致性；如第一个用户查询到商品，而第二个用户将此商品名称改了，那么这时候就会将namespace缓存强制清空，第一个用户再次查询该商品时就得从数据库中获取了；◇配置useCache=false可以不用缓存◇在某一sql语句中配置flushCache=true代表执行完该sql语句后强制清空缓存◇代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//测试一级缓存 @Test public void testLv1Cache() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); //这里执行了两次sql查询，由于使用了缓存，所以在日志中可以看到只打印出一条sql语句 Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); Goods goods1 = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode() + &quot;:&quot; + goods1.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session);//关闭了会话 &#125; try&#123; session = MyBatisUtils.openSession(); //由于前面关闭了会话，这里是新的会话，需要对数据库进行查询 Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); session.commit();//commit提交时对该namespace缓存强制清空 //由于前面对缓存进行了强制清空，所以还需要访问数据库 Goods goods1 = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode() + &quot;:&quot; + goods1.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; //测试二级缓存 //在mapper标签下添加cache标签&lt;!--开启了二级缓存 eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除 1.LRU – 最近最久未使用:移除最长时间不被使用的对象。 O1 O2 O3 O4 .. O512 14 99 83 1 893 2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 3.SOFT – 软引用:移除基于垃圾收集器状态和软引用规则的对象。 4.WEAK – 弱引用:更积极的移除基于垃圾收集器状态和弱引用规则的对象。 5.LFU - 最近最少使用：移除最近访问频率最低的对象 flushInterval代表间隔多长时间自动清空缓存，单位毫秒，600000毫秒为10分钟 --&gt; &lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;600000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; @Test public void testLv2Cache() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; try&#123; //这里虽然是新的会话，但是由于是二级缓存，所以还是可以从内存中提取数据； session = MyBatisUtils.openSession(); Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇缓存标签的属性：eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除 1.LRU – 最近最久未使用:移除最长时间不被使用的对象。 O1 O2 O3 O4 .. O512 14 99 83 1 893 2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 3.SOFT – 软引用:移除基于垃圾收集器状态和软引用规则的对象。 4.WEAK – 弱引用:更积极的移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval代表间隔多长时间自动清空缓存，单位毫秒size 缓存存储上限，用于保存对象或集合(1个集合算1个对象)的数量上限readOnly 设置为true，代表返回只读缓存，每次从缓存取出的是缓存对象本身，这种执行效率较高 设置为false，代表每次取出的是缓存对象的”副本”，每一次取出的对象都是不同的，这种安全性较高◇一些缓存相关的属性：useCache=”false”代表查询结果不被放入缓存，常用于读取全部数据的SQL语句中执行完insert语句需要立即清空缓存，flushCache=”true”在sql执行后强制清空缓存 MyBatis多表级联查询实体关系分析 商品和详情对象关联查询一对多◇增加实体类GoodsDetail 123456public class GoodsDetail &#123; private Integer gdId; private Integer goodsId; private String gdPicUrl; private Integer gdOrder;&#125; ◇配置 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;goodsDetail&quot;&gt; &lt;select id=&quot;selectByGoodsId&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.lcg.mybatis.entity.GoodsDetail&quot;&gt; select * from t_goods_detail where goods_id = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; ◇表达一个Goods对象有多个GoodsDetail对象：在Goods类中增加**private **List goodsDetails;◇Goods.xml中 1234567891011121314151617181920&lt;!-- resultMap可用于说明一对多或者多对一以及多表查询(前面学过)的映射逻辑 id 是resultMap属性引用的标志,需要和其他resultMap区分开 type 在一对多的关系中指向One的实体(Goods)--&gt;&lt;resultMap id=&quot;rmGoods1&quot; type=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; &lt;!-- 映射goods对象的主键到goods_id字段 --&gt; &lt;id column=&quot;goods_id&quot; property=&quot;goodsId&quot;&gt;&lt;/id&gt; &lt;!-- collection(集合)专用于描述Goods实体中的goodsDetails这个List数据从哪来的; 其含义是,在 select * from t_goods limit 0,10 得到结果后,对所有Goods对象遍历得到goods_id字段值, 并代入到goodsDetail命名空间的 selectByGoodsId的SQL中执行查询, 将得到的&quot;商品详情&quot;集合赋值给goodsDetails 这个List对象. --&gt; &lt;collection property=&quot;goodsDetails&quot; select=&quot;goodsDetail.selectByGoodsId&quot; column=&quot;goods_id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectOneToMany&quot; resultMap=&quot;rmGoods1&quot;&gt; select * from t_goods limit 0,10&lt;/select&gt; ◇在核心配置文件(mybatis-config.xml)中进行注册 1234&lt;mappers&gt; &lt;mapper resource=&quot;mappers/goods.xml&quot;/&gt; &lt;mapper resource=&quot;mappers/goods_detail.xml&quot;/&gt;&lt;/mappers&gt; ◇测试 123456789101112131415@Test public void testOneToMany() throws Exception &#123; SqlSession session = null; try &#123; session = MyBatisUtils.openSession(); List&lt;Goods&gt; list = session.selectList(&quot;goods.selectOneToMany&quot;); for(Goods goods:list) &#123; System.out.println(goods.getTitle() + &quot;:&quot; + goods.getGoodsDetails().size()); &#125; &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; 多对一◇在实体类GoodsDetail中增加**private **Goods goods;◇在goods_detail.xml文件中进行对像关联的描述 123456789101112&lt;resultMap id=&quot;rmGoodsDetail&quot; type=&quot;com.lcg.mybatis.entity.GoodsDetail&quot;&gt; &lt;!--主键关联--&gt; &lt;id column=&quot;gd_id&quot; property=&quot;gdId&quot;/&gt; &lt;!--结果关联--&gt; &lt;result column=&quot;goods_id&quot; property=&quot;goodsId&quot;/&gt; &lt;!--association关联标签，用于多对一--&gt; &lt;association property=&quot;goods&quot; select=&quot;goods.selectById&quot; column=&quot;goods_id&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectManyToOne&quot; resultMap=&quot;rmGoodsDetail&quot;&gt; select * from t_goods_detail limit 0,20 &lt;/select&gt; ◇测试 项目见F:mybatis; 分页插件PageHelper分页查询的麻烦事◇当前页数据查询 - select * from tab limit 0,10◇总记录数查询 - select count(*) from tab◇程序计算总页数、上一页页码、下一页页码◇MyBatis分页插件PageHelper官方网站 pageHelper使用流程◇maven引入PageHelper与jsqlparser 1234567891011//pom.xml中&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; ◇mybatis-config.xml增加Plugin配置 12345678&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!--设置数据类型 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;!--分页合理化 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; ◇代码中使用PageHelper.startPage()自动分页 123456789101112131415161718192021222324252627 &lt;select id=&quot;selectPage&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods where current_price &amp;lt; 1000 &lt;/select&gt;@Test public void testSelectPage() throws Exception &#123; SqlSession session = null; try &#123; session = MyBatisUtils.openSession(); /*startPage方法会自动将下一次查询进行分页*/ PageHelper.startPage(2,10); Page&lt;Goods&gt; page = (Page) session.selectList(&quot;goods.selectPage&quot;); System.out.println(&quot;总的页数:&quot; + page.getPages()); System.out.println(&quot;总记录数:&quot; + page.getTotal()); System.out.println(&quot;开始行号:&quot; + page.getStartRow()); System.out.println(&quot;结束行号:&quot; + page.getEndRow()); System.out.println(&quot;当前页码:&quot; + page.getPageNum()); List&lt;Goods&gt; data = page.getResult();//当前页数据 for (Goods g : data) &#123; System.out.println(g.getTitle()); &#125; System.out.println(&quot;&quot;); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; 不同数据库的分页实现MySQL分页12//第一个参数代表起始行号，第二个是偏移量select * from table limit 10,20; Oracle123456select t3.* from ( select t2.*, rownum as row_num from ( --rownum是伪列：无需声明直接使用的列，将前20条数据筛选 select * from table order by id asc --用于查询 ) t2 where rownum&lt;=20) t3 where t2.row_num&gt;11 --第三层嵌套用于起始位置的筛选 SQL Server 20001234select top 3 * from table --top语句在sql语句执行完后获取前几条数据where id not in (select top 15 id from table) SQL Server 2012+123select * from table order by id offset 4 rows fetch next 5 rows only --offset偏移量 fetch next向后取多少行 --若id为1的话即从第5(1+4)行开始向后取5条数据 MyBatis配置C3P0连接池◇pom.xml进行配置 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.4&lt;/version&gt;&lt;/dependency&gt; ◇在mybatis创建datasoutce包，再新建C3P0DataSourceFactory类，继承自UnpooledDataSourceFactory以便于连接 12345678/** * C3P0与MyBatis兼容使用的数据源工厂类 */public class C3P0DataSourceFactory extends UnpooledDataSourceFactory &#123; public C3P0DataSourceFactory()&#123; this.dataSource = new ComboPooledDataSource(); &#125;&#125; ◇在mybatis-config.xml配置文件中将的type改为com.lcg.mybatis.datasource.C3P0DataSourceFactory;因为不同的连接池对属性的命名规则不同，所以有以下更改：driver-&gt;driverClass , url-&gt;jdbcUrl , username-&gt;user 123456789&lt;dataSource type=&quot;com.lcg.mybatis.datasource.C3P0DataSourceFactory&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;www.LCG.com&quot;/&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;5&quot;/&gt;&lt;/dataSource&gt; MyBatis批处理◇goods.xml增加批处理的SQL语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;!--INSERT INTO table--&gt; &lt;!--VALUES (&quot;a&quot; , &quot;a1&quot; , &quot;a2&quot;),(&quot;b&quot; , &quot;b1&quot; , &quot;b2&quot;),(....)--&gt; &lt;insert id=&quot;batchInsert&quot; parameterType=&quot;java.util.List&quot;&gt; INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; (#&#123;item.title&#125;,#&#123;item.subTitle&#125;, #&#123;item.originalCost&#125;, #&#123;item.currentPrice&#125;, #&#123;item.discount&#125;, #&#123;item.isFreeDelivery&#125;, #&#123;item.categoryId&#125;) &lt;/foreach&gt; &lt;/insert&gt; @Test public void testBatchInsert() throws Exception &#123; SqlSession session = null; try &#123; long st = new Date().getTime(); session = MyBatisUtils.openSession(); List list = new ArrayList(); for (int i = 0; i &lt; 10000; i++) &#123; Goods goods = new Goods(); goods.setTitle(&quot;测试商品&quot;); goods.setSubTitle(&quot;测试子标题&quot;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); //insert()方法返回值代表本次成功插入的记录总数 list.add(goods); &#125; session.insert(&quot;goods.batchInsert&quot;, list); session.commit();//提交事务数据 long et = new Date().getTime(); System.out.println(&quot;执行时间:&quot; + (et - st) + &quot;毫秒&quot;);// System.out.println(goods.getGoodsId()); &#125; catch (Exception e) &#123; if (session != null) &#123; session.rollback();//回滚事务 &#125; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇批量插入数据的局限：①无法获得插入数据的id；②批量生成的SQL太长，可能会被服务器拒绝◇批量删除 12345678910111213141516171819202122232425262728293031&lt;!--delete from t_goods where goods_id in (1920,1921,...)--&gt; &lt;delete id=&quot;batchDelete&quot; parameterType=&quot;java.util.List&quot;&gt; DELETE FROM t_goods WHERE goods_id in &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/delete&gt; @Test public void testBatchDelete() throws Exception &#123; SqlSession session = null; try &#123; long st = new Date().getTime(); session = MyBatisUtils.openSession(); List list = new ArrayList(); list.add(1920); list.add(1921); list.add(1922); session.delete(&quot;goods.batchDelete&quot;, list); session.commit();//提交事务数据 long et = new Date().getTime(); System.out.println(&quot;执行时间:&quot; + (et - st) + &quot;毫秒&quot;);// System.out.println(goods.getGoodsId()); &#125; catch (Exception e) &#123; if (session != null) &#123; session.rollback();//回滚事务 &#125; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; MyBatis注解开发Mybatis常用注解◇把原有放在xml的标签语句放在程序中◇创建dao包，然后创建GoodsDAO接口 1234567891011121314151617181920212223242526public interface GoodsDAO &#123; @Select(&quot;select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125; order by current_price limit 0,#&#123;limt&#125;&quot;) public List&lt;Goods&gt; selectByPriceRange(@Param(&quot;min&quot;) Float min , @Param(&quot;max&quot;) Float max ,@Param(&quot;limt&quot;) Integer limt); @Insert(&quot;INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;)&quot;) //&lt;selectKey&gt; @SelectKey(statement = &quot;select last_insert_id()&quot; , before = false , keyProperty = &quot;goodsId&quot; , resultType = Integer.class) public int insert(Goods goods); @Select(&quot;select * from t_goods&quot;) //&lt;resultMap&gt; @Results(&#123; //&lt;id&gt; @Result(column = &quot;goods_id&quot; ,property = &quot;goodsId&quot; , id = true) , //&lt;result&gt; @Result(column = &quot;title&quot; ,property = &quot;title&quot;), @Result(column = &quot;current_price&quot; ,property = &quot;currentPrice&quot;) &#125;) public List&lt;GoodsDTO&gt; selectAll();&#125; ◇在核心配置文件mybatis-config.xml中进行相应说明 1234&lt;mappers&gt; &lt;!--&lt;mapper class=&quot;com.lcg.mybatis.dao.GoodsDAO&quot;/&gt; 指向接口，下为简便方法--&gt; &lt;package name=&quot;com.lcg.mybatis.dao&quot;/&gt;&lt;/mappers&gt; ◇测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Test public void testSelectByPriceRange() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); //传入类对象 GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List&lt;Goods&gt; list = goodsDAO.selectByPriceRange(100f, 500f, 20); System.out.println(list.size()); &#125;catch (Exception e)&#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125;/** * 新增数据 * @throws Exception */ @Test public void testInsert() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(&quot;测试商品&quot;); goods.setSubTitle(&quot;测试子标题&quot;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); //insert()方法返回值代表本次成功插入的记录总数 int num = goodsDAO.insert(goods); session.commit();//提交事务数据 System.out.println(goods.getGoodsId()); &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; @Test public void testSelectAll() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List&lt;GoodsDTO&gt; list = goodsDAO.selectAll(); System.out.println(list.size()); &#125;catch (Exception e)&#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBaits","slug":"Java数据库/MyBaits","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MyBaits/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"MyBaits入门","slug":"MyBatis入门","date":"2022-02-03T00:34:00.000Z","updated":"2022-02-21T14:32:31.234Z","comments":true,"path":"p/f37d.html","link":"","permalink":"https://618dt.github.io/p/f37d.html","excerpt":"","text":"MyBatis课程介绍MyBatis入门使用 MyBatis高级特性 认识框架-Framework生活中的框架 软件开发中框架◇框架是可被应用开发者定制的应用骨架◇框架是一种规则,保证开发者遵循相同的方式开发程序◇框架提倡”不要重复造轮子”,对基础功能进行封装 框架的优点◇极大提高了开发效率◇统一的编码规则,利于团队管理◇灵活配置的应用,拥有更好的维护性 SSM开发框架 介绍MyBatis什么是MyBatis◇MyBatis是优秀的持久层框架◇MyBatis使用XML将SQL与程序解耦,便于维护◇MyBatis学习简单,执行高效,是JDBC的延伸 MyBatis开发流程◇引入MyBatis依赖 ◇创建核心配置文件◇创建实体(Entity)类 ◇创建Mapper映射文件◇初始化SessionFactory ◇利用SqlSession对象操作数据 单元测试与JUnit 4单元测试◇单元测试是指对软件中的最小可测试单元进行检查和验证◇测试用例是指编写一段代码对已有功能(方法)进行校验◇JUnit 4是Java中最著名的单元测试工具,主流IDE内置支持 JUnit 4使用方法◇引入JUnit Jar包或增加Maven依赖◇编写测试用例验证目标方法是否正确运行◇在测试用例上增加@Test注解开始单元测试 JUnit 4使用入门◇创建Maven项目 –pom.xml配置 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; –main中创建类 1234567891011121314151617public class Calculator &#123; public int add(int a, int b) &#123; return a+b; &#125; public int subtract(int a, int b) &#123; return a - b; &#125; public int multiply(int a, int b) &#123; return a * b; &#125; public float divide(int a, int b) &#123; return (a*1f)/b; &#125;&#125; –test中创建测试类,测试类或测试方法前有√则为正确运行,也要看程序运行和预期是否相同 123456789101112131415161718192021222324252627282930public class CalculatorTest &#123; private Calculator cal = new Calculator(); //测试用例命名规则 //1.与原方法保持一致add //2.在原方法前增加test前缀testAdd @Test public void testAdd()&#123; int result = cal.add(3, 5); System.out.println(result); &#125; @Test public void subtract() &#123; int result = cal.subtract(1, 2); System.out.println(result); &#125; @Test public void multiply() &#123; int result = cal.multiply(1, 2); System.out.println(result); &#125; @Test public void divide() &#123; float result = cal.divide(1, 2); System.out.println(result); &#125;&#125; ◇快速生成测试类方法：选中需要测试的类-&gt;Code-&gt;Generate-&gt;Test◇可以同时运行多个测试类 MyBatis环境配置mybatis-config.xml◇ MyBatis采用XML格式配置数据库环境信息◇ MyBaits环境配置标签◇ environment包含数据库驱动、URL、用户名与密码 项目演示◇IDEA支持数据库面板，DataBase-&gt;+ -&gt;DataSource-&gt;MySql◇pom.xml配置 12345678910111213141516171819202122&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--增加junit用于测试 --&gt; &lt;/dependencies&gt; ◇在main/resources目录下创建mybatis-config.xml文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--设置默认指向的数据库,这里默认指向dev--&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;!--配置环境，不同的环境不同的id名字--&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--采用连接池方式管理数据库连接--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value= &quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;www.LCG.com&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; SqlSessionFactory◇ SqlSessionFactory是MyBatis的核心对象◇ 用于初始化MyBatis,创建SqlSession对象◇ 保证SqlSessionFactory在应用中全局唯一 SqlSession◇ SqlSession是MyBatis操作数据库的核心对象◇ SqlSession使用JDBC方式与数据库交互◇ SqlSession对象提供了数据表CRUD对应方法 项目演示◇pom.xml中增加junit依赖用于测试◇JUNIT单元测试类 123456789101112131415161718192021222324252627282930313233343536373839404142public class MyBatisTestor &#123; @Test public void testSqlSessionFactory()throws IOException &#123; //按照字符流方式进行.xml文件的读取，返回Reader对象 Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); //初始化SqlSessionFactory对象，同时通过reader对象解析xml文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); System.out.println(&quot;SessionFactory加载成功&quot;); SqlSession sqlSession = null; try &#123; //创建SqlSession对象，SqlSession是JDBC的扩展类，用于与数据库交互 sqlSession = sqlSessionFactory.openSession(); //进行数据库的交互 Connection connection = sqlSession.getConnection(); System.out.println(connection); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; /*如果type=&quot;POOLED&quot;,代表使用连接池，close则是将连接回收到连接池中 * 如果type=&quot;UNPOOLED&quot;,代表直连，close则会调用Connection.close() * 方法关闭连接*/ if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; &#125; //测试工具类 @Test public void testMyBatisUtils()throws Exception&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.openSession(); Connection connection = sqlSession.getConnection(); System.out.println(connection); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; MyBatisUtils.closeSession(sqlSession); &#125; &#125;&#125; ◇初始化工具类 123456789101112131415161718192021222324252627282930313233343536373839public class MyBatisUtils &#123; //利用static(静态)属于类不属于对象，且全局唯一 private static SqlSessionFactory sqlSessionFactory = null; //利用静态块在初始化类时实例化sqlSessionFactory static &#123; Reader reader = null; try &#123; reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); //初始化错误时，通过抛出异常ExceptionInInitializerError通知调用者 throw new ExceptionInInitializerError(e); &#125; &#125; /** * openSession 创建一个新的SqlSession对象 * 对于工具类的方法大都使用static描述， * 这样通过类名和方法名就可以直接使用了 * @return SqlSession对象 */ public static SqlSession openSession() &#123; return sqlSessionFactory.openSession(); &#125; /** * 释放一个有效的SqlSession对象 * * @param session 准备释放SqlSession对象 */ public static void closeSession(SqlSession session) &#123; if (session != null) &#123; session.close(); &#125; &#125;&#125; MyBatis数据查询MyBatis数据查询步骤◇创建实体类(Entity) ◇创建Mapper XML◇编写SQL标签 ◇开启驼峰命名映射◇新增 ◇SqlSession执行select语句 项目演示◇生成实体类，entity 1234567891011public class Goods &#123; private Integer goodsId;//商品编号 private String title;//标题 private String subTitle;//子标题 private Float originalCost;//原始价格 private Float currentPrice;//当前价格 private Float discount;//折扣率 private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮 private Integer categoryId;//分类编号 ...&#125; ◇在Resources目录中创建mapper(映射器)文件，在其中创建xml文件;goods.xml文件说明了实体类和哪一张表对应 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--与config中的不同 --&gt;&lt;!--命名空间用来区分 --&gt;&lt;mapper namespace=&quot;goods&quot;&gt; &lt;!--编写sql标签,resultType说明查询结果返回的实体类 --&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods order by goods_id desc limit 10 &lt;/select&gt;&lt;/mapper&gt; ◇新建了goods.xml后还需要在mybatis-config.xml中进行声明◇驼峰命名转换(在mybatis-config中配置)，数据表字段不区分大小写，但java属性区分大小写；防止读取数据库数据时丢失一些例如goods_id字段的数据 1234&lt;settings&gt; &lt;!-- goods_id ==&gt; goodsId 驼峰命名转换 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; ◇编写测试 123456789101112131415@Testpublic void testSelectAll() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); List&lt;Goods&gt; list = session.selectList(&quot;goods.selectAll&quot;); for(Goods g : list)&#123; System.out.println(g.getTitle()); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125;&#125; Sql传参查询 - select1234&lt;select id=&quot;selectById&quot; parameterType=&quot;Integer&quot;resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt;select * from t_goods where goods_id = #&#123;value&#125;&lt;/select&gt; 项目示例①单个参数◇在goods.xml中新增一个select查询 123&lt;select id=&quot;selectById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods where goods_id = #&#123;value&#125; &lt;/select&gt; ◇进行测试 1234567891011121314151617/** * 传递单个SQL参数 * @throws Exception */ @Test public void testSelectById() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.getTitle()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ②多个参数◇session.selectxxx方法无法传递多个参数，所以利用Java.Util.Map键值对来进行多个参数的传递，即参数名为键，值为参数值◇新增查询 123456&lt;select id=&quot;selectByPriceRange&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125; limit 0,#&#123;limt&#125;&lt;/select&gt; ◇测试 1234567891011121314151617181920212223/** * 传递多个(3个)SQL参数 * @throws Exception */ @Test public void testSelectByPriceRange() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Map param = new HashMap(); param.put(&quot;min&quot;,100); param.put(&quot;max&quot; , 500); param.put(&quot;limt&quot; , 10); List&lt;Goods&gt; list = session.selectList(&quot;goods.selectByPriceRange&quot;, param); for(Goods g:list)&#123; System.out.println(g.getTitle() + &quot;:&quot; + g.getCurrentPrice()); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ③多表关联◇Sql语句 12345678910&lt;!-- 利用LinkedHashMap保存多表关联结果 MyBatis会将每一条记录包装为LinkedHashMap对象 key是字段名 value是字段对应的值 , 字段类型根据表结构进行自动判断 优点: 易于扩展,易于使用 缺点: 太过灵活,无法进行编译时检查 --&gt;&lt;select id=&quot;selectGoodsMap&quot; resultType=&quot;java.util.LinkedHashMap&quot;&gt; select g.*,c.category_name from t_goods g, t_category c where g.category_id = c.category_id &lt;/select&gt; ◇测试 123456789101112131415@Test public void testSelectGoodsMap() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); List&lt;Map&gt; list = session.selectList(&quot;goods.selectGoodsMap&quot;); for(Map map : list)&#123; System.out.println(map); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ResultMap结果映射◇ResultMap可以将查询结果映射为复杂类型的Java对象◇ResultMap适用于Java对象保存多表关联结果◇ResultMap支持对象关联查询等高级特性项目示例◇创建类别实体 12345678public class Category &#123; private Integer categoryId; private String categoryName; private Integer parentId; private Integer categoryLevel; private Integer categoryOrder; ...&#125; ◇创建新包dto，用来进行对原始数据的扩展，保存以及传递;如在包中创建GoodsDTO对原始的Goods进行扩展 1234567//Data Transfer Object--数据传输对象public class GoodsDTO &#123; private Goods goods = new Goods(); private Category category = new Category(); private String test;...&#125; ◇结果映射 12345678910111213141516171819202122&lt;!--结果映射--&gt; &lt;resultMap id=&quot;rmGoods&quot; type=&quot;com.lcg.mybatis.dto.GoodsDTO&quot;&gt; &lt;!--设置主键字段与属性映射--&gt; &lt;id property=&quot;goods.goodsId&quot; column=&quot;goods_id&quot;&gt;&lt;/id&gt; &lt;!--设置非主键字段与属性映射--&gt; &lt;result property=&quot;goods.title&quot; column=&quot;title&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.originalCost&quot; column=&quot;original_cost&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.currentPrice&quot; column=&quot;current_price&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.discount&quot; column=&quot;discount&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.isFreeDelivery&quot; column=&quot;is_free_delivery&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.categoryId&quot; column=&quot;category_id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryId&quot; column=&quot;category_id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryName&quot; column=&quot;category_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.parentId&quot; column=&quot;parent_id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryLevel&quot; column=&quot;category_level&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryOrder&quot; column=&quot;category_order&quot;&gt;&lt;/result&gt; &lt;result property=&quot;test&quot; column=&quot;test&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectGoodsDTO&quot; resultMap=&quot;rmGoods&quot;&gt; select g.* , c.*,&#x27;1&#x27; as test from t_goods g , t_category c where g.category_id = c.category_id &lt;/select&gt; ◇测试 123456789101112131415@Test public void testSelectGoodsDTO()throws Exception&#123; SqlSession session = null; try &#123; session = MyBatisUtils.openSession(); List&lt;GoodsDTO&gt; list = session.selectList(&quot;goods.selectGoodsDTO&quot;); for(GoodsDTO g:list)&#123; System.out.println(g.getGoods().getTitle()); &#125; &#125; catch (Exception e) &#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; MyBatis数据写入数据库事务◇数据库事务是保证数据操作完整性的基础 MyBatis写操作包含三种◇插入 - insert 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt;INSERT INTO `babytun`.`t_goods`( `title`, `sub_title`, `original_cost`, current_price`)VALUES ( #&#123;title&#125;, #&#123;subTitle&#125;, #&#123;originalCost&#125;, #&#123;currentPrice&#125;)&lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt;&lt;!-- 当前连接中最后产生的id号 --&gt;select last_insert_id()&lt;/selectKey&gt;&lt;/insert&gt;--示例代码 &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery,category_id) value (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;) //用来将新插入的id回填到类中 &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; &lt;/insert&gt; @Test public void testInsert() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(&quot;测试商品&quot;); goods.setSubTitle(&quot;测试子标题&quot;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); //insert()方法返回值代表本次成功插入的记录总数 int num = session.insert(&quot;goods.insert&quot;, goods); session.commit();//提交事务数据 System.out.println(goods.getGoodsId()); &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇更新 - update 123456789101112131415161718192021222324252627282930313233&lt;update id=&quot;update&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; UPDATE t_goods SET title = #&#123;title&#125; , sub_title = #&#123;subTitle&#125; , original_cost = #&#123;originalCost&#125; , current_price = #&#123;currentPrice&#125; , discount = #&#123;discount&#125; , is_free_delivery = #&#123;isFreeDelivery&#125; , category_id = #&#123;categoryId&#125; WHERE goods_id = #&#123;goodsId&#125; &lt;/update&gt; @Test public void testUpdate() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); //通过selectOne方法得到指定商品编号的goods对象 Goods goods = session.selectOne(&quot;goods.selectById&quot;, 739); goods.setTitle(&quot;更新测试商品&quot;); int num = session.update(&quot;goods.update&quot; , goods); session.commit();//提交事务数据 &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇删除 - delete 1234567891011121314151617181920&lt;!--delete from t_goods where goods_id in (1920,1921)--&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;Integer&quot;&gt; delete from t_goods where goods_id = #&#123;value&#125; &lt;/delete&gt;@Test public void testDelete() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); int num = session.delete(&quot;goods.delete&quot; , 739); session.commit();//提交事务数据 &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; selectKey与useGeneratedKeys的区别◇selectKey标签的用法 123456&lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; INSERT INTO SQL语句 &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; &lt;/insert&gt; ◇useGeneratedKeys属性用法 1234567&lt;insert&gt; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;goodsId&quot; KeyColumn=&quot;goods_id&quot; INSERT INTO SQL 语句&lt;/insert&gt; 二者区别◇selectKey标签需要明确编写获取最新主键的SQL语句◇useGeneratedKeys属性会自动根据驱动生成对应SQL语句◇selectKey适用于所有的关系型数据库◇useGeneratedKeys只适用于能够”自增主键”类型的数据库◇在Oracle(非自增)中selectKey的用法 123456&lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; INSERT INTO SQL语句 &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;BEFORE&quot;&gt; select seq_goods.nextval as id from dual &lt;/selectKey&gt; &lt;/insert&gt; MyBatis预防SQL注入攻击SQL注入攻击 ◇SQL注入是指攻击者利用SQL漏洞,绕过系统约束,越权获取数据的攻击方式 1234567SQL代码:select * from a where name =&#x27;&quot;+ name+&quot;&#x27;&quot;;正常情况:name:张三 -&gt; select * from a where name=&#x27;张三&#x27;;SQL注入攻击:name:&#x27; or 1=1 or 1=&#x27;select * from a where name=&#x27;&#x27; or 1=1 or 1=&#x27;&#x27; MyBatis两种传值方式◇${}文本替换,未经任何处理对SQL文本替换◇ #{}预编译传值,使用预编译传值可以预防SQL注入 MyBatis工作流程◇首先在Java应用中创建mybatis-config.xml文件，用于全局配置，这个配置文件包含了全局设置项、环境配置、mapper声明等核心配置信息；然后在程序的运行过程中通过SqlSessionFactoryBuilder构造器对象来build(构造)SqlSessionFactory工厂类对象；该工厂类对象需要保证全局唯一，用于创建SqlSession对象；SqlSession是我们用于对数据库增删改查的核心对象，它要解析与之对应的mapper.xml文件，每一个mapper.xml文件中包含了大量的sql语句；我们通过SqlSession来访问mapper.xml文件，进而执行其中的sql语句；在SqlSession中主要提供了四种方法(insert | update | delete | select)和数据库进行交互；在进行写的操作时，不要忘记对事务进行相应的提交和回滚；在交互完毕后，应当关闭会话任务，这样我们的底层数据库连接要么被连接池回收要么就直接释放掉；SessionClose这个操作一般放在finally块中，保证它一定能够执行；","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBaits","slug":"Java数据库/MyBaits","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MyBaits/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2022-02-03T00:30:00.000Z","updated":"2022-02-21T14:32:31.231Z","comments":true,"path":"p/8609.html","link":"","permalink":"https://618dt.github.io/p/8609.html","excerpt":"","text":"课程介绍◇实例讲解Lambda语法◇基于Lambda实现函数式编程◇Stream流式处理 初识Lambda表达式什么是Lambda表达式◇JDK8开始支持Lambda表达式,用来让程序编写更优雅◇利用Lambda可以更简洁的实现匿名内部类与函数声明与调用◇基于Lambda提供stream流式处理极大简化对集合的操作 传统代码12345678List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);//实现集合排序Collections.sort(names, new Comparator&lt;String&gt;() &#123;@Overridepublic int compare(String a, String b) &#123;return b.compareTo(a);&#125;&#125;); 使用Lambda表达式123List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);//通过lambda表达式简化匿名类的编写Collections.sort(names, (a,b) -&gt; b.compareTo(a)); Lambda表达式语法Lambda语法格式 Lambda表达式示例1234//四则运算接口interface MathOperation &#123;int operation(int a, int b);&#125; 12345678910111213141516171819public class LambdaSample &#123; public static void main(String[] args) &#123; //1.标准使用方式 //约束条件：Lambda表达式只能实现有且仅有一个抽象方法的接口，java称为&quot;函数式接口&quot; MathOperation addition = (Integer a,Integer b)-&gt;&#123; System.out.println(&quot;加法运算&quot;); return a + b + 0f;//加上0f隐式的将结果转换为浮点型，与接口数据类型对应 &#125;; System.out.println(addition.operation(3,9)); //2.Lambda允许参数类型忽略 MathOperation substraction = (a,b)-&gt;&#123; System.out.println(&quot;减法运算&quot;); return a-b+0f; &#125;; //3.单行实现代码可以省略大括号和return MathOperation multiplication = (a,b)-&gt;a*b+0f; &#125;&#125;//传统方法：新建一个class类，在类中定义运算方法，然后再实例化进行运算 函数式编程什么是函数式编程◇函数式编程是基于函数式接口并使用lambda表达的编程方式◇函数式编程理念是将代码作为可重用数据代入到程序运行中◇函数式编程强调”你想做什么”,而不是”你想怎么做” 什么是函数式接口◇函数式接口是有且只有一个抽象方法的接口◇Java中拥有大量函数式接口,如java.lang.Runnable◇JDK8后提供了一系列新的函数式接口,位于java.util.function◇函数式接口的注解@FunctionInterface用来进行抽象方法检查，防止接口中存在多个方法 函数式接口Predicate◇Predicate是新增的函数式接口,位于java.util.function◇Predicate用于测试传入的数据是否满足判断要求◇Predicate接口需要实现test()方法进行逻辑判断 函数式编程示例◇示例一 1234567891011121314151617181920212223public class PredicateSample &#123; public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate = n-&gt;n&gt;4; boolean result = predicate.test(5); System.out.println(result); List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); /* 传统方法判断奇数，代码写死，不灵活 for(Integer num:list)&#123; if(num%2==1)&#123; System.out.println(num); &#125; &#125;*/ filter(list,n-&gt;n%2==1);//判断奇数，直接传参数即可 filter(list,n-&gt;n%2==0);//判断偶数 &#125; public static void filter(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate)&#123; for(Integer num:list)&#123; if(predicate.test(num))&#123; System.out.print(num + &quot; &quot;); &#125; &#125; &#125;&#125; 函数式编程与面向对象编程比较 函数式接口JDK8常用函数式接口 函数式接口的应用123456789//Function函数式接口说明闭包要求输入参数并返回数据Function&lt;String, String&gt; fn = (str) -&gt; str.toUpperCase();String result = fn.apply(&quot;admin&quot;); //apply用于执行方法返回结果System.out.println(result);//Consumer函数式接口说明闭包只要求输入参数,但不会返回数据Consumer&lt;String&gt; c = arg -&gt; &#123;System.out.println(arg);&#125;;c.accept(&quot;hello&quot;); //accept只接受参数,没有任何结果返回 ◇利用Function函数式接口生成定长随机字符串 123456789101112131415161718public class FunctionSample &#123; public static void main(String[] args) &#123; Function&lt;Integer,String&gt; randomStringFunction = len-&gt;&#123; String chars=&quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;; StringBuffer stringBuffer = new StringBuffer(); Random random = new Random(); for(int i=0;i&lt;len;i++)&#123; //截取某一个字符的位置 int position = random.nextInt(chars.length()); //charAt方法按照指定位置将字符提取出来 stringBuffer.append(chars.charAt(position)); &#125; return stringBuffer.toString(); &#125;; String randomString = randomStringFunction.apply(5); System.out.println(randomString); &#125;&#125; Stream流式处理◇Stream流式处理是建立在Lambda基础上的多数据处理技术◇Stream对集合数据处理进行高度抽象,极大简化代码量◇Stream可对集合进行迭代,去重,筛选,排序,聚合等一系列处理 Stream示例123456//获取List集合中最大的偶数Optional&lt;Integer&gt; op = Arrays.asList(1,2,3,4,5,6).stream().filter(x -&gt; x%2 == 0)//先进行筛选,得到偶数.sorted((a,b) -&gt; b-a)//b-a表示降序,a-b表示升序.findFirst();//取第一个,这里即最大的System.out.println(op.get()); Stream常用方法 Stream操作实例◇Stream流的五种创建方式；最常用的为1,2两种 12345678910111213141516171819202122232425262728293031323334353637383940414243public class StreamGenerator &#123; //1.基于数组创建 @Test public void generator1()&#123; String[] arr = &#123;&quot;莉莉&quot;, &quot;安迪&quot;, &quot;明明&quot;, &quot;牛牛&quot;&#125;; Stream&lt;String&gt; stream = Stream.of(arr); stream.forEach(s-&gt;System.out.println(s)); &#125; //2.基于集合创建 @Test public void generator2()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;莉莉&quot;); list.add(&quot;安迪&quot;); list.add(&quot;马马&quot;); list.add(&quot;牛牛&quot;); Stream&lt;String&gt; stream = list.stream(); stream.forEach(s-&gt; System.out.println(s)); &#125; //3.利用generate方法创建无限长度流 @Test public void generator3()&#123; //bound限制产生的随机数小于其参数 Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; new Random().nextInt(1000)); //limit用来限制流的最大长度，不设置则为无限 stream.limit(10).forEach(i-&gt; System.out.println(i)); &#125; //4.基于迭代器创建 @Test public void generator4()&#123; //seed：起始的数据；n+1表示每一次循环步长为1 Stream&lt;Integer&gt; stream = Stream.iterate(1, n -&gt; n + 1); stream.limit(100).forEach(i-&gt; System.out.println(i)); &#125; //5.基于字符序列创建 @Test public void generator5()&#123; String str = &quot;hello你好&quot;; IntStream stream = str.chars(); //输出为字母的ASCII码或者汉字的Unicode编码;将c强制转换成char类型即可输出原字符 stream.forEach(c -&gt; System.out.println((char)c)); &#125;&#125; ◇Stream流的常用方法 1234567891011121314151617181920212223242526272829303132333435363738public class StreamMethod &#123; //1.提取集合中所有偶数并求和 @Test public void case1()&#123; //List的泛型设为String类型,否则编译器默认s为object,而parseInt不支持object类型 List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;); int sum = list.stream() //获取stream对象 .mapToInt(s-&gt;Integer.parseInt(s)) //mapToInt将流中的每一个数据转换为整数 .filter(n-&gt;n%2==0)//对流中数据进行过滤 .sum();//将所有数据进行求和，数据只能为整数 System.out.println(sum); &#125; //2.所有名字首字母大写 @Test public void case2()&#123; List&lt;String&gt; list = Arrays.asList(&quot;lily&quot;,&quot;smith&quot;,&quot;jackson&quot;,&quot;bob&quot;); List newList = list.stream() /*substring()截取位置为a到b的字符串， 若只有一个参数，则此参数表示从该位置截取 到最后*/ .map(s -&gt; s.substring(0, 1).toUpperCase()+s.substring(1)) //.forEach(s -&gt; System.out.println(s));只能进行打印，没有保存 //collect对流数据进行收集，生成新的List/Set(Set可以将重复数据自动清除) .collect(Collectors.toList());//可以将转换后的结果保存到新的List中 System.out.println(newList); &#125; //3.将所有奇数从大到小进行排序，且不许出现重复 //Set方法可以清楚重复数据，但没有顺序，排序功能会失效 @Test public void case3()&#123; List&lt;Integer&gt; list = Arrays.asList(1,60,38,21,51,60,51,73); List newList = list.stream().distinct()//去除重复的流数据 .filter(n-&gt;n%2==1) .sorted((a,b)-&gt;b-a) .collect(Collectors.toList()); System.out.println(newList); &#125;&#125; 如何通过oracle官网学习Stream流的方法◇官网地址:百度java.util.stream◇查看每一个方法的作用​","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"https://618dt.github.io/tags/Lambda/"}],"author":"LCG"},{"title":"Java反射","slug":"Java反射","date":"2022-02-03T00:24:00.000Z","updated":"2022-02-21T14:32:31.232Z","comments":true,"path":"p/7c7c.html","link":"","permalink":"https://618dt.github.io/p/7c7c.html","excerpt":"","text":"课程介绍◇介绍反射及作用◇讲解反射四个核心类◇反射在项目中的应用 主要知识点◇反射的作用◇Class类◇Constructor构造方法类◇Method方法类◇Field成员变量类 什么是反射Reflect◇反射(Reflect)是在运行时动态访问类与对象的技术◇反射是JDK1.2版本后的高级特性,隶属于java.lang.reflect◇大多数Java框架都基于反射实现参数配置、动态注入等特性◇反射方法与传统方法对比,传统方法要增加乘法类时需要再写一个if else而反射方法支持动态增加方法的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 传统的创建对象方式 */ public static void case1()&#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入计算类名:&quot;); String op = scanner.next(); System.out.print(&quot;请输入a:&quot;); int a = scanner.nextInt(); System.out.print(&quot;请输入b:&quot;); int b = scanner.nextInt(); MathOperation mathOperation = null; if(op.equals(&quot;Addition&quot;))&#123; mathOperation = new Addition(); &#125;else if(op.equals(&quot;Subtraction&quot;)) &#123; mathOperation = new Subtraction(); &#125;else if(op.equals(&quot;Multiplication&quot;))&#123; mathOperation = new Multiplication(); &#125;else&#123; System.out.println(&quot;无效的计算类&quot;); return; &#125; float result = mathOperation.operate(a, b); System.out.println(result); &#125; /** * 利用反射创建对象更加灵活 */ public static void case2()&#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入计算类名:&quot;); String op = scanner.next(); System.out.print(&quot;请输入a:&quot;); int a = scanner.nextInt(); System.out.print(&quot;请输入b:&quot;); int b = scanner.nextInt(); MathOperation mathOperation = null; try &#123; mathOperation = (MathOperation) Class.forName(&quot;com.lcg.reflect.&quot; + op).newInstance(); &#125;catch(Exception e)&#123; System.out.println(&quot;无效的计算类&quot;); return; &#125; float result = mathOperation.operate(a, b); System.out.println(result); &#125; 反射的核心类◇Class类◇Constructor构造方法类◇Method方法类◇Field成员变量类 Class类◇Class是JVM中代表”类和接口”的类◇Class对象具体包含了某个特定类的结构信息◇通过Class对象可获取对应类的构造方法/方法/成员变量 Class核心方法 利用Class创建对象123456789101112131415161718192021public class ClassSample &#123; public static void main(String[] args) &#123; try &#123; //Class.forName()方法将指定的类加载到jvm,并返回对应Class对象(得到员工类对象) Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;); System.out.println(&quot;Employee已被加载到jvm&quot;); //newInstance通过默认构造方法创建新的对象(实例化),返回Object对象，需要强制转换 Employee emp = (Employee)employeeClass.newInstance(); System.out.println(emp); &#125; catch (ClassNotFoundException e) &#123; //类名与类路径书写错误是抛出&quot;类无法找到&quot;异常 e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; //非法访问异常,当在作用域外访问对象方法或成员变量时抛出 e.printStackTrace(); &#125; catch (InstantiationException e) &#123; //对象无法被实例化,抛出&quot;实例化异常&quot; e.printStackTrace();//抽象类(abstract)无法被实例化 &#125; &#125;&#125; Constructor构造方法类◇Constructor类是对Java类中的构造方法的抽象◇Contructor对象包含了具体类的某个具体构造方法的声明◇通过Constructor对象调用带参构造方法创建对象 Constructor类核心方法 利用Constructor创建对象1234567891011121314151617181920212223242526272829public class ConstructorSample &#123; public static void main(String[] args) &#123; try &#123; //得到员工类的类对象 Class employeeClass = Class.forName(&quot;com.lcg.reflect.entity.Employee&quot;); //得到Employee类中包含有四个参数的构造方法对象,Class[]类型数组 Constructor constructor = employeeClass.getConstructor(new Class[]&#123; Integer.class,String.class,Float.class,String.class &#125;); //通过指定构造方法传入数据,创建对象 Employee employee = (Employee) constructor.newInstance(new Object[]&#123; 100,&quot;李磊&quot;,3000f,&quot;研发部&quot; &#125;); System.out.println(employee); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; //没有找到与之对应格式的方法 e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; //当被调用的方法的内部抛出了异常而没有被捕获时 e.printStackTrace(); &#125; &#125;&#125; Method方法类◇Method对象指代某个类中的方法的描述◇Method对象使用classObj.getMethod()方法获取◇通过Method对象调用指定对象的对应方法 Method类核心方法 利用Method执行方法1234567891011121314151617181920212223242526272829303132/** * 利用Method方法类调用 */public class MethodSample &#123; public static void main(String[] args) &#123; try &#123; Class employeeClass = Class.forName(&quot;com.lcg.reflect.entity.Employee&quot;); Constructor constructor = employeeClass.getConstructor(new Class[]&#123; Integer.class, String.class, Float.class, String.class &#125;); //传入参数时用Object[]对象数组 Employee employee = (Employee) constructor.newInstance(new Object[]&#123; 100, &quot;李磊&quot;, 3000f, &quot;研发部&quot; &#125;); Method updateSalaryMethod = employeeClass.getMethod(&quot;updateSalary&quot;, new Class[]&#123; Float.class &#125;); Employee employee1 = (Employee) updateSalaryMethod.invoke(employee, new Object[]&#123;1000f&#125;); System.out.println(employee1); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Field成员变量类◇Field对应某个具体类中的成员变量的声明◇Field对象使用classObj.getField()方法获取◇通过Field对象可为某对象成员变量赋值/取值 Field类核心方法 利用Field赋值与取值1234567...//获取员工姓名Field成员变量对象Field enameField = employeeClass.getField(&quot;ename&quot;);//成员变量赋值enameField.set(employee,&quot;李雷&quot;);//成员变量取值，参数为对象名String ename = (String)enameField.get(employee); getDeclared系列方法◇getDeclaredConstructor(s)|Method(s)|Field(s)获取对应对象(构造方法，方法，成员变量) ,+s表示获取所有(多个)◇getConstructor(s)|Method(s)|Field(s)只能获取public对象◇访问非作用域内构造方法、方法、成员变量,会抛出异常◇public变量.get()直接获取，非public变量先通过类对象获取到get方法再来调用get方法获取 123456789101112131415161718192021222324Class employeeClass = Class.forName(&quot;com.lcg.reflect.entity.Employee&quot;);Constructor constructor = employeeClass.getConstructor(new Class[]&#123; Integer.class, String.class, Float.class, String.class &#125;);Employee employee = (Employee) constructor.newInstance(new Object[]&#123; 100, &quot;李磊&quot;, 3000f, &quot;研发部&quot; &#125;);//获取当前类所有成员变量Field[] fields = employeeClass.getDeclaredFields();for(Field field : fields)&#123; //System.out.println(field.getName()); //对成员变量区分对待 if(field.getModifiers() == 1)&#123; //pubilc修饰 Object val = field.get(employee); System.out.println(field.getName() + &quot;:&quot; + val); &#125;else if(field.getModifiers() == 2)&#123; //private修饰 //构造出get方法名,eg: getSalary(); String methodName = &quot;get&quot; + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1); Method getMethod = employeeClass.getMethod(methodName);//获取类的get方法; Object ret = getMethod.invoke(employee);//执行get方法 System.out.println(field.getName() + &quot;:&quot; + ret); &#125;&#125; 反射在项目中的应用◇网站的国际化 123456789101112131415161718192021public class Application &#123; public static void say()&#123; Properties properties = new Properties();//加载指定配置文件 //获取配置文件路径 String configPath = Application.class.getResource(&quot;/config.properties&quot;).getPath(); try &#123; configPath = new URLDecoder().decode(configPath,&quot;UTF-8&quot;); properties.load(new FileInputStream(configPath)); //用 Properties.getProperty来读取配置文件里面的(language属性)的属性值 String language = properties.getProperty(&quot;language&quot;); //利用language告知Class获取哪一个指定类并实例化 I18N i18n = (I18N)Class.forName(language).newInstance(); System.out.println(i18n.say()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Application.say(); &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://618dt.github.io/tags/%E5%8F%8D%E5%B0%84/"}],"author":"LCG"},{"title":"工厂模式","slug":"工厂模式","date":"2022-02-03T00:22:00.000Z","updated":"2022-02-21T14:32:31.240Z","comments":true,"path":"p/177d.html","link":"","permalink":"https://618dt.github.io/p/177d.html","excerpt":"","text":"课程介绍◇ 介绍工厂模式的用途与特点◇ 介绍设计模式◇ 掌握工厂模式的项目应用 设计模式◇ 设计模式是前辈总结的设计经验◇ 设计模式的目标是代码更容易理解,更容易维护◇ 通过设计模式可以让代码更加可靠 设计模式的分类◇ 创建型模式◇ 结构型模式◇ 行为型模式 工厂模式◇ 工厂模式用于隐藏创建对象的细节◇ 工厂模式核心:工厂类(Factory)◇ 工厂模式可细分为简单工厂、工厂方法与抽象工厂 简单工厂 项目应用-i18n国际化◇工程结构◇软件类 123456public class Software &#123; public static void main(String[] args) &#123; I18N i18n = I18NFactory.geI18NObject(&quot;China&quot;);//静态的，不需要new，直接调用方法即可 System.out.println(i18n.getTitle()); &#125;&#125; ◇国际化工厂类 12345678910111213public class I18NFactory &#123; public static I18N geI18NObject(String area) &#123;//静态工厂 if(area.equals(&quot;China&quot;)) &#123; return new Chinese(); &#125;else if(area.equals(&quot;UK&quot;)) &#123; return new English(); &#125;else if(area.equals(&quot;Japan&quot;)) &#123; return new Japanese(); &#125;else &#123; return null; &#125; &#125;&#125; ◇语言类 12345public class Chinese implements I18N &#123; public String getTitle() &#123; return &quot;这是中文&quot;; &#125;&#125; ◇接口 123public interface I18N &#123; public String getTitle();&#125; ◇面向接口的开发 项目应用-多端应用切换◇工程目录◇工厂类 12345678910111213public class DeviceFactory &#123; public static Device getDevice(HttpServletRequest req) &#123; String userAgent=req.getHeader(&quot;user-agent&quot;); System.out.println(userAgent); if(userAgent.indexOf(&quot;Windows NT&quot;)!=-1) &#123; return new DesktopDevice(); &#125;else if(userAgent.indexOf(&quot;iPhone&quot;)!=-1 || userAgent.indexOf(&quot;Android&quot;)!=-1) &#123; return new MobileDevice(); &#125;else &#123; return null; &#125; &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"LCG"},{"title":"Maven项目管理","slug":"Maven项目管理","date":"2022-02-02T23:54:00.000Z","updated":"2022-02-21T14:32:31.235Z","comments":true,"path":"p/316f.html","link":"","permalink":"https://618dt.github.io/p/316f.html","excerpt":"","text":"课程介绍 ◇ 介绍Maven的核心特性 ◇ 掌握Maven的依赖管理 ◇ 掌握Maven的打包方式 Maven介绍 ◇ Maven 是项目管理工具,对软件项目提供构建与依赖管理 ◇ Maven是Apache下的Java开源项目 ◇ Maven为Java项目提供了统一的管理方式，已成为业界标准 Maven核心特性◇ 项目设置遵循统一的规则，保证不同开发环境的兼容性 Maven核心特性◇ 强大的依赖管理，项目依赖组件自动下载、自动更新◇ 可扩展的插件机制，使用简单，功能丰富 Maven的安装与配置Maven的坐标 ◇ GroupId：机构或者团体的英文，采用”逆向域名”形式书写 ◇ ArtifactId：项目名称,说明其用途，例如：cms、oa… ◇ Version：版本号，一般采用”版本+单词”形式，例如：1.0.0.RELEASE Maven项目标准结构 Maven依赖管理◇Maven利用dependency(依赖)自动下载、管理第三发jar◇在pom.xml文件中配置项目依赖的第三方组件◇maven自动将依赖从远程仓库下载至本地仓库，并在工程中引用◇maven中央仓库检索网站◇pinyin4j将汉字转换为拼音 配置 12345&lt;dependency&gt; &lt;groupId&gt;com.belerweb&lt;/groupId&gt; &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt;&lt;/dependency&gt; 代码 12345678public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String str = scan.nextLine(); String[] pinyin = PinyinHelper.toHanyuPinyinStringArray(&#x27;李&#x27;); for(String py : pinyin) &#123; System.out.println(py); &#125; &#125; ◇配置多个jar包:依赖本身也依赖于底层jar包，因此有多个jar包 本地仓库与中央仓库 本地仓库目录 ◇创建备份服务器，提高下载速度 12345678&lt;repositories&gt; &lt;repository&gt; &lt;!-- 创建私服的地址 --&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 项目打包 ◇ Maven可将Java项目打包为jar、war包 ◇ Maven项目打包是通过Plugins（插件）技术实现 ◇ Maven输出Jar包插件：maven-assembly-plugin ◇ 配置文件 123456789101112131415161718192021&lt;build&gt; &lt;!-- 配置插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;mainfest&gt; &lt;mainClass&gt;com.lcg.maven.PinyinTestor&lt;/mainClass&gt; &lt;/mainfest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;!-- all in one 在打包时会将所有引用的jar合并到输出的jar文件中 --&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ◇ 配置运行◇ 打包成功后的运行命令 1java -jar maven-1-1.0.0-RELEASE-jar-with-dependencies.jar Maven构建Web工程◇创建maven项目-&gt;配置JRE：JRE System Library-&gt;properties-&gt;Workspace default JRE-&gt;Apply and Close◇修改JDK编译级别：工程名-&gt;properties-&gt;Java Compiler-&gt;Compiler compliance level(编译级别):1.8-OK◇在src/main目录下创建webapp文件夹◇工程名-&gt;properties-&gt;Project Facets-&gt;Convert to faceted form-&gt;勾选Dynamic Web Module 3.1-&gt;Runtimes:指定Apache Tomcat-&gt;Further configuration available-&gt;Content directory:src/main/webapp-&gt;勾选web.xml-OK-&gt;Apply and Close Web工程打包◇遇见错误：将jar文件复制到工程的WEB-INF/lib目录即可◇配置：RunConfigurations-&gt;MavenBuild-&gt;NewConfiguration-&gt;Name:build-war-&gt;Base directory:指向工程-&gt;Goals:package-&gt;Apply-&gt;Run◇pom.xml 1234567891011121314151617181920212223242526272829&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation= &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lcg&lt;/groupId&gt; &lt;artifactId&gt;maven&lt;/artifactId&gt; &lt;version&gt;1.0.0-RELEASE&lt;/version&gt; &lt;!-- packaging代表输出的格式 --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 自定义解压文件名 --&gt; &lt;build&gt; &lt;finalName&gt;maven-web&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Maven常用命令◇需要配置环境变量◇在cmd中使用 修改本地仓库地址◇打开F:\\JAVA\\tool\\apache-maven-3.6.0\\conf中的settings.xml文件◇修改49-52处的代码 12345678910111213修改前 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; 修改后 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository --&gt; &lt;localRepository&gt;G:/maven-repo&lt;/localRepository&gt; ◇Eclipse中配置：Window-&gt;Preferences-&gt;Maven-&gt;User Settings:选择apache-maven-3.6.0\\conf中的settings.xml文件-&gt;Reindex-Apply and Close 在IDEA中配置Maven◇Settings-&gt;Build,Execution-&gt;Build Tools-&gt;Maven-&gt;Maven home directory: ;User settings file: ;Local repository:◇创建Maven项目：New Project-&gt;Maven-&gt;Next-&gt;GroupID;ArtifactID;Version-&gt;Next-&gt;Finish◇IDEA关于Maven的快捷键:点击右边的Maven弹出界面,即Maven的常用命令","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://618dt.github.io/tags/Maven/"}],"author":"LCG"},{"title":"JDBC入门","slug":"JDBC入门","date":"2022-02-02T23:49:00.000Z","updated":"2022-02-21T14:32:31.230Z","comments":true,"path":"p/8791.html","link":"","permalink":"https://618dt.github.io/p/8791.html","excerpt":"","text":"课程介绍◇JDBC快速入门◇精讲JDBC开发细节◇连接池与JDBC进阶使用 主要知识点◇JDBC使用步骤◇数据库查询方法◇数据库写入方法◇SQL注入攻击的应对◇连接池的使用◇Apache Commons DBUtils 什么是JDBC◇Java数据库连接-Java DataBase Connectivity◇JDBC可让Java通过程序操作关系型数据库◇JDBC基于驱动程序实现与数据库的连接与操作 什么是驱动程序 ◇JDBC驱动程序 JDBC的优点◇统一的API,提供一致的开发过程◇易于学习,容易上手,代码结构稳定◇功能强大,执行效率高,可处理海量数据 JDBC开发简要流程0.Navicat创建数据库：字符集采用utf8mb4 1. 加载并注册JDBC驱动◇将MySQL驱动的jar包复制到工程的lib目录-&gt;File-&gt;Project Structure-&gt;Modules(模块)-&gt;Dependencies(依赖)-&gt;’+’-&gt;1-&gt;选择lib目录下的jar包，OK-&gt;勾选Export-&gt;OK 1Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 2. 创建数据库连接12&quot;jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;, &quot;root&quot;,&quot;www.LCG.com&quot; 3. 创建Statement对象12Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(&quot;select * from employee&quot;); 4. 遍历查询结果123456while (rs.next()) &#123; Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置 String ename = rs.getString(&quot;ename&quot;);//获取ename列的数据（数据为String型），按名称 Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); 5. 关闭连接,释放资源123if (conn!=null&amp;&amp;conn.isClosed()==false)&#123;//防止空指针异常 //5. 关闭连接,释放资源 conn.close();//如果conn为空，则会出现空指针异常，如执行1.就报错后，conn为空&#125; JDBC开发详细流程如何获取JDBC驱动Jar◇Mysql官网下载MySQL Connectors -&gt;JDBC Driver for MySQL-&gt;由于是跨平台的，选择任意版本即可Ubuntu Linux-&gt;直接下载 创建数据库连接代码123456789String dbDriver = &quot;com.mysql.cj.jdbc.Driver&quot;; //JDBC驱动类String dbURL = &quot;jdbc:mysql://localhost:3306/gamest&quot; ; //连接字符串String dbUsername = &quot;root&quot;; //数据库用户名String dbPassword = &quot;123456&quot;; //数据库密码//1.加载并初始化JDBC驱动Class.forName(dbDriver);//2.创建数据库连接Connection connection = DriverManager.getConnection(dbURL, dbUsername, dbPassword); Class.forName的作用◇Class.forName用于加载指定的JDBC驱动类◇Class.forName本质是通知JDBC注册这个驱动类◇驱动由数据库厂商自行开发,连接字符串也不同 数据库与连接字符串 DriverManager◇DriverManager用于注册/管理JDBC驱动程序◇DriverManager.getConnection(连接字符串,用户名,密码)◇返回值Connection对象,对应数据库的物理网络连接 Connection对象◇Connection对象用于JDBC与数据库的网络通信对象◇java.sql.Connection是一个接口，具体由驱动厂商实现◇所有数据库的操作都建立在Connection基础上 MySQL连接字符串◇格式: jdbc:mysql://[主机ip][:端口]/数据库名?参数列表◇主机ip与端口是可选设置,默认值为127.0.0.1与3306◇参数列表采用url编码,格式:参数1=值1&amp;参数2=值2&amp;… MySQL连接字符串常用参数 连接数据库的常见问题◇ClassNotFoundException - 类未找到异常◇Connection refuse - 数据库连接被拒绝异常◇Access denied for user - 用户名与密码错误异常 数据库查询操作◇部分代码 1234567891011121314151617181920212223242526272829303132//4. 遍历查询结果 /*rs.next()返回布尔值，代表是否存在下一条记录，若有，返回true 同时提取下一条记录；如果没有，返回false，循环就会停止*/ while (rs.next())&#123; Integer eno = rs.getInt(1);//JDBC中字段索引从1开始 String ename = rs.getString(&quot;ename&quot;);//获取ename列的数据（数据为String型），按名称 Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); &#125; //5.关闭连接，释放资源 try &#123; if(rs!=null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(stmt!=null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null&amp;&amp;!conn.isClosed())&#123;//不为空并且没有关闭 conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; Statement对象◇Statement是用于执行SQL的工具◇查询方法: ResultSet executeQuery(String sql)◇注意: sql参数必须是SELECT 查询SQL语句 ResultSet对象◇ResultSet结果集对象,保存查询结果◇ResultSet采用迭代方式逐行获取每一行表数据◇每一次迭代,使用ResultSet对象的getXXX()方法获取列数据 SQL注入攻击◇SQL注入攻击是指利用SQL漏洞越权获取数据的黑客行为◇SQL注入攻击根源是未对原始SQL中的敏感字符做特殊处理◇解决方法:放弃Statement改用PreparedStatement处理SQL PreparedStatement◇PreparedStatement 预编译Statement是Statement接口的子接口◇PreparedStatement对SQL进行参数化,预防SQL注入攻击◇PreparedStatement比Statement执行效率更高◇原始代码 123456789// 存在SQL注入风险// pdname值为&#x27; or 1=1 or 1=&#x27;时,所有筛选条件均失效// SQL: select * from employee where pdname=&#x27;&#x27; or 1=1 or 1=&#x27;&#x27; ;单引号没有处理String sql = &quot;select * from employee where dname=&#x27;&quot; + pdname + &quot;&#x27;&quot; ;Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery(sql);while(rs.next())&#123;....&#125; ◇PreparedStatement 12345678910// 利用PreparedStatement预防SQL注入风险// 当dname值为&#x27; or 1=1 or 1=&#x27;时 , 查询不到任何结果// SQL: select * from employee where dname=&#x27;\\&#x27; or 1=1 or 1=\\&#x27;&#x27; ;单引号被处理String sql = &quot;select * from employee where dname=?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1,dname); //设置SQL参数,参数从1开始ResultSet rs = pstmt.executeQuery();while(rs.next())&#123;....&#125; ◇示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.lcg.jdbc.hrapp.command;import java.sql.*;import java.util.Scanner;/** * PreparedStatement对象使用方法 */public class PstmtQueryCommand implements Command &#123; @Override public void execute() &#123; System.out.print(&quot;请输入部门名称：&quot;); Scanner in = new Scanner(System.in); String pdname = in.nextLine(); Connection conn = null; //Statement stmt = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; //1. 加载并注册JDBC驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2. 创建数据库连接 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;); //3. 创建PreparedStatement对象 String sql = &quot;select * from employee where dname=? and eno &gt; ?&quot;; pstmt = conn.prepareStatement(sql); pstmt.setString(1, pdname); //注意:参数索引从1开始 pstmt.setInt(2, 3500);//2,即第二个参数 //结果集 rs = pstmt.executeQuery(); //4. 遍历查询结果 //rs.next()返回布尔值，代表是否存在下一条记录 //如果有，返回true,同时结果集提取下一条记录 //如果没有，返回false，循环就会停止 while (rs.next()) &#123; Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0 String ename = rs.getString(&quot;ename&quot;); Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //5. 关闭连接,释放资源 try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (pstmt != null) &#123; pstmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null &amp;&amp; !conn.isClosed()) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 错误的使用方式◇select * from employee where ?=’abc’◇select * from employee where salary = ?+100◇select ? from employee where ename = ? JDBC实现写数据封装DbUtils工具类◇工具类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DbUtils &#123; /** * 在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板 * 创建新的数据库连接 * @return 新的Connection对象 * @throws SQLException * @throws ClassNotFoundException */ public static Connection getConnection() throws SQLException, ClassNotFoundException &#123; //1. 加载并注册JDBC驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2. 创建数据库连接 Connection conn = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;, &quot;root&quot;, &quot;www.LCG.com&quot; ); return conn; &#125; /** * 关闭连接，释放资源 * @param rs 结果集对象 * @param pstmt Statement对象 * @param conn Connection对象 */ public static void closeConnection(ResultSet rs, PreparedStatement pstmt,Connection conn)&#123; try &#123; if(rs!=null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(pstmt!=null)&#123; pstmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null&amp;&amp;!conn.isClosed())&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDBC执行INSERT语句1234567String sql= &quot;insert into employee(eno,ename) values(?,?)&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setInt(1,10);pstmt.setString(2,&quot;张三&quot;);//executeUpdate方法返回记录数int cnt = pstmt.executeUpdate(); //cnt=1,表示sql语句所影响的数据库的行数System.out.println(&quot;数据新增成功&quot;); ◇新增员工数据 12345678910111213141516171819202122232425262728293031323334public class InsertCommand implements Command&#123; @Override public void execute()&#123; Scanner in = new Scanner(System.in); System.out.println(&quot;请输入员工编号&quot;); int eno = in.nextInt(); System.out.println(&quot;请输入员姓名&quot;); String ename = in.next(); System.out.println(&quot;请输入员工薪资&quot;); float salary = in.nextFloat(); System.out.println(&quot;请输入隶属部门&quot;); String dname = in.next(); Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = DbUtils.getConnection(); String sql = &quot;insert into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;; pstmt = conn.prepareStatement(sql); pstmt.setInt(1, eno); pstmt.setString(2, ename); pstmt.setFloat(3, salary); pstmt.setString(4, dname); int cnt = pstmt.executeUpdate();//所有写操作都使用executeUpdate System.out.println(&quot;cnt:&quot;+cnt); System.out.println(ename+&quot;员工入职手续办理成功&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; DbUtils.closeConnection(null,pstmt,conn); &#125; &#125;&#125; JDBC执行UPDATE语句123456String sql= &quot;update employee set salary=salary + 1000 where dname=?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1,&quot;研发部&quot;);//executeUpdate方法返回记录数int cnt = pstmt.executeUpdate();System.out.println(&quot;研发部&quot; + cnt + &quot;名员工提薪1000元&quot;); JDBC执行DELETE语句123456String sql= &quot;delete from employee where eno = ?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setInt(1, 3395);//executeUpdate方法返回记录数int cnt = pstmt.executeUpdate();System.out.println(cnt+&quot;名员工数据已被删除&quot;); JDBC中的事务管理什么是事务◇事务是以一种可靠的、一致的方式，访问和操作数据库的程序单元◇说人话：要么把事情做完，要么什么都不做，不要做一半◇事务依赖于数据库实现,MySQL通过事务区作为数据缓冲地带 事务的提交操作 事务的回滚操作 JDBC两种事务模式◇JDBC允许两种事务模式◇自动提交事务模式◇手动提交事务模式 自动提交事务模式◇自动提交模式是指每执行一次写操作SQL,自动提交事务◇自动提交开启方法: conn.setAutoCommit(true)◇自动事务是JDBC默认行为,此模式无法保证多数据一致性 手动提交事务模式◇手动提交模式是指显式调用commit()与rollback()方法管理事务◇手动提交开启方法: conn.setAutoCommit(false)◇手动提交事务可保证多数据一致性,但必须手动调用提交/回滚方法 实现批量增加员工1234567891011121314151617181920212223242526272829303132333435363738/** * JDBC中的事务机制 */public class TransactionSample &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = DbUtils.getConnection(); //JDBC默认使用自动提交模式 conn.setAutoCommit(false);//设置手动提交 String sql = &quot;insert into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;; for(int i=100;i&lt;200;i++)&#123;/* if(i==105)&#123; throw new RuntimeException(&quot;插入失败&quot;);//模拟抛出异常 &#125;*/ pstmt = conn.prepareStatement(sql); pstmt.setInt(1,i); pstmt.setString(2, &quot;员工&quot; + i); pstmt.setFloat(3, 5000); pstmt.setString(4, &quot;市场部&quot;); pstmt.executeUpdate(); &#125; conn.commit();//当for循环全部完成后，才开始进行提交 &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; if (conn!=null&amp;&amp;!conn.isClosed()) &#123; conn.rollback();//发生异常回滚 &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; DbUtils.closeConnection(null,pstmt,conn); &#125; &#125;&#125; 基于实体类实现分页数据封装◇实体类代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 员工实体类 */public class Employee &#123; /** * 需符合javabean的要求 * 1.具备默认构造函数 * 2.属性私有 * 3.存在getter与setter */ public Employee()&#123;&#125; private Integer eno; private String ename; private Float salary; private String dname; public Integer getEno() &#123; return eno; &#125; public void setEno(Integer eno) &#123; this.eno = eno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public Float getSalary() &#123; return salary; &#125; public void setSalary(Float salary) &#123; this.salary = salary; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125;&#125; ◇分页命令代码 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 分页查询员工数据 */public class PaginationCommand implements Command &#123; @Override public void execute()&#123; Scanner in = new Scanner(System.in); System.out.println(&quot;请输入页号：&quot;); int page = in.nextInt(); Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; List&lt;Employee&gt; list = new ArrayList();//存储查询结果 try &#123; conn = DbUtils.getConnection(); String sql = &quot;select * from employee limit ?,10&quot;;//10代表从？开始往后取10条记录 pstmt = conn.prepareStatement(sql); pstmt.setInt(1,(page-1)*10);//分页公式 rs = pstmt.executeQuery(); while (rs.next())&#123; Integer eno = rs.getInt(&quot;eno&quot;); String ename = rs.getString(&quot;ename&quot;); Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); Employee emp = new Employee(); emp.setEno(eno); emp.setEname(ename); emp.setSalary(salary); emp.setDname(dname); list.add(emp);//将emp实体加到list集合中 &#125; System.out.println(list.size()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; DbUtils.closeConnection(rs, pstmt, conn); &#125; &#125;&#125; JDBC中Date日期对象的处理◇实体类中添加日期 1234567private Date hiredate;public Date getHiredate() &#123; return hiredate; &#125;public void setHiredata(Date hiredate) &#123; this.hiredate = hiredate; &#125; ◇分页命令添加日期 1234//JDBC获取日期使用java.sql.Date,其继承自java.util.Date//所以两者互相兼容Date hiredata = rs.getDate(&quot;hiredate&quot;); emp.setHiredate(hiredate); ◇向数据库中写入日期时需要使用java.sql.Date 12345678910111213141516System.out.println(&quot;请输入入职日期&quot;); String strHiredate = in.next(); //String 到java.sql.Date分为两步 //1.将String转为java.util.Date SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); java.util.Date udHiredate = null; try &#123; udHiredate = sdf.parse(strHiredate); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; //2.将util转为sql long time = udHiredate.getTime();//获取1970年到现在的毫秒数 java.sql.Date sdHiredate = new java.sql.Date(time); pstmt.setDate(5,sdHiredate);//java.sql.Date JDBC数据批处理◇批处理部分代码 1234567891011pstmt = conn.prepareStatement(sql); for(int i=100000;i&lt;200000;i++)&#123; pstmt.setInt(1,i); pstmt.setString(2, &quot;员工&quot; + i); pstmt.setFloat(3, 5000f); pstmt.setString(4, &quot;市场部&quot;); pstmt.addBatch();//将参数加入批处理任务 //pstmt.executeUpdate(); &#125; pstmt.executeBatch();//执行批处理任务 conn.commit();//当for循环全部完成后，才开始进行提交 ◇批处理效率高的原因：在标准方法中，创建了十万个prepareStatement对象，每一个对象都是新增一条数据；而在批处理方法中，是用一个对象新增十万条数据； 连接池与JDBC进阶使用◇连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用 阿里巴巴Druid连接池◇Druid是阿里巴巴开源连接池组件,是最好的连接池之一◇Druid对数据库连接进行有效管理与重用,最大化程序执行效率◇连接池负责创建管理连接,程序只负责取用与归还 Druid连接池配置与使用◇配置.properties文件 1234567//不需要引号和分号,将初始尺寸和最大尺寸设为一致可便于维护driverClassName=url=username=password=initialSize=10 //初始尺寸:连接池默认创建10个数据库连接maxActive=20 //最大尺寸:数据库不够用时，创建的最大连接数，还不够用则需等待 ◇使用连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Druid连接池配置与使用 */public class DruidSample &#123; public static void main(String[] args) &#123; //1.加载属性文件 Properties properties = new Properties(); //作用：获取当前类(DruidSample)路径下对应文件的路径，因为配置文件会随着代码运行而发布到运行文件夹中 String propertyFile = DruidSample.class.getResource(&quot;/druid-cofig.properties&quot;).getPath(); //在上面获取的路径中getPath方法会进行URL编码:空格-&gt;%20 // 如：原始路径：c:\\java code 转换后的路径：c:\\java%20code; // 使用URLDecoder().decode()方法进行容错，将%20还原为空格 try &#123; propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;); properties.load(new FileInputStream(propertyFile));//加载,load参数为文件流 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; try &#123; //2.获取DataSource数据源对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//DataSource选择sql //3.创建数据库连接 conn = dataSource.getConnection(); psmt = conn.prepareStatement(&quot;select * from employee limit 0,10&quot;); rs = psmt.executeQuery(); while (rs.next()) &#123; Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置 String ename = rs.getString(&quot;ename&quot;);//获取ename列的数据（数据为String型），按名称 Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; /** * 不使用连接池：conn.close()关闭连接 * 使用连接池：conn.close()将连接回收至连接池 */ DbUtils.closeConnection(rs,psmt,conn); &#125; &#125;&#125; 扩展知识:C3P0连接池◇配置文件，使用xml且文件名必须为：c3p0-config.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driveClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;www.LCG.com&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; ◇使用 123456789101112public class C3P0Sample &#123; public static void main(String[] args) &#123; //1.加载配置文件 //2.创建DataSource DataSource dataSource = new ComboPooledDataSource(); //3.得到数据库连接 Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; ..... &#125;&#125; Apache Commons DBUtils◇commons-dbutils是Apache提供的开源JDBC工具类库◇它是对JDBC的简单封装,学习成本极低◇使用commons-dbutils可以极大简化JDBC编码工作量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Apache DBUtils + Druid联合使用 */public class DbUtilsSample &#123; private static void query()&#123; Properties properties = new Properties(); String propertyFile = DruidSample.class.getResource(&quot;/druid-config.properties&quot;).getPath(); try &#123; propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;); properties.load(new FileInputStream(propertyFile)); DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); //利用Apache DbUtils大幅简化了数据的提取过程 /** * BeanListHandler将结果集包装成list对象 * Object[]&#123;1&#125;用来传递参数，这里表示？=1 */ QueryRunner qr = new QueryRunner(dataSource); List&lt;Employee&gt; list = qr.query(&quot;select * from employee limit ?,10&quot;, new BeanListHandler&lt;&gt;(Employee.class), new Object[]&#123;1&#125;); for (Employee emp : list) &#123; System.out.println(emp.getEname()+&quot;--&quot;+emp.getSalary()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;//自动关闭数据库连接 &#125; public static void update()&#123; Properties properties = new Properties(); String propertyFile = DruidSample.class.getResource(&quot;/druid-config.properties&quot;).getPath(); Connection conn = null; try &#123; propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;); properties.load(new FileInputStream(propertyFile)); DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); conn = dataSource.getConnection();//创建连接 conn.setAutoCommit(false);//关闭自动提交 String sql1 = &quot;update employee set salary=salary+10000 where eno=?&quot;; String sql2 = &quot;update employee set salary=salary-1000 where eno=?&quot;; QueryRunner qr = new QueryRunner(); qr.update(conn,sql1,new Object[]&#123;1&#125;); qr.update(conn, sql2, new Object[]&#123;100&#125;); conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; if (conn!=null&amp;&amp;!conn.isClosed())&#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally &#123; try &#123; if(conn!=null&amp;&amp;!conn.isClosed())&#123; conn.close();//对数据库连接进行回收，前面手动创建了连接 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; query(); //update(); &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java数据库开发基础","slug":"Java数据库/Java数据库开发基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"IDEA开发工具入门","slug":"IntelliJ IDEA开发工具入门","date":"2022-02-02T23:44:00.000Z","updated":"2022-02-21T14:32:31.227Z","comments":true,"path":"p/5708.html","link":"","permalink":"https://618dt.github.io/p/5708.html","excerpt":"","text":"导学◇IntelliJ IDEA开发工具![image.png](IntelliJ IDEA开发工具入门/1627031307362-df459f62-a437-412b-98d4-032af338ced4.png)◇JDBC![image.png](IntelliJ IDEA开发工具入门/1627031379177-38c40c23-926b-4f28-b27e-d9b05895bdf0.png) ◇数据库连接池与DBUtils![image.png](IntelliJ IDEA开发工具入门/1627031423402-2d5357f4-8868-460e-bdf3-e131bba797d5.png) IDEA开发工具入门IntelliJ IDEA◇IDEA全称IntelliJ IDEA ,是Java编程公认的最好的IDE◇IDEA提供了大量的智能工具，例如语法提示，代码分析，格式化等◇IDEA最核心的特色是它的快捷键，利用快捷键可以极大提高开发效率 IDEA的特点◇沉浸式开发体验◇超强的快捷键体系◇智能的代码助手◇全栈开发环境◇丰富的模板支持 IDEA快捷键IDEA窗口快捷键◇Find Action即模糊查询所有的功能![image.png](IntelliJ IDEA开发工具入门/1627034483641-291f75af-d7ad-48a5-a4d5-fd4466b7a384.png) 代码快捷键![image.png](IntelliJ IDEA开发工具入门/1627035810111-7868b20d-b5b8-44c3-b520-f7fe08cb09e9.png)![image.png](IntelliJ IDEA开发工具入门/1627035825273-6cfd6292-c04a-4cfa-ac9a-38797269ca46.png) 代码快速定位![image.png](IntelliJ IDEA开发工具入门/1627045126097-c1703455-f245-4358-b636-0bebf19ac62e.png) Live Template◇也可以自定义，自定义方法为：settings-&gt;Editor-&gt;Live Template-&gt;’+’ 2-&gt;’+’1;​ ![image.png](IntelliJ IDEA开发工具入门/1627045672656-22d16bcf-8e69-4516-9915-68c68efec231.png) 运行与打包◇打包方法：File-&gt;Project Structure-&gt;Artifacts-&gt;’+’ -&gt;JAR-&gt;empty-&gt;Create Manifest(定义入口类)-&gt;默认选中-&gt;OK-&gt;选择入口类-&gt;将右侧的compile output双击添加到左侧(即将编译后的类打入JAR包)-&gt;OK-&gt;.MF文件创建成功-&gt;Build-&gt;Build Artifacts -&gt;Action:Bulid-&gt;生成jar包在生成的jar包上右键选中Open in File path( Show in explore在文件管理器中打开)-&gt;在地址栏中删掉地址然后直接输入cmd进入命令行(会自动定位到目录地址)-&gt;键入java -jar 文件名.jar![image.png](IntelliJ IDEA开发工具入门/1627046432804-188ee97a-c21c-4cd5-b9b4-fa4f47c59270.png) 其他快捷键◇查看方法返回类型：Ctrl+q◇查看方法的具体实现：Ctrl+Alt◇方法或类注释：在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板 IDEA开发Web应用◇NewProjece-&gt; Java Enterprise -&gt;服务器选择Tomcat -&gt;勾选WebApplication 3.1-&gt;勾选create web.xml-&gt;Next-&gt;输入工程名称-&gt;finish;◇如何更改URL的上下文路径: 点击Tomcat下拉框-&gt;Edit Configurations -&gt;Deployment-&gt;Application context-&gt;修改-&gt;OK◇热部署(即修改项目后在浏览器能直接查看，只支持在DeBug模式下)：点击Tomcat下拉框-&gt;Edit Configurations -&gt;Server-&gt;On frame deactivation-&gt;Update classes and resources-&gt;OK◇打包Web项目：File-&gt;Project Structure-&gt;Artifacts-&gt;’+’Web Application:Archive-&gt;Empty-&gt;双击compile output添加到左侧war包中-&gt;双击Web facet resource将静态资源放入左侧-&gt;OK-&gt;Build-&gt;Build Artifact -&gt;选择打包文件-&gt;Build -&gt;复制.war文件将其放到Tomcat实际运行环境的webapps目录下-&gt;在Tomcat/bin目录中双击startup.bat文件启动Tomcat-&gt;浏览器输入路径即可![image.png](IntelliJ IDEA开发工具入门/1627096260390-f697c0eb-8644-4516-bc22-fa9ba432d2e0.png)","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java数据库开发基础","slug":"Java数据库/Java数据库开发基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://618dt.github.io/tags/%E5%BC%80%E5%8F%91/"}],"author":"LCG"},{"title":"MySQL综合应用","slug":"MySQL综合应用","date":"2022-01-28T05:44:00.000Z","updated":"2022-02-21T14:32:31.238Z","comments":true,"path":"p/c9e2.html","link":"","permalink":"https://618dt.github.io/p/c9e2.html","excerpt":"","text":"数据库的事务机制避免写入直接操作数据文件 ◇ 如果数据的写入直接操作数据文件是非常危险的事情 利用日志来实现间接写入◇ MySQL总共有5种日志，其中只有redo(重做)日志和undo(撤销)日志与事务有关 事务机制（Transaction）◇ RDBMS = SQL语句 + 事务（ACID）◇ 事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要 么全都执行失败 事务案例◇ 把10部门中MANGER员工调往20部门，其他岗位的员工调往30部门，然后删除10部门 管理事务◇ 默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务◇ 为了让多条SQL语句纳入到一个事务之下，可以手动管理事务 123START TRANSACTION ;//开启事务SQL语句[ COMMIT | ROLLBACK ] ;//提交|回滚 事务的ACID属性 事务的原子性◇ 一个事务中的所有操作要么全部完成，要么全部失败。事务执行后 ，不允许停留在中间某个状态 事务的一致性◇ 不管在任何给定的时间、并发事务有多少，事务必须保证运行结果 的一致性◇ 事务可以并发执行，但是最终MySQL却串行执行 事务的隔离性◇ 隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务是数据库唯一运行的事物◇ 默认情况下A事务，只能看到日志中该事务的相关数据 事务的持久性 ◇事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化 事务的四个隔离级别 修改事务隔离级别◇在Navicat中开启两个sql面板可以模拟两个不同的事务；Mysql默认的隔离级别是REPEATABLE READ◇ READ UNCOMMITTED 代表可以读取其他事务未提交的数据 12SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; ◇ READ COMMITTED 代表只能读取其他事务提交的数据 12SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; ◇ REPEATABLE READ 代表事务在执行中反复读取数据，得到的结果是一致的，不会受其他事务影响 12SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; 业务案例①比如说购票场景里面，由于事务之间是隔离的，所以A、B两事务分别对第一条记录进行操作；A事务修改将其改为已售出，但是A事务未进行提交，因此真实的数据还是未售出状态；B事务将其改为已售出，并且很快进行提交；那么当A进行提交时，发现记录变成了已售出，就会发生回滚，即修改失败；虽然说没有产生有歧义的数据，但是动不动就购票失败，十分影响用户体验；因此在这个场景下我们应当允许事务去读取其他事务的临时状态；B事务可以看到A事务里的临时信息，即修改了第一条记录，但未提交；那么B就无法修改此记录；就不会引发数据冲突了；所以这里使用的隔离级别为:READ UNCOMMITTED②对于银行转账之类的业务场景；就只能让当前事务去读取其他事务已经提交的数据，而不能够去读取其他事务的临时数据;比如说下面的Scott账户，假设B事务执行，需要支出100元，但是还没有提交；而这时A事务进行转账操作，由于可以看到B事务的临时数据，所以A事务看到Scott账户为4900元，提交后，账户变为5900元；但如果B事务由于某些原因回滚的话，原来的操作无效；而此时账户余额却是4900元，凭空少了100元；因此这种场景必须使用READ COMMITTED隔离级别；③又如，A事务进行某商品的下单购票后未提交事务，但是B事务确将商品价格提高了；那么此时A事务应该根据原价购买；所以隔离级别使用REPEATABLE READ；即不受其他任何事务的影响，无论其他事务提交与否； 事务的序列化◇ 由于事务并发执行所带来的各种问题，前三种隔离级别只适用在某些业务场景中，但是序列化的隔离性，只有前面的会话结束后(事务提交后)才能执行下一个事务，即让事务逐一执行，不能够并发地执行事务；但是这样会大大降低数据库的并发能力，所以不太常用； 12SET SESSION TRANSACTION ISOLATION LEVELSERIALIZABLE; 数据导入与导出数据导出与备份的区别◇ 数据导出，导出的纯粹是业务数据◇ 数据备份，备份的是数据文件、日志文件、索引文件等等 数据导出的分类 导出SQL文件◇ mysqldump用来把业务数据导出成SQL文件，其中也包括了表结构 1mysqldump -uroot -p [ no-data ] 逻辑库 &gt; 路径 ◇ 如果业务数据非常多，建议只导出表结构，然后用SELECT INTO OUTFILE把数据导出成文本文档 导入SQL文件◇ source命令用于导入SQL文件，包括创建数据表，写入记录等 12sql &gt; USE demo ;sql &gt; SOURCE backup.sql ;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"}],"author":"LCG"},{"title":"MySQL基本函数","slug":"MySQL基本函数","date":"2022-01-28T05:42:00.000Z","updated":"2022-02-21T14:32:31.235Z","comments":true,"path":"p/8500.html","link":"","permalink":"https://618dt.github.io/p/8500.html","excerpt":"","text":"MySQL的函数 ◇像编程语言利用函数封装业务功能一样，数据库也把一些复杂的功能封装到函数里，供使用者调用 ◇也可以自定义函数 数字函数数字函数（一） 数字函数（二）◇三角函数的参数为弧度 日期函数获取系统时间函数◇NOW()函数能获得系统日期和时间，格式yyyy-MM-dd hh:mm:ss◇CURDATE()函数能获得当前系统日期，格式yyyy-MM-dd◇CURTIME()函数能获得当前系统时间，格式hh:mm:ss 日期格式化函数◇ DATE_FORMAT()函数用于格式化日期，返回用户想要的日期格式 1234DATE_FORMAT( 日期, 表达式)SELECT ename,DATE_FORMAT(hiredate,&quot;%Y&quot;)//获取年份的格式DATE_FORMAT(hiredate,&quot;%Y/%m%d&quot;) //返回2021/07/20这种格式FROM t_emp; 日期计算的注意事项◇ MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减 日期偏移计算 ◇ DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活 1234DATE_ADD( 日期 , INTERVAL 偏移量 时间单位 )SELECT DATE_ADD(NOW(),INTERVAL 15 DAY);SELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE); 计算日期之间相隔的天数◇ DATEDIFF()函数用来计算两个日期之间相差的天数 1DATEDIFF ( 日期 , 日期 ) 课堂练习◇ 利用日期函数，查询明年你的生日是星期几？ 1SELECT DATE_FORMAT(&quot;2020-02-19&quot;,&quot;%w&quot;) ◇ 利用日期函数，查询1981年上半年入职的员工有多少人？ 123SELECT COUNT(*) FROM t_empWHERE DATE_FORMAT(hiredate,&quot;%Y&quot;)=1981AND DATE_FORMAT(hiredate,&quot;%m&quot;)&lt;=6; 字符函数字符函数（一）◇INSERT(“ABC”,1,0,”DE”)数字1表示从前面的字符串ABC的第一个位置插入后面的字符串DE，0表示替换从插入位置起的0个字符；◇REPLACE() 的第二个参数表示被替换的内容，最后一个参数表示替换的内容 字符函数（二）◇截取字符串起始位置从1开始◇填充字符函数第二个参数表示填充到多少字符，而不是填充多少字符； 课堂练习◇将某人的姓名的名用替代 eg: 欧* 1SELECT RPAD(SUBSTRING(&quot;欧宝玉&quot;,1,1),LENGTH(&quot;欧宝玉&quot;)/3,&quot;*&quot;); 条件函数◇ SQL语句中可以利用条件函数来实现编程语言里的条件判断 12IFNULL( 表达式 , 值 )IF( 表达式 , 值1 , 值2 )//如果满足表达式则是值1，否则是值2 条件语句 ◇ 复杂的条件判断可以用条件语句来实现，比IF语句功能更强大 1234CASEWHEN 表达式 THEN 值1 ,WHEN 表达式 THEN 值2 , …… , ELSE 值NEND 课堂练习◇ 中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B， 打印每名员工获得的礼品。 123SELECT FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno,IF(d.dname=&quot;SALES&quot;,&quot;礼品A&quot;,&quot;礼品B&quot;)FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno; ◇ 公司年庆决定组织员工集体旅游，每个部门旅游目的地是不同的。SALES部门去P1地点，ACCOUNTING部门去P2地点 ，RESEARCH部门去P3地点，查询每名员工的旅行地点。 123456789SELECT e.empno,e.ename, CASE WHEN d.dname=&quot;SALES&quot; THEN &quot;P1&quot; WHEN d.dname=&quot;ACCOUNTING&quot; THEN &quot;P2&quot; WHEN d.dname=&quot;RESEARCH&quot; THEN &quot;P3&quot; END AS placeFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno ◇ 公司决定为员工调整基本工资，具体调整方案如下： 1234567891011121314UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptnoLEFT JOIN (SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) tON e.deptno=t.deptnoSET sal=(CASE WHEN d.dname=&quot;SALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&gt;=20 THEN e.sal*1.1 WHEN d.dname=&quot;SALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&lt;20 THEN e.sal*1.05 WHEN d.dname=&quot;ACCOUNTING&quot; THEN e.sal+300 WHEN d.dname=&quot;RESEARCH&quot; AND e.sal&lt;t.avg THEN e.sal+200 WHEN e.deptno IS NULL THEN e.sal+100 END);","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"}],"author":"LCG"},{"title":"MySQL基本操作","slug":"MySQL基本操作","date":"2022-01-28T05:38:00.000Z","updated":"2022-02-21T14:32:31.237Z","comments":true,"path":"p/a881.html","link":"","permalink":"https://618dt.github.io/p/a881.html","excerpt":"","text":"数据操作语言：INSERT语句INSERT语句 ◇ INSERT语句可以向数据表写入记录，可以是一条记录，也可以是多条记录 1234INSERT INTO 表名 ( 字段1, 字段2, …… ) VALUES ( 值1, 值2, …… ) ;INSERT INTO 表名 ( 字段1, 字段2, …… ) VALUES ( 值1, 值2, …… ) , ( 值1, 值2, …… ) ;//插入多条记录 INSERT语句方言 ◇ MYSQL的INSERT语句还有一种方言语法 1INSERT INTO 表名 SET 字段1=值1, 字段2=值2, …… ; IGNORE关键字 ◇ IGNORE关键字会让INSERT只插入数据库不存在的记录 1INSERT [ IGNORE ] INTO 表名 …… ; INSERT中的子查询◇ INSERT语句中可以包含子查询语句，代表把子查询的内容写入到数据表◇ 把人数超过5人的部门记录拷贝到新的部门表 1234567CREATE TABLE t_dept_new LIKE t_dept;INSERT INTO t_dept_new(deptno,dname,loc)(SELECT d.deptno,d.dname,d.loc FROM t_dept d JOIN(SELECT deptno FROM t_emp GROUP BY deptnoHAVING COUNT(*)&gt;=5) tempON d.deptno = temp.deptno); 数据操作语言：UPDATE语句UPDATE语句 ◇ UPDATE语句用于修改表的记录 123456//&quot;IGNORE&quot;关键字在UPDATE语句中表示忽略修改数据时遇到冲突的记录，把不冲突的记录写到数据表里UPDATE [ IGNORE ] 表名SET 字段1=值1, 字段2=值2, ……[ WHERE 条件1, 条件2, …… ] [ ORDER BY …… ] //排序，如果需要将员工编号+1的话，可以先进行降序否则可能引发主键冲突[ LIMIT …… ] //取分页数据 UPDATE语句的表连接◇ 因为WHERE子句中的子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句 12UPDATE 表1 JOIN 表2 ON 条件SET 字段1 = 值1 , 字段2 = 值2 , …… ; ◇ 表连接的UPDATE语句可以修改多张表的记录◇ UPDATE语句的表连接可以演变成下面的样子 123UPDATE 表1 , 表2SET 字段1 = 值1 , 字段2 = 值2 , ……WHERE 连接条件 ; ◇ UPDATE语句的表连接既可以是内连接，又可以是外连接 12UPDATE 表1 [ LEFT | RIGHT ] JOIN 表2 ON 条件SET 字段1 = 值1 , 字段2 = 值2 , …… ; ◇ 把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门 123UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptnoSET e.deptno=20WHERE e.deptno IS NULL OR (d.dname=&quot;SALES&quot; AND e.sal&lt;2000); 课堂练习◇ 把每个员工的编号和上司的编号+1，用ORDER BY子句完成 12UPDATE t_emp SET empno=empno+1,mgr=mgr+1ORDER BY empno DESC ◇ 把月收入前三名的员工底薪减100元，用LIMIT子句完成 123UPDATE t_emp SET sal=sal-100ORDER BY sal+IFNULL(comm,0) DESCLIMIT 3; ◇ 把ALLEN调往RESEARCH部门，职务调整为ANALYST //牵扯到两张表1234//这里不能写连接条件(ON e.deptno=d.deptno)，因为会将A锁定到R部门UPDATE t_emp e JOIN t_dept d SET e.deptno=d.deptno,e.job=&quot;ANALYST&quot;WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot; ◇ 把底薪低于公司平均底薪的员工，底薪增加150元 1234UPDATE t_emp e JOIN(SELECT AVG(sal) AS avg FROM t_emp) t//子查询结果集ON e.sal&lt;t.avgSET e.sal=e.sal+150; 数据操作语言：DELETE语句DELETE语句◇ DELETE语句用于删除记录，语法如下： 1234DELETE [ IGNORE ] FROM 表名//IGNORE:能删则删，不能删则忽略，不会报错[ WHERE 条件1, 条件2, …… ][ ORDER BY …… ] [ LIMIT …… ] ; DELETE语句的表连接◇ 因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造DELETE语句 1234DELETE 表1 , …… FROM 表1 JOIN 表2 ON 条件[ WHERE 条件1 , 条件2 , …… ] [ ORDER BY …… ] [ LIMIT …… ] ; ◇ DELETE语句的表连接既可以是内连接，又可以是外连接 12DELETE 表1 , …… FROM 表1 [ LEFT | RIGHT ] JOIN 表2 ON 条件 …… ; ◇ 删除SALES部门的员工，以及没有部门的员工。 123DELETE eFROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptnoWHERE d.dneme=&quot;SALES&quot; OR e.deptno IS NULL 快速删除数据表全部记录◇ DELETE语句是在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里，然后再删除记录。◇ TRUNCATE语句在事务机制之外删除记录，速度远超过DELETE语句 1TRUNCATE TABLE 表名 ; 课堂练习◇ 删除10部门中，工龄超过20年的员工记录 12DELETE FROM t_empWHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365 ◇ 删除20部门中工资最高的员工记录 1234DELETE FROM t_empWHERE deptno=20ORDER BY sal+IFNULL(comm,0) DESCLIMIT 1; ◇ 删除SALES部门和该部门的全部员工记录 123DELETE e,dFROM t_emp e JOIN t_dept d ON e.deptno=d.deptnoWHERE d.dname=&quot;SALES&quot;; ◇ 删除每个低于部门平均底薪的员工记录 1234DELETE eFROM t_emp e JOIN (SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) tON e.deptno = t.deptno AND e.sal&lt;t.avg ◇ 删除员工KING和他的直接下属的员工记录，用表连接实现。 1234DELETE eFROM t_emp e JOIN (SELECT empno FROM t_emp WHERE ename=&quot;KING&quot;) t//结果集里的数据不能删ON e.mgr=t.empno OR e.empno=t.empno;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"}],"author":"LCG"},{"title":"SQL简介","slug":"SQL简介","date":"2022-01-28T05:38:00.000Z","updated":"2022-02-21T14:32:31.239Z","comments":true,"path":"p/a804.html","link":"","permalink":"https://618dt.github.io/p/a804.html","excerpt":"","text":"学习目标◇ 管理逻辑库和数据表 创建、删除、修改逻辑库和数据表◇ 了解常用的数据类型和约束 字符串、整数、浮点数、精确数字、日期、枚举。主键约束、非空 约束、唯一约束、外键约束等◇ 掌握索引运行机制和使用原则 排序为什么可以提高数据检索速度？怎么创建和删除索引？什么条 件下使用索引？ 什么是SQL语言 ？◇ SQL 是用于访问和处理数据的标准的计算机语言 SQL语言分类 SQL语句注意事项◇ SQL语句不区分大小写，但是字符串区分大小写◇ SQL语句必须以分号结尾◇ SQL语句中的空白和换行没有限制，但是不能破坏语法 SQL语句的注释◇ SQL语句的注释有两种，分别如下： #这是一段注释/这是另一段注释/ 创建逻辑库 创建数据表12345CREATE TABLE 数据表 (列名1 数据类型 [ 约束 ] [COMMENT 注释] ,列名2 数据类型 [ 约束 ] [COMMENT 注释] , ……) [ COMMENT = 注释 ] ;DROP TABLE 数据表 ; 1234567CREATE TABLE student (id INT UNSIGNED PRIMARY KEY ,name VARCHAR(20) NOT NULL , sex CHAR(1) NOT NULL ,birthday DATE NOT NULL ,tel CHAR(11) NOT NULL ,remark VARCHAR(200)); 数据表的其他操作1234SHOW tables ;DESC student ; //查看表的结构SHOW CREATE TABLE student ;DROP TABLE student ; 数据定义语言：数据类型数据类型：数字◇DECIMAL相当于用字符来保存数字，所以不存在精度的丢失；参数10表示整数+小数为十位参数2表示精确到小数点后两位 不精确的浮点数◇ 十进制的浮点数无法在计算机中用二进制精确表达 数据类型：字符串 数据类型：日期类型 数据定义语言：修改表结构添加字段123ALTER TABLE 表名称ADD 列1 数据类型 [ 约束 ] [COMMENT 注释] , ADD 列2 数据类型 [ 约束 ] [COMMENT 注释] ,…… ; 修改字段类型和约束123ALTER TABLE 表名称MODIFY 列1 数据类型 [ 约束 ] [COMMENT 注释] , MODIFY 列2 数据类型 [ 约束 ] [COMMENT 注释] ,…… ; 修改字段名称1234ALTER TABLE 表名称CHANGE 列1 新列名1 数据类型 [ 约束 ] [COMMENT 注释] ,CHANGE 列2 新列名2 数据类型 [ 约束 ] [COMMENT 注释] ,…… ; 删除字段1234ALTER TABLE 表名称DROP 列1 ,DROP 列2 ，…… ; 修改表名1ALTER TABLE 表名 RENAME 新表名","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库的高级查询","slug":"数据库的高级查询","date":"2022-01-28T05:35:00.000Z","updated":"2022-02-21T14:32:31.242Z","comments":true,"path":"p/1648.html","link":"","permalink":"https://618dt.github.io/p/1648.html","excerpt":"","text":"数据操作语言：聚合函数什么是聚合函数◇ 聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对数 据求和、求最大值和最小值、求平均值等等。◇ 求公司员工的平均月收入是多少？ 1SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp; SUM函数 ◇ SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0 ，日期类型统计结果是毫秒数相加 ◇ SUM函数求和会排除NULL值 MAX函数 ◇ MAX函数用于获得非空值的最大值。 ◇ 问题1：查询10和20部门中，月收入最高的员工？ 12SELECT MAX(sal+IFNULL(comm,0)) FROM t_empWHERE deptno IN(10,20); ◇ 问题2：查询员工名字最长的是几个字符？ 1SELECT MAX(LENGTH(ename)) FROM t_emp; MIN函数 ◇ MIN函数用于获得非空值的最小值。 AVG函数 ◇ AVG函数用于获得非空值的平均值，非数字数据统计结果为0 COUNT函数 ◇ COUNT(*)用于获得包含空值的记录数，COUNT(列名)用于获得包 含非空值的记录数。 ◇ 查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数？ 123SELECT COUNT(*) FROM t_empWHERE deptno IN(10,20) AND sal&gt;=2000AND DATEDIFF(NOW(),hiredate)/365&gt;=15; //DATEDIFF指相差的天数 ◇ 查询1985年以后入职的员工，底薪超过公司平均底薪的员工数量？ 123SELECT COUNT(*) FROM t_empWHERE hiredate&gt;=&quot;1985-01-01&quot;AND sal&gt;AVG(sal);//WHERE 子句不能有聚合函数，这里是错误的？ 数据操作语言：分组查询为什么要分组？ ◇ 默认情况下汇总函数是对全表范围内的数据做统计 ◇ GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干 个小的区域，然后针对每个小区域分别进行数据汇总处理 逐级分组 ◇ 数据库支持多列分组条件，执行的时候逐级分组。 ◇ 查询每个部门里，每种职位的人员数量和平均底薪 对SELECT子句的要求 ◇ 查询语句中如果含有GROUP BY子句，那么SELECT子句中的内容就 必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在SELECT子句中如下sql语句就是错误的： 12SELECT deptno,COUNT(*),AVG(sal),sal //sal字段并不是GROUP BY子句的分组列FROM t_emp GROUP BY deptno; 对分组结果集再次做汇总计算12SELECT deptno,COUNT(*),AVG(sal),MAX(sal),MIN(sal)FROM t_emp GROUP BY deptno WITH ROLLUP; GROUP_CONCAT函数 ◇ GROUP_CONCAT函数可以把分组查询中的某个字段拼接成一个字符串 ◇ 查询每个部门内底薪超过2000元的人数和员工姓名 123SELECT deptno,GROUP_CONCAT(ename),COUNT(*)FROM t_emp WHERE sal&gt;=2000GROUP BY deptno; 各种子句的执行顺序 ◇ 查询语句中，GROUP BY子句应该第几个执行？FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT 数据操作语言：HAVING子句分组查询遇到的困难？ ◇ 查询部门平均底薪超过2000元的部门编号 ◇ 因为WHERE子句先于GROUP BY执行，一旦WHERE子句中出现了 汇总函数，数据库根本不知道按照什么范围计算汇总值 HAVING子句的用途 ◇ 可以将聚集函数写在HAVING子句中 ◇ 查询每个部门中，1982年以后入职的员工超过2个人的部门编号 1234SELECT deptno FROM t_empWHERE hiredate&gt;=&quot;1982-01-01&quot;GROUP BY deptno HAVING COUNT(*)&gt;=2;ORDER BY deptno ASC HAVING子句的特殊用法 ◇ 按照数字1分组，MySQL会依据SELECT子句中的列进行分组， HAVING子句也可以正常使用 12345SELECT deptno,COUNT(*), FROM t_empGROUP BY 1;SELECT deptno,COUNT(*), FROM t_empGROUP BY 1 HAVING deptno IN (10,20); 数据操作语言：表连接查询从多张表中提取数据 ◇ 从多张表中提取数据，必须指定关联的条件。如果不定义关联条件 就会出现无条件连接，两张表的数据会交叉连接，产生笛卡尔积。 ◇ 规定了连接条件的表连接语句，就不会出现笛卡尔积 表连接的分类 ◇ 表连接分为两种：内连接和外连接 ◇ 内连接是结果集中只保留符合连接条件的记录 ◇ 外连接是不管符不符合连接条件，记录都要保留在结果集中 内连接的简介 ◇ 内连接是最常见的一种表连接，用于查询多张关系表符合连接条件 的记录。INNER关键字可省略 内连接的多种语法形式123SELECT …… FROM 表1 JOIN 表2 ON 连接条件 ;SELECT …… FROM 表1 JOIN 表2 WHERE 连接条件 ;SELECT …… FROM 表1 , 表2 WHERE 连接条件 ;//常用 内连接练习 ◇ 查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级？ 123SELECT e.empno,e.ename,d.deptno,e.sal,e.job,s.gradeFROM t_emp e,t_dept d,t_salgrade s WHERE e.deptno=d.deptno AND e.sal BETWEEN s.losal AND s.hisal; ◇ 内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以 ◇ 相同的数据表也可以做表连接 ◇ 结果集也可以作为一张“表”来跟其他表连接 为什么要使用外连接 ◇ 如果说陈浩是一名临时人员，没有固定的部门编制，那么我们想查询每名员工和他的部门名称，用内连接就会漏掉陈浩，所以要引入外连接的语法才能解决这个问题 外连接简介 ◇ 外连接与内连接的区别在于，除了符合条件的记录之外，结果集中 还会保留不符合条件的记录。 左连接和右连接 ◇ 左外连接就是保留左表所有的记录，与右表做连接。如果右表有符 合条件的记录就与左表连接。如果右表没有符合条件的记录，就用 NULL与左表连接。右外连接也是如此。 外连接练习 ◇ 查询每个部门的名称和部门的人数？ 1234SELECT d.dname,COUNT(e.deptno)//忽略右表(t_emp)的NULL记录FROM t_dept d LEFT JOIN t_emp e //保留左表(t_dept)的所有记录ON d.deptno=e.deptnoGROUP BY d.deptno; ◇结果： ◇ 查询每个部门的名称和部门的人数？如果没有部门的员工，部门名称用NULL代替。 123456789(SELECT d.dname,COUNT(e.deptno)FROM t_dept d LEFT JOIN t_emp e ON d.deptno=e.deptnoGROUP BY d.deptno ) UNION //使用UNION关键字进行左外连接和右外连接的合并(SELECT d.dname,COUNT(*) //保留所有有效记录FROM t_dept d RIGHT JOIN t_emp e ON d.deptno=e.deptnoGROUP BY d.deptno ) ◇结果： ◇ 查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司 编号、上司姓名、上司部门？ 12345678SELECT e1.empno AS &#x27;编号&#x27;,e1.ename AS &#x27;姓名&#x27;,d1.dname AS &#x27;部门&#x27;,e1.sal+IFNULL(e1.comm,0) AS &#x27;薪水&#x27;,t.grade AS &#x27;薪资等级&#x27;,FLOOR(DATEDIFF(NOW(),e1.hiredate)/365) AS &#x27;工龄&#x27;,e1.mgr AS &#x27;上司编号&#x27;,e2.ename AS &#x27;上司姓名&#x27;,d2.dname AS &#x27;上司部门&#x27; FROM t_emp e1 LEFT JOIN t_dept d1 ON e1.deptno=d1.deptnoLEFT JOIN t_emp e2 ON e1.mgr=e2.empnoLEFT JOIN t_salgrade t ON e1.sal BETWEEN t.losal AND t.hisalLEFT JOIN t_dept d2 ON e2.deptno=d2.deptno; ◇结果： ◇ UNION关键字可以将多个查询语句的结果集进行合并 ,结果集字段名称、个数需要相同 1( 查询语句 ) UNION ( 查询语句 ) UNION ( 查询语句 ) …… 外连接的注意事项 ◇ 内连接只保留符合条件的记录，所以查询条件写在ON子句和 WHERE子句中的效果是相同的。但是外连接里，条件写在WHERE 子句里，不合符条件的记录是会被过滤掉的,而不是保留下来。①使用ON子句 1234SELECT e.ename,d,dname,d.deptnoFROM t_emp eLEFT JOIN t_dept d ON e.deptno = d.deptnoAND e.deptno=10; 结果： 发现所有记录都被保留，但不符合条件的记录为空②使用WHERE子句 1234SELECT e.ename,d,dname,d.deptnoFROM t_emp eLEFT JOIN t_dept d ON e.deptno = d.deptnoWHERE e.deptno=10; 结果： 数据操作语言：子查询子查询简介 ◇ 子查询是一种查询中嵌套查询的语句 ◇ 查询底薪超过公司平均底薪的员工的信息 123SELECT empno,ename,salFROM t_empWHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); 子查询的分类 ◇ 子查询可以写在三个地方：WHERE子句、FROM子句、SELECT子 句，但是只有FROM子句子查询是最可取的 WHERE子查询 ◇ 这种子查询最简单，最容易理解，但是却是效率很低的子查询 ◇ 查询底薪超过公司平均底薪的员工的信息 用表连接替代WHERE子查询 ◇ 表连接的优点是子查询只执行一次，查询效率特别高 12345SELECT e2.empno,e2.enameFROM t_emp e1 JOIN t_emp e2ON e1.deptno = e2.deptnoAND e2.ename!=&quot;FORD&quot;AND e1.ename=&quot;FORD&quot;; FROM子查询 ◇ 这种子查询只会执行一次，所以查询效率很高，把子查询写在FROM子句中 ◇ 查询底薪超过公司平均底薪的员工的信息 123456SELECT e.empno,e.ename,e.sal,t.avgFROM t_emp e JOIN (SELECT deptno,AVG(sal) as avgFROM t_emp GROUP BY deptno) tON e.deptno=t.deptno AND e.sal&gt;=t.avg; SELECT子查询 ◇ 这种子查询每输出一条记录的时候都要执行一次，查询效率很低 12SELECT e.empno,e.ename,(SELECT dname FROM t_dept WHERE deptno=e.deptno)FROM t_emp e; 相关子查询◇ 查询语句执行的时候要多次的依赖于子查询的结果，这类子查询被 称作相关子查询◇ WHERE子查询和SELECT子查询都属于相关子查询◇ 因为相关子查询要反复多次执行，所以应该避免使用 单行子查询和多行子查询◇ 单行子查询的结果集只有一条记录，多行子查询结果集有多行记录◇ 多行子查询只能出现在WHERE子句和FROM子句中◇ 子查询一般先写出子查询语句◇ 如何用子查询查找FORD和MARTIN两个人的同事？ 123456SELECT FROM t_empWHERE deptno IN //这里子查询结果集为多行记录，所以不能用&quot;=&quot;,而用&quot;IN&quot;表示等于其中一条记录即可(SELECT deptno FROM t_emp WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;))AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;); WHERE子句中的多行子查询◇ WHERE子句中，可以使用IN、ALL、ANY、EXISTS关键字来处理多行表达式结果集的条件判断◇ 查询比FORD和MARTIN底薪都高的员工信息？ 12345SELECT enameFROM t_empWHERE sal&gt;=ALL(SELECT sal FROM t_emp WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;))AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;); EXISTS关键字 ◇ EXISTS关键字是把原来在子查询之外的条件判断，写到了子查询的里面。 1SELECT …… FROM 表名 WHERE [NOT] EXISTS ( 子查询 ) ; ◇ 查询工资等级3和4级的员工信息？ 1234567SELECT empno,ename,salFROM t_empWHERE EXISTS(SELECT grade FROM t_salgradeWHERE sal BETWEEN losal AND hisalAND grade IN(3,4));","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库的基本查询","slug":"数据库的基本查询","date":"2022-01-28T05:33:00.000Z","updated":"2022-02-21T14:32:31.241Z","comments":true,"path":"p/f427.html","link":"","permalink":"https://618dt.github.io/p/f427.html","excerpt":"","text":"数据操作语言：普通查询记录查询◇ 最基本的查询语句是由 SELECT 和 FROM 关键字组成的◇ SELECT语句屏蔽了物理层的操作，用户不必关心数据的真 实存储，交由数据库高效的查找数据 12SELECT * FROM t_student;SELECT id,name,sex FROM t_student; 使用列别名◇ 通常情况下，SELECT子句中使用了表达式，那么这列的名 字就默认为表达式，因此需要一种对列名重命名的机制 12345SELECT ename, sal * 12 AS &quot;annual_salary&quot; FROM emp; ◇ 重命名只在显示输出的时候使用，数据表列名不会真的改变◇ 查询语句的子句执行顺序 数据操作语言：数据分页数据分页◇ 比如我们查看朋友圈，只会加载少量部分信息，不用一次性加载全 部朋友圈，那样只会浪费CPU时间、内存和网络带宽◇ 如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量。 12SELECT …… FROM …… LIMIT 起始位置 , 偏移量 ;SELECT empno,ename FROM t_emp LIMIT 0,20;//20是偏移量而不是终止的 数据分页的简写用法◇如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0◇执行顺序： FROM -&gt; SELECT -&gt; LIMIT 数据操作语言：结果集排序结果集排序◇ 如果没有设置，查询语句不会对结果集进行排序。也就是说，如果 想让结果集按照某种顺序排列，就必须使用ORDER BY子句。 1SELECT …… FROM …… ORDER BY 列名 [ ASC | DESC ] ; 排序关键字 ◇ASC代表升序（默认），DESC代表降序 如果排序列是数字类型，数据库就按照数字大小排序，如果是日期 类型就按照日期大小排序，如果是字符串就按照字符集序号排序。 排序字段内容相同的情况◇ 默认情况下，如果两条数据排序字段内容相同，那么排序会是什么 样子？◇ 如果排序字段内容相同，MySQL会按照主键大小来排序两条数据 多个排序字段 ◇我们可以使用ORDER BY规定首要排序条件和次要排序条件。数据 库会先按照首要排序条件排序，如果遇到首要排序内容相同的记录 ，那么就会启用次要排序条件接着排序 123SELECT empno,ename,sal,hiredateFROM t_empORDER BY sal DESC,hiredate ASC; 排序+分页◇ ORDER BY子句书写的时候放在LIMIT子句的前面 FROM -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT 数据操作语言：去除重复记录◇ 假如我们要查询员工表有多少种职业， 如果我们需要去除重复的数据，可以使用DISTINCT关键字来实现 ； 1SELECT DISTINCT 字段 FROM …… ; ◇ 注意事项 ： ①使用DISTINCT的SELECT子句中只能查询一列数据，如果查询多列， 去除重复记录就会失效。② DISTINCT关键字只能在SELECT子句中使用一次 ； 数据操作语言：条件查询条件查询◇ 很多时候，用户感兴趣的并不是逻辑表里的全部记录，而只是它们 当中能够满足某一种或某几种条件的记录。这类条件要用WHERE子 句来实现数据的筛选 1SELECT …… FROM …… WHERE 条件 [ AND | OR ] 条件 …… ; 四类运算符 WHERE语句中的条件运算会用到以下四种运算符： 算数运算符 比较运算符 逻辑运算符 二进制按位运算◇ 二进制位运算的实质是将参与运算的两个操作数，按对应的二进制数逐位进行逻辑运算。 按位运算符 WHERE子句的注意事项◇ WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把索引条件，或者筛选掉记录最多的条件写在最左侧 12345SELECT empno,ename FROM t_empWHERE ename = &quot;FORD&quot; AND sal &gt;= 2000;SELECT empno,ename FROM t_empWHERE deptno = 10 AND sal &gt;= 2000; 各种子句的执行顺序 条件查询中，WHERE子句应该是第几个执行？ FROM -&gt; WHERE -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库范式","slug":"数据库的范式","date":"2022-01-28T05:28:00.000Z","updated":"2022-02-21T14:32:31.241Z","comments":true,"path":"p/77e3.html","link":"","permalink":"https://618dt.github.io/p/77e3.html","excerpt":"","text":"概念◇ 构造数据库必须遵循一定的规则，这种规则就是范式◇ 目前关系数据库有6种范式，一般情况下，只满足第三范式即可 第一范式：原子性◇ 第一范式是数据库的基本要求，不满足这一点就不是关系数据库◇ 数据表的每一列都是不可分割的基本数据项，同一列中不能有多个值，也不能存在重复的属性。 第二范式：唯一性◇ 数据表中的每条记录必须是唯一的。为了实现区分，通常要为表 加上一个列用来存储唯一标识，这个唯一属性列被称作主键列 第三范式：关联性◇ 每列都与主键有直接关系，不存在传递依赖 ◇依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联 字段约束◇ MySQL中的字段约束共有四种： 主键约束◇ 主键约束要求字段的值在全表必须唯一，而且不能为NULL值◇ 建议主键一定要使用数字类型，因为数字的检索速度会非常快◇ 如果主键是数字类型，还可以设置自动增长 1234CREATE TABLE t_teacher(id INT PRIMARY KEY AUTO_INCREMENT,.......) 非空约束◇ 非空约束要求字段的值不能为NULL值◇ NULL值以为没有值，而不是” “空字符串 12345CREATE TABLE t_teacher(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(200) NOT NULL,married BOOLEAN NOT NULL DEFAULT FALSE //设置默认值为false); 唯一约束◇ 唯一约束要求字段值如果不为NULL，那么在全表必须唯一 1234CREATE TABLE t_teacher(...tel CHAR(11) NOT NULL UNIQUE); 外键约束◇ 外键约束用来保证关联数据的逻辑关系◇ 外键约束的定义是写在子表上的 12345678CREATE TABLE t_emp(empno INT UNSIGNED PRIMARY KEY,ename VARCHAR(20) NOT NULL,sex ENUM(&quot;MAN&quot;,&quot;WOMAN&quot;) NOT NULL,deptno INT UNSIGNED NOT NULL,hiredate DATE NOT NULL,FOREIGN KEY (deptno) REFERENCES t_dept(deptno)); ** 外键约束的闭环问题 **◇ 如果形成外键闭环，我们将无法删除任何一张表的记录 数据定义语言：索引数据排序的好处◇ 一旦数据排序之后，查找的速度就会翻倍，现实世界跟程 序世界都是如此 数据表的索引◇ MySQL利用二叉树结构，对数据表的记录排序，从而加速 数据的检索速度 如何创建索引123CREATE TABLE 表名称 ( ……，INDEX [ 索引名称 ] ( 字段 ) ……//给哪一个字段设置索引) ; 如何添加与删除索引1234CREATE INDEX 索引名称 ON 表名( 字段 ) ；ALTER TABLE 表名称 ADD INDEX [ 索引名 ]( 字段 ) ;SHOW INDEX FROM 表名 ; //查看索引情况DROP INDEX 索引名称 ON 表名 ; 索引的使用原则◇ 数据量很大，而且经常被查询的数据表可以设置索引◇ 索引只添加在经常被用作检索条件的字段上面◇ 不要在大字段上创建索引","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库简介","slug":"数据库简介","date":"2022-01-28T05:26:00.000Z","updated":"2022-02-21T12:29:33.997Z","comments":true,"path":"p/f849.html","link":"","permalink":"https://618dt.github.io/p/f849.html","excerpt":"","text":"学习目标了解关系型数据库的重要性 -为什么会出现关系型数据库？有哪些常见的关系型数据库？掌握MySQL的安装和配置 -怎么安装MySQL数据库？怎么配置MySQL的字符集、端口号、IP 地址绑定、数据目录等等？实践用户创建、分配权限和密码找回 如何创建root之外的帐户并分配权限？忘记数据库密码，应该如何 找回？ 课程内容操作系统中数据存放的载体◇ Windows、Linux和MacOS都是基于文件的操作系统◇ 文件能保存数据，为什么不用文件来管理数据？什么是(关系型)数据库系统？◇ 数据库系统（DBMS）是指一个能为用户提供信息服务 的系统。它实现了有组织地、动态地储存大量相关数据 的功能，提供了数据处理和信息资源共享的便利手段。◇ 关系型数据库系统（RDBMS）是指使用了关系模型的数 据库系统◇ 关系模型中，数据是分类存放的，数据之间可以有联系 关系型数据库的应用◇ 关系型数据库被应用在非常多的领域 关系型数据库可以有效组织和管理大量复杂的数据，所 以关系型数据库才是最重要的数据库产品◇数据库的大规模应用◇主流关系型数据库 什么是NoSQL数据库系统？◇ NoSQL数据库指的是数据分类存放，但是数据之间没有关联关系的数据库系统◇ 主流NoSQL数据库 用户管理◇MySQL客户端 Navicat 重设root密码◇ 密码忘记后◇ 创建一个TXT文件，定义修改密码的SQL语句 12ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY&#x27;123456&#x27; ; ◇以管理员身份打开PowerShell窗口◇ 修改my.ini文件，删除之前添加的参数C:\\ProgramData\\MySQL\\MySQL Server 8.0，先打开隐藏文件；◇ 重启MySQL服务，用新密码登陆root帐户 MySQL配置文件◇ 在my.ini文件中，我们可以设置各种MySQL的配置，例 如字符集、端口号、目录地址等等 12345678910111213141516171819202122232425262728[client]port=3306 [mysql]no-beep #关闭蜂鸣器[mysqld]port=3306 #端口号datadir=C:/ProgramData/MySQL/MySQL Server 8.0\\Data #数据目录default_authentication_plugin=mysql_native_password #密码认证插件default-storage-engine=INNODB #默认存储引擎sql-mode=&quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION&quot; #开启严格模式log-output=FILE #用文件记录日志general-log=0 #关闭日志输出general_log_file=&quot;LAPTOP-3NL7HPNI.log&quot; #日志文件名称slow-query-log=1 #开启慢查询日志slow_query_log_file=&quot;LAPTOP-3NL7HPNI-slow.log&quot; #慢查询日志文件名称long_query_time=10 #大于多少秒的执行SQL被记录在慢查询log-error=&quot;LAPTOP-3NL7HPNI.err&quot; #错误日志名称log-bin=&quot;LAPTOP-3NL7HPNI-bin&quot;server-id=1 #数据库ID，集群时用到report_port=3306lower_case_table_names=1 #把表名转换成小写secure-file-priv=&quot;C:/ProgramData/MySQL/MySQL Server 8.0/Uploads&quot; #导入导出数据的目录地址max_connections=151 #最大连接数table_open_cache=2000tmp_table_size=21Mthread_cache_size=10 #线程数量.......","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"Freemaker","slug":"FreeMarker","date":"2022-01-26T12:06:00.000Z","updated":"2022-02-21T11:57:34.672Z","comments":true,"path":"p/f1c8.html","link":"","permalink":"https://618dt.github.io/p/f1c8.html","excerpt":"","text":"模板引擎与Freemaker项目实战什么是模板引擎◇模板引擎的目标是”数据+模板=结果”◇模板引擎将数据与展现有效”解耦” 主流模板引擎◇Java Servlet Page◇Fremarker◇Beetl Fremarker◇Fremarker是免费开源的模板引擎技术◇Fremarker脚本为Fremarker Template Language◇Fremarker提供了大量内建函数来简化开发 JSP与Fremarker Fremarker快速上手代码演示ftl：${site}-${url} 1234567891011121314151617181920212223public class FreemarkerSample1 &#123; public static void main(String[] args) throws TemplateNotFoundException, MalformedTemplateNameException, ParseException, IOException, TemplateException &#123; // TODO Auto-generated method stub //1.加载模板 //1.1创建核心配置对象 Configuration config = new Configuration(Configuration.VERSION_2_3_31); //1.2设置加载的目录 config.setClassForTemplateLoading(FreemarkerSample1.class, &quot;&quot;); //1.3得到模板对象 Template t = config.getTemplate(&quot;sample1.ftl&quot;); //2.创建数据 Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;(); data.put(&quot;site&quot;, &quot;百度&quot;); data.put(&quot;url&quot;, &quot;http://www.baidu.com&quot;); //3.产生输出 //转换类将System.out输出字节流转换为字符输出流 t.process(data, new OutputStreamWriter(System.out)); &#125;&#125; FTL取值◇${属性名} 取值，可对属性进行计算◇${属性名!默认值} 使用默认值 eg：${author!”不存在的属性”}◇${属性名?string} 格式化输出eg：${date?string(“yyyy年MM月dd日HH:mm:ss”)} 分支判断◇if分支判断◇switch分支判断 123456789101112131415161718192021&lt;#if computer.state==1&gt;状态:正在使用&lt;#elseif computer.state==2&gt;状态:闲置&lt;#elseif computer.state==3&gt;状态:已作废&lt;/#if&gt; &lt;#-- 闭合 --&gt;&lt;#switch computer.state&gt; &lt;#case 1&gt; 状态:正在使用 &lt;#break&gt; &lt;#case 2&gt; 状态:闲置 &lt;#break&gt; &lt;#case 3&gt; 状态:已作废 &lt;#break&gt; &lt;#default&gt; 状态:无效状态 &lt;/#switch&gt; list迭代列表 –格式 1234&lt;#--student被迭代的集合；stu迭代变量 --&gt;&lt;#list student as stu&gt;&lt;li&gt;$&#123;stu_index&#125;-$&#123;stu.name&#125;&lt;/li&gt;&lt;/#list&gt; –代码演示 12345678910111213141516171819202122232425262728&lt;#list computers as c&gt;序号:$&#123;c_index + 1&#125; &lt;#-- 迭代变量_index保存了循环的索引,从0开始 --&gt;SN:$&#123;c.sn&#125;型号:$&#123;c.model&#125;&lt;#switch c.state&gt;&lt;#case 1&gt;状态:使用中&lt;#break&gt;&lt;#case 2&gt;状态:闲置&lt;#break&gt;&lt;#case 3&gt;状态:已作废&lt;#break&gt;&lt;/#switch&gt;&lt;#if c.user??&gt;用户:$&#123;c.user&#125;&lt;/#if&gt;采购日期:$&#123;c.dop?string(&quot;yyyy-MM-dd&quot;)&#125;采购价格:$&#123;c.price?string(&quot;0.00&quot;)&#125;-------------------------------------------&lt;/#list&gt;==========================================&lt;#list computer_map?keys as k &gt;$&#123;k&#125;-$&#123;computer_map[k].model&#125;$&#123;computer_map[k].price?string(&quot;0.00&quot;)&#125;&lt;/#list&gt; list迭代Map –格式 123&lt;#list map?keys as key&gt; $&#123;key&#125;:$&#123;map[key]&#125;&lt;/#list&gt; 内建函数 代码示例： 1234567891011121314151617181920$&#123;name?cap_first&#125;$&#123;brand?upper_case&#125;$&#123;brand?length&#125;$&#123;words?replace(&quot;blood&quot; , &quot;*****&quot;)&#125;$&#123;words?index_of(&quot;blood&quot;)&#125;&lt;#-- 利用?string实现三目运算符的操作 --&gt;$&#123;(words?index_of(&quot;blood&quot;) != -1)?string(&quot;包含敏感词汇&quot;,&quot;不包含敏感词汇&quot;)&#125;$&#123;n?round&#125;$&#123;n?floor&#125;$&#123;n?ceiling&#125;公司共有$&#123;computers?size&#125;台电脑第一台:$&#123;computers?first.model&#125;最后一台:$&#123;computers?last.model&#125;&lt;#-- 集合排序 ?reverse代表反转，将默认的升序排列改为降序 --&gt;&lt;#list computers?sort_by(&quot;price&quot;)?reverse as c&gt; $&#123;c.sn&#125;-$&#123;c.price&#125;&lt;/#list&gt; ◇Freemarker参考手册 Freemarker与Servlet整合代码演示 –xml配置FreemarkerServlet 12345678910111213141516&lt;!-- 配置freemarker类，和配置servlet一样 在配置class上可以按住Ctrl若路径出现蓝色下划线则说明路径正确 通过设置初始化参数来说明FreemarkerServlet加载哪个目录 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; –Employee类提供员工类信息 12345678public class Employee &#123; private Integer empno; private String ename; private String department; private String job; private Float salary; /*省略构造函数*/ &#125; –ListServlet为界面准备数据 1234567891011protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; List list = new ArrayList(); list.add(new Employee(2020,&quot;关浩&quot;,&quot;市场部&quot;,&quot;客户代表&quot;,6000f)); list.add(new Employee(2021,&quot;右磊&quot;,&quot;研发部&quot;,&quot;运维工程师&quot;,6500f)); list.add(new Employee(2022,&quot;方传输&quot;,&quot;运输部&quot;,&quot;交通工程师&quot;,8500f)); list.add(new Employee(2023,&quot;才刚&quot;,&quot;董事会&quot;,&quot;CEO&quot;,120000f)); request.setAttribute(&quot;employee_list&quot;, list); //请求转发到ftl文件上 request.getRequestDispatcher(&quot;/employee.ftl&quot;).forward(request, response); &#125; –ftl显示页面 123456789101112&lt;#-- 遍历集合，将数据填到每一行 --&gt; &lt;#list employee_list as emp&gt; &lt;tr&gt; &lt;td&gt;$&#123;emp_index+1&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.empno?string(&quot;0&quot;)&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.department&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.job&#125;&lt;/td&gt; &lt;td style=&quot;color: red;font-weight: bold&quot;&gt; ￥$&#123;emp.salary?string(&quot;0.00&quot;)&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; 效果图","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Freemaker","slug":"Freemaker","permalink":"https://618dt.github.io/tags/Freemaker/"}],"author":"LCG"},{"title":"监听器","slug":"监听器","date":"2022-01-26T12:03:00.000Z","updated":"2022-02-21T11:24:50.906Z","comments":true,"path":"p/83aa.html","link":"","permalink":"https://618dt.github.io/p/83aa.html","excerpt":"","text":"监听器 - Listener◇监听器是J2EE Servlet模块下的组件◇Listener的作用是对Web应用对象的行为进行监控◇通过Listener监听自动触发指定的功能代码 三种监听对象◇ServletContext - 对全局ServletContext及其属性进行监听◇HttpSession - 对用户会话及其属性操作进行监听◇ServletRequest - 对请求及属性操作进行监听 过滤器与监听器的区别◇过滤器的职责是对URL进行过滤拦截，是主动的执行◇监听器的职责是对Web对象进行监听，是被动触发 开发监听器三要素◇实现XxxListener接口，不同接口对应不同监听对象◇实现每个接口中独有的方法，实现触发监听的后续操作◇在web.xml中配置是使听器生效代码演示 123456789101112131415@WebListener//使用注解配置public class FirstListener implements ServletContextListener&#123; @Override public void contextDestroyed(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(&quot;已销毁&quot;); &#125; @Override public void contextInitialized(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(&quot;已初始化&quot;); &#125; –使用xml配置 123&lt;listener&gt; &lt;listener-class&gt;com.lcg.listener.FirstListener&lt;/listener-class&gt; &lt;/listener&gt; 六种常用监听接口内置对象监听接口◇ServletContextListener - 监听ServletContext对象创建、销毁等操作◇HttpSessionListener - 监听HttpSession对象创建、销毁等操作◇ServletRequestListener - 监听 HttpServletRequest对象创建、销毁等操作 属性监听接口◇ServletContextAttributeListener - 监听全局属性操作◇HttpSessionAttributeListener -监听用户会话属性操作◇ServletRequestAttributeListener -监听请求属性操作 监听器的应用场景请求流量分析代码演示： –监听器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*导包部分省略*/public class RequestTotalListener implements ServletContextListener,ServletRequestListener&#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; // TODO Auto-generated method stub &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; // TODO Auto-generated method stub /*排除/rt这个url的访问统计*/ HttpServletRequest request = (HttpServletRequest)sre.getServletRequest(); String url = request.getRequestURL().toString(); if(url.endsWith(&quot;/rt&quot;)==true) &#123; return; &#125; /*请求初始化，每来一个新的请求，监听器都会执行此方法。则应当在此方法中记录变化的值 * 存储结构：TimeList: 10:02 10:03 ... 访问时间 * ValueList: 5 7 ... 访问次数 * */ //先获取全局属性，再记录 List&lt;String&gt; timeList = (List)sre.getServletContext().getAttribute(&quot;timeList&quot;); List&lt;Integer&gt; valueList = (List)sre.getServletContext().getAttribute(&quot;valueList&quot;); Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm&quot;); String time = sdf.format(date); if(timeList.indexOf(time)==-1) &#123; timeList.add(time);//如果时间不存在，则追加 valueList.add(1); sre.getServletContext().setAttribute(&quot;timeList&quot;, timeList); sre.getServletContext().setAttribute(&quot;valueList&quot;, valueList); &#125;else &#123; int index = timeList.indexOf(time);//若存在，则返回时间的索引值 int value = valueList.get(index);//根据时间的索引获取value值 valueList.set(index, value+1); sre.getServletContext().setAttribute(&quot;valueList&quot;, valueList); &#125; &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; // TODO Auto-generated method stub &#125; @Override public void contextInitialized(ServletContextEvent sce) &#123; // TODO Auto-generated method stub //全局初始化时间和值两个属性，一个保存时间，一个保存数值 List timeList = new ArrayList(); List valueList = new ArrayList(); //两个属性的值会随着请求变化 sce.getServletContext().setAttribute(&quot;timeList&quot;, timeList); sce.getServletContext().setAttribute(&quot;valueList&quot;, valueList); &#125;&#125; –Servlet 1234567891011121314151617181920212223242526272829303132333435363738394041/*导包部分省略*/@WebServlet(&quot;/rt&quot;)public class RequestTotalServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public RequestTotalServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext(); List&lt;String&gt; timeList = (List)context.getAttribute(&quot;timeList&quot;); List&lt;Integer&gt; valueList = (List)context.getAttribute(&quot;valueList&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); /* response.getWriter().println(timeList.toString()); response.getWriter().println(&quot;&lt;br&gt;&quot;); response.getWriter().println(valueList.toString());*/ //将原来的数据封装成JSON Map result = new HashMap(); result.put(&quot;timeList&quot;, timeList); result.put(&quot;valueList&quot;, valueList); String json = JSON.toJSONString(result); response.getWriter().println(json); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; –统计页面◇EChart数据可视化插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showChart()&#123; //ajax获取./rt的数据，成功后将json数据的数组代替原来的数组 $.ajax(&#123; url:&quot;./rt&quot;, type:&quot;get&quot;, dataType:&quot;json&quot;, success: function(json)&#123; console.log(json.timeList); console.log(json.valueList); // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(&#x27;main&#x27;)); // 指定图表的配置项和数据 var option = &#123; title : &#123; //标题 text : &#x27;请求流量分析&#x27; // 标题文本 &#125;, tooltip : &#123;&#125;, legend : &#123; data : [ &#x27;访问量&#x27; ] &#125;, xAxis : &#123; //x轴坐标数据 data : json.timeList //json.timeList类型正好是数组 &#125;, yAxis : &#123;&#125;, series : [ &#123; name : &#x27;访问量&#x27;, type : &#x27;line&#x27;,//图表形式,bar代表柱状图,line表示折线图 data : json.valueList &#125; ] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &#125;) &#125; window.setInterval(&quot;showChart()&quot;,1000);//每一秒执行showChart()函数 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态数据预处理 ◇创建类来定义结构 ◇创建监听器初始化和设置属性 ◇利用jst-l来获取属性，展示在页面​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Listener","slug":"Listener","permalink":"https://618dt.github.io/tags/Listener/"}],"author":"LCG"},{"title":"过滤器","slug":"过滤器","date":"2022-01-26T12:01:00.000Z","updated":"2022-03-06T09:02:54.634Z","comments":true,"path":"p/cb9.html","link":"","permalink":"https://618dt.github.io/p/cb9.html","excerpt":"","text":"基础初识过滤器◇过滤器(Filter)是J2EE servlet模块下的组件◇Filter的作用是对URL进行统一的拦截处理◇Filter通常用于应用程序层面进行全局处理◇过滤链，正向传递请求，最终有ServletJSP处理，然后逆向响应； 开发过滤三要素◇任何过滤器都要实现javax.servlet.Filter接口◇在Filter接口的doFilter()方法中编写过滤器的功能代码◇在web.xml中对过滤器进行配置，说明拦截URL的范围 开发第一个过滤器代码演示：1.任何过滤器都要实现javax.servlet.Filter接口；在Filter接口的doFilter()方法中编写过滤器的功能代码 1234567891011121314151617181920212223public class MyFirstFilter implements Filter&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器已生效&quot;); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 2.在web.xml中对过滤器进行配置，说明拦截URL的范围 123456789101112&lt;!-- filter标签用于说明哪个类是过滤器，并在启动时自动加载 --&gt;&lt;filter&gt; &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lcg.filter.MyFirstFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;!-- filter-mapping标签用于说明过滤器对URL应用的范围，要点有二：1.filter-name 过滤器名称与filter.filter-name保持一致2.url-pattern 说明过滤作用范围，/*代表对所有URL进行过滤 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器生命周期 ◇代码演示 1234567891011121314151617181920212223public class MyFirstFilter implements Filter&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器已销毁&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器已生效&quot;); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器初始化&quot;); &#125;&#125; ◇运行结果:启动Tomcat后，过滤器自动初始化； 在浏览器进行访问时，如果访问的地址符合过滤策略，则过滤器会生效； 当关闭Tomcat后，过滤器自动销毁； 过滤器特性◇过滤器对象在Web应用启动时被创建且全局唯一◇唯一的过滤器对象在并发环境中采用”多线程”提供服务 过滤器的配置形式◇在xml中配置 过滤器的注解形式◇在class中注解 1@WebFilter(filterName=&quot;MyAnnoationFilter&quot;,urlPatterns=&quot;/*&quot;) 配置与注解如何选择◇配置形式维护性更好，适合应用全局过滤◇注解形式开发体验更好，适用于小型项目敏捷开发◇尽量避免混合使用 过滤器开发开发字符集过滤器◇web中文乱码的解决◇缺点：每一个servlet都要单独设置，无法统一设置；◇使用字符集过滤器解决： 1234567891011@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub //必须强制转换为HttpServletRequest，与Servlet底层机制有关 HttpServletRequest req = (HttpServletRequest)request; req.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponse res = (HttpServletResponse)response; res.setContentType(&quot;text/html;charset=utf-8&quot;); chain.doFilter(request, response); &#125; ServletRequest接口 过滤器参数化◇过滤器为了增强灵活性，允许配置信息放在web.xml◇在web.xml中配置&lt;init-param&gt;设置过滤器参数◇优化字符集过滤器 代码演示： –xml配置 12345678&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lcg.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;!--参数名--&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;!--参数值--&gt; &lt;/init-param&gt;&lt;/filter&gt; –过滤器使用 123456789101112131415161718 private String encoding;//类中的全局私有变量 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub encoding = filterConfig.getInitParameter(encoding);//获取前面设置的参数 &#125;@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub //必须强制转换为HttpServletResponse，与Servlet底层机制有关 HttpServletRequest req = (HttpServletRequest)request; req.setCharacterEncoding(&quot;encoding&quot;); HttpServletResponse res = (HttpServletResponse)response; res.setContentType(&quot;text/html;charset=&quot;+ encoding); chain.doFilter(request, response); &#125; –注解形式配置 123456@WebFilter(filterName=&quot;CharacterEncodingFilter&quot;,urlPatterns=&quot;/*&quot;,initParams= &#123; @WebInitParam(name=&quot;encoding&quot;,value=&quot;UTF-8&quot;), @WebInitParam(name=&quot;p1&quot;,value=&quot;v1&quot;), @WebInitParam(name=&quot;p2&quot;,value=&quot;v2&quot;)&#125;) url-pattern设置过滤范围url-pattern常用写法◇/index.jsp - 执行资源精准匹配◇/servlet/* - 以前缀进行模糊匹配◇*.jsp - 以后缀进行模糊匹配/映射的问题◇/值映射Web应用根路径，且只对Servlet生效◇默认首页index.jsp会让/失效◇/与/*含义不同，前者指向根路径，后者代表所有◇设置默认首页index.jsp，会隐式的跳转到默认根路径：”/“，则会使配置的过滤器失效。◇设置多个过滤页面，就编写多个&lt;filter-mapping&gt;标签◇注解形式@WebFilter(filterName=””,urlPattrens={“/“, “/servlet/“, “.jsp”}) 过滤链开发注意事项◇每一个过滤器应具有单独职能◇过滤器的执行顺序以&lt;filter-mapping&gt;的书写前后顺序为准 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;filter-chain&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;FilterA&lt;/filter-name&gt; &lt;filter-class&gt;com.lcg.filter.FilterA&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterA&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;FilterB&lt;/filter-name&gt; &lt;filter-class&gt;com.lcg.filter.FilterB&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterB&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;FilterC&lt;/filter-name&gt; &lt;filter-class&gt;com.lcg.filter.FilterC&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterC&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; ◇调用chain.doFilter()将请求向后传递◇会逆向返回，把输出语句放在chain.doFilter()语句后面，会发现过滤器倒序输出。如代码： 12chain.doFilter(request, response);System.out.println(&quot;I&#x27;m Filter A&quot;); 因为此时先执行chain.doFilter()方法，就会先将请求向后传递，而不先执行打印方法；直到不再向后传递请求后(即到了过滤器C)，才执行打印方法，进行逆向的返回；因此会看到打印是C-B-A的逆序；◇使用注解形式的执行顺序，按照类名的名称执行； 项目中过滤器的应用场景◇多端设备自动匹配 –代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.imooc.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class DeviceAdapterFilter implements Filter&#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub HttpServletRequest req = (HttpServletRequest)request; HttpServletResponse res = (HttpServletResponse)response; /* /index.html PC: /desktop/index.html MOBILE: /mobile/index.html /test.html PC: /desktop/test.html MOBILE: /mobile/test.html */ String uri = req.getRequestURI(); System.out.println(&quot;URI:&quot; + uri); //startWith判断是否以&quot;&quot;开头 if(uri.startsWith(&quot;/desktop&quot;) || uri.startsWith(&quot;/mobile&quot;)) &#123; //如果输入的是正确的手机端和电脑端的uri,则不需处理,直接向后请求 chain.doFilter(request, response); &#125;else &#123; //否则,根据设备访问特定的uri String userAgent = req.getHeader(&quot;user-agent&quot;).toLowerCase(); String targetURI=&quot;&quot;; if(userAgent.indexOf(&quot;android&quot;)!=-1 || userAgent.indexOf(&quot;iphone&quot;) != -1) &#123; targetURI = &quot;/mobile&quot; + uri; System.out.println(&quot;移动端设备正在访问,重新跳转URI:&quot; + targetURI); //sendRedirect()方法将页面重定向到指定的URL地址上 res.sendRedirect(targetURI); &#125;else &#123; targetURI = &quot;/desktop&quot; + uri; System.out.println(&quot;PC端设备正在访问,重新跳转URI:&quot; + targetURI); res.sendRedirect(targetURI); &#125; &#125; &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Filter","slug":"Filter","permalink":"https://618dt.github.io/tags/Filter/"}],"author":"LCG"},{"title":"Java正则表达式","slug":"Java正则表达式","date":"2022-01-26T11:54:00.000Z","updated":"2022-02-21T11:53:27.672Z","comments":true,"path":"p/830d.html","link":"","permalink":"https://618dt.github.io/p/830d.html","excerpt":"","text":"什么是正则表达式◇正则表达式是检查、匹配字符串的表达式◇正则表达式是描述规则，主流语言都有良好支持◇字符串校验、查找与替换是正则表达式的主要使用场景 正则表达式案例◇检查输入身份证号是否合法(15位，18位)◇示例：522725200012140613◇正则表达式：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 字符串匹配范围 元字符◇eg：3213.383219 匹配四个整数，六个小数正则表达式1：[0-9][0-9][0-9][0-9].[0-9][0-9][0-9][0-9][0-9][0-9]可以看出原始方法过于繁琐正则表达式2：\\d\\d\\d\\d.\\d\\d\\d\\d\\d\\d 多次重复匹配 定位匹配 贪婪模式◇在满足条件的情况下尽可能多匹配到字符串（默认）◇eg：111222333 正则： \\d{6,8} 结果：11122233 非贪婪模式◇在满足条件的情况下尽可能少匹配到字符串◇eg：111222333 正则： \\d{6,8}? 结果：111222 表达式分组◇分组将”正则”分组为多个子表达式◇示例：abababcdcdcd◇正则表达式： (ab){3}(cd){3} JavaScript表单验证 –代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;frmInfo&quot;&gt; &lt;div id=&quot;err&quot; style=&quot;color:red&quot;&gt; &lt;/div&gt; &lt;div&gt; 姓名:&lt;input id=&quot;name&quot; name=&quot;name&quot;/&gt; &lt;/div&gt; &lt;div&gt; 身份证:&lt;input id=&quot;idno&quot; name=&quot;idno&quot;/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/div&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;frmInfo&quot;).onsubmit = function()&#123; //在JS中定义正则表达式只需在 /正则表达式/ var regex1 = /^[\\u4e00-\\u9fa5]&#123;2,8&#125;$/; var regex2 = /^[1234568]\\d&#123;16&#125;[0-9xX]$/ var name = document.getElementById(&quot;name&quot;).value; var idno = document.getElementById(&quot;idno&quot;).value; //利用正则校验数据，true表示匹配 if(regex1.test(name)==false)&#123; document.getElementById(&quot;err&quot;).innerHTML=&quot;无效姓名&quot;; return false;//在onsubmit中，return false代表表单不提交 &#125;else if(regex2.test(idno)==false)&#123; document.getElementById(&quot;err&quot;).innerHTML=&quot;无效身份证号&quot;; return false; &#125; else&#123; alert(&quot;success&quot;); return true; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Java中Web页面信息提取 ◇html 12345678910111213141516171819202122232425262728&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;国际主要城市&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;国际主要城市&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;纽约NewYork&lt;/li&gt; &lt;li&gt;伦敦London&lt;/li&gt; &lt;li&gt;东京Tokyo&lt;/li&gt; &lt;li&gt;巴黎Paris&lt;/li&gt; &lt;li&gt;香港HongKong&lt;/li&gt; &lt;li&gt;新加坡Singapore&lt;/li&gt; &lt;li&gt;悉尼Sydney&lt;/li&gt; &lt;li&gt;米兰Milano&lt;/li&gt; &lt;li&gt;上海Shanghai&lt;/li&gt; &lt;li&gt;北京Beijing&lt;/li&gt; &lt;li&gt;马德里Madrid&lt;/li&gt; &lt;li&gt;莫斯科Moscow&lt;/li&gt; &lt;li&gt;首尔Seoul&lt;/li&gt; &lt;li&gt;曼谷Bangkok&lt;/li&gt; &lt;li&gt;台北Taipei&lt;/li&gt; ... &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; ◇regex类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.lcg.regex;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStreamReader;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexSample &#123; public static void main(String[] args) &#123; StringBuilder content = new StringBuilder(); try &#123; FileInputStream fis = new FileInputStream(&quot;F:\\\\JAVA\\\\workspace\\\\regex\\\\WebContent\\\\sample.html&quot;); //将二进制流转换为可读的字符串流 InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;); //缓冲流，提高对原始文件的读取效率 BufferedReader bufferedReader = new BufferedReader(isr); String lineText=&quot;&quot;; while((lineText=bufferedReader.readLine())!=null) &#123; content.append(lineText+&quot;\\n&quot;);//将读取到的每一行数据追加到content中 &#125; bufferedReader.close(); //System.out.println(content); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //1.创建正则表达式对象 //在字符串中\\前增加一个\\表示原义输出 Pattern p = Pattern.compile(&quot;&lt;li&gt;([\\\\u4e00-\\\\u9fa5]&#123;2,10&#125;)([a-zA-Z]+)&lt;/li&gt;&quot;); //2.匹配正则表达式 Matcher m = p.matcher(content); //3.查找匹配结果 while( m.find()) &#123; //m.group(0)是匹配的完整字符串,1是第一个分组。 // System.out.println(m.group(0)); String chs = m.group(1); String eng = m.group(2); System.out.println(chs+&quot;-&quot;+eng); &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://618dt.github.io/tags/%E6%AD%A3%E5%88%99/"}],"author":"LCG"},{"title":"JQuery与Ajax入门","slug":"JQuery与Ajax入门","date":"2022-01-26T11:53:00.000Z","updated":"2022-02-21T11:52:12.269Z","comments":true,"path":"p/b52a.html","link":"","permalink":"https://618dt.github.io/p/b52a.html","excerpt":"","text":"JQueryJavaScript库◇为了简化JavaScript开发，第三发厂商开发了JavaScript库◇主流JavaScript库有：JQuery, Vue.js, AngularJS, React… jQuery介绍◇jQuery是一个轻量级的JS库，使用简单◇jQuery的核心是选择器，用于获取页面元素◇jQuery提供了大量高效方法，开发速度大幅提升 jQuery选择器实验室12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html &gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;jQuery实验室&lt;/title&gt;&lt;style&gt;.myclass &#123; font-style: italic; color: darkblue;&#125;/* 高亮css类 */.highlight &#123; color: red; font-size: 30px; background: lightblue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;section&quot;&gt; &lt;h2&gt;jQuery选择器实验室&lt;/h2&gt; &lt;input style=&quot;height: 24px&quot; id=&quot;txtSelector&quot; /&gt; &lt;button id=&quot;btnSelect&quot; style=&quot;height: 30px&quot;&gt;选择&lt;/button&gt; &lt;hr /&gt; &lt;div&gt; &lt;p id=&quot;welcome&quot;&gt;欢迎来到选择器实验室&lt;/p&gt; &lt;ul&gt; &lt;li&gt;搜索引擎：&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;span&gt; &lt;a style=&quot;color: darkgreen&quot; href=&quot;http://www.so.com&quot;&gt;360&lt;/a&gt; &lt;/span&gt; &lt;/li&gt; &lt;li&gt;电子邮箱：&lt;a href=&quot;http://mail.163.com&quot;&gt;网易邮箱&lt;/a&gt; &lt;span&gt; &lt;a style=&quot;color: darkgreen&quot; href=&quot;http://mail.qq.com&quot;&gt;QQ邮箱&lt;/a&gt; &lt;/span&gt; &lt;/li&gt; &lt;li&gt;中国名校：&lt;a href=&quot;http://www.tsinghua.edu.cn&quot;&gt;清华大学&lt;/a&gt; &lt;span&gt; &lt;a style=&quot;color: darkgreen&quot; href=&quot;https://www.pku.edu.cn/&quot;&gt;北京大学&lt;/a&gt; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;myclass &quot;&gt;我是拥有myclass类的span标签&lt;/span&gt; &lt;p class=&quot;myclass&quot;&gt;我是拥有myclass的p标签&lt;/p&gt; &lt;form id=&quot;info&quot; action=&quot;#&quot; method=&quot;get&quot;&gt; &lt;div&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;admin&quot; /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;upsd&quot; value=&quot;123456&quot; /&gt; &lt;/div&gt; &lt;div&gt; 婚姻状况： &lt;select id=&quot;marital_status&quot;&gt; &lt;option value=&quot;1&quot;&gt;未婚&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;已婚&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;离异&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;丧偶&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;left clear-left&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* id选择器使用&quot;#id值&quot;进行选择 css选择器使用&quot;.css类名&quot;进行选择 $(&quot;.myclass&quot;).addClass(&quot;highlight&quot;); */ //单击事件 document.getElementById(&quot;btnSelect&quot;).onclick = function()&#123; var selector = document.getElementById(&quot;txtSelector&quot;).value;//获取文本框的值 //jquery的选择器方法 //()里是选择器表达式 $(&quot;*&quot;).removeClass(&quot;highlight&quot;);//清除高亮类 $(selector).addClass(&quot;highlight&quot;);//selector本身是字符串，故不用加&quot;&quot; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Web页面开发的两个要素◇在使用HTML开发页面时，有两个基本点： *选择HTML页面上在哪些元素 *在这些元素上做哪些动作 jQuery选择器◇jQuery选择器用于选中需要操作的页面元素◇语法1：jQuery(选择器表达式)◇语法2：$(选择器表达式) 基本选择器◇基本选择器是jQuery最基础也是最常用的选择器表达式–代码演示 1234$(&quot;#marital_status&quot;).addClass(&quot;highlight&quot;);$(&quot;.myclass&quot;).addClass(&quot;highlight&quot;);$(&quot;a&quot;).addClass(&quot;highlight&quot;);$(&quot;.myclass,a,#marital_status&quot;).addClass(&quot;highlight&quot;); 层叠选择器◇层叠选择器是根据元素的位置关系来获取元素的选择器表达式◇后代选择器：选择所有后代◇子选择器：只选择直接后代◇兄弟选择器：选择prev之后的同级 属性选择器◇属性选择器是根据元素的属性值来选择元素的选择器表达式eg：$(“a[href=’http://www.baidu.com&#39;]&quot;) 位置选择器与表单选择器（了解即可）◇位置选择器是通过位置获取指定的元素，例如”获取第3个元素”eg：$(“.myclass:first”)◇表单选择器是获取表单元素的简化形式，例如：获取所有文本框 操作元素属性◇attr(name|properties|key) - 获取或设置元素属性◇removeAttr(name) - 移除元素属性代码示例： 12345678910&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var href_attr = $(&quot;a[href*=&#x27;163&#x27;]&quot;).attr(&quot;href&quot;);//获取href属性 alert(href_attr); $(&quot;a[href*=&#x27;163&#x27;]&quot;).attr(&quot;href&quot; , &quot;http://www.163.com&quot;);//传递两个参数，则为设置属性 var attr = $(&quot;a&quot;).attr(&quot;href&quot;);//获取当前网页的所有超链接 alert(attr); $(&quot;a&quot;).removeAttr(&quot;href&quot;); &lt;/script&gt; ◇var attr = $(“a”).attr(“href”);如果选中多个属性，在用attr获取多个属性值的时候，默认返回第一个href属性值，而设置则会把所有超链接都设置。总之，在获取属性值时，只会返回第一个符合要求的属性值；而设置属性值时，将所有属性值设置。 操作元素的CSS样式◇css() -获取或设置匹配元素的样式属性◇addClass() -为每个匹配的元素添加指定的类名◇removeClass() - 从所有匹配的元素中删除全部或者指定的类代码示例： 12345678&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;a&quot;).css(&quot;color&quot;,&quot;red&quot;);//将当前页面所有超链接改成红色 //一次性设置多个属性值 $(&quot;a&quot;).css(&#123;&quot;color&quot;:&quot;red&quot;,&quot;font-weight&quot;:&quot;bold&quot;,&quot;font-style&quot;:&quot;italic&quot;&#125;); var color = $(&quot;a&quot;).css(&quot;color&quot;);//获取匹配元素(第一个)属性值 $(&quot;li&quot;).addClass(&quot;highlight&quot;);//添加类，多个类用空格分开 &lt;/script&gt; 设置元素内容◇val() -获取或设置输入项的值◇text() -获取或设置元素的纯文本◇html() -获取或设置元素内部的HTML代码示例： 12345678910111213&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script &gt; //设置文本框的数据 $(&quot;input[name=&#x27;uname&#x27;]&quot;).val(&quot;adminstrator&quot;); //获取文本框的数据 var n = $(&quot;input[name=&#x27;uname&#x27;]&quot;).val(); /*text与html方法最大的区别在于对于文本中的html标签是否 进行转义*/ $(&quot;span.myclass&quot;).text(&quot;男儿何不带吴钩&quot;); $(&quot;p.myclass&quot;).html(&quot;&lt;b&gt;收取关山五十州&lt;/b&gt;&quot;); //获取属性 var m = $(&quot;p.myclass&quot;).html(); &lt;/script&gt; jQuery事件处理方法◇on(“click”, function) - 为选中的页面元素绑定单击事件◇click(function) - 是绑定事件的简写形式◇处理方法中提供了event参数包含了事件的相关信息代码示例： 1234567891011121314151617&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script &gt; $(&quot;p.myclass&quot;).on(&quot;click&quot;,function()&#123; //$(this)是指当前事件产生的对象 $(this).css(&quot;background-color&quot;,&quot;yellow&quot;); &#125;) //简化方法 $(&quot;span.myclass&quot;).click(function()&#123; $(this).css(&quot;background-color&quot;,&quot;pink&quot;); &#125;) //键盘事件,输入空格显示红色警告 $(&quot;input[name=&#x27;uname&#x27;]&quot;).keypress(function(event)&#123; if(event.key==&quot; &quot;)&#123; $(this).css(&quot;color&quot;,&quot;red&quot;); &#125; &#125;) &lt;/script&gt; AjaxAjax介绍◇Asynchronous JavaScript And XML(异步的JavaScript和XML)◇Ajax可以在不刷新页面的前提下，进行页面局部更新◇Ajax不是新的技术，Ajax并不是W3C的标准 Ajax的使用流程◇创建XmlHttpRequest对象 -XmlHttpRequest用于在后台与服务器交换数据，是AJAX的核心 -XmlHttpRequest并不是W3C的标准，不同浏览器创建方式不同 -通用创建代码： 12345678var xmlhttp; if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();//火狐，谷歌等新版本浏览器 &#125;else&#123; //IE5,IE6等老版本浏览器代码 xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; ◇发送Ajax请求 -xmlhttp.open()用于创建请求 -xmlhttp.send()用于发送请求 -代码： 123//发送Ajax请求 xmlhttp.open(&quot;GET&quot;, &quot;/ajax/content&quot;, &quot;ture&quot;);//true表示此请求为异步方式 xmlhttp.send(); ◇处理服务器响应 -xmlhttp.onreadystatechange()事件用于监听AJAX的执行过程 -xmlhttp.readyState属性说明XMLHttpRequest当前状态 -xmlhttp.status属性服务器响应状态码， 200：成功 ；404：未找到 … -代码示例： 123456789//处理服务器响应xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState == 4&amp;&amp; xmlhttp.status == 200)&#123; var t = xmlhttp.responseText; alert(t); //处理服务器响应文本 document.getElementById(&quot;divContent&quot;).innerHTML = t; &#125;&#125; 利用Ajax实现新闻列表 开发模式： ①创建新闻类，设置新闻的格式框架 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lcg.ajax;public class News &#123; private String title; private String date; private String source; private String content; public News() &#123; &#125; public News(String title, String date, String source, String content) &#123; super(); this.title = title; this.date = date; this.source = source; this.content = content; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getSource() &#123; return source; &#125; public void setSource(String source) &#123; this.source = source; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; &#125; ②创建Servlet，初始化新闻数据，并将数据序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lcg.ajax;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.alibaba.fastjson.JSON;/** * Servlet implementation class NewsListServlet */@WebServlet(&quot;/newslist&quot;)public class NewsListServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public NewsListServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; List list = new ArrayList(); list.add(new News(&quot;TIOBE:2018年5月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年6月份全球编程语言排行榜&quot;,&quot;2018-6-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年7月份全球编程语言排行榜&quot;,&quot;2018-7-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年8月份全球编程语言排行榜&quot;,&quot;2018-8-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); //转换为json对象 String json = JSON.toJSONString(list);//fastjson为java提供的json对象 System.out.print(json); response.setContentType(&quot;text/html;charset=UTF-8&quot;); //list集合在早期采用转换为xml传输，现在使用json来序列化， response.getWriter().println(json); &#125;&#125; ③实现页面，将json转为html输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //1.创建XMLHttpRequest var xmlhttp; if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();//火狐，谷歌等新版本浏览器 &#125;else&#123; //IE5,IE6等老版本浏览器代码 xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2.发送Ajax请求 xmlhttp.open(&quot;GET&quot;, &quot;/ajax/newslist&quot;, &quot;ture&quot;);//true表示此请求为异步方式 xmlhttp.send(); //3.处理服务器响应 xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState == 4&amp;&amp; xmlhttp.status == 200)&#123; var text = xmlhttp.responseText; console.log(text); var json = JSON.parse(text);//JavaScript内置的JSON对象 console.log(json); var html =&quot; &quot;; //循环输出新闻 for(var i = 0;i&lt;json.length;i++)&#123; var news = json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h1&gt;&quot;; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h2&gt;&quot;;//&amp;nbsp表示空格 html=html+&quot;&lt;hr/&gt;&quot;;//分割 &#125; //处理服务器响应文本,实现动态加载 document.getElementById(&quot;container&quot;).innerHTML=html; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同步与异步的区别◇同步：只有前面的执行完成后，后面的才能执行，代码处于阻塞状态；◇异步：在网络发送过程中，不进行代码的阻塞； Ajax函数jQuery对Ajax的支持◇jQuery对Ajax进行封装，提供了$.ajax()方法◇语法：$.ajax(options) jsonp：解决数据跨域传输问题函数使用方法–Servlet1234567891011121314151617181920212223242526@SuppressWarnings(&quot;null&quot;)protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取传递参数?t=pypl|tiobe String type = request.getParameter(&quot;t&quot;); List list = new ArrayList(); if (type != null &amp;&amp; type.equals(&quot;pypl&quot;)) &#123; list.add(new News(&quot;PYPL:2018年4月份全球编程语言排行榜&quot;, &quot;2018-5-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); list.add(new News(&quot;PYPL:2018年5月份全球编程语言排行榜&quot;, &quot;2018-6-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); list.add(new News(&quot;PYPL:2018年6月份全球编程语言排行榜&quot;, &quot;2018-7-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); list.add(new News(&quot;PYPL:2018年7月份全球编程语言排行榜&quot;, &quot;2018-8-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); &#125; else if (type != null &amp;&amp; type.equals(&quot;tiobe&quot;)) &#123; list.add(new News(&quot;TIOBE:2018年4月份全球编程语言排行榜&quot;, &quot;2018-5-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年5月份全球编程语言排行榜&quot;, &quot;2018-6-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年6月份全球编程语言排行榜&quot;, &quot;2018-7-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年7月份全球编程语言排行榜&quot;, &quot;2018-8-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); &#125; String json = JSON.toJSONString(list);// fastjson为java提供的json对象 System.out.print(json); response.setContentType(&quot;text/html;charset=UTF-8&quot;); response.getWriter().println(json);&#125; -jquery_news.html123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //jQuery对Ajax的支持$(function()&#123; $.ajax(&#123; &quot;url&quot; : &quot;/ajax/newslist&quot;, &quot;type&quot; : &quot;get&quot; , &quot;data&quot; : &#123;&quot;t&quot;:&quot;pypl&quot;, &quot;abc&quot;:&quot;123&quot;, &quot;uu&quot;:&quot;777&quot;&#125;, //&quot;data&quot;:&quot;t=pypl&amp;abc=123&amp;uu=777&quot;,多个参数时可用json格式写，但最终还是转换为这种形式 &quot;dataType&quot; : &quot;json&quot; , &quot;success&quot; : function(json)&#123; console.log(json); for(var i = 0 ; i &lt; json.length ; i++)&#123; $(&quot;#container&quot;).append(&quot;&lt;h1&gt;&quot; + json[i].title + &quot;&lt;/h1&gt;&quot;); &#125; &#125;, //xmlhttp对象，errorText错误文本 &quot;error&quot;:function(xmlhttp,errorText)&#123; console.log(xmlhttp); console.log(errorText); //根据错误状态码显示错误信息 if(xmlhttp.status==&quot;405&quot;)&#123; alert(&quot;无效的请求方式&quot;); &#125;else if(xmlhttp.status==&quot;404&quot;)&#123; alert(&quot;未找到URL资源&quot;); &#125;else if(xmlhttp.status==&quot;500&quot;)&#123; alert(&quot;服务器内部错误，请联系管理员&quot;); &#125; &#125; &#125;)&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现二级联动菜单①类实现123456789101112131415161718192021222324252627package com.lcg.ajax;public class Channel &#123; private String code; private String name;public Channel() &#123; &#125;public Channel(String code, String name) &#123; super(); this.code = code; this.name = name;&#125;public String getCode() &#123; return code;&#125;public void setCode(String code) &#123; this.code = code;&#125;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125; &#125; ②数据初始化123456789101112131415161718192021222324252627282930313233 /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String level = request.getParameter(&quot;level&quot;);//根据level判断查询哪一频道 String parent = request.getParameter(&quot;parent&quot;); List chlist = new ArrayList(); if(level.equals(&quot;1&quot;)) &#123; chlist.add(new Channel(&quot;ai&quot;,&quot;前沿/区块链/人工智能&quot;)); chlist.add(new Channel(&quot;web&quot;,&quot;前端/小程序/JS&quot;)); &#125;else if(level.equals(&quot;2&quot;)) &#123; if(parent.equals(&quot;ai&quot;)) &#123; chlist.add(new Channel(&quot;micro&quot; , &quot;微服务&quot;)); chlist.add(new Channel(&quot;blockchain&quot; , &quot;区块链&quot;)); chlist.add(new Channel(&quot;other&quot; , &quot;...&quot;)); &#125;else if(parent.equals(&quot;web&quot;))&#123; chlist.add(new Channel(&quot;html&quot; , &quot;HTML&quot;)); chlist.add(new Channel(&quot;css&quot; , &quot;CSS&quot;)); chlist.add(new Channel(&quot;other&quot; , &quot;...&quot;)); &#125; &#125; //JSON序列化 String json = JSON.toJSONString(chlist); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(json); &#125;&#125; ③页面显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //页面就绪函数 $(function()&#123; $.ajax(&#123; &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:&#123;&quot;level&quot;:&quot;1&quot;&#125;, &quot;type&quot;:&quot;get&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)&#123; for(var i=0;i&lt;json.length;i++)&#123; var ch = json[i]; $(&quot;#lv1&quot;).append(&quot;&lt;option value=&#x27;&quot;+ch.code+&quot;&#x27;&gt;&quot;+ch.name+&quot;&lt;/option&gt;&quot;) &#125; &#125; &#125;) &#125;) //页面就绪函数，联动二级频道的数据 $(function()&#123; $(&quot;#lv1&quot;).on(&quot;change&quot;,function()&#123; var parent = $(this).val(); $.ajax(&#123; &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:&#123;&quot;level&quot;:&quot;2&quot;, &quot;parent&quot;:parent&#125;, &quot;type&quot;:&quot;get&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)&#123; //清除lv2下的原始option选项 $(&quot;#lv2&gt;option&quot;).remove(); for(var i=0;i&lt;json.length;i++)&#123; var ch = json[i]; $(&quot;#lv2&quot;).append(&quot;&lt;option value=&#x27;&quot;+ch.code+&quot;&#x27;&gt;&quot;+ch.name+&quot;&lt;/option&gt;&quot;) &#125; &#125; &#125;) &#125;) &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 一级栏目 --&gt; &lt;select id=&quot;lv1&quot; style=&quot;width:200px;height:30px&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;请选择&lt;/option&gt; &lt;/select&gt; &lt;!-- 二级栏目 --&gt; &lt;select id=&quot;lv2&quot; style=&quot;width:200px;height:30px&quot;&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://618dt.github.io/tags/Ajax/"}],"author":"LCG"},{"title":"JSON入门","slug":"JSON入门","date":"2022-01-26T10:08:00.000Z","updated":"2022-02-21T11:24:50.903Z","comments":true,"path":"p/2e67.html","link":"","permalink":"https://618dt.github.io/p/2e67.html","excerpt":"","text":"导学◇JSON入门◇jQuery与Ajax◇正则表达式◇过滤器 JSON语法规则JSON介绍◇JavaScript Object Notation(JavaScript对象表示法)◇JSON是轻量级的文本数据交换格式◇JSON独立于语言，具有自我描述性，更易理解◇示例代码： 123456&#123; &quot;sites&quot;:[ &#123;&quot;name&quot;:&quot;张珊&quot;,&quot;age&quot;:&quot;22&quot;&#125;, &#123;&quot;name&quot;:&quot;李肆&quot;,&quot;age&quot;:&quot;21&quot;&#125; ]&#125; JSON语法规则◇数据由键(key)/值(value)描述，由逗号分隔；键和值均用””包裹。◇大括号代表一个完整的对象，拥有多个键/值对◇中括号保存数组，多个对象之间使用逗号分隔，最后一个不用 代码演示 –在JavaScript中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; var json = [ &#123; &quot;empno&quot;: &quot;2023&quot;, &quot;ename&quot;: &quot;李才刚&quot;, &quot;job&quot;: &quot;首席执行官&quot;, &quot;hiredate&quot;: &quot;2025-06-18&quot;, &quot;salary&quot;: &quot;500000&quot;, &quot;dname&quot;: &quot;董事会&quot; &#125;, &#123; &quot;empno&quot;: &quot;2021&quot;, &quot;ename&quot;: &quot;石磊&quot;, &quot;job&quot;: &quot;客服经理&quot;, &quot;hiredate&quot;: &quot;2028-01-26&quot;, &quot;salary&quot;: &quot;8000&quot;, &quot;dname&quot;: &quot;市场部&quot;, &quot;customers&quot;: [ &#123; &quot;cname&quot;: &quot;吴浩&quot; &#125;, &#123; &quot;cname&quot;: &quot;方传书&quot; &#125; ] &#125; ]; //在浏览器控制台中对json内容进行输出 console.log(json); //在浏览器页面进行输出 for(var i = 0 ; i &lt; json.length ; i++)&#123; var emp = json[i]; document.write(&quot;&lt;h1&gt;&quot;); document.write(emp.empno); document.write(&quot;,&quot; + emp.ename); document.write(&quot;,&quot; + emp.job); document.write(&quot;,&quot; + emp.hiredate); document.write(&quot;,&quot; + emp.salary); document.write(&quot;,&quot; + emp.dname); document.write(&quot;&lt;/h1&gt;&quot;); if(emp.customers != null)&#123; document.write(&quot;&lt;h2&gt;---&quot;) for(var j = 0 ; j &lt; emp.customers.length ; j++)&#123; var customer = emp.customers[j]; document.write(customer.cname + &quot;,&quot;) &#125; document.write(&quot;&lt;/h2&gt;&quot;) &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; JSON与字符串互相转换(在js中)◇JSON.parse()方法将字符串转换为JSON对象◇JSON.stringify()方法将JSON对象转换为字符串eg： 123456&lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;&#123;\\&quot;class_name\\&quot;:\\&quot;五年级三班\\&quot;&#125;&quot;; var json=JSON.parse(str); console.log(str); console.log(json);&lt;/script&gt; ◇原始的字符串和json对象打印显示在浏览器控制台中；第一行是原始的字符串；下面就是json对象(Object);json对象中包含一个class_name的属性，值为”五年级三班” 1234&lt;script type=&quot;text/javascript&quot;&gt; var json=&#123;&quot;class_name&quot;:&quot;五年级三班&quot;&#125;; var str = JSON.stringify(json); &lt;/script&gt; –初始化json的另一种方法 123var json =&#123;&#125;;//先定义json.class_name=&quot;五年级三班&quot;;json.teacher=&quot;王老师&quot;; JSON与Java交互FastJson工具包◇Java的JSON工具包还有FastJson、Jackson、Gson、Json-lib…◇FastJson是阿里著名的JSON序列化与反序列工具包◇FastJson国内拥有大量使用者，拥有API简单，效率高等优点 FastJson序列化与JSON注解 –单个 123456@JSONField(format=&quot;yyyy-MM-dd&quot;)//注解，格式化输出日期private Date hdate;@JSONField(serialize=false)//不对下面的dname成员序列化private String dname;String json = JSON.toJSONString(employee);Employee emp = JSON.parseObject(json,Employee.class);//将JSON反序列化 –多个 1234567891011121314151617181920212223242526package com.lcg.json;import java.util.ArrayList;import java.util.List;import com.alibaba.fastjson.JSON;public class FastJsonSample2 &#123; public static void main(String[] args) &#123; List emplist = new ArrayList(); //模拟100个员工 for(int i =1;i&lt;=100;i++) &#123; Employee employee = new Employee(); employee.setEmpno(2020+i); employee.setEname(&quot;员工&quot;+i); emplist.add(employee); &#125; String json = JSON.toJSONString(emplist); //将转换后的字符解析成链表 List&lt;Employee&gt; emps = JSON.parseArray(json,Employee.class); for(Employee e:emps) &#123; System.out.println(e.getEmpno()+&quot;:&quot;+e.getEname()); &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://618dt.github.io/tags/JSON/"}],"author":"LCG"},{"title":"JSTL与EL表达式","slug":"JSTL与EL表达式","date":"2022-01-24T16:00:00.000Z","updated":"2022-02-21T08:53:03.259Z","comments":true,"path":"p/5d7.html","link":"","permalink":"https://618dt.github.io/p/5d7.html","excerpt":"","text":"初识EL表达式EL表达式◇EL(Expression Language)表达式语言，用于简化JSP的输出◇EL表达式的基本语法：${表达式}eg： 12JSP：&lt;h1&gt;学生姓名：&lt;%=student.name%&gt; &lt;/h1&gt;EL：&lt;h1&gt;学生姓名：$&#123;student:name&#125;&lt;/h1&gt; ◇代码演示 –学生信息类 12345678910111213141516171819package com.gamest.el;public class Student &#123; private String name; private String mobile; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; &#125; –Servlet初始化 123456789101112protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Student stu = new Student(); stu.setName(&quot;李与析&quot;); stu.setMobile(&quot;HUAWEI&quot;); String grade = &quot;A&quot;; //info.jsp用来展现学生信息，studentservlet用来初始化 request.setAttribute(&quot;student&quot;, stu); request.setAttribute(&quot;grade&quot;, grade); request.getRequestDispatcher(&quot;/info.jsp&quot;).forward(request, response); &#125; –JSP显示信息(传统方法) 123456789&lt;body&gt; &lt;% Student stu = (Student)request.getAttribute(&quot;student&quot;); String grade = (String)request.getAttribute(&quot;grade&quot;); out.println(&quot;&lt;h1&gt;姓名：&quot;+stu.getName()+&quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h2&gt;手机：&quot;+stu.getMobile()+&quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;h1&gt;教师等级：&quot;+grade+&quot;&lt;/h1&gt;&quot;); %&gt;&lt;/body&gt; –EL表达式方法 12345&lt;body&gt; &lt;h1&gt;姓名：$&#123;requestScope.student.name&#125;&lt;/h1&gt; &lt;h1&gt;手机：$&#123;requestScope.student.mobile&#125;&lt;/h1&gt; &lt;h1&gt;评级：$&#123;requestScope.grade&#125;&lt;/h1&gt;&lt;/body&gt; 作用域对象◇EL表达式内置四种作用域对象代码示例： –将学生信息放在session会话中 123456789101112protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Student stu = new Student(); stu.setName(&quot;李与析&quot;); stu.setMobile(&quot;HUAWEI&quot;); String grade = &quot;A&quot;; //将学生信息放在session会话中 HttpSession session = request.getSession(); session.setAttribute(&quot;student&quot;, stu); session.setAttribute(&quot;grade&quot;, grade); request.getRequestDispatcher(&quot;/info.jsp&quot;).forward(request, response); &#125; –则应当使用sessionScope 12345&lt;body&gt; &lt;h1&gt;姓名：$&#123;sessionScope.student.name&#125;&lt;/h1&gt; &lt;h1&gt;手机：$&#123;sessionScope.student.mobile&#125;&lt;/h1&gt; &lt;h1&gt;评级：$&#123;sessionScope.grade&#125;&lt;/h1&gt;&lt;/body&gt; –EL也可以忽略作用域对象 它会自动按作用域从小到大的顺序获取(page -&gt; application)若都没有，则会输出空字符串； 12345&lt;body&gt; &lt;h1&gt;姓名：$&#123;student.name&#125;&lt;/h1&gt; &lt;h1&gt;手机：$&#123;student.mobile&#125;&lt;/h1&gt; &lt;h1&gt;评级：$&#123;grade&#125;&lt;/h1&gt;&lt;/body&gt; EL表达式输出◇语法: ${[作用域].属性名.[子属性]}◇EL表达式支持将运算结果进行输出◇EL支持绝大多数对象输出，本质是调用toString()方法eg：${title} //将自定义属性title输出${emp.salary + 300} //算术运算${1&lt;=3&amp;&amp;2&gt;4}​ 通过改写toString()方法可以就可以使用EL表达式按照自定义的格式输出对象: 123456publie String toString()&#123; return name + &quot;:&quot; + moblie;&#125;直接输出对象，student具有子属性；$&#123;student&#125;; EL输出参数值◇EL表达式内置param对象来简化参数的输出◇语法:${param.参数名} eg：${param.teacher}； 浏览器输入：?teacher=王老师 JSTLJSTL标签库◇JSTL(JSP Standard Tag Library),JSP标准标签库◇JSTL用于简化JSP开发，提高代码可读性与可维护性◇JSTL由SUN(Oracle)定义规范，由Apache Tomcat团队实现 下载JSTL标签库◇官方地址：http://tomcat.apache.org◇JSTL v1.2.5组件介绍 如果需要默认支持JSTL，则需将前两个包复制到Tomcat\\apache-tomcat-8.5.34\\lib目录中；仅工程目录的话，就复制到工程文件的lib中。 JSTL的标签库种类◇JSTL按功能划分可分为五类标签库引用JSTL核心库◇核心标签库(Core)是JSTL最重要的标签库，提供了JSTL的基础功能◇&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core&quot; prefix=”c” %&gt;◇JSTL核心标签库在taglibs-standard-impl,jar由META-INF/c.tld定义 判断标签◇JSTL核心库提供了两组判断的标签◇&lt;c:if&gt; -单分支判断◇&lt;c:choose&gt; 、&lt;c:when&gt;、&lt;c:otherwise&gt; - 多分支判断◇代码演示： –Servlet数据端 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;score&quot;, 100); request.setAttribute(&quot;grade&quot;, &quot;A&quot;); request.getRequestDispatcher(&quot;/core.jsp&quot;).forward(request, response); &#125; –JSP 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!--在java或者jsp文件中按住Alt+/可以出现智能提示 --&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;requestScope.score&#125;&lt;/h1&gt; &lt;!-- EL表达式 --&gt; &lt;c:if test =&quot;$&#123;score&gt;=90&#125;&quot;&gt; &lt;!-- 单分支判断 --&gt; &lt;h1 style = &quot;color:green&quot;&gt;恭喜，你已通过考试&lt;/h1&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;score&lt;90&#125;&quot;&gt; &lt;h1 style = &quot;color:red&quot;&gt;很遗憾，请再接再厉&lt;/h1&gt; &lt;/c:if&gt; &lt;!-- choose when otherwise --&gt; $&#123;grade&#125; &lt;c:choose&gt; &lt;!-- 多分支 --&gt; &lt;c:when test=&quot;$&#123;grade==&#x27;A&#x27;&#125;&quot;&gt;&lt;h2&gt;你很优秀&lt;/h2&gt;&lt;/c:when&gt; &lt;c:when test=&quot;$&#123;grade==&#x27;B&#x27;&#125;&quot;&gt;&lt;h2&gt;你很不错&lt;/h2&gt;&lt;/c:when&gt; &lt;c:when test=&quot;$&#123;grade==&#x27;C&#x27;&#125;&quot;&gt;&lt;h2&gt;勉强及格&lt;/h2&gt;&lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h2&gt;再接再厉&lt;/h2&gt;&lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; 遍历集合◇&lt;c:forEach&gt;标签用于遍历集合(Collection)中的每一个对象◇代码演示 –Java创建公司类 12345678910111213141516171819202122package com.lcg.jstl;public class Company &#123; private String cname; private String url; public Company(String cname,String url) &#123; this.cname=cname; this.url=url; &#125; public String getCname() &#123; return cname; &#125; public void setCname(String cname) &#123; this.cname = cname; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125;&#125; –Servlet初始化 123456789protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ArrayList&lt;Company&gt; list=new ArrayList&lt;Company&gt;(); list.add(new Company(&quot;百度&quot;,&quot;www.baidu.com&quot;)); list.add(new Company(&quot;腾讯&quot;,&quot;www.tencent.com&quot;)); list.add(new Company(&quot;交通&quot;,&quot;www.gamest.link&quot;)); request.setAttribute(&quot;companies&quot;, list); request.getRequestDispatcher(&quot;/core.jsp&quot;).forward(request, response); &#125; –core.jsp使用 12345678910&lt;!-- forEach标签用于遍历集合 java代码实现 List companies =(List)request.getAttribute(&quot;companies&quot;); for(Company c : companies)&#123; out.print(&quot;...&quot;) &#125; --&gt; &lt;!--items数据来源 var 数据变量 varStatus变量状态(第几个) --&gt; &lt;c:forEach items=&quot;$&#123;requestScope.companies&#125;&quot; var=&quot;c&quot; varStatus=&quot;idx&quot;&gt; &lt;h2&gt;$&#123;idx.index+1&#125;.$&#123;c.cname&#125;--$&#123;c.url&#125;&lt;/h2&gt; &lt;/c:forEach&gt; 格式化标签库◇fmt格式化标签库 URL:http://java.sun.com/jsp/jstl/fmt◇&lt;fmt:formatDate value=”” pattern =”” &gt; 格式化日期标签◇&lt;fmt:formatNumber value=”” pattern =”” &gt; 格式化数字标签◇代码演示 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% request.setAttribute(&quot;amt&quot;,1575101.585); request.setAttribute(&quot;now&quot;,new java.util.Date()); request.setAttribute(&quot;html&quot;, &quot;&lt;a href=&#x27;index.html&#x27;&gt;index&lt;/a&gt;&quot;); request.setAttribute(&quot;nothing&quot;,null); %&gt; &lt;!-- formatDate pattern yyyy -四位年 MM - 两位月 dd - 两位日 HH - 24小时制 hh - 12小时制 mm - 分钟 ss - 秒数 sss - 毫秒 --&gt; &lt;!--格式化日期--&gt; &lt;h2&gt; &lt;fmt:formatDate value=&quot;$&#123;requestScope.now&#125;&quot; pattern=&quot;yyyy年MM月dd日HH时mm分ss秒&quot;/&gt; &lt;/h2&gt; &lt;!--格式化数字 0.00表示保留两位小数 0,00.00表示按百分位用&#x27;,&#x27;分割--&gt; &lt;h2&gt; &lt;fmt:formatNumber value=&quot;$&#123;requestScope.amt&#125;&quot; pattern=&quot;0.00&quot;/&gt; &lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; ◇默认值，与转义 –defalut设置默认值，escapeXml表示是否进行转义，若转义，则将标签的链接显示出来， 123&lt;h2&gt;null默认值：&lt;c:out value=&quot;$&#123;nothing&#125;&quot; default=&quot;无&quot;&gt;&lt;/c:out&gt;&lt;/h2&gt;&lt;h2&gt;&lt;c:out value=&quot;$&#123;html&#125;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt;&lt;/h2&gt; 综合训练◇创建Dynamic web工程；◇导入静态页面demo文件，放在项目主目录employee下；◇静态的页面◇导入jstl的声明jar包和实现jar包，放入到WEB-INF\\lib目录下；◇新增员工实体类 12345678public class Employee &#123; private Integer empno; private String ename; private String department; private String job; private Float salary; //get和set方法&#125; ◇新建ListServlet初始化数据； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.lcg.employee;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class ListServlet */@WebServlet(&quot;/list&quot;)public class ListServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ListServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext(); if(context.getAttribute(&quot;employees&quot;)==null) &#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); Employee emp = new Employee(2020,&quot;吴浩&quot;,&quot;市场部&quot;,&quot;客户代表&quot;,6000f); list.add(emp); list.add(new Employee(2021,&quot;石磊&quot;,&quot;研发部&quot;,&quot;交通工程师&quot;,8000f)); context.setAttribute(&quot;employees&quot;, list); &#125; //跳转到员工信息页 request.getRequestDispatcher(&quot;/employee.jsp&quot;).forward(request, response); &#125;&#125; ◇将静态的html页面改为动态的jsp页面输出员工信息； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;link href=&quot;css/bootstrap.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/link&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .pagination &#123; margin: 0px &#125; .pagination &gt; li &gt; a, .pagination &gt; li &gt; span &#123; margin: 0 5px; border: 1px solid #dddddd; &#125; .glyphicon &#123; margin-right: 3px; &#125; .form-control[readonly] &#123; cursor: pointer; background-color: white; &#125; #dlgPhoto .modal-body&#123; text-align: center; &#125; .preview&#123; max-width: 500px; &#125; &lt;/style&gt; &lt;script&gt; $(function () &#123; $(&quot;#btnAdd&quot;).click(function () &#123; $(&#x27;#dlgForm&#x27;).modal() &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h1 style=&quot;text-align: center&quot;&gt;交通控股员工信息表&lt;/h1&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;clearfix panel-heading &quot;&gt; &lt;div class=&quot;input-group&quot; style=&quot;width: 500px;&quot;&gt; &lt;button class=&quot;btn btn-primary&quot; id=&quot;btnAdd&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-zoom-in&quot;&gt;&lt;/span&gt;新增 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;职务&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;--利用循环以及EL表达式输出每一个员工的信息 --&gt; &lt;c:forEach items=&quot;$&#123;applicationScope.employees&#125;&quot; var=&quot;emp&quot; varStatus=&quot;idx&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;idx.index+1&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.empno&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.department &#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.job &#125;&lt;/td&gt; &lt;td style=&quot;color: red;font-weight: bold&quot;&gt; ￥&lt;fmt:formatNumber value=&quot;$&#123;emp.salary&#125;&quot; pattern=&quot;0,000.00&quot;&gt;&lt;/fmt:formatNumber&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 表单 --&gt;&lt;div class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; id=&quot;dlgForm&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;新增员工&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form action=&quot;/employee/create&quot; method=&quot;post&quot; &gt; &lt;!-- action表单存放地址 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;empno&quot;&gt;员工编号&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;empno&quot; class=&quot;form-control&quot; id=&quot;empno&quot; placeholder=&quot;请输入员工编号&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;ename&quot;&gt;员工姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;ename&quot; class=&quot;form-control&quot; id=&quot;ename&quot; placeholder=&quot;请输入员工姓名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;部门&lt;/label&gt; &lt;select id=&quot;dname&quot; name=&quot;department&quot; class=&quot;form-control&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;请选择部门&lt;/option&gt; &lt;option value=&quot;市场部&quot;&gt;市场部&lt;/option&gt; &lt;option value=&quot;研发部&quot;&gt;研发部&lt;/option&gt; &lt;option value=&quot;后勤部&quot;&gt;后勤部&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;职务&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;job&quot; class=&quot;form-control&quot; id=&quot;sal&quot; placeholder=&quot;请输入职务&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sal&quot;&gt;工资&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; class=&quot;form-control&quot; id=&quot;sal&quot; placeholder=&quot;请输入工资&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center;&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/body&gt;&lt;/html&gt; ◇实现新增功能，创建新的servlet用于创建员工; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lcg.employee;import java.io.IOException;import java.util.List;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class CreateServlet */@WebServlet(&quot;/create&quot;)public class CreateServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CreateServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ //表单通过post提交; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); String empno = request.getParameter(&quot;empno&quot;);//empno是在jsp中设置的name属性; String ename = request.getParameter(&quot;ename&quot;); String department = request.getParameter(&quot;department&quot;); String job = request.getParameter(&quot;job&quot;); //尽管salary是float类型，但getParameter接收时须为String类型 String salary = request.getParameter(&quot;salary&quot;); Employee emp = new Employee(Integer.parseInt(empno),ename,department,job,Float.parseFloat(salary)); /*将emp对象保存到原始数据中，原始数据由应用全局对象保存， 注意属性employees来自于context.setAttribute(&quot;employees&quot;, list);*/ ServletContext context = request.getServletContext(); //获取初始的数据 List employees = (List)context.getAttribute(&quot;employees&quot;); //添加数据 employees.add(emp); //再将添加完成后的数据放回去 context.setAttribute(&quot;employees&quot;, employees); request.getRequestDispatcher(&quot;/employee.jsp&quot;).forward(request, response); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"EL","slug":"EL","permalink":"https://618dt.github.io/tags/EL/"}],"author":"LCG"},{"title":"Servlet与JSP进阶","slug":"Servlet与JSP进阶","date":"2022-01-23T16:00:00.000Z","updated":"2022-02-21T08:52:49.559Z","comments":true,"path":"p/e24.html","link":"","permalink":"https://618dt.github.io/p/e24.html","excerpt":"","text":"请求与响应的结构HTTP请求的结构◇HTTP请求包含三部分：请求行，请求头，请求体 ◇请求行：第一行，表明请求方法，请求URL及HTTP协议版本。◇常用请求头：Accept；User-Agent(说明操作系统和浏览器的环境)等等；◇只有POST才有请求体；◇F12可以查看请求头等信息 巧用请求头开发多端应用◇在新建JAVA类时，可以直接新建Servlet，它会自动映射到地址；◇代码演示 123456789101112131415protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub String userAgent = request.getHeader(&quot;User-Agent&quot;);//获取浏览器配置信息 response.setContentType(&quot;text/html;charset=utf-8&quot;);//编码方式，支持中文 response.getWriter().println(userAgent); String output = &quot;&quot;; //indexof()方法进行字符串查找，如果找到，则返回大于大于等于0的数字，若未找到，则返回-1； if(userAgent.indexOf(&quot;Windows NT&quot;) != -1) &#123; //!= -1表明找到 output = &quot;&lt;h1&gt;这是ＰＣ端首页&lt;/h1&gt;&quot;; &#125;else if(userAgent.indexOf(&quot;iPhone&quot;) != -1 || userAgent.indexOf(&quot;Android&quot;) != -1) &#123; output = &quot;&lt;h1&gt;这是移动端首页&lt;/h1&gt;&quot;; &#125; response.getWriter().println(output);//对外输出 &#125; 响应的结构◇HTTP响应包含三部分：响应行、响应头、响应体； HTTP常见状态码 ContentType的作用◇ContentType决定浏览器采用何种方法对响应体进行处理 MIME类型 描述 text/plain 纯文本 text/html HTML文档 text/xml XML文档 application/x-msdownload 需要下载的资源 image/jpeg image/gif image/… 图片资源 ◇代码示例 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String output = &quot;&lt;h1&gt;&lt;a href =&#x27;http://www.baidu.com&#x27;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/h1&gt;&quot;; response.setContentType(&quot;application/x-msdownload;charset=utf-8&quot;);//设置类型 response.getWriter().println(output); &#125; 请求转发与重定向使用◇多个Serclet(JSP)之间跳转有两种方式： ◇request.getRequestDispatcher().forward() - 请求转发 ◇response.sendRedirect() - 响应重定向创建一个servlet –运行后登陆：http://localhost:8080/request-struc/direct/check 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;);//在控制台打印显示 //实现了请求转发功能,跳转到首页去 request.getRequestDispatcher(&quot;/direct/index&quot;).forward(request, response); &#125; ◇结果：http://localhost:8080/request-struc/direct/check 地址没有改变； 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;);//在控制台打印显示 //响应重定向需要增加contentPath：/request-struc response.sendRedirect(&quot;/request-struc/direct/index&quot;); &#125; ◇结果： http://localhost:8080/request-struc/direct/index 地址变为跳转界面的url地址；◇分析： –可以看到，请求转发后并没有改变页面地址，而响应重定向却改变了；因为请求转发功能是在服务器，也就是Tomcat内部把请求从第一个Servlet转发到第二个Servlet上；而重定向不同，它是在第一次处理完请求后，由浏览器重新发送一个新的请求，因而改变了地址； 原理请求转发◇请求转发是服务器跳转，只会产生一次请求◇请求转发语句是:request.getRequestDispatcher().forward();响应重定向◇重定向则是浏览器端跳转，会产生两次请求◇响应重定向的语句：response.sendRedirect(); 设置请求自定义属性◇请求允许创建自定义属性◇设置请求属性：request.setAttribute(属性名，属性值)◇获取请求属性：Object attr = request.getAttribute(属性名)◇代码演示 –请求端 Servlet1 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;);//在控制台打印显示 request.setAttribute(&quot;username&quot;, &quot;admin&quot;);//将用户信息保存到请求中 //实现了请求转发功能 request.getRequestDispatcher(&quot;/direct/index&quot;).forward(request, response); &#125; –目的端Servlet2 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取属性,需强制转换 String name = (String)request.getAttribute(&quot;username&quot;); response.getWriter().println(&quot;this index page!current username is &quot; + name); &#125; ◇响应重定向由于会产生两个请求，当它发送第一个请求时，会把自定义属性传递给Tomcat，但第二次重新创建的请求并不包含自定义属性（因为这是新的请求并且直接请求Servlet2了）；因此使用响应重定向时，会看到username is null;如果在Servlet2里增加 request.setAttribute(“username”, “servlet2”);则会显示 username is servlet2； 浏览器Cookie ，Session-用户会话Cookie◇Cookie(小甜饼)是浏览器保存在本地的文本内容◇Cookie常用于保存登录状态，用户资料等小文本◇Cookie具有时效性，Cookie内容会伴随请求发送给Tomcat◇Cookie如果不设置有效期，则默认存在于浏览器窗口中，当浏览器关闭，则自动销毁。◇Cookie是以文件形式保存在电脑本地的: C:\\Users\\ASUS\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cookies文件；–代码演示–登录端，创建Cookie 12345678protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;); Cookie cookie = new Cookie(&quot;user&quot; , &quot;admin&quot;); cookie.setMaxAge(60*60*24*7);//以秒为单位，设置有效期为一周 response.addCookie(cookie);//添加cookie response.getWriter().print(&quot;login success&quot;); &#125; –首页端，获取Cookie 1234567891011121314151617181920protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cs = request.getCookies();//获取Cookie，返回数组 if(cs == null)&#123; response.getWriter().print(&quot;user not login&quot;); return;//为空，终止程序 &#125; String user = null; for(Cookie c : cs) &#123; System.out.print(c.getName()+&quot;:&quot;+c.getValue()); if(c.getName().equals(&quot;user&quot;)) &#123; user=c.getValue();break; &#125; &#125; if(user==null) &#123; response.getWriter().print(&quot;user not login&quot;); &#125;else &#123; response.getWriter().print(&quot;user:&quot;+user); &#125; &#125; Session-用户会话◇Session(用户会话)用于保存于“浏览器窗口”对应的数据；◇Session的数据存储在Tomcat服务器的内存中，具有时效性(30min)；◇Session通过浏览器Cookie的Sessionid值提取用户数据；◇代码演示 –首页端 123456789protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); String sessionId = session.getId();//获取SessionId System.out.println(sessionId); String name = (String)session.getAttribute(&quot;name&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(&quot;这是首页，当前用户为：&quot;+ name); &#125; –登录端 1234567891011protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.print(&quot;用户登录成功&quot;); //获取到用户会话Session对象,登录端和首页的session是同一个对象 HttpSession session = request.getSession(); String sessionId = session.getId();//获取SessionId System.out.println(sessionId); session.setAttribute(&quot;name&quot;, &quot;李&quot;); //请求转发 request.getRequestDispatcher(&quot;/session/index&quot;).forward(request, response); &#125; ◇对于session而言，形象的看成是一个和浏览器窗口绑定的对象；对于这一个浏览器窗口中所产生的数据，Tomcat会创建一个单独的存储空间；每个浏览器窗口所对应的存储空间都是不同的，存储空间的标识符就是sessionId；因此，同一个窗口中，登录和首页两个servlet共用一个存储空间，因此sessionId是一样的，而当切换一个窗口后，sessionId改变； Session实现原理◇对于第一个浏览器窗口，它在向Tomcat发送请求的时候，Tomcat发现这是一个全新的请求，就会自动的在Tomcat的内存中开辟一段存储空间，并给它一个id号；当servlet调用setAttribute()方法的时候，就会将 name=张三 的数据保存在存储空间中，Tomcat就会把刚才生成的SessionId:7U809JP返回给浏览器；浏览器就会把这个id值存储到cookie中； 当浏览器再次请求的时候，就会附带这个sessionId，Tomcat就会根据这个ID去查找到对应的存储空间；假如servlet调用了getAttribute()方法,数据就会从存储空间中获得；◇如果是一个新的浏览器窗口，就会创建新的session; ServletContext◇ ServletContext(Servlet上下文对象)，是Web应用全局对象◇ 一个Web应用只会创建一个ServletContext对象◇ ServletContext随着Web应用启动而自动创建◇代码实现 –初始化 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext(); context.setAttribute(&quot;copyright&quot;,&quot;@2021 gamest.link 京ICP备xxxxxx&quot;); context.setAttribute(&quot;title&quot;, &quot;个人开发网站&quot;); response.getWriter().print(&quot;init susess&quot;); &#125; –默认页 12345678protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext();//获取应用程序全局对象 String copyright = (String)context.getAttribute(&quot;copyright&quot;); String title = (String)context.getAttribute(&quot;title&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().print(&quot;&lt;h1&gt;&quot;+title+&quot;&lt;/h1&gt;&quot;+copyright); &#125; Java Web三大作用域对象◇HttpServletRequest -请求对象 生命周期最短，当请求送往Tomcat，请求对象就会被创建，当Servlet处理完成后，产生响应并返回给浏览器，则就被销毁。​ ◇HttpSession - 用户会话对象 第一次用户发来请求时被创建，一般30分钟内不被访问则会被销毁​ ◇ServletContext - web应用全局对象 Web应用启动时创建，关闭或重启时销毁 问题解决Web应用的中文乱码由来◇Tomcat默认使用字符集ISO-8859-1，属于西欧字符集◇解决乱码的核心思路是将ISO-8859-1转换为UTF-8◇Servlet中请求与响应都需要设置UTF-8字符集​ ◇代码实现 –Get&amp;Post方法分别实现 12345678910111213141516171819202122232425262728protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //对于Tomcat8.x的版本，默认get请求发送中文就是UTF-8的格式，因此无需转换 String ename = request.getParameter(&quot;ename&quot;); String address = request.getParameter(&quot;address&quot;); System.out.println(ename + &quot;:&quot; + address); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(ename + &quot;:&quot; + address); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //request.setCharacterEncoding方法用于将请求体中的字符集转换为UTF-8，方法简单 //但对于get方法无效 request.setCharacterEncoding(&quot;UTF-8&quot;);//一定要写在post方法的第一行 // TODO Auto-generated method stub String ename = request.getParameter(&quot;ename&quot;);//获取基本参数 String address = request.getParameter(&quot;address&quot;); System.out.println(ename + &quot;:&quot; + address); //转换语句，但过于麻烦 //String utf8Ename = new String(ename.getBytes(&quot;iso-8859-1&quot;) , &quot;utf-8&quot;); //String utf8Address = new String(address.getBytes(&quot;iso-8859-1&quot;) , &quot;utf-8&quot;); //System.out.println(utf8Ename + &quot;:&quot; + utf8Address); &#125; web.xml常用配置◇修改web应用默认首页◇Servlet通配符映射及初始化参数◇设置404、500等状态码默认页面​ ◇代码实现–不用指定具体地址，默认访问的页面 12345678&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; //如果index.html存在，则优先访问此页面 &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; ◇Servlet通配符映射(*) –XML 12345678&lt;servlet&gt; &lt;servlet-name&gt;patternServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lcg.servlet.pattern.PatternServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;patternServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/pattern/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; –Java 1234567891011121314151617181920212223242526272829303132333435package com.lcg.servlet.pattern;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class PatternServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //查询员工的基本信息 //获取当前访问的URL String url = request.getRequestURL().toString(); System.out.println(url); //lastIndexOf()方法获取最后一次字符参数出现的位置，substring()方法从指定位置截取字符 String id = url.substring(url.lastIndexOf(&quot;/&quot;) + 1); int eid = Integer.parseInt(id); response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); out.println(id); if(eid == 1) &#123; out.println(&quot;张三&quot;); &#125;else if(eid == 2) &#123; out.println(&quot;李四&quot;); &#125;else &#123; out.println(&quot;其他员工&quot;); &#125; &#125; &#125; ◇配置全局参数(应用程序的基本全局配置项目用context-param标签实现) –XML配置 12345678&lt;context-param&gt; &lt;param-name&gt;copyright&lt;/param-name&gt; &lt;param-value&gt;© 2018 gamest.com 京ICP备 XXXXXXXX号-22&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;title&lt;/param-name&gt; &lt;param-value&gt;无产阶级联合起来！&lt;/param-value&gt; &lt;/context-param&gt; –Java端使用 12345678910protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext();//获取 //获取在web.xml中设置的全局参数使用getInitParameter()方法 String copyright = context.getInitParameter(&quot;copyright&quot;); context.setAttribute(&quot;copyright&quot;, copyright); String title = context.getInitParameter(&quot;title&quot;); context.setAttribute(&quot;title&quot;, title); response.getWriter().println(&quot;init success&quot;); &#125; ◇指定错误页面 123456789&lt;!-- 指定错误页面 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/404.html&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/500.html&lt;/location&gt;&lt;/error-page&gt; JSP九大内置对象◇对于JSP来说，平时我们使用的时候它内置了一些对象来简化我们的操作；◇最重要的一个对象pageContext◇代码实现 12345678910111213141516171819202122232425262728293031&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% //内置对象，可直接拿来使用;因为在经过Tomcat转义为java文件后, //可以发现前面已经定义了HttpServletRequest request String url = request.getRequestURL().toString(); // 即HttpServletRequest对象 response.getWriter().println(url);//HttpServletResponse %&gt; &lt;% out.println(&quot;&lt;br&gt;ABCCC&quot;); session.setAttribute(&quot;user&quot;, &quot;张三&quot;); out.println((String)session.getAttribute(&quot;user&quot;)); %&gt; &lt;% String cp = application.getInitParameter(&quot;copyright&quot;) ; //ServletContext out.println(&quot;&lt;hr/&gt;&quot;); out.println(cp); //pageContext相当于一个中转站,通过它来获取当前页面的其他内置对象; pageContext.getRequest(); pageContext.getResponse(); pageContext.getSession(); pageContext.getServletContext(); %&gt;&lt;/body&gt;&lt;/html&gt; –显示错误信息方法 isErrorPage=”true”表示当前jsp是用来显示错误的页面 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot; isErrorPage=&quot;true&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 服务器内部错误，请联系管理员 ,错误信息如下： &lt;% //应用异常对象 String msg = exception.getMessage(); out.print(&quot;&lt;br&gt;&quot; + exception.getClass().getSimpleName() + &quot;:&quot; + msg); %&gt;&lt;/body&gt;&lt;/html&gt; Java Web打包与发布◇Java Web应用采用war包进行发布◇发布路径为：{TOMCAT_HOME}/webapps◇Eclipse支持war包导出​ ☆打包步骤 File -&gt; Export -&gt; Web -&gt; WAR file -&gt; Destination(指定保存文件路径后缀不能少eg:servlet_test.war) -&gt;finish☆使用方法将.war文件复制到Tomcat\\apache-tomcat-8.5.34\\webapps路径中，然后启动Tomcat\\apache-tomcat-8.5.34\\bin中的startup.bat文件​ ☆Tomcat配置文件修改◇找到Tomcat\\apache-tomcat-8.5.34\\conf中的servlet.xml文件，在63行，将8080改为80，则以后访问不需要加localhost:8080也不要加localhost:80; 1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; ◇将path路径后面只留”/“，则访问以后直接localhost即可 1&lt;Context docBase=&quot;F:\\JAVA\\Tomcat\\apache-tomcat-8.5.34\\webapps\\request-struc&quot; path=&quot;/&quot; reloadable=&quot;true&quot; source=&quot;org.eclipse.jst.jee.server:request-struc&quot;/&gt;&lt;/Host&gt; reloadable:是否自动加载​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://618dt.github.io/tags/JSP/"}],"author":"LCG"},{"title":"JSP入门","slug":"JSP入门","date":"2022-01-22T16:00:00.000Z","updated":"2022-02-21T08:52:34.696Z","comments":true,"path":"p/121d.html","link":"","permalink":"https://618dt.github.io/p/121d.html","excerpt":"","text":"基础简介Servlet开发的痛点◇简单的页面却工作量太大，繁琐；◇静态HTML与动态Java代码混合在一起，难以维护；◇Servlet利用out.println()语句输出，开发效率低下；◇Eclipse很难在开发过程中发现错误，调试困难； JSP介绍◇JSP全称是(Java Servlet Pages),java服务器页面◇JSP是J2EE的功能模块，由Web服务器执行◇JSP的作用就是降低动态网页开发难度 JSP特点◇JSP可将Java代码与HTML分离，降低开发难度◇JSP的本质就是Servlet JSP运行要求◇可正常运行的Tomcat◇所有JSP页面扩展名必须是.jsp◇JSP页面应放在Web应用程序目录下 JSP代码示例◇案例描述；公司薪资制度：新入职员工：基本工资1500元工作5年内员工：每年工资上浮基本工资的10%工作5-10年员工：每年工资上浮基本工资的20%工作10年以上员工：每年工资上浮基本工资的25%要求列出工资试算表； ◇在WebContent目录下创建一个salaty.jsp文件，在一个jsp文件中用&lt;% %&gt;嵌入java代码实现开发效率，输出员工各个工龄的工资； 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;year&lt;/th&gt; &lt;th&gt;salary&lt;/th&gt; &lt;/tr&gt; &lt;% for(int i=0;i&lt;=50;i++)&#123; //五十年 out.println(&quot;&lt;tr&gt;&quot;);//每一行 out.println(&quot;&lt;td&gt;&quot;+i+&quot;&lt;/td&gt;&quot;);//第一列:年份 int sal=0; if(i&lt;=5)&#123; sal=1500+i*150; &#125;else if(i&gt;5&amp;&amp;i&lt;=10)&#123; sal=1500+150*5+300*(i-5); &#125;else if(i&gt;10)&#123; sal=1500+150*5+300*5+375*(i-10); &#125; out.println(&quot;&lt;td&gt;&quot;+sal+&quot;&lt;/td&gt;&quot;);//第二列:工资 out.println(&quot;&lt;/tr&gt;&quot;); &#125; %&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; JSP的执行过程◇浏览器访问JSP首先将请求发送给Tomcat，Tomcat在应用目录中找到对应的jsp，然后将jsp转换为标准的Servlet源代码，编译成字节码； JSP的转译过程◇&lt;%=a%&gt;即把a打印输出；◇在apache-tomcat-8.5.34\\work\\Catalina\\localhost\\项目名\\org\\jsp中可以查看转译后的salary_jsp.java JSP的基本语法◇JSP语法按功能分为以下四种①JSP代码块 ②JSP声明构造块③JSP输出指令 ④JSP处理指令 JSP代码块◇JSP代码块用于JSP中嵌入Java代码◇JSP代码块语法：&lt;%java代码块%&gt; JSP声明构造块◇JSP声明构造用于声明变量或方法◇JSP声明构造块语法：&lt;%! 声明语句 %&gt;◇eg：声明方法，&lt;%! public int add(int a,int b){return a+b;} %&gt; JSP输出指令◇JSP输出指令用于在JSP页面中显示java代码执行结果◇JSP输出指令语法：&lt;%= java代码 %&gt;eg: &lt;%=”“+name+”“%&gt; %=即out.println的简化形式 JSP处理指令◇JSP处理指令用于提供JSP执行过程中的辅助信息◇JSP处理指令语法：&lt;%@ jsp指令 %&gt;◇eg: &lt;%@ page import=”java.util.*” %&gt; jsp常用处理指令123&lt;%@ page %&gt; //定义当前JSP页面的全局设置&lt;%@ include %&gt;//将其他JSP页面与当前JSP页面合并&lt;%@ taglib %&gt;//引入JSP标签库 JSP中注释的区别◇&lt;%– 注释–%&gt; JSP注释，被注释语句不做任何处理◇// , /../ 用于注释&lt;%%&gt;java代码，被注释代码不执行◇ HTML注释，被注释的语句不会被浏览器解释 综合训练质数算法◇列出1000以内的质数(除1外，只能被1和自身整除的自然数)◇要求：使用List保存所有有效的质数，将结果打印到页面，格式为”X是质数“◇综合运用JSP语法； 1234567891011121314151617181920212223242526272829303132333435&lt;%@page import=&quot;java.util.*&quot; contentType=&quot;text/html;charset=utf-8&quot;%&gt; &lt;%! boolean isPrime(int num) &#123; boolean flag = true; for (int j = 2; j &lt; num; j++) &#123; if (num % j == 0) &#123; flag = false; break; &#125; &#125; return flag; &#125; %&gt; &lt;% List&lt;Integer&gt; primes = new ArrayList(); for (int i = 2; i &lt;= 1000; i++) &#123; boolean flag = isPrime(i); if (flag) &#123; /* out.println(&quot;&lt;h1&gt;&quot; + i + &quot;&lt;/h1&gt;&quot;); */ primes.add(i); &#125; &#125;%&gt;&lt;% for(int p : primes)&#123; //out.println(&quot;&lt;h1 style=&#x27;color:pink&#x27;&gt;&quot; + p + &quot;是质数&lt;/h1&gt;&quot;);%&gt; &lt;h1 style=&#x27;color:blue&#x27;&gt;&lt;%=p %&gt;是质数 &lt;/h1&gt;&lt;% &#125;%&gt; contentType=”text/html;charset=utf-8”%&gt; 设置字体能显示中文； JSP页面重用◇利用JSP指令进行引用 12345678&lt;%@page contentType=&quot;text/html;charset=utf-8&quot; %&gt;&lt;%@include file=&quot;header.jsp&quot; %&gt;//引用页头&lt;% out.println(&quot;&lt;h1&gt;新闻标题&lt;/h1&gt;&quot;); out.println(&quot;&lt;p&gt;新闻正文&lt;/p&gt;&quot;);%&gt;&lt;%@include file=&quot;footer.jsp&quot; %&gt;引用页脚","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://618dt.github.io/tags/JSP/"}],"author":"LCG"},{"title":"Servlet入门","slug":"Servlet入门","date":"2022-01-21T16:00:00.000Z","updated":"2022-02-21T08:52:17.066Z","comments":true,"path":"p/1d42.html","link":"","permalink":"https://618dt.github.io/p/1d42.html","excerpt":"","text":"软件结构发展史单机时代-桌面应用◇软件所有数据都保存在电脑本地硬盘中◇优点：易于使用，结构简单◇缺点：数据难以共享，安全性差，更新不及时。eg：Word，eclipse； 联机时代（Client-Server模式）◇Client/Server结构（C/S结构）是指客户端和服务器结构◇优点：数据方便共享，安全性高◇缺点：必须安装客户端，升级与维护困难。eg：QQ，微信，支护宝 互联网时代（Browser-Server模式）◇Browser-Server（B/S）模式及浏览器和服务器架构模式◇优点：开发简单，无需安装客户端，数据易于共享◇缺点：相较于C/S模式，执行速度与用户体验较弱eg：百度网，新浪微博； Tomcat与ServletB/S模式执行流程 请求与响应◇从浏览器发出送给服务器的数据包称为”请求（Request）”◇从服务器返回给浏览器的结果称为”响应（Response）”◇请求和响应对称出现 J2EE简介◇J2EE（Java 2 Platform Enterprise Edition） 是指”Java 2 企业版”◇开发BS应用程序就是J2EE最核心的功能◇J2EE由13个功能模块组成 J2EE中的13个功能模块 Apache Tomcat◇Tomcat是一个Web应用服务器程序 J2EE与Tomcat的关系◇J2EE是一组技术规范与指南，具体实现由软件厂商决定◇Tomcat是J2EE Web（Servlet 与JSP）标准的实现者◇J2SE是J2EE运行的基石，运行Tomcat离不开J2SE Servlet◇Servelt与Tomcat的作用如下图，Servlet相当于服务器主机代码 Eclipse整合Tomcat◇下载Eclipse 64位的压缩包，下载Eclipse IDE for Java EE Developers版本；然后解压，运行eclipse.exe即可；打开后；Window-&gt;Preferences-&gt;搜索jre-&gt;Installed JREs-&gt;Add-&gt;Standard VM-&gt;选择安装的jdk1.8.0_181-&gt;finish-&gt;OK;◇Window-&gt;Show View-&gt;Servers-&gt;OK-&gt;Servers下的链接-&gt;Apache-&gt;Tomcat v8.5 Server(自定义安装的版本)-&gt;next-&gt;Browse(选择安装路径)-&gt;apache-tomcat的安装路径-&gt;JRE:jdk1.8.0_181-&gt;Next-&gt;Finish-&gt;双击Tomcat v8.5-&gt;Server Locations:选择第二项Use Tomcat installation-&gt;Depoly path: \\apache-tomcat-8.5.34\\webapps-&gt;保存即可； 第一个Servlet创建应用程序◇新建一个Dynamic Web Project对象-&gt;Project name:FirstServlet-&gt;-Next-&gt;Next-&gt;勾选Generate web.xml-Finish;◇在自动生成的Java Resources\\src目录下创建一个class,包名为com.lcg.servlet，类名为:FirstServlet; 12345678910111213141516171819202122232425262728293031323334package com.lcg.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class FirstServlet extends HttpServlet&#123; public FirstServlet()&#123; System.out.println(&quot;正在创建FirstServlet对象&quot;); &#125; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;正在初始化FirstServlet对象&quot;); &#125; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接收请求发来的参数 String name = request.getParameter(&quot;name&quot;); String html = &quot;&lt;h1 style=&#x27;color:red&#x27;&gt;hi,&quot; + name +&quot;!&lt;/h1&gt;&lt;hr/&gt;&quot;; System.out.println(&quot;返回给浏览器的响应数据为：&quot; + html); PrintWriter out = response.getWriter(); out.println(html);//将html发送回浏览器 &#125; @Override public void destroy() &#123; System.out.println(&quot;正在销毁servlet对象&quot;); &#125;&#125; ◇配置web.xml，绑定URL 123456789101112&lt;!-- 声明Servlet --&gt;&lt;servlet&gt; &lt;!-- servlet的别名 --&gt; &lt;servlet-name&gt;first&lt;/servlet-name&gt; &lt;servlet-class&gt;com.imooc.servlet.FirstServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 将Servlet与URL绑定 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;first&lt;/servlet-name&gt; &lt;url-pattern&gt;/hi&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ◇浏览器输入localhost:8080/FirstServlet/hi?name=Jackson 图解执行流程◇在地址栏输入地址以后,这个信息通过请求发送给Tomcat，然后Tomcat就根据发送来的url地址在web.xml中去查找与/hi匹配的servlet，这里查找匹配到name=first的servlet，然后根据这个name继续在web.xml中查找与之对应的类，这里与之对应的类为FirstServlet,Tomcat就会创建FirstServlet对象,并且执行其中的service方法;◇service方法将name拼接成html字符串,Tomcat会将这个字符串通过response原封不动的发送给浏览器，浏览器再展示在页面上； 标准Java Web工程结构◇index.html放在WebContent目录下 Servlet开发步骤◇创建Servlet类，继承HttpServlet◇重写service方法，编写程序代码 1234567public class SampleServlet extends HttpServlet&#123; public void service(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; PrintWriter out = response.getWriter();//向浏览器输出的数据流，返回PrintWriter对象 out.println(&quot;&lt;a href=&#x27;http://www.gamest.link&#x27;&gt;COF&lt;/a&gt;&quot;); &#125;&#125; ◇配置web.xml，绑定URL 12345678910&lt;!-- 声明servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;sample&lt;/servlet-name&gt;&lt;!-- servlet的别名 ，Tomcat通过别名绑定URL，提高安全性--&gt; &lt;servlet-class&gt;com.gamest.servlet.SampleServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 将servlet于URL绑定 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sample&lt;/servlet-name&gt; &lt;url-pattern&gt;/sample&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet访问方法◇http://IP地址：端口（8080）/context-path(eclipse的工程名称)/url-mapping◇远程访问使用IP地址，本地访问localhost(127.0.0.1)◇context-path成为”上下文路径”，默认为工程名 请求参数◇请求参数是指浏览器通过请求向Tomcat提交的数据◇请求参数通常是用户输入的数据，待Servlet进行处理◇参数名1=值1&amp;参数名2=值2&amp;参数名n=…eg:name=lcg&amp;mobile=15751015885&amp;sex=male&amp;spec=Program&amp;spec=Swimming 获取参数◇student.html文件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;学员信息登记表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;学员信息登记表&lt;/h1&gt; &lt;!-- 表单提交的后台路径,请求方法--&gt; &lt;form action=&quot;/FirstServlet/sample&quot; method=&quot;get&quot; &gt; 姓名：&lt;input name=&quot;name&quot;/&gt; &lt;br/&gt; 电话：&lt;input name=&quot;mobile&quot;/&gt; &lt;br/&gt; 性别： &lt;select name=&quot;sex&quot; style=&quot;width:100px;padding:5px;&quot;&gt; &lt;option value=&quot;male&quot; &gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 特长: &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;English&quot;/&gt;英语 &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;Program&quot;/&gt;编程 &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;Speech&quot;/&gt;演讲 &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;Swimming&quot;/&gt;游泳 &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 获取单个参数： 123String name = request.getParameter(&quot;name&quot;);String mobile = request.getParameter(&quot;mobile&quot;);String sex = request.getParameter(&quot;sex&quot;); 获取多个：如上面的spec特长数据； 1String[] specs = request.getParameterValues(&quot;spec&quot;);//多个值的，用数组 在页面显示参数： 1234567out.println(&quot;&lt;h1&gt;name:&quot;+name+&quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;mobile:&quot;+mobile+&quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;sex:&quot;+sex+&quot;&lt;/h1&gt;&quot;); for(int i=0;i&lt;specs.length;i++) &#123; out.print(&quot;&lt;h2&gt;spec:&quot;+specs[i]+&quot;&lt;/h2&gt;&quot;); &#125; out.println(&quot;&lt;a href=&#x27;http://www.gamest.link&#x27;&gt;COF&lt;/a&gt;&quot;); Get与Post请求方法◇Get方式是将数据通过在URL附加数据显性向服务器发送数据 eg：http://localhost:8080/FirstServlet/sample?name=Lcg◇Post方法会将数据存放在”请求体”中隐性向服务器发送数据 eg：http://localhost:8080/FirstServlet/sample 请求体：name=Lcg◇区别：二者数据格式一样的，存放数据地址不一样，可以通过F12键Network来查看。post存放在了不可见的请求体中；◇Service是请求处理的核心方法，无论是get或者post都会被service方法处理，request。在Java中getMethod（）方法可以获取是那种方法。 设置方法◇设置表单的请求方法 1&lt;form action=&quot;/FirstServlet/sample&quot; method=&quot;post|get&quot; &gt; ◇设置请求参数，通过设置表单中input,select等标签的name属性。只有设置了name属性的表单元素才能在提交表单时传递它们的值； 12345性别：&lt;select name=&quot;sex&quot; style=&quot;width:100px;padding:5px;&quot;&gt; &lt;option value=&quot;male&quot; &gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt;&lt;/select&gt; Get与Post处理方式◇所有请求 - service()方法； 12345678910111213141516171819public class SampleServlet extends HttpServlet &#123; //service是请求处理的核心方法，无论是get或者post都会被service（）方法处理 public void service(HttpServletRequest request , HttpServletResponse response) throws IOException&#123; String methodName = request.getMethod();//得到请求的方法; String name = request.getParameter(&quot;name&quot;); String mobile = request.getParameter(&quot;mobile&quot;); String sex = request.getParameter(&quot;sex&quot;); String[] specs = request.getParameterValues(&quot;spec&quot;); PrintWriter out = response.getWriter();//向浏览器输出的数据流 out.println(&quot;&lt;h1&gt;method:&quot; + methodName + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;name:&quot; + name + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;mobile:&quot; + mobile + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;sex:&quot; + sex + &quot;&lt;/h1&gt;&quot;); for(int i = 0 ; i &lt; specs.length ; i++)&#123; out.println(&quot;&lt;h2&gt;spec:&quot; + specs[i] + &quot;&lt;/h2&gt;&quot;); &#125; out.println(&quot;&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;Baidu&lt;/a&gt;&quot;); &#125;&#125; ◇Get请求 - doGet()方法； 1234public void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String name = request.getParameter(&quot;name&quot;); response.getWriter().println(&quot;&lt;h1 style=&#x27;color:green&#x27;&gt;&quot;+name+&quot;&lt;/h1&gt;&quot;); ◇Post请求 - doPost()方法； 123456//处理Post请求 public void doPost(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String name = request.getParameter(&quot;name&quot;); response.getWriter().println(&quot;&lt;h1 style=&#x27;color:red&#x27;&gt;&quot;+name+&quot;&lt;/h1&gt;&quot;); &#125; Get与Post应用场景◇Get常用于不包含敏感信息的查询功能 *例如：https://www.baidu.com/s?wd=imooc&amp;rsv_spt=1◇Post用于安全性要求较高的功能或者服务器的”写”操作 *用户登录 *用户注册 *更新新公司账目 Servlet生命周期◇装载 -web.xml ◇创建 - 构造函数◇初始化 - init() ◇提供服务 - service()|doGet()|doPost◇销毁 - destory() //应用重启或关闭的时候执行代码： 123456789101112131415161718192021222324public class FirstServlet extends HttpServlet&#123; public FirstServlet() &#123; System.out.println(&quot;正在创建FirstServlet对象&quot;); &#125; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;正在初始化FirstServlet对象&quot;); &#125; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter(&quot;name&quot;); String html = &quot;&lt;h1 style=&#x27;color:pink&#x27;&gt;hi,&quot;+name+&quot;!&lt;/h1&gt;&quot;; System.out.println(&quot;返回给浏览器的响应数据为：&quot;+ html); //response.getWriter()相当于从服务器向浏览器返回的输出流 PrintWriter out = response.getWriter(); out.println(html);//将html发送回浏览器 &#125; @Override public void destroy() &#123; System.out.print(&quot;正在销毁FirstServlet对象&quot;); &#125;&#125; 服务端：正在创建FirstServlet对象正在初始化FirstServlet对象返回给浏览器的响应数据为：hi,lcg!返回给浏览器的响应数据为：hi,lcg!五月 13, 2021 11:28:02 上午 org.apache.catalina.core.StandardContext reload信息: Reloading Context with name [/FirstServlet] has started正在销毁FirstServlet对象​ ◇可以看到在访问浏览器页面后就会自动创建和初始化对象，而且每一个Servlet有且仅有一个对象；当更改信息后，并保存（相当于应用重启或关闭）后就会销毁对象。 注解简化配置 及启动时加载Servlet使用注解简化配置◇Servlet 3.x之后引入了”注解Annotation”特性◇注解用于简化Web应用程序的配置过程◇Servlet有且仅有一个核心注解：@WebServlet 代码实现：12345678910@WebServlet(&quot;/anno&quot;)public class AnnotationServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().println(&quot;I&#x27;m annotation servlet!&quot;); &#125; &#125; ◇写了@WebServlet(“/anno”) 后，就不用再在web.xml里面进行配置了。它告诉我们映射的地址就是/anno 启动时加载Servlet◇web.xml使用设置启动加载◇0~9999 其中数字代表优先级，0位最高，有多个Servlet需要启动时加载，则优先加载优先级高的。◇启动时加载在工作中常用于系统的预处理。◇这种Servlet不需要提供服务，因此不用绑定URL 代码实现传统方法重写init()方法 123public void init() throws ServletException &#123; System.out.print(&quot;正在创建数据库&quot;); &#125; 分析Servlet 12345&lt;servlet&gt; &lt;servlet-name&gt;create&lt;/servlet-name&gt; &lt;servlet-class&gt;com.gamest.servlet.CreateServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; 注解方法12345678//在使用注解开发时，强制要求必须设置一个URL，可以任意设置，只要不与其它冲突（可能不会用到，但一定要设置）@WebServlet(urlPatterns=&quot;/unused&quot;,loadOnStartup=0)public class CreateServlet extends HttpServlet &#123; @Override public void init() throws ServletException &#123; System.out.print(&quot;正在创建数据库&quot;); &#125; &#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://618dt.github.io/tags/Servlet/"}],"author":"LCG"},{"title":"XML入门","slug":"XML入门","date":"2022-01-20T16:00:00.000Z","updated":"2022-02-21T08:51:28.045Z","comments":true,"path":"p/f394.html","link":"","permalink":"https://618dt.github.io/p/f394.html","excerpt":"","text":"课程简介XML重点知识 Servlet入门 JSP入门 Servlet与JSP进阶 JSTL与EL表达式XML ◇XML介绍与用途； ◇XML的语法规则◇XML语义约束； ◇Java解析XML◇XPath路径表达式 XML是什么◇ XML的全称是EXtensible Markup Language,可扩展标记语言 ◇ 编写XML就是编写标签，与HTML非常类似，扩展名.xml ◇ 良好的人机可读性 123456#hr.xml&lt;employee&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;31&lt;/age&gt;&lt;height&gt;178&lt;/height&gt;&lt;/employee&gt; XML与HTML的比较◇XML与HTML非常相似，都是编写标签◇XML没有预定义标签，HTML存在大量预定义标签◇XML重在保存与传输数据，HTML用于显示信息◇eg： 1234567891011xml: &lt;school&gt; &lt;class no=&quot;G3N1&quot;&gt; &lt;grade&gt;三年级&lt;/grade&gt; &lt;name&gt;1班&lt;/name&gt; &lt;/class&gt; &lt;class no=&quot;G3N2&quot;&gt; &lt;grade&gt;三年级&lt;/grade&gt; &lt;name&gt;2班&lt;/name&gt; &lt;/class&gt;&lt;/school&gt; 1234html:&lt;body&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&lt;/body&gt; XML用途◇Java程序的配置描述文件；在程序开发过程中会遇到各种各样的设置项，如果把这些设置项写死在程序中，每次修改配置的时候需要对代码进行修改并重新编译，非常的麻烦；这个时候就可以考虑将这些配置写在xml文件中保存；例如下面的web应用配置文件； 123456789101112131415web.xml - web应用配置文件&lt;web-app&gt;&lt;servlet&gt;&lt;servlet-name&gt;InitTest&lt;/servlet-name&gt;&lt;servlet-class&gt;moreservlets.InitServlet&lt;/servlet-class&gt;&lt;init-param&gt;&lt;param-name&gt;param1&lt;/param-name&gt;&lt;param-value&gt;value1&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;param2&lt;/param-name&gt;&lt;param-value&gt;2&lt;/param-value&gt;&lt;/init-param&gt;&lt;/servlet&gt;&lt;/web-app&gt; ◇用于保存程序产生的数据；因为xml拥有良好的人机可读性，所以xml可以用来对数据进行存储和转移；◇网络间的数据传输；即在网络传输的过程中，发送方可以将数据组织成xml，接收方对xml进行解析就可以了；如： 12345678webservice底层soap协议：&lt;Envelope&gt; &lt;Body&gt; &lt;m:reverse xmlns:m=&quot;urn:strings-com:IString&quot;&gt; &lt;theString&gt;Hello,World&lt;/theString&gt; &lt;/m:reverse&gt; &lt;/Body&gt;&lt;/Envelope&gt; XML的文档结构◇第一行必须是XML声明◇有且只有一个根节点◇XML标签的书写规则与HTML完全相同 XML标签书写规则◇合法的标签名 1234&lt;abc&gt;abc&lt;/abc&gt; × (无意义的)&lt;考试$&gt;数学期末&lt;/考试$&gt; × (不可包含特殊字符)&lt;class&gt;&lt;class&gt;班级&lt;/class&gt;&lt;/class&gt; × (父标签子标签不可同名)&lt;shop-cart&gt;&lt;item&gt;相册&lt;/item&gt;&lt;/shop-cart&gt; √ ◇适当的注释与缩进； 适当的注释与缩进可以让XML文档更容易阅读。 1234567&lt;!-- 员工信息 --&gt; &lt;employee&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;31&lt;/age&gt; &lt;!--身高cm--&gt; &lt;height&gt;178&lt;/height&gt;&lt;/employee&gt; ◇合理使用属性 123456789101112&lt;shop-cart&gt; &lt;item sn=&quot;771938&quot; category=&quot;电器&quot;&gt; &lt;name&gt;XX空调&lt;/name&gt; &lt;price&gt;2000.00&lt;/price&gt; &lt;num&gt;1&lt;/num&gt; &lt;/item&gt; &lt;item sn=&quot;890321&quot; category=&quot;食品&quot;&gt; &lt;name&gt;法式面包&lt;/name&gt; &lt;price&gt;10.00&lt;/price&gt; &lt;num&gt;5&lt;/num&gt; &lt;/item&gt;&lt;/shop-cart&gt; ◇特殊字符与CDATA标签；– 标签体中，出现”&lt;”、”&gt;”特殊字符，会破坏文档原有的结构 ；– 解决方案1：使用实体引用。 – 解决方案2：使用CDATA标签。 12345无效的XML：&lt;exam&gt; &lt;question&gt;1+4&lt;3是否正确？&lt;/question&gt;&lt;!--出现小于号&lt;会别认为是特殊字符 --&gt; &lt;question&gt;3+5&gt;8是否正确？&lt;/question&gt;&lt;/exam&gt; ◇ XML支持五种实体引用 ◇修改后的XML 1234&lt;exam&gt; &lt;question&gt;1+4&amp;lt;3是否正确？&lt;/question&gt;&lt;!--出现小于号&lt;会别认为是特殊字符 --&gt; &lt;question&gt;3+5&amp;gt;8是否正确？&lt;/question&gt;&lt;/exam&gt; ◇实体引用的方法只适用于特殊字符少的情况；解决批量的问题用CDATA标签；◇ CDATA 指的是不应由 XML 解析器进行解析的文本数据 ◇ 从”“结束 ◇如我们想要标签的内容原义输出；则可使用CDATA包裹； 12345678910&lt;lesson&gt; &lt;content&gt; &lt;![CDATA[ 本节我们来学习html中a标签的使用： &lt;body&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt; &lt;/body&gt; ]]&gt; &lt;/content&gt;&lt;/lesson&gt; ◇有序的子元素，在XML多层嵌套的子元素中，标签前后顺序应保持一致。 123456789101112&lt;shop-cart&gt;&lt;item sn=&quot;771938&quot; category=&quot;电器&quot;&gt;&lt;name&gt;XX空调&lt;/name&gt;&lt;price&gt;2000.00&lt;/price&gt;&lt;num&gt;1&lt;/num&gt;&lt;/item&gt;&lt;item sn=&quot;890321&quot; category=&quot;食品&quot;&gt;&lt;name&gt;法式面包&lt;/name&gt;&lt;price&gt;10.00&lt;/price&gt;&lt;num&gt;5&lt;/num&gt;&lt;/item&gt;&lt;/shop-cart&gt; XML声明◇XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行。 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 其中，version代表版本号1.0(初始版本)/1.1(升级版本)；encoding UTF-8设置字符集，用于支持中文；​ XML语义约束◇ XML文档结构正确，但可能不是有效的。 – 例如，员工档案XML中绝不允许出现”植物品种” 标签。XML语义约束就是用于规定XML文档中允许 出现哪些元素。 – XML语义约束有两种定义方式:DTD与XML Schema。 DTD简介◇ DTD(Document Type Definition，文档类型定义)是 一种简单易用的语义约束方式。 ◇ DTD文件的扩展名为.dtd。 123456hr.dtd&lt;!ELEMENT hr (employee+)&gt;&lt;!ELEMENT employee (name,age,salary,department)&gt;&lt;!ATTLIST employee no CDATA &quot;&quot;&gt;&lt;!ELEMENT name (#PCDATA)&gt;... DTD定义结点◇利用DTD中的&lt;!ELEMENT&gt;标签，定义XML文档中允许出现的节点及数量；eg: ①定义hr节点下只允许出现一个employee子节点 ： 1&lt;!ELEMENT hr (employee)&gt; ②employee节点下必须包含以下四个节点，且按顺序出现： 1&lt;!ELEMENT employee(name,age,salary,department)&gt; ③定义name标签只能是文本，#PCDATA代表文本元素。 1&lt;!ELEMENT name(#PCDATA) DTD定义节点数量◇如某个子节点需要多次重复出现，则需要在子节点后增加相应的描述符。eg：①hr节点下最少出现1个employee子节点： 1&lt;!ELEMENT hr(employee+)&gt; ②hr节点下可出现0..n个employee子节点： 1&lt;!ELEMENT hr(employee*)&gt; ③hr节点下最多可出现1个employee子节点： 1&lt;!ELEMENT hr(employee?)&gt; XML引用DTD文件◇在XML使用&lt;!DOCTYPE&gt;标签来引用DTD文件书写格式: 123&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt;eg:&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt; XML Schema◇XML Schema比DTD更为复杂，提供了更多功能。◇XML Schema提供了数据类型、格式限定、数据范围等特性。◇XML Schema是W3C标准。◇eg 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;element name=&quot;hr&quot;&gt; &lt;!-- complexType标签含义是复杂节点，包含子节点时必须使用这个标签 这里表示hr下有子节点 --&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!--队列 说明前后顺序--&gt; &lt;element name=&quot;employee&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;9999&quot;&gt; &lt;complexType&gt; &lt;!--employee下有子节点 --&gt; &lt;sequence&gt; &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;age&quot;&gt; &lt;simpleType&gt; &lt;restriction base=&quot;integer&quot;&gt; &lt;minInclusive value=&quot;18&quot;&gt;&lt;/minInclusive&gt; &lt;maxInclusive value=&quot;60&quot;&gt;&lt;/maxInclusive&gt; &lt;/restriction&gt; &lt;/simpleType&gt; &lt;/element&gt; &lt;element name=&quot;salary&quot; type=&quot;integer&quot;&gt;&lt;/element&gt; &lt;element name=&quot;department&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;dname&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;address&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;attribute name=&quot;no&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt;&lt;!--required表示必须存在no这个属性--&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/schema&gt; DOM模型与Dom4jDOM文档对象模型◇DOM(Document Object Moder) 定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构来查看，能够通过DOM树来读写所有元素。 Dom4j◇Dom4j是一个易用的、开源的库，用于解析XML。它应用于java平台，具有性能优异、功能强大和极其易使用的特点。◇Dom4j将XML视为Document对象◇XML标签被Dom4j定义为Element对象 利用Dom4j遍历XML◇在xml工程中src存储了xml文件以及dtd和xsd文件；新建一个lib文件用于引入dom4j的依赖；即将dom4j-2.1.1.jar文件复制到lib中，然后右键Build Path-&gt;Add to Build Path即可；◇hr.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt;&lt;!-- 人力资源管理系统 --&gt;&lt;hr&gt; &lt;employee no=&quot;3301&quot;&gt; &lt;name&gt;李铁柱&lt;/name&gt; &lt;age&gt;37&lt;/age&gt; &lt;salary&gt;3600&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;人事部&lt;/dname&gt; &lt;address&gt;XX大厦-B105&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no=&quot;3302&quot;&gt; &lt;name&gt;林海&lt;/name&gt; &lt;age&gt;50&lt;/age&gt; &lt;salary&gt;7000&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;财务部&lt;/dname&gt; &lt;address&gt;XX大厦-B106&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no=&quot;3303&quot;&gt; &lt;name&gt;安娜&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;salary&gt;4600&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;人事部&lt;/dname&gt; &lt;address&gt;XX大厦-B105&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt;&lt;/hr&gt; ◇新建包com.lcg.dom4j，创建类HrReader读取xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lcg.dom4j;import java.util.List;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class HrReader &#123; public void readXml()&#123; String file = &quot;d:/workspace/xml/src/hr.xml&quot;; //SAXReader类是读取XML文件的核心类，用于将XML解析后以“树”的形式保存在内存中。 SAXReader reader = new SAXReader(); try &#123; //read方法解析出一个document对象; Document document = reader.read(file); //获取XML文档的根节点，即hr标签 Element root = document.getRootElement(); //elements方法用于获取指定的标签集合 List&lt;Element&gt; employees = root.elements(&quot;employee&quot;); for(Element employee : employees)&#123; //element方法用于获取唯一的子节点对象 Element name = employee.element(&quot;name&quot;); String empName = name.getText();//getText()方法用于获取标签或者属性的文本 System.out.println(empName); //直接打印,不赋值; System.out.println(employee.elementText(&quot;age&quot;)); //elementText方法和getText()方法一样; System.out.println(employee.elementText(&quot;salary&quot;)); Element department = employee.element(&quot;department&quot;); System.out.println(department.element(&quot;dname&quot;).getText()); System.out.println(department.element(&quot;address&quot;).getText()); //attribute方法用于获取属性; Attribute att = employee.attribute(&quot;no&quot;); System.out.println(att.getText()); &#125; &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrReader reader = new HrReader();//实例化HrReader方法; reader.readXml(); &#125; &#125; 利用Dom4j更新XML◇新建类HrWriter 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lcg.dom4j;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class HrWriter &#123; public void writeXml()&#123; String file = &quot;d:/workspace/xml/src/hr.xml&quot;; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); Element root = document.getRootElement(); //增加新的子节点employee; Element employee = root.addElement(&quot;employee&quot;); //增加节点的属性; employee.addAttribute(&quot;no&quot;, &quot;3311&quot;); Element name = employee.addElement(&quot;name&quot;);//增加name子节点; name.setText(&quot;李铁柱&quot;);//设置文本; employee.addElement(&quot;age&quot;).setText(&quot;37&quot;);//合成一行代码; employee.addElement(&quot;salary&quot;).setText(&quot;3600&quot;); Element department = employee.addElement(&quot;department&quot;); department.addElement(&quot;dname&quot;).setText(&quot;人事部&quot;); department.addElement(&quot;address&quot;).setText(&quot;XX大厦-B105&quot;); //把文件的输出流转换为Writer对象 Writer writer = new OutputStreamWriter(new FileOutputStream(file) , &quot;UTF-8&quot;); //将dom模型写入到对应文件中; document.write(writer); writer.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrWriter hrWriter = new HrWriter(); hrWriter.writeXml(); &#125;&#125; XPath表达式XPath路径表达式◇XPath路径表达式是XML文档中查找数据的语言。◇掌握XPath可以极大提高在提取数据时的开发效率。◇学习XPath本质就是掌握各种形式表达的使用技巧。 XPath基本表达式◇最常用的基本表达式 表达式 描述 nodename 选取此节点的所有子节点 / 从根节点选取 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 XPath基本表达式案例 XPath谓语表达式◇谓语表达式统一使用中括号，里面再加一个谓语表示； Xpath实验室Jaxen介绍◇Jaxen是一个java编写的开源的XPath库。这是适应多种不同的对象模型，包括DOM，XOM,dom4j和JDOM。◇Dom4j底层依赖Jaxen实现XPath查询◇Jaxen下载地址:meaven.aliyun.com在阿里云的仓库中搜索下载 代码演示◇引入jaxen依赖；◇创建类XPathTestor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.lcg.dom4j;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;public class XPathTestor &#123; public void xpath(String xpathExp)&#123; String file = &quot;E:/lianxi/xml/hr.xml&quot;; SAXReader reader = new SAXReader(); try &#123; //获取document对象 Document document = reader.read(file); /*selectNodes方法用来执行xpath表达式;对于xpath表达式来说,不仅可以查询标签本身, 还可以查询属性,Node是标签和属性的一个父类,因此返回的是一个Node; */ List&lt;Node&gt; nodes = document.selectNodes(xpathExp); for(Node node : nodes)&#123; Element emp = (Element)node;//把node转换为Element对象; //输出相关信息; System.out.println(emp.attributeValue(&quot;no&quot;)); System.out.println(emp.elementText(&quot;name&quot;)); System.out.println(emp.elementText(&quot;age&quot;)); System.out.println(emp.elementText(&quot;salary&quot;)); System.out.println(&quot;==============================&quot;); &#125; &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; XPathTestor testor = new XPathTestor();// testor.xpath(&quot;/hr/employee&quot;);// testor.xpath(&quot;//employee&quot;);// testor.xpath(&quot;//employee[salary&lt;4000]&quot;); 工资小于4000的职员// testor.xpath(&quot;//employee[name=&#x27;李铁柱&#x27;]&quot;);// testor.xpath(&quot;//employee[@no=3304]&quot;);// testor.xpath(&quot;//employee[1]&quot;);// testor.xpath(&quot;//employee[last()]&quot;); //testor.xpath(&quot;//employee[position()&lt;3]&quot;); testor.xpath(&quot;//employee[3] | //employee[8]&quot;); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"xml","slug":"xml","permalink":"https://618dt.github.io/tags/xml/"}],"author":"LCG"},{"title":"删除功能出现的BUG","slug":"异常处理BUG","date":"2021-12-09T07:34:46.961Z","updated":"2022-02-28T13:48:10.263Z","comments":true,"path":"p/de80.html","link":"","permalink":"https://618dt.github.io/p/de80.html","excerpt":"","text":"功能简介​ 开发一个删除油画功能模块，要求能够在前台中点击某一油画进行删除后，弹出对话框进行确认删除，若确认则发送ajax请求到后台，然后后台根据发送过来的id进行相应的删除，并且使用json对象返回处理的结果； 实现思路​ 对于底层的数据删除，使用dom4j进行对xml的删除操作；首先根据id筛选出指定的节点p；然后根据此节点获取到其父节点，使用父节点的remove方法来删除此节点；代码如下： 12//得到P的根节点然后用根节点删去P;p.getParent().remove(p); ​ 然后就是根据MVC的调用要求，依次创建Dao、Service、Controller中的方法；在Controller方法中进行与前台的交互即可； 出现的BUG​ 当在前台页面点击删除油画后，发现删除成功，然后不刷新页面。再次删除此油画，这幅油画实际上已经被删除了，所以根据后台的逻辑，应该会删除失败，并提示该油画已经被删除或者不存在；但是前台确提示删除成功，按F12查看浏览器控制台打印的json对象如下: 这说明在控制器中根本没有执行catch块里的代码，而是执行了try里的代码，没有捕捉到XmlDataSource中抛出的异常；后端控制台打印的信息如下： 1234567891011121314151617181920212223242526272829303132333435获取ajax请求发送过来的id为:16/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xmljava.lang.RuntimeException: 编号为16的油画不存在或已删除 at com.lcg.mgallery.utils.XmlDataSource.delete(XmlDataSource.java:186) at com.lcg.mgallery.dao.PaintingDao.delete(PaintingDao.java:68) at com.lcg.mgallery.service.PaintingService.delete(PaintingService.java:69) at com.lcg.mgallery.controller.ManagementController.delete(ManagementController.java:247) at com.lcg.mgallery.controller.ManagementController.doGet(ManagementController.java:64) at com.lcg.mgallery.controller.ManagementController.doPost(ManagementController.java:73) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source)/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xml成功执行了删除的操作 ​ 可以发现确实出现了异常，但出现异常后却仍然打印出”成功执行了删除的操作”；这是什么原因呢？为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常？我们来分析一下后台的代码； 对Xml文件进行直接操作的XmlDataSource类中的删除方法代码如下： 1234567891011121314151617public static void delete(Integer id) &#123; try &#123; document = reader.read(dataFile); List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting[@id=&quot; + id + &quot;]&quot;); if(nodes.size() == 0) &#123; throw new RuntimeException(&quot;编号为&quot; + id + &quot;的油画不存在或已删除&quot;); &#125; //省略执行删除操作代码.. &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); throw new RuntimeException(&quot;编号为&quot; + id + &quot;的油画不存在或已删除&quot;); &#125;finally &#123; //...部分代码 reload(); &#125; &#125; ​ 控制器中的删除方法代码如下(控制器中调用的是Service中的delete方法，按照MVC的架构模式会逐级调用到XmlDataSource中的方法) 123456789101112131415161718192021//删除油画private void delete(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String id = request.getParameter(&quot;id&quot;);//获取ajax请求发送过来的参数 System.out.println(&quot;获取ajax请求发送过来的id为:&quot;+id); Map result = new HashMap(); try &#123; //调用方法进行油画的删除 paintingService.delete(Integer.parseInt(id)); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); System.out.println(&quot;成功执行了删除的操作&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); result.put(&quot;code&quot;, &quot;1&quot;); result.put(&quot;msg&quot;, e.getMessage()); System.out.println(&quot;遇到了异常&quot;); &#125; String json = JSON.toJSONString(result); response.setContentType(&quot;text/html;charset=UTF-8&quot;); response.getWriter().println(json);&#125; ​ 通过对控制台中的打印结果分析想到，既然在Controller中并没有捕捉到，那么为什么会打印出异常的信息呢？很快就想到可能在XmlDataSource中就把异常给捕捉了，于是在XmlDataSource中将catch块中的e.printStackTrace();注释掉，在前台执行重复删除的操作，发现后台果然没有打印出异常信息! BUG解决方法​ 在知道了为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常后，就能想到出错的原因在哪里了；因为在XmlDataSource的删除方法中，前面的一些代码也会抛出异常，为了寻求方便我索性使用Exception来捕捉这些异常，这就导致将我们自定义的异常给捕获并处理了（因为RuntimeException继承自Exception），进而在Controller中无法捕捉到异常，给前台的反馈消息总是删除成功的； ​ 所以解决方法是分别捕捉可能出现的每一种异常(除RuntimeException以外)；修改后的方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940public static void delete(Integer id) &#123; SAXReader reader = new SAXReader(); Writer writer = null; Document document; try &#123; document = reader.read(dataFile); List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting[@id=&quot; + id + &quot;]&quot;); if(nodes.size() == 0) &#123; throw new RuntimeException(&quot;编号为&quot; + id + &quot;的油画不存在或已删除&quot;); &#125; Element p = (Element)nodes.get(0); //得到P的根节点然后用根节点删去P; p.getParent().remove(p); //修改后的数据回写到原来的xml文件中; writer = new OutputStreamWriter(new FileOutputStream(dataFile),&quot;UTF-8&quot;); document.write(writer); &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; reload(); &#125; &#125; ​ 这样以后，成功解决了前面出现的问题；这里附上前台页面的代码，弹出窗口使用了SweetAlert 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt;//提示删除 function del(previewObj)&#123; var preview = $(previewObj).attr(&quot;data-preview&quot;);//获取自定义属性 var pname = $(previewObj).attr(&quot;data-pname&quot;); var id = $(previewObj).attr(&quot;data-id&quot;); Swal.fire(&#123; title: &#x27;删除&#x27;+pname+&#x27;?&#x27;, html: &quot;&lt;img src=&#x27;&quot; + preview + &quot;&#x27; style=&#x27;width:361px;height:240px&#x27;&gt;&quot;, icon: &#x27;warning&#x27;, showCancelButton: true, confirmButtonColor: &#x27;#3085d6&#x27;, cancelButtonColor: &#x27;#d33&#x27;, confirmButtonText: &#x27;是的&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(function(isConfirm)&#123; if (isConfirm.value) &#123; //发送ajax请求 $.ajax(&#123; &quot;url&quot; : &quot;/management?method=delete&quot;, &quot;type&quot; : &quot;post&quot;, &quot;data&quot; : &#123;&quot;id&quot;:id&#125;, &quot;dataType&quot; : &quot;json&quot;, &quot;success&quot; : function(json)&#123; console.log(json); if(json.code==&quot;0&quot;)&#123; Swal.fire(&#x27;删除成功!&#x27;,&#x27;油画已经成功删除&#x27;,&#x27;success&#x27;).then(function(isConfirm)&#123; if (isConfirm.value)&#123; //点击确认后刷新页面 window.location.reload(); &#125; &#125;) &#125;else&#123; Swal.fire(&#x27;删除失败!&#x27;,json.msg,&#x27;error&#x27;).then(function(isConfirm)&#123; if (isConfirm.value)&#123; //点击确认后刷新页面 window.location.reload(); &#125; &#125;) &#125; &#125; &#125;) &#125; &#125;) &#125;&lt;/script&gt; &lt;!-- 省略部分代码 --&gt;&lt;a class=&quot;oplink&quot; data-id=&quot;$&#123;painting.id&#125;&quot; data-preview=&quot;$&#123;painting.preview&#125;&quot; data-pname=&quot;$&#123;painting.pname&#125;&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;del(this)&quot;&gt;删除&lt;/a&gt; 总结​ try-catch-finally执行的基本步骤是：如果try块中出现了异常,不管是自定义抛出的还是系统抛出的，在catch块中只要符合捕捉的范围，都会对该异常进行处理，最后执行finally块中的代码； 如果没有出现异常，则直接执行try块中的代码，然后执行finally中的代码；因此在开发过程中不要一时图方便，将捕捉异常的范围扩大，还应当业务逻辑进行仔细分析，采用最佳的处理方法；","categories":[{"name":"Java开发","slug":"Java开发","permalink":"https://618dt.github.io/categories/Java%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://618dt.github.io/tags/BUG/"}],"author":"LCG"},{"title":"递归逆置链表","slug":"递归翻转链表","date":"2021-12-03T13:20:20.644Z","updated":"2021-12-09T07:39:08.914Z","comments":true,"path":"p/bac2.html","link":"","permalink":"https://618dt.github.io/p/bac2.html","excerpt":"","text":"实验内容 对于一个不带头结点的单链表，设计递归算法逆置所有结点。 实验原理 1.递归介绍 ​ 程序调用自身的编程技巧称为递归；一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。递归必须具备两个条件，一个是调用自己，一个是有终止条件。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方如下面的代码一样: 123456void recursion(参数0) &#123; if (终止条件) &#123; return; &#125; recursion(参数1);&#125; 2.逆置方法 ​ 对于单链表的递归逆置虽然只有几行代码，但刚开始接触可能会有点绕，所以我尽可能详细的把思路理出来； ​ 对于有n个结点的链表的逆置，利用递归的思想可以先将前n-1个结点逆置；当链表为空或者链表只有一个结点的时候终止递归；每一次调用逆置函数R()完成后返回链表已经逆置完成的部分的第一个结点(设为newNode)；因为在当前结点(设为p)前面的结点都已经完成了逆置，所以当前结点指向的下一个结点(p-&gt;next)，成为了已经逆置完成的部分的最后一个结点；如果要进行逆置的话，当前结点应该要变成最后一个结点；所以将p-&gt;next的下一个结点设置为当前结点，即指向p：p-&gt;next-&gt;next=p; p变为最后一个结点后，其下一个结点为空，即p-&gt;next=NULL;这样就完成了以当前结点为第一个结点的链表部分的逆置，返回当前的第一个结点，继续进行逆置，直到所有递归函数调用完毕； ​ 我们来看一个例子，比如要对链表a-&gt;b-&gt;c-&gt;d进行逆置；调用逆置函数R(a),R(a)中会递归调用R(a-&gt;next)即R(b),而R(b)中又会调用R(b-&gt;next)即R(c);这样依次下来：（递归完成部分加粗显示，按照调用完成的顺序） ①R(d),对d进行逆置，由于d-&gt;next为空，所以直接返回d;此时有newNode=d, a-&gt;b-&gt;c-&gt;d-&gt;NULL; ②R(c),对c-&gt;d进行逆置,当前结点为c，要进行逆置，c应该为最后一个结点，则有：c-&gt;next(d)-&gt;next=c;c-&gt;next=NULL; 此时有newNode=d,d-&gt;c-&gt;NULL; a-&gt;b-&gt;c-&gt;NULL;注意这里没有任何结点指向d了，因为已经将c-&gt;next设置为空； ③R(b),对b-&gt;c-&gt;d进行逆置，由于c-&gt;d部分已经逆置成d-&gt;c-&gt;NULL了，所以只需要将b设置为最后一个结点即可；b-&gt;next(c)-&gt;next=b; b-&gt;next=NULL;返回d；此时有newNode=d,d-&gt;c-&gt;b-&gt;NULL; a-&gt;b-&gt;NULL; ④R(a),对a-&gt;b-&gt;c-&gt;d进行逆置,由于b-&gt;c-&gt;d部分已经逆置成d-&gt;c-&gt;b-&gt;NULL，所以像③一样，a-&gt;next(b)-&gt;next=a, a-&gt;next=NULL;至此，所有的递归函数都已经调用完毕；得到了newNode=d，d-&gt;c-&gt;b-&gt;a-&gt;NULL完成了所有节点的逆置； 代码演示完整代码运行结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;typedef struct Node &#123; int data; struct Node* next;&#125; LinkNode;LinkNode* CreateList(int a[],int n) &#123; if (n &lt; 0) return NULL; LinkNode* head = new LinkNode(); LinkNode* p = new LinkNode(); p = head; head-&gt;data = a[0]; int i = 0; for (i = 1; i &lt; n; i++) &#123; LinkNode* node = new LinkNode(); node-&gt;data = a[i]; p-&gt;next = node; p = node; &#125; p-&gt;next = NULL; // 尾结点next域置为空 return head;&#125;void DispList(LinkNode* ln) &#123; cout &lt;&lt; &quot; &quot;; if (ln != NULL) &#123; cout &lt;&lt; ln-&gt;data; DispList(ln-&gt;next); &#125;&#125;LinkNode* Release(LinkNode* ln) &#123; if (ln == NULL || ln-&gt;next == NULL) return ln; else &#123; LinkNode* newNode = Release(ln-&gt;next); ln-&gt;next-&gt;next = ln;//将当前结点接在逆置完成部分的最后结点后面,使其成为最后结点 ln-&gt;next = NULL;//逆置后，最后一个结点的下一个结点为空 return newNode;//返回逆置完成部分的第一个结点 &#125;&#125;int main() &#123; int a[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; int n = sizeof(a) / sizeof(a[0]); LinkNode* L, *N; L = CreateList(a,n); cout &lt;&lt; &quot;初始链表:&quot; &lt;&lt; endl; DispList(L); cout &lt;&lt; endl; cout &lt;&lt; &quot;逆置链表:&quot; &lt;&lt; endl; N = Release(L); DispList(N); cout &lt;&lt; endl; delete L; delete N; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://618dt.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://618dt.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"【转载】如何成为优秀的程序员","slug":"如何成为优秀的程序员","date":"2021-11-25T11:28:36.430Z","updated":"2021-12-06T11:41:54.751Z","comments":true,"path":"p/6380.html","link":"","permalink":"https://618dt.github.io/p/6380.html","excerpt":"","text":"​ 本文转自:http://www.akaedu.org/pages/news_detail.php?id=294 ​ 我们的老师每天都要应对报名者和学员提出的很多同样的问题，以下是这类典型问题的汇总：嵌入式行业（或者IT业）有没有前途？我听说编程编到三十五 岁就没人要了，一定要转行找出路是吗？做驱动开发和做应用开发哪个更有前途？我一开始看什么书都看不懂，怎么才能理出一个学习顺序？诸如此类。这使我迫切 地感觉到，应该总结这样一份非具体技术问题的FAQ了。本文仅代表我个人观点，有问题欢迎Email: songjinshan@akaedu.org。 ​ 在看这份FAQ之前，你必须先读完ESR的《如何成为一名黑客》（本文末尾附有中译版），该文所讲过的道理我不再重复。该文用很大的篇幅讲什么是黑客文 化，虽然态度和信仰的确是成功的最关键因素，但是你肯定会想，做不做黑客跟我没关系，我只是想学个一技之长，找个好工作而已，对吧？那么肯定更希望获得一 些具体的可操作的指导。 1、各种软件技术之间是怎样的关系？ 我把软件技术分为三个层次： 问题域：计算机图形学、音视频编码、信息安全、模式识别、信息检索、自然语言分析、人工智能、科学计算等； 系统集成：C++和Java等面向对象语言、Python等解释型语言、LISP等函数式编程语言、GUI、中间件、编译器与解释器、虚拟机、数据库、网络服务、并行计算、集群、Peer2Peer、系统管理等； 系统功能：硬件描述语言、计算机体系结构与编程模型、指令集与汇编语言、C语言、内核、文件系统、设备驱动、网络协议、POSIX等。 ​ 计算机最终是做什么用的呢？最终是通过问题域的各种技术为用户解决问题的，这些技术都包含很高深的算法，然而它们必须在一个平台上运行，它们需要利用平台 提供的各种基础设施，比如计算能力、I/O能力和网络互联能力。系统功能和系统集成层就是用来实现这个平台的。系统功能层实现计算、I/O和网络的基本功 能，系统集成层对这些基本功能做一些抽象和包装，提供更方便灵活的接口。 2、为什么要学习嵌入式技术？​ 在亚嵌的学习期间，你将详细了解系统功能层的各部分是如何工作的，也会在面向对象编程、GUI、数据库、网络服务等系统集成层的技术方向进行探索。嵌入式 系统可说是麻雀虽小五脏俱全，虽然没有PC和服务器那么复杂，但计算机系统的各种组成一样也不缺。因此，以嵌入式系统作为切入点开始学习软件技术是非常好 的选择，避开不必要的复杂性，把握计算机系统最根本的概念和技术要点。打下扎实的基础之后，你的职业发展则完全不必局限于嵌入式领域，即使你日后做PC或 服务器开发，在亚嵌所学的知识和技能同样使你终生受益。正如庖丁解牛，心中有全牛，自然就能游刃有余。 ​ 另一方面，你一定见到各大网站都有大量的宣传，说现在嵌入式行业前景空前的好，嵌入式人才紧缺，有几百万职位空缺等等。这些说法也是对的，但我们需要更深 入地理解这说明了什么问题。刚才我们说，嵌入式系统也是一个完整的计算机系统，和PC或服务器没有本质的区别，事实上，嵌入式、PC和服务器的界限已经越 来越模糊了。以前的嵌入式就是单片机，只能做简单的运算处理，现在的ARM处理器性能比从前的奔腾还强，打游戏、看电影都没问题，谁能说它不是PC呢？另 外有些专用的嵌入式系统已经在充当服务器的功能了，而集群技术更是可以使许多廉价的处理器组合在一起发挥大型服务器的作用。由于嵌入式越来越多地应用到电 器、汽车和各种设施上，无处不在，并且与PC、服务器呈融合的趋势，所以嵌入式行业前景空前的好。 ​ 那么，为什么说嵌入式人才紧缺呢？其实，学嵌入式系统就是学计算机系统，本质上并没有什么特殊的只有嵌入式系统才有的技术。说嵌入式人才紧缺，其实质上是 说真正懂计算机的人才紧缺。现在很多学校的所谓“软件学院”培养的软件人才都是一叶障目不见泰山的：只懂J2EE和.NET，没学过C和汇编；只会调库函 数sort()，而对各种排序算法一无所知；设计模式、软件工程讲得头头是道，却不知道好的软件还是要靠牛人靠智商来做的。培养人像蒸包子一样一屉一屉地 出，靠软件工程搭一条生产线，然后让熟练工人站在生产线上拧螺丝，幻想着这样就能生产出好的软件，那是把软件工程和程序员的作用本末倒置了。现在嵌入式开 发对程序员的素质要求更高了，以上这类“软件人才”不能胜任了，因此说嵌入式人才紧缺。亚嵌的就业班虽然只有几个月，但培养目标是有完整的计算机系统概念 的软件人才，而不是只会拧螺丝的软件工人，这正得益于我们始终坚持做嵌入式培训而不是Java或.NET培训。 3、有人说软件技术变化太快，现在学的东西过两年就要完全淘汰，是吗？​ 你知道这话是什么人说的吗？必然是已经被淘汰的人说的。比如Delphi、BCB、PB这些开发工具和语言，都曾经很是风光了一阵，但现在已经完全被 Java和.NET取代了。那么Java和.NET会不会被取代呢，也许在相当长的时间内还不会，但是我看好Python。 ​ 这些被淘汰的程序员有一些共同的特点：只会用鼠标拖拽控件，离开IDE就不知道如何工作，学点儿花拳绣腿的功夫就想吃一辈子，对学习新技术不感兴趣，做一 天和尚撞一天钟。现在请回头看看FAQ1，在整个软件技术领域，这些变化快的技术其实只占了很小的一块，却成了这些人的全部看家本领，这样的人能不被淘汰 吗？ ​ 与这些流行的开发工具和语言相反，很多技术和思想是很少变化的。比如，POSIX和SUS标准规定了一套系统函数接口和基本命令的语义，只有实现了这些才 可以称作UNIX，因此今天的Linux、Solaris跟20多年前的UNIX在系统功能层上是基本一致的。而指导计算机科学发展的数学理论，甚至是老 祖宗们在计算机还没诞生的年代就替我们想好的：布尔代数发表于19世纪，直到一个世纪后发明了计算机和数字电路才有了用武之地；数论在17世纪就出现了， 一直都被数学家们当成一套好玩的理论，但只是好玩而已，直到计算机密码学诞生后才发现它的实际用处。 ​ 各种流行的开发工具和高级语言虽然变化很快，但是底层的编程语言却非常稳定，各种操作系统的内核都是用C语言写的，以前是这样，以后也不会改变。另一方 面，各种编程语言的设计思想也是非常稳定的。其实世界上只有两种编程语言，一种是C，一种是LISP，前者是imperative的，是对计算机模型的抽 象，后者是functional的，是对数学函数模型的抽象。面向对象是一种重要的软件工程思想，却算不上一种新的语言模型，应该归在C的一类。属于同一 类的各种语言其实都大同小异，一个精通C++的人学习Java需要多长时间？熟悉语法一个星期，熟悉类库三个星期，一个月足矣，以往的经验都可以套到新的 编程语言上。然而要想习得深厚的算法功底、逻辑思维和抽象思维修养，能够真正说清楚“系统”是什么，如何分析和设计“系统”，需要多长时间？恐怕要数十 年。 4、C和Java哪种语言更好？​ 计算机科学与编程语言无关，甚至与计算机本身也没太大关系，它研究的对象并不是计算机，而是人分析问题解决问题的方法论。程序写出来最主要不是为了给计算 机执行的，而是为了给人看的，使用编程语言和使用自然语言一样是为了表达和交流，只不过程序还可以顺便给计算机执行而已。 ​ 以上这些话并不是我说的，而是一位著名的计算机科学家说的。所以，在编程语言的层面上争论是没有意义的。很多初学者错误地认为掌握了编程语言就等于学会了 计算机，一种编程语言都还没有掌握好，更没有上升到方法论的层面，只有这种无知的人才会去争论哪种语言好的问题。掌握了编程语言远远不等于学会了计算机， 而只是最开始的一步，最简单的一步，到了工作中，用到什么语言就去学什么语言，什么语言过时了就丢掉，编程语言不需要积累因为它太简单了，真正需要积累的 是方法论。 ​ 很多人喜欢参与到这类争论之中，毫无例外，每个人都在为自己熟练掌握的编程语言辩护，就是“我会的语言最好，我不会的语言都不好”，其实这些人真正想说的 是“我会的语言最好是千秋万代，我就不必学新的语言，不必适应新的变化了”，概括起来说就是一个字，懒。真正的高手都是会很多编程语言的，国外有些做技术 咨询的，每年都要学好几门新的编程语言，这样才能应对市场的变化。不断丢掉旧的编程语言学习新的，看起来好像完全是白费力气，没有积累，其实，每种编程语 言的设计都有独到之处，体现了每种语言的精髓，在融汇百家之后积累下来的正是方法论。 ​ 争论哪种语言能做的事情更多、功能更强是没有意义的。从理论上说，任何一种符合图灵机模型的编程语言，加上适当的I/O扩展都可以做任何事情，用 shell脚本也可以写出很像样的游戏来。只不过各种语言的设计目标不同，表达能力不同，做不同的事情所需的代码量不同而已。 ​ 另外一种错误认识是：哪种语言的市场最大，开发人员最多，哪种语言就最好。单从这种意义上说，Java的确比C更好，所以往届有学员问我们为什么只教C语 言。请你注意，操作系统内核是用C写的，各种底层的应用程序包括Java虚拟机也是用C写的。如果你想学Java，在亚嵌的学习完成后你将有能力分析 Java虚拟机的实现，站在计算机系统的高度来学Java才会使你成为真正的Java高手。如果你只想速成，想早点学成一门技术去做拧螺丝的工作，那么亚嵌不适合你。 ​ 在FAQ3里说过，世界上有C和LISP两种编程语言，你现在学了C，以后学了C++、Java、.NET等等，也仍然只认识了半个世界。LISP和 Haskell构成了另外半个世界，现在很常见的Python和JavaScript等解释型语言也借用了functional programming的思想。如果你只管闷着头写代码，而不去广泛涉猎，那么你将错过很多精彩。 5、我听说编程编到三十五岁就没人要了一定要转行找出路是吗？​ 这个观点虽然很流行，但根本不值一驳。现在三十五岁转行的那些人，都具有前面所说的那些特征，对学习新技术不感兴趣，对探索计算机的本质不感兴趣，得过且 过，下了班就是打游戏、看电视，总之就是懒。如果是开出租、摆摊，勤快人懒人都有饭吃，而IT这一行对懒人是非常无情的，懒人就不该入IT这一行，不从自 身找原因，却到处散布这种言论，怪社会不好，打击新人的信心，着实可恨。 ​ 另外一种情况，编程编到三十五岁，进入公司的管理层，或者自己创业，这都是很勤快的人，如果他们把这种勤快用在技术上肯定也可以做得更好，所以也无法证明编程编到三十五岁会因为没有出路而转行。 ​ 编程不是个体力活，需要高强度的思考和智力投入，分析能力、思考能力都需要时间积累起来，所以并不是越年轻干得越好。相反，我认为三十岁以前写的代码都是 垃圾，三十岁以后才能写出像样的程序来。如果希望一辈子走技术的道路而不会被迫转行，就要不断地把自己的工作性质从“体力活”变成“脑力活”。什么叫“不 断地”变呢？这里的“体力活”并不是指种地、盖房子这种劳动，而是指简单重复地编写代码，这时你会感觉，派给你的工作都能凭以往的经验轻松应付了，但是千 万不要满足于现状，就像温水煮青蛙一样，这是危险的处境！要摆脱这种处境就需要学习、思考、提高，让公司派给你更有挑战性的工作，在工作中应用新学到的知 识和技术就是“脑力活”了，但是用得久了又会变成简单重复的“体力活”，这时就需要再学习、再提高，所以叫做“不断地”把自己的工作性质从“体力活”变成 “脑力活”。如果有一天你发现，自己长期陷于简单重复的劳动之中，并且业余时间非常少，无法学习提高，这说明公司不会用人，你就该考虑跳糟了。 ​ 从另外一个角度来说，如果希望一辈子走技术的道路，就要有自己的核心竞争力，这个核心竞争力决不是凭以往的经验能够做某些工作的能力，而是学习能力、思考 能力和解决有挑战性的新问题的潜力。在IT这一行，凭借以往的经验干重复的活是干不长久的，原因很简单，一个问题不会被解决两次，当你发现你的经验能够解 决一类问题时，别人早把解决这一类问题的套路编写成framework，新上手的人即使不具备你的这些经验也可以调用framework中的类和函数来解 决问题，然后在这个framework的基础上积累新的经验解决新的问题。正因为如此，全世界开发人员的经验才会积累起来，促使软件技术发展得如此迅速。 这并不是说经验完全没有用，最关键的，学习和思考也是建立在以往经验的基础之上的。另一方面，现有的framework并不一定是某方面开发经验的完美整 合，也需要不断发展，用新的办法重新解决老问题，以Web开发为例，从早期的ASP、PHP到后来的.NET、J2EE，到现在的Ruby on Rails、Django等等，这些framework解决的是同一问题，就是如何快速有效地开发Web应用，这方面的经验被不断重新整合，推陈出新。总 结一下，什么才是核心竞争力呢？应该是在经验的基础上学习新技术、解决新问题的能力。 6、做驱动开发还是做应用开发更有前途？​ 意思就是说，“你告诉我哪个更有前途，我就好好学哪个，另外一个就不用学了”。问这种问题的学员往往会同时问另外一些问题：我以后就想做驱动开发，你教我这些应用开发的技术有什么用？C++用得多吗？学了有什么用？我以后不想做GUI，你教我Qt有什么用？ ​ 学习最忌讳的就是“有用的就学，没有用的就不学”这种功利的态度。两个问题：第一，在你还没学进去、还不了解这种技术时，要如何判断这种技术学了有没有 用？只能是根据道听途说，看各种论坛上都怎么说的，岂不知论坛上参与这种讨论的100%都是菜鸟，有的水平还不如你。第二，就算你学的技术没有用上，有什 么损失吗？从亚嵌毕业的学员从事各种各样的开发工作，有做驱动的，有做系统编程的，有做GUI的，有做Web开发的，只要确定了做一类工作，就不可能把在 亚嵌四个月学的知识都用上，但至少也用得上3/4的知识，假设剩下的1/4你一辈子也没机会用上了，那也就损失你一个月的学习时间而已，相比于你的收获， 这算是很大的损失吗？请注意，上面的假设是不成立的，没用上的那1/4也只是暂时没用上而已，程序员要换工作或者换项目是很常见的，任何人都不可能只涉及 一类开发工作，只要有扎实的基础、完备的知识体系，任何工作都能轻松上手。 ​ 扎实的基础，完备的知识体系，我们在安排就业班课程体系的时候，正是以这两点为依据的。有的课程内容很少有学员在以后工作中会用到，但是缺了这一环就不成 为一个完备的知识体系，例如MMU和Cache，那这种课该不该上呢？毫无疑问该上。有的课程培养一种基本的编程思想，例如通过C++来讲面向对象编程， 通过Qt来讲面向对象、事件驱动和状态机编程，这些编程思想是程序员必备的基本素质，而C++和Qt可能有些学员以后工作用不到，那这种课该不该上呢？毫 无疑问该上。至于还有些人争论说C++不如Java用得多，Qt不如GTK用得多，请翻回去看FAQ4，这种争论是无意义的，有工夫争论谁优谁劣，不如把 两种都学了，会更有收获。 ​ 回到做驱动开发还是做应用开发更有前途的问题。我只能说，做好了都有前途，做不好都没有前途，只会做一样而完全不懂另一样是最没前途的。不要以为内核开发 者就不写应用程序，Linus写了一个源代码管理系统git来维护内核，因为觉得现有的源代码管理系统都不好用。牛人都是这样，需要什么就写什么，才不管 是kernel space还是user space。同样，做应用开发如果不懂内核，也没有办法很好地利用内核提供的服务写出性能最优的程序。做内核难，因为调试难，要跟踪大量的并发线程，因为 入门难，要写一个hello world都需要学很多知识。做应用也难，回头去看FAQ1，计算机科学从理论到实践大部分都在上面两层做文章。所以不存在哪个更难哪个更有前途的问题， 任何关于哪个更难的讨论都是too naive的。 7、我一开始看什么书都看不懂，怎么才能理出一个学习顺序？​ 以前有个学员在学C语言时说，“C语言很多地方都很奇怪，都得用内核的知识去解释，可是你又不先教我内核，我没法学C语言。我只好自己看操作系统的书，看 内核代码，可是看不懂。”当然看不懂了，内核代码都是用C写的，如果不学内核就没法学C语言，那不学C语言又怎么可能看懂内核？看来这是一个鸡生蛋还是蛋 生鸡的问题。 ​ 懒真的是人的本性，就连学习的过程都希望是一条路顺利地走下去，不用动脑就能学会的：身后走过的路都是“已知”，每走一步就把眼前新的“未知”变成“已 知”，如此一路走来，把所有的“未知”都变成“已知”就算学成了。可惜，知识不是一条路，而是一个圈，你从任何一个地方跳进这个圈开始走，身后都是“未 知”，眼前也都是“未知”。有的人就是不能容忍自己的身后是“未知”：看一本书，一个新的概念A是用我不了解的概念B、C来解释的，我连B、C都不懂怎么 学A？没法学了！ 不是人家书写得不好，而是没有任何办法能把一个圈扯成一条直线的。学习的过程本质上就是一个循环往复的过程，唯一的办法就是“存疑”：在本子上记着，有 B、C这样两个概念是我暂时不理解的，然后就不再去想这回事，而是相信自己已经理解了B、C，基于自己的理解和假设去学习A，由A再去理解X、Y，这样学 下去，走完一圈之后再回来，自然就明白当初对B、C的假设正确不正确了，理解了这两个概念，就从本子上划掉，这时需要再走一圈，把原来的一些错误认识纠正 过来。所以，任何书都要至少看两遍，第二遍看的时候你会对很多概念有新的认识，因为你看过这个概念后面的章节，在此基础上产生了新的认识。古人早就明白这 个道理，所以提出了“温故而知新”。 ​ 亚嵌的课程体系经过多年教学实践的锤炼，已经很好地理顺了知识之间的关系，使你从最佳的位置跳进这个圈开始学习，所谓“最佳位置”是指，在你初学的时候需 要容忍的“未知”尽可能少，需要做的假设尽可能少，但要想消除所有的“未知”是不可能的，例如没有学内核就要学C语言。根据你以往的经验和一些运气因素， 你对内核的一些假设可能正确也可能错误，但这并不影响你学C语言，对内核的一些错误假设可能会导致在学C语言的过程中有些误解，但没关系，只要跟着我们的 课程体系一步一步走下来，这些误解和错误的假设最终都会纠正过来。 8、有哪些好书可以推荐一下吗？​ 能问出这个问题的都是聪明的学员。看书学习是入门过程中非常重要的一环，如果用一本烂书入门，浪费时间还是小事，如果被误导了就麻烦了，如果形成的错误认 识不能及时纠正，变得根深蒂固了就更麻烦了。所以，看书一定要有“品牌意识”，在决定看书学习一门技术时先问问这一领域最权威的书是哪本，这里列举一些 Bible级别的书： The C Programming Language, 2nd Edition；* C++ Primer, 4th Edition； Structure and Interpretation of Computer Programs, 2nd Edition； Introduction to Algorithms, 2nd Edition； Compilers: Principles, Techniques, and Tools； Advanced Programming in the UNIX Environment, 2nd Edition； TCP/IP Illustrated, Volume 1: The Protocols； UNIX Network Programming Volume 1, 3rd Edition: The Sockets Networking API； Understanding the Linux Kernel, 3rd Edition； Linux Device Drivers, 3rd Edition。* 在学习过程中，眼界一定要开阔，不要学到一点东西就沾沾自喜，坐井观天，以为这就是技术的全部。要多和别人交流，多了解别人在看什么书、别人对技术的认识是怎样的。书是看不完的，活到老学到老，对于程序员来说尤其如此。 9、如何处理打游戏和学习的关系？​ ESR的文章中也说过，黑客们都有一些特别的业余爱好，并且往往是非理性思维的爱好，大概是需要换换脑子吧。典型的例子是因滑翔机事故去世的 Stevens，他写了FAQ8所推荐的Bible当中的三本。爱打游戏的优秀程序员肯定大有人在，有一些还成了优秀的游戏开发人员。但是我认为，要想成 为优秀的程序员，必须有两点基本素质，一是对编程非常感兴趣，二是对所有别的事情都不感兴趣，或者都不如对编程感兴趣。有人说，人的一天有24小时，8小时休息，8小时上班，另外的8小时在干什么就决定了你以后有多大发展。一有时间就看书学习，这就是一个程序员应该做的。今天打游戏，明天看电影，后天炒股，那么你就等着三十五岁下岗。如果你不能够认同编程和思考是比其它事情更有吸引力的，那么你不必学编程，集中精力去做最喜欢的事情或许会有更大的成就。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://618dt.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://618dt.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"author":"宋劲杉"},{"title":"测试文章","slug":"测试文章","date":"2021-10-23T05:49:43.000Z","updated":"2021-12-09T07:34:20.874Z","comments":true,"path":"p/1023.html","link":"","permalink":"https://618dt.github.io/p/1023.html","excerpt":"","text":"测试标题这是一个测试页面,以下内容为余华的《活着》 &emsp;&emsp; 我比现在年轻十岁的时候，获得了一个游手好闲的职业，去乡间收集民间歌谣。那一年的整个夏天，我如同一只乱飞的麻雀，游荡在知了和阳光充斥的村舍田野。 &emsp;&emsp; 我喜欢喝农民那种带有苦味的茶水，他们的茶桶就放在田埂的树下，我毫无顾忌地拿起漆满茶垢的茶碗舀水喝，还把自己的水壶灌满，与田里干活的男人说上几句废话，在姑娘因我而起的窃窃私笑里扬长而去。我曾经和一位守着瓜田的老人聊了整整一个下午，这是我有生以来瓜吃得最多的一次，当我站起来告辞时，突然发现自己像个孕妇一样步履艰难了。然后我与一位当上了祖母的女人坐在门槛上，她编着草鞋为我唱了一支《十月怀胎》。我最喜欢的是傍晚来到时，坐在农民的屋前，看着他们将提上的井水泼.在地上，压住蒸腾的尘土，夕阳的光芒在树梢上照射下来，拿一把他们递过来的扇子，尝尝他们和盐一样咸的咸菜，看看几个年轻女人，和男人们说着话。 &emsp;&emsp; 我头戴宽边草帽，脚上穿着拖鞋，一条毛巾挂在身后的皮带上，让它像尾巴似的拍打着我的屁股。我整日张大嘴巴打着呵欠，散漫地走在田间小道上，我的拖鞋吧哒吧哒，把那些小道弄得尘土飞扬，仿佛是车轮滚滚而过时的情景。 &emsp;&emsp; 我到处游荡，已经弄不清楚哪些村庄我曾经去过，哪些我没有去过。我走近一个村子时，常会听到孩子的喊叫： &emsp;&emsp; “那个老打呵欠的人又来啦。” print &quot;hello world&quot; 123for(int i=0;i=100;i++)&#123; cout&lt;&lt;&quot;这是第&quot;&lt;&lt;i+1&lt;&lt;&quot;次&quot;&lt;&lt;循环&lt;&lt;endl;&#125;","categories":[{"name":"分类测试","slug":"分类测试","permalink":"https://618dt.github.io/categories/%E5%88%86%E7%B1%BB%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试标签","slug":"测试标签","permalink":"https://618dt.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}],"author":"LCG"}],"categories":[{"name":"Java开发","slug":"Java开发","permalink":"https://618dt.github.io/categories/Java%E5%BC%80%E5%8F%91/"},{"name":"分布式与微服务","slug":"分布式与微服务","permalink":"https://618dt.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/categories/Spring/"},{"name":"SpringBoot","slug":"Spring/SpringBoot","permalink":"https://618dt.github.io/categories/Spring/SpringBoot/"},{"name":"SSM开发项目","slug":"Spring/SSM开发项目","permalink":"https://618dt.github.io/categories/Spring/SSM%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/"},{"name":"SpringMVC基础","slug":"Spring/SpringMVC基础","permalink":"https://618dt.github.io/categories/Spring/SpringMVC%E5%9F%BA%E7%A1%80/"},{"name":"Spring基础","slug":"Spring/Spring基础","permalink":"https://618dt.github.io/categories/Spring/Spring%E5%9F%BA%E7%A1%80/"},{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux与Redis基础","slug":"Java数据库/Linux与Redis基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Linux%E4%B8%8ERedis%E5%9F%BA%E7%A1%80/"},{"name":"OA系统项目","slug":"Java数据库/OA系统项目","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/OA%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"name":"MyBaits","slug":"Java数据库/MyBaits","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MyBaits/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"name":"Java数据库开发基础","slug":"Java数据库/Java数据库开发基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"},{"name":"数据结构","slug":"数据结构","permalink":"https://618dt.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂谈","slug":"杂谈","permalink":"https://618dt.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"分类测试","slug":"分类测试","permalink":"https://618dt.github.io/categories/%E5%88%86%E7%B1%BB%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://618dt.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://618dt.github.io/tags/Dubbo/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://618dt.github.io/tags/Zookeeper/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://618dt.github.io/tags/SpringCloud/"},{"name":"微服务","slug":"微服务","permalink":"https://618dt.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://618dt.github.io/tags/RabbitMQ/"},{"name":"Nginx","slug":"Nginx","permalink":"https://618dt.github.io/tags/Nginx/"},{"name":"Docker","slug":"Docker","permalink":"https://618dt.github.io/tags/Docker/"},{"name":"分布式","slug":"分布式","permalink":"https://618dt.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"线程","slug":"线程","permalink":"https://618dt.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://618dt.github.io/tags/SpringBoot/"},{"name":"SSM","slug":"SSM","permalink":"https://618dt.github.io/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"https://618dt.github.io/tags/Spring/"},{"name":"开发","slug":"开发","permalink":"https://618dt.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"Redis","slug":"Redis","permalink":"https://618dt.github.io/tags/Redis/"},{"name":"Linux","slug":"Linux","permalink":"https://618dt.github.io/tags/Linux/"},{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"},{"name":"Lambda","slug":"Lambda","permalink":"https://618dt.github.io/tags/Lambda/"},{"name":"反射","slug":"反射","permalink":"https://618dt.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"Maven","slug":"Maven","permalink":"https://618dt.github.io/tags/Maven/"},{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"},{"name":"Freemaker","slug":"Freemaker","permalink":"https://618dt.github.io/tags/Freemaker/"},{"name":"Listener","slug":"Listener","permalink":"https://618dt.github.io/tags/Listener/"},{"name":"Filter","slug":"Filter","permalink":"https://618dt.github.io/tags/Filter/"},{"name":"正则","slug":"正则","permalink":"https://618dt.github.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"Ajax","slug":"Ajax","permalink":"https://618dt.github.io/tags/Ajax/"},{"name":"JSON","slug":"JSON","permalink":"https://618dt.github.io/tags/JSON/"},{"name":"EL","slug":"EL","permalink":"https://618dt.github.io/tags/EL/"},{"name":"JSP","slug":"JSP","permalink":"https://618dt.github.io/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"https://618dt.github.io/tags/Servlet/"},{"name":"xml","slug":"xml","permalink":"https://618dt.github.io/tags/xml/"},{"name":"BUG","slug":"BUG","permalink":"https://618dt.github.io/tags/BUG/"},{"name":"递归","slug":"递归","permalink":"https://618dt.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"程序员","slug":"程序员","permalink":"https://618dt.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"测试标签","slug":"测试标签","permalink":"https://618dt.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}]}