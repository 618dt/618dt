{"meta":{"title":"才刚的博客","subtitle":"记录点点滴滴","description":"也许不能描绘将来，但愿记录此刻美好","author":"lcg","url":"https://618dt.github.io","root":"/"},"pages":[{"title":"","date":"2021-11-26T14:34:42.577Z","updated":"2021-11-26T14:34:42.577Z","comments":true,"path":"blog/about/index.html","permalink":"https://618dt.github.io/blog/about/index.html","excerpt":"","text":"关于小站关于我 2021-11-23 将主题改为了volantis增加了valine评论系统 2021-10-30 利用hexo+github搭建了静态博客使用的主题是简洁大方的next 2021-02-26 购买了域名www.gamest.link利用阿里云服务器,WP以及宝塔面板搭建了第一个博客由于服务器到期网站作废 我的名字:李**(╹▽╹)兴趣爱好:音乐,电影,篮球;我所擅长:熟悉Java, Mybatis, Spring, SpringMVC, RabbitMQ等单词的拼写;熟悉计算机的基本操作:如开机,关机,重启等;我的缺点:缺点就是不愿意说出自己的缺点;自我评价:计算机类专业大三在读,虽然很菜,但也热爱开源,热爱技术;希望能够在互联网上学到更多的技术,并且运用这些技术解决有趣的问题;座右铭:桃李不言,下自成蹊"},{"title":"我的相册","date":"2022-02-21T11:46:23.625Z","updated":"2022-02-21T11:46:23.625Z","comments":true,"path":"blog/album/index.html","permalink":"https://618dt.github.io/blog/album/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-11-23T10:37:51.892Z","updated":"2021-11-23T10:37:51.892Z","comments":true,"path":"blog/categories/index.html","permalink":"https://618dt.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-23T10:39:52.165Z","updated":"2021-11-23T10:39:52.165Z","comments":true,"path":"404.html","permalink":"https://618dt.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有标签","date":"2021-11-23T10:38:05.824Z","updated":"2021-11-23T10:38:05.823Z","comments":true,"path":"blog/tags/index.html","permalink":"https://618dt.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis入门","slug":"Redis入门","date":"2022-02-03T00:55:00.000Z","updated":"2022-02-21T14:31:07.186Z","comments":true,"path":"p/d40.html","link":"","permalink":"https://618dt.github.io/p/d40.html","excerpt":"","text":"课程介绍◇Redis介绍与安装◇掌握在Java中操作Redis◇掌握Redis的常用命令与数据类型 Redis介绍◇Redis是Key-Value型NoSQL数据库 ,即每一个数据都有键和值；◇Redis将数据存储在内存中，同时也能持久化到磁盘◇Redis常用于缓存，利用内存的高效提高程序的处理速度 Redis特点◇ 速度快 ◇ 广泛的语言支持◇ 持久化 ◇ 多种数据结构◇ 主从复制 ◇ 分布式与高可用 Redis的安装与启动在Linux系统中安装Redis◇进入redis官网◇创建redis目录，安装gcc用于make编译◇安装命令 1234$ wget https://download.redis.io/releases/redis-5.0.2.tar.gz$ tar xzf redis-5.0.2.tar.gz$ cd redis-5.0.2$ make ◇启动redis: 在src目录中redis-server开启服务器；redis-cli进行客户端连接；◇[root@master redis-5.0.2]# ./src/redis-server redis.conf #启动命令 在Windows系统中安装Redis◇进入github下载◇点击releases，下载zip文件进行解压◇在终端(cmd)进入解压目录中，dir查看文件；◇安装命令：redis-server redis.windows.conf◇由于Windows的版本过旧，仅做学习使用； Redis的常用基本配置◇编辑redis.conf（配置文件）定位到136行，有一个daemonize（是否后台运行，守护进程)，改为yes即可进行守护；这样启动后，不会出现redis的logo并且启动会只要虚拟机运行，则redis一直提供服务；netstat -tulpn#查看系统占用的端口，进而查看redis是否运行；若要关闭redis，可以杀死进程或者利用客户端关闭；◇redis-cli即redis客户端，用来执行redis指令；进入方法：./src/redis-cli 退出命令：exit◇在客户端使用命令:ping 若出现PONG 则说明redis正常运行；关闭redis进程：./src/redis-cli shutdown◇在redis.conf文件可以使用vim命令修改相关配置；◇修改redis端口后需要指定端口进行连接， ./src/redis-cli -p 6380 #指定6380端口进行连接◇redis的数据库名字为数字0~15；如果觉得数据库数量不够用，可以在配置文件中设置，在大概186行出的databases进行修改;◇在配置文件的507行有个#requirepass foobared,说明默认密码是foobared，将注释取消，修改为12345。这样在使用redis时需要使用密码了。在启动后，输入命令：auth 12345即可◇在263行，有dir ./即数据的保存目录；dump.rdb就是redis的全量备份。 Redis通用命令◇示例 123456789./src/redis-cli -p 6379 #连接客户端auth 12345 #输入密码select 0 #选择0号数据库set name lily #在当前数据库中增加一个key=name,value=lily的数据get name #获取数据set name lee #会将前面的数据覆盖掉keys * #查询所有的keydbsize #显示当前数据库的数据总量del name #删除name这个key Redis数据类型◇ String - 字符串类型 ◇ Hash - Hash类型◇ List - 列表类型 ◇ Set - 集合类型◇ Zset - 有序集合类型 String 字符串类型 字符串命令 Hash键值类型◇Hash类型用于存储结构化数据 Hash 命令 List列表类型◇List列表就是一系列字符串的“数组”，按插入顺序排序◇List列表最大长度为2的32次方-1，可以包含40亿个元素 List 命令◇rpush listkey c b a - 右侧插入◇lpush listkey f e d - 左侧插入◇ d e f c b a◇rpop listkey - 右侧弹出◇lpop listkey - 左侧弹出 List 指令◇llen listkey - 获取长度◇lrange listkey 0 2◇lrange listkey 1 -1 获取子集 Set与Zset集合类型◇Set集合是字符串的无序集合，集合成员是唯一的◇Zset集合是字符串的有序集合，集合成员是唯一的 Java客户端-Jedis◇Jedis是Java语言开发的Redis客户端工具包◇Jedis只是对Redis命令的封装,掌握Redis命令便可轻易上手 Jedis使用演示◇编辑配置文件redis.conf，在88行处：protected-mode yes #是否开启保护模式，设置为no关闭，允许其他ip主机连接进来◇在69行处bind 127.0.0.1改为0.0.0.0表示任意ip主机都可以访问进来；◇设置防火墙放行6379端口：firewall-cmd –zone=public –add-port=6379/tcp –permanent; firewall-cmd –reload#重载◇查看redis服务器的IP地址◇Windows上下载jedis◇利用maven进行下载 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 在IDEA中创建maven工程◇JedisTestor 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class JedisTestor &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.132.144&quot; , 6379);//虚拟机IP地址，redis服务器端口号 try &#123; jedis.auth(&quot;12345&quot;);//输入密码 jedis.select(2); System.out.println(&quot;Redis连接成功&quot;); //字符串 jedis.set(&quot;sn&quot; , &quot;7781-9938&quot;); String sn = jedis.get(&quot;sn&quot;); System.out.println(sn); jedis.mset(new String[]&#123;&quot;title&quot; , &quot;婴幼儿奶粉&quot; , &quot;num&quot; , &quot;20&quot;&#125;); List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot; , &quot;title&quot; , &quot;num&quot;&#125;); System.out.println(goods); Long num = jedis.incr(&quot;num&quot;); System.out.println(num); //Hash jedis.hset(&quot;student:3312&quot; , &quot;name&quot; , &quot;张晓明&quot;); String name = jedis.hget(&quot;student:3312&quot; , &quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; studentMap = new HashMap(); studentMap.put(&quot;name&quot;, &quot;李兰&quot;); studentMap.put(&quot;age&quot;, &quot;18&quot;); studentMap.put(&quot;id&quot;, &quot;3313&quot;); jedis.hmset(&quot;student:3313&quot;, studentMap); Map&lt;String,String&gt; smap = jedis.hgetAll(&quot;student:3313&quot;); System.out.println(smap); //List jedis.del(&quot;letter&quot;); //将letter列表删除,否则后面会依次叠加 jedis.rpush(&quot;letter&quot; , new String[]&#123;&quot;d&quot; , &quot;e&quot; , &quot;f&quot;&#125;); jedis.lpush(&quot;letter&quot; , new String[]&#123;&quot;c&quot; , &quot;b&quot; , &quot;a&quot;&#125;); List&lt;String&gt; letter = jedis.lrange(&quot;letter&quot; , 0 , -1); jedis.lpop(&quot;letter&quot;); jedis.rpop(&quot;letter&quot;); letter = jedis.lrange(&quot;letter&quot;, 0, -1); System.out.println(letter); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; jedis.close(); &#125; &#125;&#125; 利用Jedis缓存数据◇创建实体类Good 12345678public class Goods &#123; private Integer goodsId; private String goodsName; private String description; private Float price; ...&#125; ◇创建缓存示例类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CacheSample &#123; public CacheSample()&#123; Jedis jedis = new Jedis(&quot;192.168.132.144&quot;); try &#123; List&lt;Goods&gt; goodsList = new ArrayList&lt;Goods&gt;(); //初始化模拟数据 goodsList.add(new Goods(8818, &quot;红富士苹果&quot;, &quot;&quot;, 3.5f)); goodsList.add(new Goods(8819, &quot;进口脐橙&quot;, &quot;&quot;, 5f)); goodsList.add(new Goods(8820, &quot;进口香蕉&quot;, &quot;&quot;, 25f)); jedis.auth(&quot;12345&quot;); jedis.select(3);//选择redis的三号数据库 //将每一个二进制存储的java对象序列化为json字符串以便redis存储 for (Goods goods : goodsList) &#123; String json = JSON.toJSONString(goods); System.out.println(json); String key = &quot;goods:&quot; + goods.getGoodsId(); jedis.set(key , json); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; jedis.close(); &#125; &#125; public static void main(String[] args) &#123; new CacheSample(); System.out.printf(&quot;请输入要查询的商品编号：&quot;); String goodsId = new Scanner(System.in).next(); Jedis jedis = new Jedis(&quot;192.168.132.144&quot;); try&#123; jedis.auth(&quot;12345&quot;); jedis.select(3); String key = &quot;goods:&quot; + goodsId; if(jedis.exists(key))&#123; String json = jedis.get(key); System.out.println(json); //json字符串转换为java对象 Goods g = JSON.parseObject(json, Goods.class); System.out.println(g.getGoodsName()); System.out.println(g.getPrice()); &#125;else&#123; System.out.println(&quot;您输入的商品编号不存在，请重新输入！&quot;); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; jedis.close(); &#125; &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux与Redis基础","slug":"Java数据库/Linux与Redis基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Linux%E4%B8%8ERedis%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://618dt.github.io/tags/Redis/"}],"author":"LCG"},{"title":"Linux基础和Java环境搭建","slug":"Linux基础和Java环境搭建","date":"2022-02-03T00:53:00.000Z","updated":"2022-02-21T14:29:12.656Z","comments":true,"path":"p/c40f.html","link":"","permalink":"https://618dt.github.io/p/c40f.html","excerpt":"","text":"内容简介◇Linux基础入门◇Linux进阶应用◇Redis应用入门 主要知识点◇介绍Linux与CentOS ◇讲解Linux基础命令◇yum应用安装与卸载 ◇CentOS的权限与系统安全◇Linux文本工具与命令 ◇部署OA项目至Linux服务器 操作系统什么是操作系统◇操作系统(Operating System)是应用程序运行的基础支撑环境◇操作系统作用是管理和控制计算机系统的硬件与软件资源◇Intel x86架构上常见的操作系统:Windows、Linux、Unix… Linux操作系统◇Linux是开源的基于Intel x86架构的类Unix多用户操作系统◇Linux是目前最主要的服务器端操作系统◇互联网大厂都在使用Linux作为服务器主要操作系统 Linux为什么受欢迎◇免费使用，自由传播 ◇支持多任务、多用户、多CPU◇高效而灵活 ◇兼容任意x86架构计算机◇强大易用的系统命令 ◇完整的应用软件生态 Linux发行版本◇Linux系统内核(kernel)提供了Linux操作系统的核心功能◇不同开发商在内核基础上扩展封装,形成了不同发行版本◇常见发行版：Red Hat Linux、CentOS、Ubuntu、SUSE… Linux发行版选择建议◇桌面系统:Ubuntu◇服务器操作系统: CentOS（免费）、Red Hat Linux（收费）◇特定需求: Debian(稳定性)、Fedora(新特性)、麒麟Linux(国产) CentOS - 社区企业操作系统简介◇基于Red Hat Enterprice Linux 的开源企业级Linux发行版本◇各版本CentOS都会获得十年的支持,与RHEL保持同步更新◇CentOS采用社区支持,同时修正了RHEL许多BUG CentOS版本选择◇CentOS 5/6 : 历史版本,已被淘汰◇CentOS 7 : 主流版本,稳定成熟,大多数服务器的首选版本◇CentOS 8 : 全新版本,基于最新内核,不排除存在漏洞隐患 安装CentOS 7.7CentOS 7 运行要求◇CPU : 1核,建议2核以上◇内存 : 1G,建议2G以上◇硬盘 : 预留20G可用空间 开启CPU虚拟化◇Ctrl+Alt+Delete打开任务管理器-&gt;性能-&gt;查看右下角虚拟化是否已启用◇若未启动,则应开启CPU虚拟化，由于电脑型号不同，具体方法可百度 安装VMware Workstation虚拟机◇在VMware中搭建CentOS Linux系统目录Linux倒挂树形目录结构◇”/“是所有目录的顶点,称为”根目录”◇不同目录下的数据可分布在不同磁盘,所有目录按规则组织与命名◇Linux也区分绝对路径与相对路径 常见系统目录 Linux远程管理SSH客户端 ◇SSH是专为远程登录和其他网络服务提供的安全性协议◇SSH分为两个不兼容版本1.x与2.x,默认通过SSH2.x连接◇基于SSH远程连接工具有很多,最常见的是Xshell与SecureCRT Xshell与Xftp◇Xshell是著名的Linux客户端,常用于在Windows下远程访问◇Xshell同时还支持Telent、RLogin、Serial等其他连接方式◇Xftp是Xshell配套组件，用于向服务器上传/下载文件 Xshell与Xftp安装与配置◇在官方网站安装个人版◇在虚拟机终端输入ifconfig查看虚拟机的ip地址◇新建xshell会话，连接后输入用户名和密码即可◇在Xshell顶部绿色的新建文件传输打开，可以进行文件的传输 Linux文件操作命令Linux命令格式◇命令 [参数选项] [文件或路径] Linux文件操作核心命令◇clear 清屏 ◇rmdir 删除空目录◇cd时输入某个路径的前一个字母后可以按Tab进行自动补全◇命令 –help可以查看命令的参数等相关信息◇mv 重命名格式：mv old.c new.c ;移动格式：mv old.c /xx/xx 也可以移动整个文件夹◇不要轻易使用rm -rf，这样会强制迭代删除而不进行询问，rm -r迭代删除进行询问 vim文本编辑器◇vi是Linux重要的文字编辑工具,vim是它的增强版◇vim用于在远程环境下用命令形式对文本进行在线编辑◇用法格式: vim [选项] [文件] vim三种模式◇普通模式:默认模式,文本只读,不可编辑◇编辑模式:编辑文本模式,普通模式按i键进入,Esc键退出◇命令模式:执行保存、搜索、退出等操作 vim重要快捷键 Linux文本工具常用文本工具 文件输入与输出◇文件输入：&lt; (重写) 或者 &lt;&lt; (追加) ◇文件输出：&gt; (重写) 或者 &gt;&gt; (追加)◇echo “xxxx” &gt;&gt; log.txt 将xxxx文本追加写入到log.txt文件中◇合并文件：cat hello.txt myname.txt &gt;&gt; full.txt◇tail full.txt –显示文件尾部内容; tail -n 2 full.txt –显示文件最后两行◇tail -f full.txt –动态监测文件末尾所产生的新行; ctrl+c退出◇grep lcg test.txt –查找test.txt文件中包含lcg字符串的文本行,字符串可以是正则表达式◇grep -v lcg test.txt –查找test.txt文件中不包含lcg字符串的文本行◇ll | grep -E “log[0-9]{1,5}.txt” –进行文件的筛选，查看所有日志文件 -E表示使用扩展正则表达式；{1,5}表示数字位数为1~5； 文件打包与压缩Linux压缩程序-gzip◇gzip是Linux系统的文件压缩程序◇gzip压缩包文件扩展名.gz◇大流量的网站默认都在使用gzip进行数据压缩传输 tar打包与压缩◇tar是Linux系统将多个文件打包和压缩的工具◇tar本质是打包软件，扩展名.tar◇tar可结合gzip或其他压缩工具实现打包压缩，扩展名.tar.gz◇压缩命令: tar zcvf tomcat.tar.gz /usr/local/tomcat◇解压缩命令: tar zxvf tomcat.tar.gz -C /usr/local/tomcat tar常用可选项 安装与卸载应用程序为CentOS安装应用程序◇在CentOS中安装第三方应用程序包含两种方式:◇rpm:Red Hat软件包管理器,相当于应用程序安装文件的执行者◇编译安装:用户自己从网站下载程序源码进行编译安装 yum与rpm的关系◇rpm安装过程中,需要用户自己解决依赖问题◇yum通过引入软件仓库,联网下载rpm包及依赖,并依次自动安装◇yum是rpm的前端程序,其目的就是简化rpm的安装过程 yum常用命令◇yum search 应用名 #在仓库中查询是否存在指定应用◇yum install -y 应用名 #全自动下载安装应用及其依赖◇yum info 应用名 #查看软件详细信息◇yum list installed 应用名 #查看已安装的应用程序◇rpm -ql 应用名 #查看安装后输出的文件清单◇yum remove -y 应用名 #全自动卸载指定应用 ，-y表示遇到询问都用y 编译方式安装编译方式安装应用程序◇如yum仓库未提供rpm,往往需要采用编译安装方式◇编译安装是指从应用官网下载源码后,对源码进行编译后使用◇编译命令: make #使用对应编译器对源码编译生成可执行文件 yum与编译安装比较 编译安装Redis◇利用xftp将下载好的压缩包文件上传到linux；然后解压；进入redis-4.0.14目录；安装gcc编译器：yum install -y gcc;◇有时候第一次make编译出错后，可能改变了原来的文件结构，因此纠正错误后下一次编译时需要将解压后的目录删除重新解压；当出现Hint: It’s a good idea to run ‘make test’ ;)时代表编译成功；◇编译安装后的应用程序redis-server存放在src中，在启动redis-server前需要加载上一级目录下的redis.conf配置文件;即启动命令为:./src/redis-server redis.conf 启动后ctrl+c退回命令状态 Linux进阶应用Linux系统管理命令◇使用ifconfig查看网卡ip◇netstat 查看网络端口号：netstat -tulpn 或 netstat -ano◇Recv-Q:接收队列；Send-Q:发送队列; LISTEN表示网络状态正在被监听;PID:进程编号；Program name创建网络连接的应用◇netstat 常用选项◇查看进程: ps -ef ，箭头处5412指PID；杀掉进程：kill -9 PID◇一般使用应用程序退出来关闭进程，而不是强制杀掉进程，因为可能造成数据丢失◇ps -ef | grep vim ; | 表示通道，即ps -ef查询产生的数据像通过通道一样送入到后一个指令 应用服务化简介◇ 应用服务化是指让应用程序以服务方式在系统后台运行◇ Linux系统对服务化应用进行统一管理◇ 服务管理命令：systemctl systemctl◇.pid文件用来保存进程编号◇将redis服务化，需要在/usr/lib/systemd/system目录下创建 vim redis.service；在文件中写入配置： 123456789101112131415[Unit]Description=RedisAfter=syslog.target network.target remote-fs.target nss-lookup.target #表示在这些服务启动以后才能启动redis[Service]Type=forking #forking代表后台运行PIDFile=/run/redis_6379.pid#说明启动时执行server，加载配置文件ExecStart=/home/lcg/0/redis-4.0.14/src/redis-server /home/lcg/0/redis-4.0.14/redis.conf#关闭,-s采用正常流程进行退出；-9表示强制退出ExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=True #为每一个服务设置私有的Tmp临时文件目录[Install]WantedBy=multi-user.target #将当前的redis服务分配到multi-user服务组上； ◇systemctl daemon-reload #对所有service进行重载;◇systemctl start redis #启动服务； systemctl status redis #查看状态 Linux用户与权限用户◇ Linux是多用户多任务系统,包含两个概念:用户与用户组◇ 用户与账户是同一概念,用于登录系统与区分资源权限◇ 用户让系统变的更安全,同时也保护了用户的个人数字资产 用户组◇ 用户组就是将用户分组,隶属用户自动拥有组权限◇ 一个用户可隶属于多个组,用户可任意切换当前组◇ 用户组的出现让用户权限管理变更轻松 用户与用户组常用命令◇分组：usermod -g [组名] [用户名]◇让用户拥有多个组： usermod -G [组名1],[组名2] [用户名];通过newgrp进行切换◇将用户连接系统: 打开-&gt;创建系统副本：然后用新建的用户密码登录◇groups #查看用户隶属于哪个组◇chown用法：chown [用户名]:[组名] [文件名] 项目内部文件权限管理实践文件权限代码表◇每个颜色表示一组，共三组；eg:drwxr-xr-x; 其中-代表没有对应属性，此处即没有w(完整的一组是rwx)◇在目录上r-x不允许写是指不准修改目录名 chmod命令◇ chmod 750: 组用户可读写，其他用户不允许访问◇ chmod 777: 所有用户拥有完整权限◇ chmod 700: 只有属主拥有完整权限◇chmod 750 dev-document/(文件名/) #示例操作， sudo超级管理员命令◇ sudo可以让普通用户拥有超级管理员的执行权限◇ 普通用户要进行经过超级管理员授权才能使用◇ 授权命令：visudo◇普通模式下输入：100gg 快速定位到100行,无法再屏幕上看到命令；在此处的root ALL-(ALL) ALL下增加一行：[用户名] ALL-(ALL) ALL 即可授权用户拥有sudo命令；第一个ALL代表用户可以从任意计算机进行连接；第二个ALL表示切换用户，最后一个ALL代表运行执行所有命令；◇:wq保存文件后，使用命令visudo -c进行文件的格式检查; CentOS7防火墙firewall什么是防火墙◇ 防火墙是借助硬件和软件对内外部网络环境的保护措施◇ CentOS 7基于firewall实现应用层防火墙,CentOS6基于iptables◇ firewall-cmd是firewall的核心命令 firwall-cmd◇ systemctl start|restart firewalld #启动防火墙◇ firewall-cmd –state | –reload #查看状态,重载防火墙◇ firewall-cmd –zone=public –permanent –add-port=8502/tcp 对外开放Tomcat◇解压apache-tomcat-9.0.34.tar.gz；进入apache-tomcat-9.0.34/bin目录启动startup.sh文件：./startup.sh◇增加放行端口：firewall-cmd –zone=public –permanent –add-port=8080/tcp #zone代表区域；permanent表示永久更改；将add改成remove即可去除端口;8000-9000可以用来进行端口范围的设置◇将防火墙进行重载 Bash Shell什么是Shellu Shell是一个用c语言编写的脚本解释器,是用户通过代码操作 Linux的桥梁u Shell脚本描述要执行的任务,完成系列复杂操作,文件通常以.sh后缀u Shell脚本通过Shell解释器执行,按解释器分类分为多种类型 Linux Shell 分类 一键发布Tomcat应用程序◇vim deploy_tomcat.sh创建脚本 12345678910echo &quot;准备下载Tomcat9&quot;wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.52/bin/apache-tomcat-9.0.52.tar.gzecho &quot;正在解压Tomcat9&quot;tar zxf apache-tomcat-9.0.52.tar.gzecho &quot;防火墙开放8080端口&quot;firewall-cmd --zone=public --permanent --add-port=8080/tcpfirewall-cmd --reloadecho &quot;启动Tomact&quot;cd ./apache-tomcat-9.0.52/bin./startup.sh ◇启动脚本文件：/bin/bash deploy_tomcat.sh;或./deploy.tomcat.sh 部署OA项目部署架构◇创建两个虚拟机CentosDB,CentosWEB，均最小化安装(不要图形界面);然后在界面输入: yum install -y net-tools.x86_64 #安装ifconfig等命令;◇使用Xshell进行远程连接； Centos安装MySQL8◇yum search mysql-community #查看是否安装了mysql社区版◇mkdir mysql #在/usr/local目录下新建目录存放mysql◇wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm #获取下载◇yum install -y wget #安装wget 命令◇yum localinstall -y mysql80-community-release-el7-3.noarch.rpm #从本地安装rpm文件◇以上只是安装了mysql的安装源，还没有完成mysql的安装；◇yum install -y mysql-community-server #进行安装 ctrl+c可以停止安装◇cd /var/cache/yum/x86_64/7/mysql80-community/packages/ #进入yum下载的缓存路径◇进入官网找到Mysql Red Hat Enterprise Linux/ Oracle Linux；选择系统版本Linux 7 X86_64； 下载RPM Bundle；然后将这一组rpm文件传到缓存路径中；此时重新执行yum install -y mysql-community-server命令；以此可解决跨国服务器下载缓慢问题；◇systemctl start mysqld #启动服务 systemctl status mysqld #查看服务状态◇systemctl enable mysqld #设置为开机启动 初始化MySQL8◇vi /var/log/mysqld.log #进入mysql日志 在第3~4行可以看到自动生成的密码◇mysql -uroot -p #输入密码进行登录◇alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘newpassword’(需要包含字母大小写以及数字，特殊符号，长度大于8位) 回车加上’;’ 即可修改，with mysql_native_password做与navicat的兼容考虑；◇默认的root用户只能从本机登录；use mysql #使用数据库； select host,user from user;#查询主机和用户◇update user set host=’%’ where user=’root’;#将root用户的host改为%,即任意设备都可以使用root用户连接mysql服务器; flush privileges #使刚才修改的权限立即生效◇exit #退出mysql◇放行3306端口并重载，使之能够远程访问mysql；◇打开Navicat，新建连接：主机即虚拟机的IP地址； 部署配置Web应用服务◇yum search jdk #查看仓库中包含哪些版本的jdk;openjdk表示开源jdk◇yum install -y java-1.8.0-openjdk #安装jdk◇java -version #查看◇安装Tomcat;◇将oa项目的war包传到虚拟机中，解压；◇将解压后的oa目录移动：mv lcg_oa ./apache-tomcat-9.0.34/webapps/◇进入webapps目录，vim ./lcg_oa/WEB-INF/classes/mybatis-config.xml(yum install vim-common#安装vim基础包，yum install vim-enhanced#安装增强包)◇/root全文查找，在连接字符串的地方进行调整；将localhost改为mysql服务器的IP地址，密码改为相应的密码◇回到上一层目录进行Tomcat的配置: vim ./conf/server.xml -&gt;搜索/8080-&gt;将端口改为80-&gt;按pagedown跳到最后-&gt;在Host标签上增加#将oa这个web应用映射的上下文路径指向根路径-&gt;:wq保存◇启动tomcat：./bin/startup.sh◇放行80端口，并重载◇在虚拟机DB中，屏蔽掉任意主机都能访问的3306端口；重载；◇firewall-cmd –permanent –zone=public –add-rich-rule=”rule family=”ipv4” source address=”web服务器的IP地址” port protocol=”tcp” port=”3306” accept” #-rich-rule利用规则放行端口，这样就能放行指定主机指定端口的访问;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux与Redis基础","slug":"Java数据库/Linux与Redis基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Linux%E4%B8%8ERedis%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://618dt.github.io/tags/Linux/"}],"author":"LCG"},{"title":"项目完整实现","slug":"项目实现","date":"2022-02-03T00:46:00.000Z","updated":"2022-02-21T14:23:00.910Z","comments":true,"path":"p/d371.html","link":"","permalink":"https://618dt.github.io/p/d371.html","excerpt":"","text":"动态显示功能菜单第一部分：实现底层◇sql语句 123456789101112-- 如何获取编号为 1的用户拥有哪些功能？SELECT DISTINCT n.* FROM sys_role_user ru, sys_role_node rn, sys_node n WHERE ru.role_id = rn.role_id AND rn.node_id = n.node_id AND user_id = 1 ORDER BY n.node_code ◇创建与数据库对应的Node节点类 123456789public class Node &#123; private Long nodeId; private Integer nodeType; private String nodeName; private String url; private Integer nodeCode; private Long parentId; ... &#125; ◇创建rbac.xml 1234567891011&lt;mapper namespace=&quot;rbacmapper&quot;&gt; &lt;!--获取用户编号对应的功能列表--&gt; &lt;select id=&quot;selectNodeByUserId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Node&quot;&gt; select distinct n.* from sys_role_user ru , sys_role_node rn , sys_node n where ru.role_id = rn.role_id and user_id = #&#123;value&#125; and rn.node_id = n.node_id order by n.node_code &lt;/select&gt;&lt;/mapper&gt; ◇创建dao对sql语句进行调用 1234567public class RbacDao &#123; public List&lt;Node&gt; selectNodeByUserId(Long userId) &#123; return (List)MybatisUtils.executeQuery( sqlSession -&gt; sqlSession.selectList( &quot;rbacmapper.selectNodeByUserId&quot;, userId)); &#125;&#125; ◇在UserService中进行dao的调用 12345private RbacDao rbacDao = new RbacDao();public List&lt;Node&gt; selectNodeByUserId(Long userId) &#123; List&lt;Node&gt; nodeList = rbacDao.selectNodeByUserId(userId); return nodeList; &#125; ◇进行测试 12345@Test public void selectNodeByUserId()&#123; List&lt;Node&gt; nodeList = userService.selectNodeByUserId(2l);//l表示长整型 System.out.println(nodeList); &#125; 第二部分：实现跳转◇更改LonginServlet增加返回项 1result.put(&quot;redirect_url&quot;, &quot;/index&quot;); ◇更改login.html用于接收新加的返回项 12//跳转urlwindow.location.href=json.redirect_url; ◇创建IndexServlet,并将index.html改为index.ftl 123456789101112131415@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)public class IndexServlet extends HttpServlet &#123; private UserService userService = new UserService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); User user = (User)session.getAttribute(&quot;login_user&quot;); List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId()); request.setAttribute(&quot;node_list&quot;,nodeList); request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request,response); &#125;&#125; ◇如何把在登录页面login的用户登录信息保存，并用于后面的功能区分？方法是使用范围更广的session对象即在LonginServlet中进行如下更改： 12345//调用业务逻辑User user = userService.checkLogin(username, password);HttpSession session = request.getSession();//向session存入登录用户信息,属性名:login_usersession.setAttribute(&quot;login_user&quot; , user); ◇修改index.ftl实现动态显示功能 123456789101112131415161718&lt;!--可折叠导航栏--&gt; &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt; &lt;#list node_list as node&gt; &lt;#if node.nodeType == 1&gt; &lt;!--父节点 模块 自定义属性：data-node-id--&gt; &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt; &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt; &lt;/li&gt; &lt;/#if&gt; &lt;#if node.nodeType == 2&gt; &lt;!--子节点 功能 自定义属性：data-parent-id--&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt; &lt;/dd&gt; &lt;/#if&gt; &lt;/#list&gt; &lt;/ul&gt; Xml配置下实现Mapper接口◇创建员工实体类 1234567public class Employee &#123; private Long employeeId; private String name; private Long departmentId; private String title; private Integer level;&#125; ◇创建dao接口 123public interface EmployeeDao &#123; public Employee selectById(Long employeeId);&#125; ◇创建mapper与接口对应 123456789... &lt;!--namespace与包名要一致--&gt;&lt;mapper namespace=&quot;com.lcg.oa.dao.EmployeeDao&quot;&gt; &lt;!--id与方法名对应 parameterType与方法参数类型一致 resultType与方法返回类型一致--&gt; &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Employee&quot;&gt; select * from adm_employee where employee_id = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; ◇创建员工service (getMapper的原理) 12345678910111213141516public class EmployeeService &#123; /** * 按编号查找员工 * @param employeeId 员工编号 * @return 员工对象，不存在时返回null */ public Employee selectById(Long employeeId) &#123; return (Employee) MybatisUtils.executeQuery(sqlSession-&gt;&#123; //匹配相关的Mapper,sql语句原理可网上搜getMapper //这里传入一个类对象后,就会得到一个可用的Dao接口 EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class); return employeeDao.selectById(employeeId); &#125;); &#125;&#125; ◇修改indexservlet 123456789101112131415161718192021222324@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)public class IndexServlet extends HttpServlet &#123; private UserService userService = new UserService(); private EmployeeService employeeService = new EmployeeService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); //得到当前登录用户对象 User user = (User)session.getAttribute(&quot;login_user&quot;); Employee employee = employeeService.selectById(user.getEmployeeId()); //获取登录用户可用功能模块列表 List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId()); //放入请求属性 request.setAttribute(&quot;node_list&quot;,nodeList); //放入session，范围更大,生命周期更长 session.setAttribute(&quot;current_employee&quot;,employee); //请求发至ftl进行展现 request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request,response); &#125;&#125; ◇修改首页 12&lt;!--用户信息--&gt;$&#123;current_employee.name&#125;[部门-$&#123;current_employee.title&#125;] ◇要想获取到部门，由于涉及到另外一张表，则按上面流程开发即可 基于MD5算法对密码进行加密MD5摘要算法◇MD5信息摘要算法广泛使用的密码散列函数◇MD5可以产生出一个128位的散列值用于唯一标识源数据◇项目中通常使用MD5作为敏感数据的加密算法 MD5特点◇压缩性,MD5生成的摘要长度固定◇抗修改,源数据哪怕有一个字节变化,MD5也会有巨大差异◇不可逆,无法通过MD5反向推算源数据 Apache Commons Codec◇Commons-Codec是Apache提供的编码/解码组件◇通过Commons-Codec可轻易生成源数据的MD5摘要◇MD5摘要方法: String md5 = DigestUtils.md5Hex(源数据)◇增加依赖并放入发布的工程中 使用方法◇增加依赖并放入发布的工程中 12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.14&lt;/version&gt;&lt;/dependency&gt; ◇新增工具类 12345public class MD5Utils &#123; public static String md5Digest(String source) &#123; return DigestUtils.md5Hex(source); &#125;&#125; ◇进行测试 1234@Testpublic void md5Digest() &#123; System.out.println(MD5Utils.md5Digest(&quot;test&quot;));&#125; 敏感数据”加盐”混淆◇防止MD5被通过穷举法解密◇加盐方法 123456789101112131415/** * 对源数据加盐混淆后生成MD5摘要 * @param source 源数据 * @param salt 盐值 * @return MD5摘要 */public static String md5Digest(String source, Integer salt) &#123; char[] ca = source.toCharArray();//字符数组 for (int i = 0; i &lt; ca.length; i++) &#123; ca[i] = (char)(ca[i] + salt); &#125; String target = new String(ca); String md5 = DigestUtils.md5Hex(target); return md5;&#125; ◇修改数据库sys_user表，添加salt字段,并将密码替换为加密后的MD5◇修改UserServlet 12345//对前台输入的密码加盐混淆后生成MD5，与保存在数据库中的MD5密码进行比对 String md5 = MD5Utils.md5Digest(password, user.getSalt()); if (!md5.equals(user.getPassword())) &#123; throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;); &#125; 实现注销功能◇即将保存在session中的用户登录信息清空◇创建servlet 1234567891011@WebServlet(name = &quot;LogoutServlet&quot;,urlPatterns = &quot;/logout&quot;)public class LogoutServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getSession().invalidate();//将当前会话清空 response.sendRedirect(&quot;/login.html&quot;); &#125;&#125; ◇修改index.ftl的注销按钮 12&lt;!--注销按钮--&gt; &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt; 开发多级审批流程请假流程 工作流程表设计 设计约束◇每一个请假单对应一个审批流程◇请假单创建后,按业务规则生成部门经理、总经理审批任务◇审批任务的经办人只能审批自己辖区内的请假申请◇所有审批任务”通过”,代表请假已经批准◇任意审批任务”驳回”操作,其余审批任务取消,请假申请被驳回◇请假流程中任意节点产生的操作都要生成对应的系统通知 新建数据库表◇请假单表◇处理流程表◇通知表 实现Dao与数据交互创建表的实体类◇LeaveForm.class◇ProcessFlow.class◇Notice.class 创建Dao接口◇LeaveFormDao 123456789public interface LeaveFormDao &#123; public void insert(LeaveForm form); public List&lt;Map&gt; selectByParams(@Param(&quot;pf_state&quot;) String pfState, @Param(&quot;pf_operator_id&quot;) Long operatorId); public LeaveForm selectById(Long formId); public void update(LeaveForm form);&#125; ◇ProcessFlowDao 1234567public interface ProcessFlowDao &#123; public void insert(ProcessFlow processFlow); public void update(ProcessFlow processFlow); public List&lt;ProcessFlow&gt; selectByFormId(Long formId);&#125; ◇NoticeDao 12345public interface NoticeDao &#123; public void insert(Notice notice); public List&lt;Notice&gt; selectByReceiverId(Long receiverId);&#125; 创建对应的mapper◇leave_form.xml 12345678&lt;mapper namespace=&quot;com.lcg.oa.dao.LeaveFormDao&quot;&gt; &lt;!--useGeneratedKeys是否使用自增主键；keyProperty实体中的主键；keyColumn数据库表中的主键--&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.oa.entity.LeaveForm&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;formId&quot; keyColumn=&quot;from_id&quot;&gt; INSERT INTO adm_leave_form( employee_id, form_type, start_time, end_time, reason, create_time, state) VALUES ( #&#123;employeeId&#125;, #&#123;formType&#125;, #&#123;startTime&#125;, #&#123;endTime&#125;, #&#123;reason&#125;, #&#123;createTime&#125;, #&#123;state&#125;) &lt;/insert&gt;&lt;/mapper&gt; ◇process_flow.xml 12345678910111213141516&lt;mapper namespace=&quot;com.lcg.oa.dao.ProcessFlowDao&quot;&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.oa.entity.ProcessFlow&quot; useGeneratedKeys=&quot;true&quot; keyColumn=&quot;process_id&quot; keyProperty=&quot;processId&quot;&gt; INSERT INTO adm_process_flow(form_id, operator_id, action, result, reason, create_time , audit_time , order_no , state,is_last) VALUES (#&#123;formId&#125;, #&#123;operatorId&#125;, #&#123;action&#125;, #&#123;result&#125;, #&#123;reason&#125;, #&#123;createTime&#125; , #&#123;auditTime&#125; , #&#123;orderNo&#125; , #&#123;state&#125; , #&#123;isLast&#125;); &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; UPDATE adm_process_flow SET form_id = #&#123;formId&#125;, operator_id = #&#123;operatorId&#125;, action = #&#123;action&#125;, result = #&#123;result&#125;, reason = #&#123;reason&#125;, create_time = #&#123;createTime&#125;, audit_time = #&#123;auditTime&#125;, order_no = #&#123;orderNo&#125;, state = #&#123;state&#125;, is_last = #&#123;isLast&#125; WHERE process_id = #&#123;processId&#125; &lt;/update&gt; &lt;select id=&quot;selectByFormId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; select * from adm_process_flow where form_id = #&#123;value&#125; order by order_no &lt;/select&gt;&lt;/mapper&gt; ◇notice.xml 12345678910&lt;mapper namespace=&quot;com.lcg.oa.dao.NoticeDao&quot;&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.oa.entity.Notice&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;noticeId&quot; keyColumn=&quot;notice_id&quot;&gt; INSERT INTO sys_notice( receiver_id, content, create_time) VALUES (#&#123;receiverId&#125;, #&#123;content&#125;, #&#123;createTime&#125;) &lt;/insert&gt; &lt;select id=&quot;selectByReceiverId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Notice&quot;&gt; select * from sys_notice where receiver_id = #&#123;value&#125; order by create_time desc limit 0,100 &lt;/select&gt;&lt;/mapper&gt; 开发请假申请功能前期准备◇EmployeeDao增加代码 123456/** * 根据传入员工对象获取上级主管对象 * @param employee 员工对象 * @return 上级主管对象 */ public Employee selectLeader(@Param(&quot;emp&quot;) Employee employee); ◇在employee.xml中增加对应的sql语句 12345678910111213&lt;select id=&quot;selectLeader&quot; parameterType=&quot;com.lcg.oa.entity.Employee&quot; resultType=&quot;com.lcg.oa.entity.Employee&quot;&gt; select * from adm_employee where &lt;if test=&quot;emp.level&amp;lt;7&quot;&gt; &lt;!--&#x27;&lt;&#x27;的转义--&gt; level = 7 and department_id = #&#123;emp.departmentId&#125; &lt;/if&gt; &lt;if test=&quot;emp.level == 7&quot;&gt; level = 8 &lt;/if&gt; &lt;if test=&quot;emp.level == 8&quot;&gt; employee_id = #&#123;emp.employeeId&#125; &lt;/if&gt; &lt;/select&gt; ◇新增业务常量，用来保存指定时间之类的数据 123public class BussinessConstants &#123; public static final int MANAGER_AUDIT_HOURS=36;//总经理请假审批时间阈值&#125; 创建service◇请假单流程服务LeaveFormService 12345678910111213141516public class LeaveFormService &#123; /** * 创建请假单 * * @param form 前端输入的请假单数据 * @return 持久化后的请假单对象 */ public LeaveForm createLeaveForm(LeaveForm form) &#123; //1.持久化form表单数据,8级以下员工表单状态为processing,8级(总经理)状态为approved //2.增加第一条流程数据,说明表单已提交,状态为complete //3.分情况创建其余流程数据 //3.1 7级以下员工,生成部门经理审批任务,请假时间大于72小时,还需生成总经理审批任务 //3.2 7级员工,生成总经理审批任务 //3.3 8级员工,生成总经理审批任务,系统自动通过 &#125;&#125; 创建控制器◇LeaveFormServlet 123456789101112131415161718192021222324252627@WebServlet(name = &quot;LeaveFormServlet&quot;,urlPatterns = &quot;/leave/*&quot;)public class LeaveFormServlet extends HttpServlet &#123; private LeaveFormService leaveFormService = new LeaveFormService(); private Logger logger = LoggerFactory.getLogger(LeaveFormServlet.class); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125; /** * 创建请假单 * @param request * @param response * @throws ServletException * @throws IOException */ private void create(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收各项请假单数据 ... //2. 调用业务逻辑方法 ... //3. 组织响应数据 ... &#125;&#125; 实现请假申请功能 ◇表单html文件部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; var layDate = layui.laydate; //Layui日期选择框JS对象 var layForm = layui.form; //layui表单对象 var $ = layui.$; //jQuery对象 //日期时间范围 layDate.render(&#123; elem: &#x27;#daterange&#x27; //表示将id为daterange的文本框渲染成日期选择框 ,type: &#x27;datetime&#x27; //日期+时间 ,range: true ,format: &#x27;yyyy年M月d日H时&#x27; ,done: function(value, start, end)&#123;//自动触发事件 //选择日期后出发的时间,设置startTime与endTime隐藏域,按照服务器要求的格式 var startTime = start.year + &quot;-&quot; + start.month + &quot;-&quot; + start.date + &quot;-&quot; + start.hours; var endTime = end.year + &quot;-&quot; + end.month + &quot;-&quot; + end.date + &quot;-&quot; + end.hours; console.info(&quot;请假开始时间&quot;,startTime); $(&quot;#startTime&quot;).val(startTime); console.info(&quot;请假结束时间&quot;,endTime); $(&quot;#endTime&quot;).val(endTime); &#125; &#125;); //表单提交时间,data.field由Layui提供可以获取表单所有数据，并封装成键值对 layForm.on(&#x27;submit(sub)&#x27;, function(data)&#123; console.info(&quot;向服务器提交的表单数据&quot;,data.field); $.post(&quot;/leave/create&quot;,data.field,function (json) &#123; console.info(json); if(json.code == &quot;0&quot;)&#123; /*SweetAlert2确定对话框*/ swal(&#123; type: &#x27;success&#x27;, html: &quot;&lt;h2&gt;请假单已提交,等待上级审批&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;).then(function (result) &#123;//点击确定后的触发事件 window.location.href=&quot;/forward/notice&quot;;//跳转到指定路径 &#125;); &#125;else&#123; swal(&#123; type: &#x27;warning&#x27;, html: &quot;&lt;h2&gt;&quot; + json.message + &quot;&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;); &#125; &#125;,&quot;json&quot;); return false; &#125;);&lt;/script&gt; ◇sweetalert官网,用来美化对话框◇新增控制器ForwardServlet，通用的页面跳转的servlet，可以支持跳转多个页面 123456789101112131415@WebServlet(name = &quot;ForwardServlet&quot;,urlPatterns = &quot;/forward/*&quot;)public class ForwardServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String uri = request.getRequestURI(); /** * /forward/form * /forward/a/b/c/form */ String subUri = uri.substring(1);// forward/form; forward/a/b/c/form String page = subUri.substring(subUri.indexOf(&quot;/&quot;));// /form; /a/b/c/form request.getRequestDispatcher(page+&quot;.ftl&quot;).forward(request,response); &#125;&#125; ◇将数据库node表的url填上◇修改index.ftl,将href改为${node.url} 1&lt;a href=&quot;$&#123;node.url&#125;&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt; 请假审批功能新增sql语句◇在leave_form.xml中新增查询，多个参数（工作流程任务状态；经办人）查询请假单，由于查询的字段来自不同的表，所以返回类型也是map而非某个实体类 12345678910&lt;select id=&quot;selectByParams&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;java.util.Map&quot;&gt; select f.* ,e.name , d.* from adm_leave_form f,adm_process_flow pf , adm_employee e , adm_department d where f.form_id = pf.form_id and f.employee_id = e.employee_id and e.department_id = d.department_id and pf.state = #&#123;pf_state&#125; and pf.operator_id = #&#123;pf_operator_id&#125;&lt;/select&gt; ◇在Dao中增加相应的接口对应 123//多个参数采用注解形式说明其在xml中的参数类型,名称须一致public List&lt;Map&gt; selectByParams(@Param(&quot;pf_state&quot;) String pfState, @Param(&quot;pf_operator_id&quot;) Long operatorId); 修改Service◇在LeaveFormService中新增方法用来获取请假单 12345678910111213/** * 获取指定任务状态及指定经办人对应的请假单列表 * @param pfState ProcessFlow任务状态 * @param operatorId 经办人编号 * @return 请假单及相关数据列表 */ public List&lt;Map&gt; getLeaveFormList(String pfState, Long operatorId) &#123; return (List&lt;Map&gt;) MybatisUtils.executeQuery(sqlSession-&gt;&#123; LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class); List&lt;Map&gt; formList = dao.selectByParams(pfState, operatorId); return formList; &#125;); &#125; ◇在Servlet中对service进行调用 12345678910111213141516171819202122232425if (methodName.equals(&quot;create&quot;)) &#123; this.create(request,response); &#125; else if (methodName.equals(&quot;list&quot;)) &#123; this.getLeaveFormList(request, response); &#125; /** * 查询需要审核的请假单列表 * @param request * @param response * @throws ServletException * @throws IOException */ private void getLeaveFormList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; User user = (User) request.getSession().getAttribute(&quot;login_user&quot;); List&lt;Map&gt; formList = leaveFormService.getLeaveFormList(&quot;process&quot;, user.getEmployeeId()); Map result = new HashMap(); //4个属性满足layUI数据表格的要求 result.put(&quot;code&quot;, &quot;0&quot;);//表示服务器端处理成功 result.put(&quot;msg&quot;, &quot;&quot;);//服务器返回的具体文本消息 result.put(&quot;count&quot;, formList.size());//所有数据的总数 result.put(&quot;data&quot;, formList);//显示的对象列表 String json = JSON.toJSONString(result); response.getWriter().println(json); &#125; 新增ftl文件用来审批◇部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;script&gt; var $ = layui.$; //将毫秒数转换为&quot;yyyy-MM-dd HH时&quot;字符串格式 function formatDate(time)&#123; var newDate = new Date(time); return newDate.getFullYear() + &quot;-&quot; + (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate() + &quot; &quot; + newDate.getHours() + &quot;时&quot;; &#125; // 将table渲染为数据表格 layui.table.render(&#123; elem : &quot;#grdFormList&quot; , //选择器 id : &quot;grdFormList&quot; , //id url : &quot;/leave/list&quot; , //ajax请求url page : false , //是否分页 true-是 false-否 cols :[[ //列描述 &#123;title : &quot;&quot; , width:70 , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;, // numbers代表序号列 &#123;field : &quot;create_time&quot; , title : &quot;申请时间&quot; , width : 150 , templet: function (d) &#123; //templet代表对数据进行加工后再显示 return formatDate(d.create_time) &#125;&#125;, &#123;field : &quot;form_type&quot; , title : &quot;类型&quot; , width : 100 , templet: function(d)&#123; switch (d.form_type) &#123; case 1: return &quot;事假&quot;; case 2: return &quot;病假&quot;; case 3: return &quot;工伤假&quot;; case 4: return &quot;婚假&quot;; case 5: return &quot;产假&quot;; case 6: return &quot;丧假&quot;; &#125; &#125;&#125;, &#123;field : &quot;department_name&quot; , title : &quot;部门&quot; , width : 100&#125;, &#123;field : &quot;name&quot; , title : &quot;员工&quot; , width : 100&#125;, &#123;field : &quot;start_time&quot; , title : &quot;起始时间&quot; , width : 150, templet: function (d) &#123; return formatDate(d.start_time) &#125;&#125;, &#123;field : &quot;end_time&quot; , title : &quot;结束时间&quot; , width : 150 , templet: function (d) &#123; return formatDate(d.end_time) &#125;&#125;, &#123;field : &quot;reason&quot; , title : &quot;请假原因&quot; , width : 350 &#125;, &#123;title : &quot;&quot; , width:150 ,type:&quot;space&quot; , templet : function(d)&#123; var strRec = JSON.stringify(d); console.info(&quot;请假单数据&quot;, strRec); //将请假单数据存放至data-laf属性中 return &quot;&lt;button class=&#x27;layui-btn layui-btn-danger layui-btn-sm btn-audit&#x27; data-laf=&quot; + strRec + &quot; &gt;审批&lt;/button&gt;&quot;; &#125;&#125; ]] &#125;) // 绑定每一行的审批按钮 $(document).on(&quot;click&quot; , &quot;.btn-audit&quot; , function()&#123; //初始化表单 $(&quot;#divDialog form&quot;)[0].reset(); $(&quot;#divDialog form form-item-value&quot;).text(&quot;&quot;); //获取当前点击按钮的请假单数据,回填至显示项 var laf = $(this).data(&quot;laf&quot;); $(&quot;#dname&quot;).text(laf.department_name); $(&quot;#name&quot;).text(laf.name); $(&quot;#startTime&quot;).text(formatDate(laf.start_time)); $(&quot;#endTime&quot;).text(formatDate(laf.end_time)); $(&quot;#reason&quot;).text(laf.reason); $(&quot;#formId&quot;).val(laf.form_id); //弹出layui对话框 layui.layer.open(&#123; type : &quot;1&quot; , //页面层 title : &quot;请假审批&quot; , //标题 content : $(&quot;#divDialog&quot;) , //指定对话框容器对象 area : [&quot;500px&quot; , &quot;400px&quot;] , //尺寸 end : function()&#123; //销毁后触发事件 $(&quot;#divDialog&quot;).hide(); &#125; &#125;) &#125;) /** * 提交审批数据 */ layui.form.on(&quot;submit(audit)&quot; , function(data)&#123; $.ajax(&#123; url : &quot;/leave/audit&quot;, //审核URL data : data.field , type : &quot;post&quot; , success: function (json) &#123; //关闭所有layui对话框 layui.layer.closeAll(); //显示处理结果 if(json.code == &quot;ok&quot;)&#123; swal(&#123; type: &#x27;success&#x27;, html: &quot;&lt;h2&gt;请假已审批完毕&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;).then(function (result) &#123; window.location.href=&quot;/forward/notice&quot;; &#125;); &#125;else&#123; swal(&#123; type: &#x27;warning&#x27;, html: &quot;&lt;h2&gt;&quot; + json.msg + &quot;&lt;/h2&gt;&quot;, confirmButtonText: &quot;确定&quot; &#125;); &#125; &#125; &#125;) return false; &#125;)&lt;/script&gt; ◇出现错误：Page template not found可能是ftl文件没有找到；解决方法：重启Tomcat或者将ftl文件删除后重新创建再重启Tomcat 实现审批业务逻辑审批流程可能出现的三种情况①需要总经理审批的，中间节点处理完成，并且部门经理审批通过，则后续节点reday-&gt;process②中间节点有驳回，则后续所有节点变为cancel③如果当前节点是最后一个，无论审批通过还是拒绝，执行完以后整个流程都会结束，所有节点状态都变为complete，同时表单状态变为处理结果 代码实现–在process_flow.xml中新增查询语句，通过FormId查询所有的处理表单数据，并且新增更新语句，用来更新任务状态 12345678&lt;update id=&quot;update&quot; parameterType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; UPDATE adm_process_flow SET form_id = #&#123;formId&#125;, operator_id = #&#123;operatorId&#125;, action = #&#123;action&#125;, result = #&#123;result&#125;, reason = #&#123;reason&#125;, create_time = #&#123;createTime&#125;, audit_time = #&#123;auditTime&#125;, order_no = #&#123;orderNo&#125;, state = #&#123;state&#125;, is_last = #&#123;isLast&#125; WHERE process_id = #&#123;processId&#125; &lt;/update&gt; &lt;select id=&quot;selectByFormId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.ProcessFlow&quot;&gt; select * from adm_process_flow where form_id = #&#123;value&#125; order by order_no &lt;/select&gt; –在接口中将刚才新增的两条查询语句的方法写上 123public LeaveForm selectById(Long formId);public void update(LeaveForm form); –在leave_form.xml在新增sql语句 1234567&lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt; select * from adm_leave_form where form_id = #&#123;value&#125; &lt;/select&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt; UPDATE adm_leave_form SET employee_id = #&#123;employeeId&#125; , form_type = #&#123;formType&#125;, start_time = #&#123;startTime&#125;, end_time = #&#123;endTime&#125;, reason = #&#123;reason&#125;, state = #&#123;state&#125; ,create_time = #&#123;createTime&#125; WHERE form_id = #&#123;formId&#125; &lt;/update&gt; –在LeaveForm中新增对应的方法 123public LeaveForm selectById(Long formId);public void update(LeaveForm form); –在LeaveFormService中新增方法，部分代码 123456789101112131415/** * 审核请假单 * @param formId 表单编号 * @param operatorId 经办人(当前登录员工) * @param result 审批结果 * @param reason 审批意见 */ public void audit(Long formId , Long operatorId , String result , String reason)&#123; MybatisUtils.executeUpdate(sqlSession-&gt;&#123; //1.无论同意/驳回，当前任务状态变更为complete //2.如果当前任务是最后一个节点，代表流程结束，更新请假单状态为对应的approve/refused //3.如果当前任务不是最后一个节点且审批通过，那下一个节点的状态：ready-&gt;process //4.如果当前任务不是最后一个节点且审批驳回，则后续所有任务状态变为cancel，请假单状态变为refused &#125;) &#125; 完整实现请假审批◇在LeaveFormServlet中新建方法用来处理审批操作 12345678910111213141516171819202122232425/** * 处理审批操作 * @param request * @param response * @throws ServletException * @throws IOException */ private void audit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String formId = request.getParameter(&quot;formId&quot;); String result = request.getParameter(&quot;result&quot;); String reason = request.getParameter(&quot;reason&quot;); User user = (User)request.getSession().getAttribute(&quot;login_user&quot;); Map mpResult = new HashMap(); try &#123; leaveFormService.audit(Long.parseLong(formId), user.getEmployeeId(), result, reason); mpResult.put(&quot;code&quot;, &quot;0&quot;); mpResult.put(&quot;message&quot;, &quot;success&quot;); &#125;catch(Exception e)&#123; logger.error(&quot;请假单审核失败&quot;,e); mpResult.put(&quot;code&quot;, e.getClass().getSimpleName()); mpResult.put(&quot;message&quot;, e.getMessage()); &#125; String json = JSON.toJSONString(mpResult); response.getWriter().println(json); &#125; ◇url绑定 123else if (methodName.equals(&quot;audit&quot;)) &#123; this.audit(request, response); &#125; ◇修改audit.ftl，新增dataType； 1234url : &quot;/leave/audit&quot;, //审核URL data : data.field , type : &quot;post&quot; , dataType :&quot;json&quot;, //服务器返回类型为json字符串 ◇将成功的判断条件由”ok”改为if(json.code == “0”){//0，代表成功，与后台一致◇将提示信息由html: **”“ **+ json.msg + ““,改为 json.**message ** 开发系统通知功能创建系统消息◇消息的触发时机：①当员工提交请假申请时；②当请假流程中间节点发生变化时◇部分代码–请假申请时 123456789 //String.format用于输出指定格式的字符串 String noticeContent = String.format(&quot;您的请假申请[%s-%s]已提交，请等待上机审批.&quot; ,sdf.format(form.getStartTime()), sdf.format(form.getEndTime()));noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));//存放数据库//通知部门经理审批noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot; ,employee.getTitle(),employee.getName(),sdf.format(form.getStartTime()) ,sdf.format(form.getEndTime())); noticeDao.insert(new Notice(dmanger.getEmployeeId(),noticeContent)); –审批直接完成时 12345678910111213141516171819202122232425262728//2.如果当前任务是最后一个节点，代表流程结束，更新请假单状态为对应的approve/refusedLeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);LeaveForm form = leaveFormDao.selectById(formId);SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH时&quot;);EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);Employee employee = employeeDao.selectById(form.getEmployeeId());//表单提交人信息Employee operator = employeeDao.selectById(operatorId);//任务经办人信息NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);if (process.getIsLast() == 1) &#123; form.setState(result);//approve|refused leaveFormDao.update(form); String strResult = null; if (result.equals(&quot;approve&quot;)) &#123; strResult = &quot;批准&quot;; &#125; else if (result.equals(&quot;refused&quot;)) &#123; strResult = &quot;驳回&quot;; &#125; String noticeContent = String.format(&quot;您的请假申请[%s-%s]%s%s已%s,审批意见:%S,审批流程已结束&quot; ,sdf.format(form.getStartTime()), sdf.format(form.getEndTime()) ,operator.getTitle(),operator.getName(),strResult,reason);//发给表单提交人的通知 noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent)); //发给审批人的通知 noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s]您已%s,审批意见:%s,审批流程已结束&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), strResult , reason); noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent)); –审批还需要总经理处理时 1234567891011121314151617181920212223242526272829303132333435363738394041424344//3.如果当前任务不是最后一个节点且审批通过 if (result.equals(&quot;approved&quot;)) &#123;//消息1: 通知表单提交人,部门经理已经审批通过,交由上级继续审批String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已批准,审批意见:%s ,请继续等待上级审批&quot; , sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()), operator.getTitle() , operator.getName(),reason);noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));//消息2: 通知总经理有新的审批任务String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()));noticeDao.insert(new Notice(readyProcess.getOperatorId(),noticeContent2));//消息3: 通知部门经理(当前经办人),员工的申请单你已批准,交由上级继续审批String noticeContent3 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已批准,审批意见:%s,申请转至上级领导继续审批&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason);noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent3)); &#125;else if(result.equals(&quot;refused&quot;)) &#123; //4.如果当前任务不是最后一个节点且审批驳回 for(ProcessFlow p:readyList)&#123; p.setState(&quot;cancel&quot;); processFlowDao.update(p); &#125; form.setState(&quot;refused&quot;); leaveFormDao.update(form); //消息1: 通知申请人表单已被驳回 String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已驳回,审批意见:%s,审批流程已结束&quot; , sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()), operator.getTitle() , operator.getName(),reason); noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1)); //消息2: 通知经办人表单&quot;您已驳回&quot; String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已驳回,审批意见:%s,审批流程已结束&quot; , employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason); noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent2)); &#125; 显示系统消息◇在notice.xml中新增查询语句 123&lt;select id=&quot;selectByReceiverId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.lcg.oa.entity.Notice&quot;&gt; select * from sys_notice where receiver_id = #&#123;value&#125; order by create_time desc limit 0,100 &lt;/select&gt; ◇在dao中进行定义 1public List&lt;Notice&gt; selectByReceiverId(Long receiverId); ◇新增NoticeService 12345678910111213141516/** * 消息服务 */public class NoticeService &#123; /** * 查询指定员工的系统消息 * @param receiverId * @return 最近100条消息列表 */ public List&lt;Notice&gt; getNoticeList(Long receiverId)&#123; return (List)MybatisUtils.executeQuery(sqlSession -&gt; &#123; NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class); return noticeDao.selectByReceiverId(receiverId); &#125;); &#125;&#125; ◇创建NoticeServlet向客户端返回数据 123456789101112131415161718192021@WebServlet(name = &quot;NoticeServlet&quot; , urlPatterns = &quot;/notice/list&quot;)public class NoticeServlet extends HttpServlet &#123; private NoticeService noticeService = new NoticeService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; User user = (User)request.getSession().getAttribute(&quot;login_user&quot;); List&lt;Notice&gt; noticeList = noticeService.getNoticeList(user.getEmployeeId()); Map result = new HashMap&lt;&gt;(); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;&quot;); result.put(&quot;count&quot;, noticeList.size()); result.put(&quot;data&quot;, noticeList); String json = JSON.toJSONString(result); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(json); &#125;&#125; ◇notice.ftl页面部分代码 12345678910111213141516171819&lt;script&gt; layui.table.render(&#123; elem : &quot;#grdNoticeList&quot; , id : &quot;grdNoticeList&quot; , url : &quot;/notice/list&quot; ,//请求数据的地址 page : false , cols :[[ &#123;field : &quot;&quot; , title : &quot;序号&quot; , width:&quot;10%&quot; , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;, &#123;field : &quot;create_time&quot; , title : &quot;通知时间&quot; , width : &quot;20%&quot; , templet: function (d) &#123; var newDate = new Date(d.createTime); return newDate.getFullYear() + &quot;-&quot; + (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate() + &quot; &quot; + newDate.getHours() + &quot;:&quot; + newDate.getMinutes() + &quot;:&quot; + newDate.getSeconds(); &#125;&#125;, &#123;field : &quot;content&quot; , title : &quot;通知内容&quot; , width : &quot;60%&quot;&#125; ]] &#125;)&lt;/script&gt; ◇修改index.ftl使用户一登录就能看到通知消息，即将首页内置框架绑定到notice上 1234&lt;!--主体部分采用iframe嵌入其他页面--&gt; &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt; &lt;iframe name=&quot;ifmMain&quot; src=&quot;/forward/notice&quot; style=&quot;...&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"OA系统项目","slug":"Java数据库/OA系统项目","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/OA%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"项目介绍及基础实现","slug":"项目介绍","date":"2022-02-03T00:44:00.000Z","updated":"2022-02-21T14:20:25.388Z","comments":true,"path":"p/2f49.html","link":"","permalink":"https://618dt.github.io/p/2f49.html","excerpt":"","text":"课程介绍◇需求说明与环境准备◇开发基于RABC的访问控制模块◇开发多级请假审批流程 办公自动化OA系统◇办公自动化系统(Office Automation)是替代传统办公的解决方案◇OA系统是利用软件技术构建的单位内部办公平台,用于辅助办公◇利用OA系统可将办公数据数字化,可极大提高办公流程执行效率 需求介绍◇慕课办公OA系统要求采用多用户B/S架构设计开发◇HR为每一位员工分配系统账户,员工用此账户登录系统◇公司采用分级定岗,从1-8依次提升,不同岗位薪资水平不同◇6级(含)以下员工为业务岗,对应人员执行公司业务事宜◇7-8级为管理岗,其中7级为部门经理,8级为总经理◇业务岗与管理岗员工可用系统功能不同,要求允许灵活配置 需求介绍-请假流程◇公司所有员工都可以使用”请假申请”功能申请休假◇请假时间少于72小时,部门经理审批后直接通过◇请假时间大于72小时,部门经理审批后还需总经理进行审批◇部门经理只允许批准本部门员工申请◇部门经理请假需直接由总经理审批◇总经理提起请假申请,系统自动批准通过 搭建基础架构框架&amp;组件◇MySQL 8 ◇Mybatis 3.5◇Alibaba Druid ◇Servlet 3.1◇Freemarker 2.3 ◇LayUI 2.5 搭建数据库◇新建数据库lcg-oa，字符集选择utf8m4，排序规则默认 创建Maven工程◇新建maven项目oa，JDK选择1.8◇进行工程设置以便将项目发布到服务器上：File-&gt;Project Structure-&gt;Modules-&gt;+-&gt;Web-&gt;Path:改为oa\\src\\main\\webapp\\WEB-INF\\web.xml;version:3.1; Web Resource Directory:选中webapp目录-&gt;Create Artifact-&gt;OK◇配置Tomcat:在工具栏上点击Add Configuration-&gt;+-&gt;Tomcat Server-&gt;Local(用本地的Tomcat来运行)-&gt;勾选After lanuch自动打开浏览器-&gt;HTTP port :80-&gt;Deployment(运行部署配置)-&gt;+-&gt;Artifact-&gt;Application context(应用上下文):/ -&gt;Apply-&gt;OK-&gt;下方为弹出Web面板 配置文件◇pom.xml配置 123456789101112131415161718192021222324252627282930313233343536//使用阿里云镜像仓库提高下载速度 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;//项目依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; //阿里巴巴连接池 &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; //单元测试 &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; //集成日志 &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ◇mybatis核心配置文件：在resource目录下创建mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;!--开发环境配置--&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;!--事务管理器采用JDBC方式--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--利用Mybatis自带连接池管理连接 &lt;dataSource type=&quot;POOLED&quot;&gt;--&gt; &lt;!--MyBatis与Druid的整合--&gt; &lt;dataSource type=&quot;com.lcg.oa.datasource.DruidDataSourceFactory&quot;&gt; &lt;!--JDBC连接属性--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; //连接字符串lcg-oa是数据库名 value=&quot;jdbc:mysql://localhost:3306/lcg-oa ? useSSL=false&amp;amp; useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp; serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;www.LCG.com&quot;/&gt; &lt;!--连接池初始连接数--&gt; &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt; &lt;!--连接池最大连接数--&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; ◇java目录下创建com.lcg.oa.utils.MybatisUtils工具类用于对Mybatis进行加载，SessionFactory对象的创建等初始化工作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.Reader;import java.util.function.Function;public class MybatisUtils &#123; //利用static(静态)属于类不属于对象,且全局唯一 private static SqlSessionFactory sqlSessionFactory = null; //利用静态块在初始化类时实例化sqlSessionFactory static&#123; Reader reader = null; try&#123; reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125;catch(IOException e)&#123; //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者 throw new ExceptionInInitializerError(e); &#125; &#125; /** * 执行SELECT查询SQL * @param func 要执行查询语句的代码块 * @return 查询结果 *具体的查询交给Function实现，在进行查询之前对sqlSession进行了打开和自动关闭 *Function&lt;T,R&gt;函数式接口，对应一个输入且需要返回数据的功能代码 */ public static Object executeQuery(Function&lt;SqlSession,Object&gt; func)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; //apply方法用于返回函数执行的结果 Object obj = func.apply(sqlSession); return obj; &#125;finally &#123; sqlSession.close(); &#125; &#125; /** * 执行INSERT/UPDATE/DELETE写操作SQL * @param func 要执行的写操作代码块 * @return 写操作后返回的结果 */ public static Object executeUpdate(Function&lt;SqlSession,Object&gt; func)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(false); try &#123; Object obj = func.apply(sqlSession); sqlSession.commit(); return obj; &#125;catch (RuntimeException e)&#123; sqlSession.rollback(); throw e; &#125;finally&#123; sqlSession.close(); &#125; &#125;&#125; ◇解决问题；函数式接口需要jdk1.8版本以上，但maven中统一按照1.5版本进行编译，因此需要在pom.xml配置文件中进行相关设置；在build块中，用于描述当前程序构建的各种细节；在build块中对maven的编译插件进行设置 1234567891011121314151617&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!--利用Maven编译插件将编译级别提高至1.8,解决lambda表达式错误--&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;!--maven-compiler-plugin是Maven自带的编译插件--&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;configuration&gt; &lt;!--检查源码采用1.8规则,默认为1.5--&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!--按1.8规则生成字节码--&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ◇mybatis执行sql的时候要有对应的mapper.xml文件，并且在核心配置文件(mybatis-config.xml)中进行配置；在resource目录下创建mappers目录用于存放此类文件，在其中创建一个test.xml文件进行测试 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;sample&quot; resultType=&quot;String&quot;&gt; select &#x27;success&#x27; //不从任何表中获取数据，只是返回success字符串 &lt;/select&gt;&lt;/mapper&gt;//核心配置文件配置 &lt;mappers&gt; &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt; &lt;/mappers&gt;//测试类进行测试，引用lambada表达式public class MybatisUtilsTestor &#123; @Test public void testcase1()&#123; String result = (String)MybatisUtils.executeQuery(sqlSession-&gt;&#123; String out = (String)sqlSession.selectOne(&quot;test.sample&quot;); return out; &#125;); System.out.println(result); &#125; @Test public void testcase2()&#123; String result = (String) MybatisUtils.executeQuery( sqlSession -&gt; sqlSession.selectOne(&quot;test.sample&quot;)); System.out.println(result); &#125;&#125; 连接池设置◇oa目录下创建子包datasource，在其下创建类DruidDataSourceFactory(数据源工厂类)◇执行顺序：首先通过构造方法创建空的数据源对象，然后调用setProperties方法读取xml文件并对刚才实例化的数据源进行属性设置；如果在获取数据源的时候必须要进行额外操作，则应重写getDataSource方法 1234567891011121314151617181920212223242526import com.alibaba.druid.pool.DruidDataSource;import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;import javax.sql.DataSource;import java.sql.SQLException;public class DruidDataSourceFactory extends UnpooledDataSourceFactory &#123; public DruidDataSourceFactory()&#123; this.dataSource = new DruidDataSource(); &#125; /** * DataSource是javax.sql包提供的接口，用来说明所有的数据源都要实现这个接口 * DruidDataSource当然也实现了这个接口；这样，当需要更换数据库连接池时，只需要 * 实例化不同的DataSource实现类即可 * */ @Override//进行重写代码：code-&gt;override 是否进行重写视连接池的类型而定 public DataSource getDataSource() &#123; try &#123; ((DruidDataSource)this.dataSource).init();//初始化Druid数据源 &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; return this.dataSource; &#125;&#125; 整合Freemarker◇pom.xml增加依赖 1234567891011121314&lt;!--Freemarker依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.29&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet-api--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!--依赖只参与编译测试,不进行发布--&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; ◇web.xml进行配置servlet 12345678910111213141516171819&lt;servlet&gt; &lt;!--FreemakrerServlet用于读取解析ftl文件--&gt; &lt;servlet-name&gt;freemakrer&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;!-- 定义模板的存储路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--default_encoding用于设置读取ftl文件时采用的字符集,进而避免中文乱码的产生--&gt; &lt;param-name&gt;default_encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemakrer&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ◇在WEB-INF目录下创建ftl目录，然后将test.html移入并改为test.ftl (freemarker脚本) 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;LCG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;result&#125;&lt;/h1&gt;//数据库查询结果&lt;/body&gt;&lt;/html&gt; ◇在com.lcg.oa.test下创建一个TestServlet 123456789101112@WebServlet(name = &quot;TestServlet&quot;,urlPatterns = &quot;/test&quot;)//映射地址public class TestServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String result = (String)MybatisUtils.executeQuery(sqlSession-&gt;sqlSession.selectOne(&quot;test.sample&quot;)); request.setAttribute(&quot;result&quot;,request); //请求转发 request.getRequestDispatcher(&quot;test.ftl&quot;).forward(request,response); &#125;&#125; ◇在运行测试前还需进行相关设置：File-&gt;Project Structure-&gt;Artifacts-&gt;将右侧Maven资源全选右键-&gt;Put into-&gt;OK◇配置日志文件logback.xml 开发基于RBAC的权限控制模块RBAC-基于角色的访问控制◇Role-Based Access Control◇基于角色权限控制(RBAC)是面向企业安全策略的访问控制方式◇RBAC核心思想是将控制访问的资源(功能或者特定资料等)与角色(Role)进行绑定◇系统的用户(User)与角色(Role)再进行绑定,用户便拥有对应权限 RBAC底层设计 创建数据库表◇角色表，表名：模块名_具体表名 sys_role◇资源表sys_node◇关联表sys_role_node ◇其他表的创建(此处省略) 基于LayUI开发登录页LayUI前端框架◇官方网站◇在webapp目录下创建resources文件夹(用来存放web应用所有相关的引用资源) 将layui文件夹粘贴到其下 开发登录页面◇在webapp目录下新建login.html◇进行项目热部署：Tomcat-&gt;Edit Configurations-&gt;On ‘Update’ action:改为Update classes and resources-&gt;ok然后按shift+F9就能进行热部署了 开发后台与数据库交互◇创建实体类User◇创建sql语句的xml文件user.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;usermapper&quot;&gt; &lt;select id=&quot;selectByUsername&quot; parameterType=&quot;String&quot; resultType=&quot;com.lcg.oa.entity.User&quot;&gt; select * from sys_user where username = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; ◇每次增加mapper后必须到mybatis-config中进行配置 1&lt;mapper resource=&quot;mappers/user.xml&quot;/&gt; ◇创建dao完成与user表的交互 123456789101112public class UserDao &#123; /** * 按用户名查询用户表 * @param username 用户名 * @return User对象包含对应的用户信息,null则代表对象不存在 */ public User selectByUsername(String username)&#123; User user = (User)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;usermapper.selectByUsername&quot; , username)); return user; &#125;&#125; ◇创建Service 123456789101112131415161718192021public class UserService &#123; private UserDao userDao =new UserDao();//记得实例化，否则出现空指针异常 /** * 根据前台输入进行登录校验 * @param username 前台输入的用户名 * @param password 前台输入的密码 * @return 校验通过后,包含对应用户数据的User实体类 * @throws BussinessException L001-用户名不存在,L002-密码错误 */ public User checkLogin(String username,String password)&#123; User user = userDao.selectByUsername(username); if (user == null) &#123; //抛出用户不存在异常 throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;); &#125; if (!password.equals(user.getPassword())) &#123; throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;); &#125; return user; &#125;&#125; ◇自定义异常 123456789101112131415161718192021222324252627282930/** * 业务逻辑异常，继承自运行时异常 */public class BussinessException extends RuntimeException &#123; private String code;//异常编码，异常的以为标识 private String message;//异常的具体文本消息 public BussinessException(String code, String msg) &#123; super(code + &quot;:&quot; + msg); this.code=code; this.message=msg; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; ◇箭头指向需要测试的类名，Ctrl+Shift+T 生成测试用例类，将需要测试的方法进行勾选◇空指针异常：在出错代码处做一个断点，可以找出具体哪个对象为空，有时候出现空指针可能是对象没有实例化，在创建时new 类名()即可; 与前台联通◇创建控制器controller 1234567891011121314151617181920212223242526272829303132333435363738394041@WebServlet(name = &quot;LoginServlet&quot;, urlPatterns = &quot;/check_login&quot;)public class LoginServlet extends HttpServlet &#123; //日志文件 LoginServlet.class即LoginServlet类的类对象;(对象有实例对象和类对象两种) Logger logger = LoggerFactory.getLogger(LoginServlet.class); private UserService userService = new UserService(); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); //接收用户输入 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //保存输出的内容 Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); try &#123; //调用业务逻辑 User user = userService.checkLogin(username, password); //返回项 result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;message&quot;, &quot;success&quot;); &#125; catch (BussinessException e) &#123; logger.error(e.getMessage(), e); result.put(&quot;code&quot;, e.getCode()); result.put(&quot;message&quot;, e.getMessage()); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); //由于系统自带异常没有code，用e.getClass().getSimpleName()得到的类名来充当 result.put(&quot;code&quot;, e.getClass().getSimpleName()); result.put(&quot;message&quot;, e.getMessage()); &#125; //返回对应结果 String json = JSON.toJSONString(result); response.getWriter().println(json);//向客户端返回 &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; ◇pom.xml加载fastjson依赖，并加入发布的项目中 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; ◇修改login.html文件增加提交数据功能 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=&quot;oa-container&quot;&gt; &lt;h1 style=&quot;text-align: center;margin-bottom: 20px&quot;&gt;交通控股办公OA系统&lt;/h1&gt; &lt;form class=&quot;layui-form&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; lay-verify=&quot;required&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; lay-verify=&quot;required&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;!--lay-filter即layui专属的id，autocomple表示是否显示历史输入--&gt; &lt;button class=&quot;layui-btn layui-btn-fluid&quot; lay-submit lay-filter=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 表单提交事件 /*on代表捕捉事件，里面参数为submit即提交事件，login表示绑定哪个提交按钮才会触发这段代码*/ layui.form.on(&quot;submit(login)&quot; , function(formdata)&#123;//data参数包含了当前表单的数据 console.log(formdata); //发送ajax请求进行登录校验 layui.$.ajax(&#123; url : &quot;/check_login&quot;, data : formdata.field, //提交表单数据 type : &quot;post&quot;, dataType : &quot;json&quot; , success : function(json)&#123; console.log(json); if(json.code == &quot;0&quot;)&#123; //登录校验成功 layui.layer.msg(&quot;登录成功&quot;); &#125;else&#123; layui.layer.msg(json.message); &#125; &#125; &#125;) return false;//submit提交事件返回true则表单提交,false则阻止表单提交 &#125;)&lt;/script&gt; 开发功能首页12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;交通控股OA系统&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;&lt;/head&gt;&lt;body class=&quot;layui-layout-body&quot;&gt;&lt;!-- Layui后台布局CSS --&gt;&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt; &lt;!--头部导航栏--&gt; &lt;div class=&quot;layui-header&quot;&gt; &lt;!--系统标题--&gt; &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;交通控股OA系统&lt;/div&gt; &lt;!--右侧当前用户信息--&gt; &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt; &lt;li class=&quot;layui-nav-item&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt; &lt;!--图标--&gt; &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt; &lt;/span&gt; &lt;!--用户信息--&gt; 姓名[部门-职务] &lt;/a&gt; &lt;/li&gt; &lt;!--注销按钮--&gt; &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--左侧菜单栏--&gt; &lt;div class=&quot;layui-side layui-bg-black&quot;&gt; &lt;!--可滚动菜单--&gt; &lt;div class=&quot;layui-side-scroll&quot;&gt; &lt;!--可折叠导航栏--&gt; &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt; &lt;!--父节点--&gt; &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;模块1&lt;/a&gt; &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;1&quot;&gt;&lt;/dl&gt; &lt;/li&gt; &lt;!--子节点--&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能1&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能2&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt; &lt;/dd&gt; &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;模块2&lt;/a&gt; &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;2&quot;&gt;&lt;/dl&gt; &lt;/li&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能4&lt;/a&gt; &lt;/dd&gt; &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能5&lt;/a&gt; &lt;/dd&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--主体部分采用iframe嵌入其他页面--&gt; &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt; &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;!--版权信息--&gt; &lt;div class=&quot;layui-footer&quot;&gt; Copyright © gamest. All Rights Reserved. &lt;/div&gt;&lt;/div&gt;&lt;!--LayUI JS文件--&gt;&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //将所有功能根据parent_id移动到指定模块下 layui.$(&quot;.function&quot;).each(function () &#123; var func = layui.$(this); var parentId = func.data(&quot;parent-id&quot;); layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func); &#125;) //刷新折叠菜单 layui.element.render(&#x27;nav&#x27;);&lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"OA系统项目","slug":"Java数据库/OA系统项目","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/OA%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"MyBaits进阶","slug":"MyBatis进阶","date":"2022-02-03T00:39:00.000Z","updated":"2022-02-21T14:13:09.503Z","comments":true,"path":"p/fb2c.html","link":"","permalink":"https://618dt.github.io/p/fb2c.html","excerpt":"","text":"MyBatis日志管理什么是日志◇日志文件是用于记录系统操作事件的记录文件或文件集合◇日志保存历史数据,是诊断问题以及理解系统活动的重要依据 SLF4j与Logback 代码示例​◇配置依赖 12345&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; ◇产生的日志(部分) 12320:53:41.109 [main] DEBUG goods.selectByTitle - ==&gt; Preparing: select * from t_goods where title = ? order by title desc 20:53:41.131 [main] DEBUG goods.selectByTitle - ==&gt; Parameters: &#x27;&#x27; or 1=1 or title=&#x27;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#x27;(String)20:53:41.298 [main] DEBUG goods.selectByTitle - &lt;== Total: 0 ◇自定义日志格式：在resource目录新建logback.xml文件 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!--ConsoleAppender是指在控制台输出日志 pattern指定日志输出格式，示例格式即 线程，时间，按5个字符右对齐，说明哪个类产生的日志(最多36字符超过压缩)，具体日志内容 换行 --&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 日志输出级别(优先级高到低): error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序运行的跟踪信息 --&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; MyBatis动态SQL ◇动态SQL是指根据参数数据动态组织SQL的技术 1234567891011&lt;select id=&quot;dynamicSQL&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com..Goods&quot;&gt;select * from t_goods&lt;where&gt;&lt;if test=&quot;categoryId != null&quot;&gt;and category_id = #&#123;categoryId&#125;&lt;/if&gt;&lt;if test=&quot;currentPrice != null&quot;&gt;and current_price &amp;lt; #&#123;currentPrice&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; ◇示例代码 12345678910111213141516171819202122232425262728293031323334&lt;select id=&quot;dynamicSQL&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods &lt;where&gt; &lt;if test=&quot;categoryId != null&quot;&gt; and category_id = #&#123;categoryId&#125; &lt;/if&gt; &lt;if test=&quot;currentPrice != null&quot;&gt; and current_price &amp;lt; #&#123;currentPrice&#125; //小于号转义符 &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; @Test public void testDynamicSQL() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Map param = new HashMap(); param.put(&quot;categoryId&quot;, 44); param.put(&quot;currentPrice&quot;, 500); //查询条件 List&lt;Goods&gt; list = session.selectList(&quot;goods.dynamicSQL&quot;, param); for(Goods g:list)&#123; System.out.println(g.getTitle() + &quot;:&quot; + g.getCategoryId() + &quot;:&quot; + g.getCurrentPrice()); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; MyBatis二级缓存缓存简介◇我们从数据库中查询到某一条数据后，因为业务的要求还需要这条数据，那么按照原始的方法就还需要在数据库中查询到该数据；因为MySql是将数据存放在硬盘上的，而硬盘的读取访问速度不是特别快；而且我们这里第一次获取和第二次获取记录的时候，都返回相同的数据；因此我们可以在第一次查询数据时，将该数据暂时保存到内存的某一个区域中，第二次查询时直接从内存的对应区域取出即可，因为内存的访问速度快，这样就能够提高查询的速度；在Mybatis中存在了两级缓存；◇ 一级缓存默认开启,缓存的数据范围为SqlSession会话，即在一次SqlSession会话中，对数据库中的某个数据进行重复读取，Mybatis就会利用到这个缓存来提高程序的处理速度；◇ 二级缓存手动开启,属于范围Mapper Namespace ，范围比SqlSession大的多； 缓存的范围 二级缓存运行规则◇二级开启后默认所有查询操作均使用缓存◇写操作使用commit提交时对该namespace缓存强制清空，保证商品一致性；如第一个用户查询到商品，而第二个用户将此商品名称改了，那么这时候就会将namespace缓存强制清空，第一个用户再次查询该商品时就得从数据库中获取了；◇配置useCache=false可以不用缓存◇在某一sql语句中配置flushCache=true代表执行完该sql语句后强制清空缓存◇代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//测试一级缓存 @Test public void testLv1Cache() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); //这里执行了两次sql查询，由于使用了缓存，所以在日志中可以看到只打印出一条sql语句 Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); Goods goods1 = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode() + &quot;:&quot; + goods1.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session);//关闭了会话 &#125; try&#123; session = MyBatisUtils.openSession(); //由于前面关闭了会话，这里是新的会话，需要对数据库进行查询 Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); session.commit();//commit提交时对该namespace缓存强制清空 //由于前面对缓存进行了强制清空，所以还需要访问数据库 Goods goods1 = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode() + &quot;:&quot; + goods1.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; //测试二级缓存 //在mapper标签下添加cache标签&lt;!--开启了二级缓存 eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除 1.LRU – 最近最久未使用:移除最长时间不被使用的对象。 O1 O2 O3 O4 .. O512 14 99 83 1 893 2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 3.SOFT – 软引用:移除基于垃圾收集器状态和软引用规则的对象。 4.WEAK – 弱引用:更积极的移除基于垃圾收集器状态和弱引用规则的对象。 5.LFU - 最近最少使用：移除最近访问频率最低的对象 flushInterval代表间隔多长时间自动清空缓存，单位毫秒，600000毫秒为10分钟 --&gt; &lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;600000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; @Test public void testLv2Cache() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; try&#123; //这里虽然是新的会话，但是由于是二级缓存，所以还是可以从内存中提取数据； session = MyBatisUtils.openSession(); Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.hashCode()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇缓存标签的属性：eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除 1.LRU – 最近最久未使用:移除最长时间不被使用的对象。 O1 O2 O3 O4 .. O512 14 99 83 1 893 2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 3.SOFT – 软引用:移除基于垃圾收集器状态和软引用规则的对象。 4.WEAK – 弱引用:更积极的移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval代表间隔多长时间自动清空缓存，单位毫秒size 缓存存储上限，用于保存对象或集合(1个集合算1个对象)的数量上限readOnly 设置为true，代表返回只读缓存，每次从缓存取出的是缓存对象本身，这种执行效率较高 设置为false，代表每次取出的是缓存对象的”副本”，每一次取出的对象都是不同的，这种安全性较高◇一些缓存相关的属性：useCache=”false”代表查询结果不被放入缓存，常用于读取全部数据的SQL语句中执行完insert语句需要立即清空缓存，flushCache=”true”在sql执行后强制清空缓存 MyBatis多表级联查询实体关系分析 商品和详情对象关联查询一对多◇增加实体类GoodsDetail 123456public class GoodsDetail &#123; private Integer gdId; private Integer goodsId; private String gdPicUrl; private Integer gdOrder;&#125; ◇配置 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;goodsDetail&quot;&gt; &lt;select id=&quot;selectByGoodsId&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.lcg.mybatis.entity.GoodsDetail&quot;&gt; select * from t_goods_detail where goods_id = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; ◇表达一个Goods对象有多个GoodsDetail对象：在Goods类中增加**private **List goodsDetails;◇Goods.xml中 1234567891011121314151617181920&lt;!-- resultMap可用于说明一对多或者多对一以及多表查询(前面学过)的映射逻辑 id 是resultMap属性引用的标志,需要和其他resultMap区分开 type 在一对多的关系中指向One的实体(Goods)--&gt;&lt;resultMap id=&quot;rmGoods1&quot; type=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; &lt;!-- 映射goods对象的主键到goods_id字段 --&gt; &lt;id column=&quot;goods_id&quot; property=&quot;goodsId&quot;&gt;&lt;/id&gt; &lt;!-- collection(集合)专用于描述Goods实体中的goodsDetails这个List数据从哪来的; 其含义是,在 select * from t_goods limit 0,10 得到结果后,对所有Goods对象遍历得到goods_id字段值, 并代入到goodsDetail命名空间的 selectByGoodsId的SQL中执行查询, 将得到的&quot;商品详情&quot;集合赋值给goodsDetails 这个List对象. --&gt; &lt;collection property=&quot;goodsDetails&quot; select=&quot;goodsDetail.selectByGoodsId&quot; column=&quot;goods_id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectOneToMany&quot; resultMap=&quot;rmGoods1&quot;&gt; select * from t_goods limit 0,10&lt;/select&gt; ◇在核心配置文件(mybatis-config.xml)中进行注册 1234&lt;mappers&gt; &lt;mapper resource=&quot;mappers/goods.xml&quot;/&gt; &lt;mapper resource=&quot;mappers/goods_detail.xml&quot;/&gt;&lt;/mappers&gt; ◇测试 123456789101112131415@Test public void testOneToMany() throws Exception &#123; SqlSession session = null; try &#123; session = MyBatisUtils.openSession(); List&lt;Goods&gt; list = session.selectList(&quot;goods.selectOneToMany&quot;); for(Goods goods:list) &#123; System.out.println(goods.getTitle() + &quot;:&quot; + goods.getGoodsDetails().size()); &#125; &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; 多对一◇在实体类GoodsDetail中增加**private **Goods goods;◇在goods_detail.xml文件中进行对像关联的描述 123456789101112&lt;resultMap id=&quot;rmGoodsDetail&quot; type=&quot;com.lcg.mybatis.entity.GoodsDetail&quot;&gt; &lt;!--主键关联--&gt; &lt;id column=&quot;gd_id&quot; property=&quot;gdId&quot;/&gt; &lt;!--结果关联--&gt; &lt;result column=&quot;goods_id&quot; property=&quot;goodsId&quot;/&gt; &lt;!--association关联标签，用于多对一--&gt; &lt;association property=&quot;goods&quot; select=&quot;goods.selectById&quot; column=&quot;goods_id&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectManyToOne&quot; resultMap=&quot;rmGoodsDetail&quot;&gt; select * from t_goods_detail limit 0,20 &lt;/select&gt; ◇测试 项目见F:mybatis; 分页插件PageHelper分页查询的麻烦事◇当前页数据查询 - select * from tab limit 0,10◇总记录数查询 - select count(*) from tab◇程序计算总页数、上一页页码、下一页页码◇MyBatis分页插件PageHelper官方网站 pageHelper使用流程◇maven引入PageHelper与jsqlparser 1234567891011//pom.xml中&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; ◇mybatis-config.xml增加Plugin配置 12345678&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!--设置数据类型 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;!--分页合理化 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; ◇代码中使用PageHelper.startPage()自动分页 123456789101112131415161718192021222324252627 &lt;select id=&quot;selectPage&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods where current_price &amp;lt; 1000 &lt;/select&gt;@Test public void testSelectPage() throws Exception &#123; SqlSession session = null; try &#123; session = MyBatisUtils.openSession(); /*startPage方法会自动将下一次查询进行分页*/ PageHelper.startPage(2,10); Page&lt;Goods&gt; page = (Page) session.selectList(&quot;goods.selectPage&quot;); System.out.println(&quot;总的页数:&quot; + page.getPages()); System.out.println(&quot;总记录数:&quot; + page.getTotal()); System.out.println(&quot;开始行号:&quot; + page.getStartRow()); System.out.println(&quot;结束行号:&quot; + page.getEndRow()); System.out.println(&quot;当前页码:&quot; + page.getPageNum()); List&lt;Goods&gt; data = page.getResult();//当前页数据 for (Goods g : data) &#123; System.out.println(g.getTitle()); &#125; System.out.println(&quot;&quot;); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; 不同数据库的分页实现MySQL分页12//第一个参数代表起始行号，第二个是偏移量select * from table limit 10,20; Oracle123456select t3.* from ( select t2.*, rownum as row_num from ( --rownum是伪列：无需声明直接使用的列，将前20条数据筛选 select * from table order by id asc --用于查询 ) t2 where rownum&lt;=20) t3 where t2.row_num&gt;11 --第三层嵌套用于起始位置的筛选 SQL Server 20001234select top 3 * from table --top语句在sql语句执行完后获取前几条数据where id not in (select top 15 id from table) SQL Server 2012+123select * from table order by id offset 4 rows fetch next 5 rows only --offset偏移量 fetch next向后取多少行 --若id为1的话即从第5(1+4)行开始向后取5条数据 MyBatis配置C3P0连接池◇pom.xml进行配置 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.4&lt;/version&gt;&lt;/dependency&gt; ◇在mybatis创建datasoutce包，再新建C3P0DataSourceFactory类，继承自UnpooledDataSourceFactory以便于连接 12345678/** * C3P0与MyBatis兼容使用的数据源工厂类 */public class C3P0DataSourceFactory extends UnpooledDataSourceFactory &#123; public C3P0DataSourceFactory()&#123; this.dataSource = new ComboPooledDataSource(); &#125;&#125; ◇在mybatis-config.xml配置文件中将的type改为com.lcg.mybatis.datasource.C3P0DataSourceFactory;因为不同的连接池对属性的命名规则不同，所以有以下更改：driver-&gt;driverClass , url-&gt;jdbcUrl , username-&gt;user 123456789&lt;dataSource type=&quot;com.lcg.mybatis.datasource.C3P0DataSourceFactory&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;www.LCG.com&quot;/&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;5&quot;/&gt;&lt;/dataSource&gt; MyBatis批处理◇goods.xml增加批处理的SQL语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;!--INSERT INTO table--&gt; &lt;!--VALUES (&quot;a&quot; , &quot;a1&quot; , &quot;a2&quot;),(&quot;b&quot; , &quot;b1&quot; , &quot;b2&quot;),(....)--&gt; &lt;insert id=&quot;batchInsert&quot; parameterType=&quot;java.util.List&quot;&gt; INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; (#&#123;item.title&#125;,#&#123;item.subTitle&#125;, #&#123;item.originalCost&#125;, #&#123;item.currentPrice&#125;, #&#123;item.discount&#125;, #&#123;item.isFreeDelivery&#125;, #&#123;item.categoryId&#125;) &lt;/foreach&gt; &lt;/insert&gt; @Test public void testBatchInsert() throws Exception &#123; SqlSession session = null; try &#123; long st = new Date().getTime(); session = MyBatisUtils.openSession(); List list = new ArrayList(); for (int i = 0; i &lt; 10000; i++) &#123; Goods goods = new Goods(); goods.setTitle(&quot;测试商品&quot;); goods.setSubTitle(&quot;测试子标题&quot;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); //insert()方法返回值代表本次成功插入的记录总数 list.add(goods); &#125; session.insert(&quot;goods.batchInsert&quot;, list); session.commit();//提交事务数据 long et = new Date().getTime(); System.out.println(&quot;执行时间:&quot; + (et - st) + &quot;毫秒&quot;);// System.out.println(goods.getGoodsId()); &#125; catch (Exception e) &#123; if (session != null) &#123; session.rollback();//回滚事务 &#125; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇批量插入数据的局限：①无法获得插入数据的id；②批量生成的SQL太长，可能会被服务器拒绝◇批量删除 12345678910111213141516171819202122232425262728293031&lt;!--delete from t_goods where goods_id in (1920,1921,...)--&gt; &lt;delete id=&quot;batchDelete&quot; parameterType=&quot;java.util.List&quot;&gt; DELETE FROM t_goods WHERE goods_id in &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/delete&gt; @Test public void testBatchDelete() throws Exception &#123; SqlSession session = null; try &#123; long st = new Date().getTime(); session = MyBatisUtils.openSession(); List list = new ArrayList(); list.add(1920); list.add(1921); list.add(1922); session.delete(&quot;goods.batchDelete&quot;, list); session.commit();//提交事务数据 long et = new Date().getTime(); System.out.println(&quot;执行时间:&quot; + (et - st) + &quot;毫秒&quot;);// System.out.println(goods.getGoodsId()); &#125; catch (Exception e) &#123; if (session != null) &#123; session.rollback();//回滚事务 &#125; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; MyBatis注解开发Mybatis常用注解◇把原有放在xml的标签语句放在程序中◇创建dao包，然后创建GoodsDAO接口 1234567891011121314151617181920212223242526public interface GoodsDAO &#123; @Select(&quot;select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125; order by current_price limit 0,#&#123;limt&#125;&quot;) public List&lt;Goods&gt; selectByPriceRange(@Param(&quot;min&quot;) Float min , @Param(&quot;max&quot;) Float max ,@Param(&quot;limt&quot;) Integer limt); @Insert(&quot;INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;)&quot;) //&lt;selectKey&gt; @SelectKey(statement = &quot;select last_insert_id()&quot; , before = false , keyProperty = &quot;goodsId&quot; , resultType = Integer.class) public int insert(Goods goods); @Select(&quot;select * from t_goods&quot;) //&lt;resultMap&gt; @Results(&#123; //&lt;id&gt; @Result(column = &quot;goods_id&quot; ,property = &quot;goodsId&quot; , id = true) , //&lt;result&gt; @Result(column = &quot;title&quot; ,property = &quot;title&quot;), @Result(column = &quot;current_price&quot; ,property = &quot;currentPrice&quot;) &#125;) public List&lt;GoodsDTO&gt; selectAll();&#125; ◇在核心配置文件mybatis-config.xml中进行相应说明 1234&lt;mappers&gt; &lt;!--&lt;mapper class=&quot;com.lcg.mybatis.dao.GoodsDAO&quot;/&gt; 指向接口，下为简便方法--&gt; &lt;package name=&quot;com.lcg.mybatis.dao&quot;/&gt;&lt;/mappers&gt; ◇测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Test public void testSelectByPriceRange() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); //传入类对象 GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List&lt;Goods&gt; list = goodsDAO.selectByPriceRange(100f, 500f, 20); System.out.println(list.size()); &#125;catch (Exception e)&#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125;/** * 新增数据 * @throws Exception */ @Test public void testInsert() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(&quot;测试商品&quot;); goods.setSubTitle(&quot;测试子标题&quot;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); //insert()方法返回值代表本次成功插入的记录总数 int num = goodsDAO.insert(goods); session.commit();//提交事务数据 System.out.println(goods.getGoodsId()); &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; @Test public void testSelectAll() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List&lt;GoodsDTO&gt; list = goodsDAO.selectAll(); System.out.println(list.size()); &#125;catch (Exception e)&#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBaits","slug":"Java数据库/MyBaits","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MyBaits/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"MyBaits入门","slug":"MyBatis入门","date":"2022-02-03T00:34:00.000Z","updated":"2022-02-21T14:10:45.195Z","comments":true,"path":"p/f37d.html","link":"","permalink":"https://618dt.github.io/p/f37d.html","excerpt":"","text":"MyBatis课程介绍MyBatis入门使用 MyBatis高级特性 认识框架-Framework生活中的框架 软件开发中框架◇框架是可被应用开发者定制的应用骨架◇框架是一种规则,保证开发者遵循相同的方式开发程序◇框架提倡”不要重复造轮子”,对基础功能进行封装 框架的优点◇极大提高了开发效率◇统一的编码规则,利于团队管理◇灵活配置的应用,拥有更好的维护性 SSM开发框架 介绍MyBatis什么是MyBatis◇MyBatis是优秀的持久层框架◇MyBatis使用XML将SQL与程序解耦,便于维护◇MyBatis学习简单,执行高效,是JDBC的延伸 MyBatis开发流程◇引入MyBatis依赖 ◇创建核心配置文件◇创建实体(Entity)类 ◇创建Mapper映射文件◇初始化SessionFactory ◇利用SqlSession对象操作数据 单元测试与JUnit 4单元测试◇单元测试是指对软件中的最小可测试单元进行检查和验证◇测试用例是指编写一段代码对已有功能(方法)进行校验◇JUnit 4是Java中最著名的单元测试工具,主流IDE内置支持 JUnit 4使用方法◇引入JUnit Jar包或增加Maven依赖◇编写测试用例验证目标方法是否正确运行◇在测试用例上增加@Test注解开始单元测试 JUnit 4使用入门◇创建Maven项目 –pom.xml配置 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; –main中创建类 1234567891011121314151617public class Calculator &#123; public int add(int a, int b) &#123; return a+b; &#125; public int subtract(int a, int b) &#123; return a - b; &#125; public int multiply(int a, int b) &#123; return a * b; &#125; public float divide(int a, int b) &#123; return (a*1f)/b; &#125;&#125; –test中创建测试类,测试类或测试方法前有√则为正确运行,也要看程序运行和预期是否相同 123456789101112131415161718192021222324252627282930public class CalculatorTest &#123; private Calculator cal = new Calculator(); //测试用例命名规则 //1.与原方法保持一致add //2.在原方法前增加test前缀testAdd @Test public void testAdd()&#123; int result = cal.add(3, 5); System.out.println(result); &#125; @Test public void subtract() &#123; int result = cal.subtract(1, 2); System.out.println(result); &#125; @Test public void multiply() &#123; int result = cal.multiply(1, 2); System.out.println(result); &#125; @Test public void divide() &#123; float result = cal.divide(1, 2); System.out.println(result); &#125;&#125; ◇快速生成测试类方法：选中需要测试的类-&gt;Code-&gt;Generate-&gt;Test◇可以同时运行多个测试类 MyBatis环境配置mybatis-config.xml◇ MyBatis采用XML格式配置数据库环境信息◇ MyBaits环境配置标签◇ environment包含数据库驱动、URL、用户名与密码 项目演示◇IDEA支持数据库面板，DataBase-&gt;+ -&gt;DataSource-&gt;MySql◇pom.xml配置 12345678910111213141516171819202122&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--增加junit用于测试 --&gt; &lt;/dependencies&gt; ◇在main/resources目录下创建mybatis-config.xml文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--设置默认指向的数据库,这里默认指向dev--&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;!--配置环境，不同的环境不同的id名字--&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!--采用连接池方式管理数据库连接--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value= &quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;www.LCG.com&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; SqlSessionFactory◇ SqlSessionFactory是MyBatis的核心对象◇ 用于初始化MyBatis,创建SqlSession对象◇ 保证SqlSessionFactory在应用中全局唯一 SqlSession◇ SqlSession是MyBatis操作数据库的核心对象◇ SqlSession使用JDBC方式与数据库交互◇ SqlSession对象提供了数据表CRUD对应方法 项目演示◇pom.xml中增加junit依赖用于测试◇JUNIT单元测试类 123456789101112131415161718192021222324252627282930313233343536373839404142public class MyBatisTestor &#123; @Test public void testSqlSessionFactory()throws IOException &#123; //按照字符流方式进行.xml文件的读取，返回Reader对象 Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); //初始化SqlSessionFactory对象，同时通过reader对象解析xml文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); System.out.println(&quot;SessionFactory加载成功&quot;); SqlSession sqlSession = null; try &#123; //创建SqlSession对象，SqlSession是JDBC的扩展类，用于与数据库交互 sqlSession = sqlSessionFactory.openSession(); //进行数据库的交互 Connection connection = sqlSession.getConnection(); System.out.println(connection); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; /*如果type=&quot;POOLED&quot;,代表使用连接池，close则是将连接回收到连接池中 * 如果type=&quot;UNPOOLED&quot;,代表直连，close则会调用Connection.close() * 方法关闭连接*/ if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; &#125; //测试工具类 @Test public void testMyBatisUtils()throws Exception&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.openSession(); Connection connection = sqlSession.getConnection(); System.out.println(connection); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; MyBatisUtils.closeSession(sqlSession); &#125; &#125;&#125; ◇初始化工具类 123456789101112131415161718192021222324252627282930313233343536373839public class MyBatisUtils &#123; //利用static(静态)属于类不属于对象，且全局唯一 private static SqlSessionFactory sqlSessionFactory = null; //利用静态块在初始化类时实例化sqlSessionFactory static &#123; Reader reader = null; try &#123; reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); //初始化错误时，通过抛出异常ExceptionInInitializerError通知调用者 throw new ExceptionInInitializerError(e); &#125; &#125; /** * openSession 创建一个新的SqlSession对象 * 对于工具类的方法大都使用static描述， * 这样通过类名和方法名就可以直接使用了 * @return SqlSession对象 */ public static SqlSession openSession() &#123; return sqlSessionFactory.openSession(); &#125; /** * 释放一个有效的SqlSession对象 * * @param session 准备释放SqlSession对象 */ public static void closeSession(SqlSession session) &#123; if (session != null) &#123; session.close(); &#125; &#125;&#125; MyBatis数据查询MyBatis数据查询步骤◇创建实体类(Entity) ◇创建Mapper XML◇编写SQL标签 ◇开启驼峰命名映射◇新增 ◇SqlSession执行select语句 项目演示◇生成实体类，entity 1234567891011public class Goods &#123; private Integer goodsId;//商品编号 private String title;//标题 private String subTitle;//子标题 private Float originalCost;//原始价格 private Float currentPrice;//当前价格 private Float discount;//折扣率 private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮 private Integer categoryId;//分类编号 ...&#125; ◇在Resources目录中创建mapper(映射器)文件，在其中创建xml文件;goods.xml文件说明了实体类和哪一张表对应 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--与config中的不同 --&gt;&lt;!--命名空间用来区分 --&gt;&lt;mapper namespace=&quot;goods&quot;&gt; &lt;!--编写sql标签,resultType说明查询结果返回的实体类 --&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods order by goods_id desc limit 10 &lt;/select&gt;&lt;/mapper&gt; ◇新建了goods.xml后还需要在mybatis-config.xml中进行声明◇驼峰命名转换(在mybatis-config中配置)，数据表字段不区分大小写，但java属性区分大小写；防止读取数据库数据时丢失一些例如goods_id字段的数据 1234&lt;settings&gt; &lt;!-- goods_id ==&gt; goodsId 驼峰命名转换 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; ◇编写测试 123456789101112131415@Testpublic void testSelectAll() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); List&lt;Goods&gt; list = session.selectList(&quot;goods.selectAll&quot;); for(Goods g : list)&#123; System.out.println(g.getTitle()); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125;&#125; Sql传参查询 - select1234&lt;select id=&quot;selectById&quot; parameterType=&quot;Integer&quot;resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt;select * from t_goods where goods_id = #&#123;value&#125;&lt;/select&gt; 项目示例①单个参数◇在goods.xml中新增一个select查询 123&lt;select id=&quot;selectById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods where goods_id = #&#123;value&#125; &lt;/select&gt; ◇进行测试 1234567891011121314151617/** * 传递单个SQL参数 * @throws Exception */ @Test public void testSelectById() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = session.selectOne(&quot;goods.selectById&quot; , 1603); System.out.println(goods.getTitle()); &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ②多个参数◇session.selectxxx方法无法传递多个参数，所以利用Java.Util.Map键值对来进行多个参数的传递，即参数名为键，值为参数值◇新增查询 123456&lt;select id=&quot;selectByPriceRange&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125; limit 0,#&#123;limt&#125;&lt;/select&gt; ◇测试 1234567891011121314151617181920212223/** * 传递多个(3个)SQL参数 * @throws Exception */ @Test public void testSelectByPriceRange() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Map param = new HashMap(); param.put(&quot;min&quot;,100); param.put(&quot;max&quot; , 500); param.put(&quot;limt&quot; , 10); List&lt;Goods&gt; list = session.selectList(&quot;goods.selectByPriceRange&quot;, param); for(Goods g:list)&#123; System.out.println(g.getTitle() + &quot;:&quot; + g.getCurrentPrice()); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ③多表关联◇Sql语句 12345678910&lt;!-- 利用LinkedHashMap保存多表关联结果 MyBatis会将每一条记录包装为LinkedHashMap对象 key是字段名 value是字段对应的值 , 字段类型根据表结构进行自动判断 优点: 易于扩展,易于使用 缺点: 太过灵活,无法进行编译时检查 --&gt;&lt;select id=&quot;selectGoodsMap&quot; resultType=&quot;java.util.LinkedHashMap&quot;&gt; select g.*,c.category_name from t_goods g, t_category c where g.category_id = c.category_id &lt;/select&gt; ◇测试 123456789101112131415@Test public void testSelectGoodsMap() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); List&lt;Map&gt; list = session.selectList(&quot;goods.selectGoodsMap&quot;); for(Map map : list)&#123; System.out.println(map); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ResultMap结果映射◇ResultMap可以将查询结果映射为复杂类型的Java对象◇ResultMap适用于Java对象保存多表关联结果◇ResultMap支持对象关联查询等高级特性项目示例◇创建类别实体 12345678public class Category &#123; private Integer categoryId; private String categoryName; private Integer parentId; private Integer categoryLevel; private Integer categoryOrder; ...&#125; ◇创建新包dto，用来进行对原始数据的扩展，保存以及传递;如在包中创建GoodsDTO对原始的Goods进行扩展 1234567//Data Transfer Object--数据传输对象public class GoodsDTO &#123; private Goods goods = new Goods(); private Category category = new Category(); private String test;...&#125; ◇结果映射 12345678910111213141516171819202122&lt;!--结果映射--&gt; &lt;resultMap id=&quot;rmGoods&quot; type=&quot;com.lcg.mybatis.dto.GoodsDTO&quot;&gt; &lt;!--设置主键字段与属性映射--&gt; &lt;id property=&quot;goods.goodsId&quot; column=&quot;goods_id&quot;&gt;&lt;/id&gt; &lt;!--设置非主键字段与属性映射--&gt; &lt;result property=&quot;goods.title&quot; column=&quot;title&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.originalCost&quot; column=&quot;original_cost&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.currentPrice&quot; column=&quot;current_price&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.discount&quot; column=&quot;discount&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.isFreeDelivery&quot; column=&quot;is_free_delivery&quot;&gt;&lt;/result&gt; &lt;result property=&quot;goods.categoryId&quot; column=&quot;category_id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryId&quot; column=&quot;category_id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryName&quot; column=&quot;category_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.parentId&quot; column=&quot;parent_id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryLevel&quot; column=&quot;category_level&quot;&gt;&lt;/result&gt; &lt;result property=&quot;category.categoryOrder&quot; column=&quot;category_order&quot;&gt;&lt;/result&gt; &lt;result property=&quot;test&quot; column=&quot;test&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectGoodsDTO&quot; resultMap=&quot;rmGoods&quot;&gt; select g.* , c.*,&#x27;1&#x27; as test from t_goods g , t_category c where g.category_id = c.category_id &lt;/select&gt; ◇测试 123456789101112131415@Test public void testSelectGoodsDTO()throws Exception&#123; SqlSession session = null; try &#123; session = MyBatisUtils.openSession(); List&lt;GoodsDTO&gt; list = session.selectList(&quot;goods.selectGoodsDTO&quot;); for(GoodsDTO g:list)&#123; System.out.println(g.getGoods().getTitle()); &#125; &#125; catch (Exception e) &#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; MyBatis数据写入数据库事务◇数据库事务是保证数据操作完整性的基础 MyBatis写操作包含三种◇插入 - insert 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt;INSERT INTO `babytun`.`t_goods`( `title`, `sub_title`, `original_cost`, current_price`)VALUES ( #&#123;title&#125;, #&#123;subTitle&#125;, #&#123;originalCost&#125;, #&#123;currentPrice&#125;)&lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt;&lt;!-- 当前连接中最后产生的id号 --&gt;select last_insert_id()&lt;/selectKey&gt;&lt;/insert&gt;--示例代码 &lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; insert into t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery,category_id) value (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;) //用来将新插入的id回填到类中 &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; &lt;/insert&gt; @Test public void testInsert() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle(&quot;测试商品&quot;); goods.setSubTitle(&quot;测试子标题&quot;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); //insert()方法返回值代表本次成功插入的记录总数 int num = session.insert(&quot;goods.insert&quot;, goods); session.commit();//提交事务数据 System.out.println(goods.getGoodsId()); &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇更新 - update 123456789101112131415161718192021222324252627282930313233&lt;update id=&quot;update&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; UPDATE t_goods SET title = #&#123;title&#125; , sub_title = #&#123;subTitle&#125; , original_cost = #&#123;originalCost&#125; , current_price = #&#123;currentPrice&#125; , discount = #&#123;discount&#125; , is_free_delivery = #&#123;isFreeDelivery&#125; , category_id = #&#123;categoryId&#125; WHERE goods_id = #&#123;goodsId&#125; &lt;/update&gt; @Test public void testUpdate() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); //通过selectOne方法得到指定商品编号的goods对象 Goods goods = session.selectOne(&quot;goods.selectById&quot;, 739); goods.setTitle(&quot;更新测试商品&quot;); int num = session.update(&quot;goods.update&quot; , goods); session.commit();//提交事务数据 &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; ◇删除 - delete 1234567891011121314151617181920&lt;!--delete from t_goods where goods_id in (1920,1921)--&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;Integer&quot;&gt; delete from t_goods where goods_id = #&#123;value&#125; &lt;/delete&gt;@Test public void testDelete() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); int num = session.delete(&quot;goods.delete&quot; , 739); session.commit();//提交事务数据 &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; selectKey与useGeneratedKeys的区别◇selectKey标签的用法 123456&lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; INSERT INTO SQL语句 &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; &lt;/insert&gt; ◇useGeneratedKeys属性用法 1234567&lt;insert&gt; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;goodsId&quot; KeyColumn=&quot;goods_id&quot; INSERT INTO SQL 语句&lt;/insert&gt; 二者区别◇selectKey标签需要明确编写获取最新主键的SQL语句◇useGeneratedKeys属性会自动根据驱动生成对应SQL语句◇selectKey适用于所有的关系型数据库◇useGeneratedKeys只适用于能够”自增主键”类型的数据库◇在Oracle(非自增)中selectKey的用法 123456&lt;insert id=&quot;insert&quot; parameterType=&quot;com.lcg.mybatis.entity.Goods&quot;&gt; INSERT INTO SQL语句 &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;BEFORE&quot;&gt; select seq_goods.nextval as id from dual &lt;/selectKey&gt; &lt;/insert&gt; MyBatis预防SQL注入攻击SQL注入攻击 ◇SQL注入是指攻击者利用SQL漏洞,绕过系统约束,越权获取数据的攻击方式 1234567SQL代码:select * from a where name =&#x27;&quot;+ name+&quot;&#x27;&quot;;正常情况:name:张三 -&gt; select * from a where name=&#x27;张三&#x27;;SQL注入攻击:name:&#x27; or 1=1 or 1=&#x27;select * from a where name=&#x27;&#x27; or 1=1 or 1=&#x27;&#x27; MyBatis两种传值方式◇${}文本替换,未经任何处理对SQL文本替换◇ #{}预编译传值,使用预编译传值可以预防SQL注入 MyBatis工作流程◇首先在Java应用中创建mybatis-config.xml文件，用于全局配置，这个配置文件包含了全局设置项、环境配置、mapper声明等核心配置信息；然后在程序的运行过程中通过SqlSessionFactoryBuilder构造器对象来build(构造)SqlSessionFactory工厂类对象；该工厂类对象需要保证全局唯一，用于创建SqlSession对象；SqlSession是我们用于对数据库增删改查的核心对象，它要解析与之对应的mapper.xml文件，每一个mapper.xml文件中包含了大量的sql语句；我们通过SqlSession来访问mapper.xml文件，进而执行其中的sql语句；在SqlSession中主要提供了四种方法(insert | update | delete | select)和数据库进行交互；在进行写的操作时，不要忘记对事务进行相应的提交和回滚；在交互完毕后，应当关闭会话任务，这样我们的底层数据库连接要么被连接池回收要么就直接释放掉；SessionClose这个操作一般放在finally块中，保证它一定能够执行；","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBaits","slug":"Java数据库/MyBaits","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MyBaits/"}],"tags":[{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"}],"author":"LCG"},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2022-02-03T00:30:00.000Z","updated":"2022-02-21T14:06:54.438Z","comments":true,"path":"p/8609.html","link":"","permalink":"https://618dt.github.io/p/8609.html","excerpt":"","text":"课程介绍◇实例讲解Lambda语法◇基于Lambda实现函数式编程◇Stream流式处理 初识Lambda表达式什么是Lambda表达式◇JDK8开始支持Lambda表达式,用来让程序编写更优雅◇利用Lambda可以更简洁的实现匿名内部类与函数声明与调用◇基于Lambda提供stream流式处理极大简化对集合的操作 传统代码12345678List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);//实现集合排序Collections.sort(names, new Comparator&lt;String&gt;() &#123;@Overridepublic int compare(String a, String b) &#123;return b.compareTo(a);&#125;&#125;); 使用Lambda表达式123List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);//通过lambda表达式简化匿名类的编写Collections.sort(names, (a,b) -&gt; b.compareTo(a)); Lambda表达式语法Lambda语法格式 Lambda表达式示例1234//四则运算接口interface MathOperation &#123;int operation(int a, int b);&#125; 12345678910111213141516171819public class LambdaSample &#123; public static void main(String[] args) &#123; //1.标准使用方式 //约束条件：Lambda表达式只能实现有且仅有一个抽象方法的接口，java称为&quot;函数式接口&quot; MathOperation addition = (Integer a,Integer b)-&gt;&#123; System.out.println(&quot;加法运算&quot;); return a + b + 0f;//加上0f隐式的将结果转换为浮点型，与接口数据类型对应 &#125;; System.out.println(addition.operation(3,9)); //2.Lambda允许参数类型忽略 MathOperation substraction = (a,b)-&gt;&#123; System.out.println(&quot;减法运算&quot;); return a-b+0f; &#125;; //3.单行实现代码可以省略大括号和return MathOperation multiplication = (a,b)-&gt;a*b+0f; &#125;&#125;//传统方法：新建一个class类，在类中定义运算方法，然后再实例化进行运算 函数式编程什么是函数式编程◇函数式编程是基于函数式接口并使用lambda表达的编程方式◇函数式编程理念是将代码作为可重用数据代入到程序运行中◇函数式编程强调”你想做什么”,而不是”你想怎么做” 什么是函数式接口◇函数式接口是有且只有一个抽象方法的接口◇Java中拥有大量函数式接口,如java.lang.Runnable◇JDK8后提供了一系列新的函数式接口,位于java.util.function◇函数式接口的注解@FunctionInterface用来进行抽象方法检查，防止接口中存在多个方法 函数式接口Predicate◇Predicate是新增的函数式接口,位于java.util.function◇Predicate用于测试传入的数据是否满足判断要求◇Predicate接口需要实现test()方法进行逻辑判断 函数式编程示例◇示例一 1234567891011121314151617181920212223public class PredicateSample &#123; public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate = n-&gt;n&gt;4; boolean result = predicate.test(5); System.out.println(result); List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); /* 传统方法判断奇数，代码写死，不灵活 for(Integer num:list)&#123; if(num%2==1)&#123; System.out.println(num); &#125; &#125;*/ filter(list,n-&gt;n%2==1);//判断奇数，直接传参数即可 filter(list,n-&gt;n%2==0);//判断偶数 &#125; public static void filter(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate)&#123; for(Integer num:list)&#123; if(predicate.test(num))&#123; System.out.print(num + &quot; &quot;); &#125; &#125; &#125;&#125; 函数式编程与面向对象编程比较 函数式接口JDK8常用函数式接口 函数式接口的应用123456789//Function函数式接口说明闭包要求输入参数并返回数据Function&lt;String, String&gt; fn = (str) -&gt; str.toUpperCase();String result = fn.apply(&quot;admin&quot;); //apply用于执行方法返回结果System.out.println(result);//Consumer函数式接口说明闭包只要求输入参数,但不会返回数据Consumer&lt;String&gt; c = arg -&gt; &#123;System.out.println(arg);&#125;;c.accept(&quot;hello&quot;); //accept只接受参数,没有任何结果返回 ◇利用Function函数式接口生成定长随机字符串 123456789101112131415161718public class FunctionSample &#123; public static void main(String[] args) &#123; Function&lt;Integer,String&gt; randomStringFunction = len-&gt;&#123; String chars=&quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;; StringBuffer stringBuffer = new StringBuffer(); Random random = new Random(); for(int i=0;i&lt;len;i++)&#123; //截取某一个字符的位置 int position = random.nextInt(chars.length()); //charAt方法按照指定位置将字符提取出来 stringBuffer.append(chars.charAt(position)); &#125; return stringBuffer.toString(); &#125;; String randomString = randomStringFunction.apply(5); System.out.println(randomString); &#125;&#125; Stream流式处理◇Stream流式处理是建立在Lambda基础上的多数据处理技术◇Stream对集合数据处理进行高度抽象,极大简化代码量◇Stream可对集合进行迭代,去重,筛选,排序,聚合等一系列处理 Stream示例123456//获取List集合中最大的偶数Optional&lt;Integer&gt; op = Arrays.asList(1,2,3,4,5,6).stream().filter(x -&gt; x%2 == 0)//先进行筛选,得到偶数.sorted((a,b) -&gt; b-a)//b-a表示降序,a-b表示升序.findFirst();//取第一个,这里即最大的System.out.println(op.get()); Stream常用方法 Stream操作实例◇Stream流的五种创建方式；最常用的为1,2两种 12345678910111213141516171819202122232425262728293031323334353637383940414243public class StreamGenerator &#123; //1.基于数组创建 @Test public void generator1()&#123; String[] arr = &#123;&quot;莉莉&quot;, &quot;安迪&quot;, &quot;明明&quot;, &quot;牛牛&quot;&#125;; Stream&lt;String&gt; stream = Stream.of(arr); stream.forEach(s-&gt;System.out.println(s)); &#125; //2.基于集合创建 @Test public void generator2()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;莉莉&quot;); list.add(&quot;安迪&quot;); list.add(&quot;马马&quot;); list.add(&quot;牛牛&quot;); Stream&lt;String&gt; stream = list.stream(); stream.forEach(s-&gt; System.out.println(s)); &#125; //3.利用generate方法创建无限长度流 @Test public void generator3()&#123; //bound限制产生的随机数小于其参数 Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; new Random().nextInt(1000)); //limit用来限制流的最大长度，不设置则为无限 stream.limit(10).forEach(i-&gt; System.out.println(i)); &#125; //4.基于迭代器创建 @Test public void generator4()&#123; //seed：起始的数据；n+1表示每一次循环步长为1 Stream&lt;Integer&gt; stream = Stream.iterate(1, n -&gt; n + 1); stream.limit(100).forEach(i-&gt; System.out.println(i)); &#125; //5.基于字符序列创建 @Test public void generator5()&#123; String str = &quot;hello你好&quot;; IntStream stream = str.chars(); //输出为字母的ASCII码或者汉字的Unicode编码;将c强制转换成char类型即可输出原字符 stream.forEach(c -&gt; System.out.println((char)c)); &#125;&#125; ◇Stream流的常用方法 1234567891011121314151617181920212223242526272829303132333435363738public class StreamMethod &#123; //1.提取集合中所有偶数并求和 @Test public void case1()&#123; //List的泛型设为String类型,否则编译器默认s为object,而parseInt不支持object类型 List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;); int sum = list.stream() //获取stream对象 .mapToInt(s-&gt;Integer.parseInt(s)) //mapToInt将流中的每一个数据转换为整数 .filter(n-&gt;n%2==0)//对流中数据进行过滤 .sum();//将所有数据进行求和，数据只能为整数 System.out.println(sum); &#125; //2.所有名字首字母大写 @Test public void case2()&#123; List&lt;String&gt; list = Arrays.asList(&quot;lily&quot;,&quot;smith&quot;,&quot;jackson&quot;,&quot;bob&quot;); List newList = list.stream() /*substring()截取位置为a到b的字符串， 若只有一个参数，则此参数表示从该位置截取 到最后*/ .map(s -&gt; s.substring(0, 1).toUpperCase()+s.substring(1)) //.forEach(s -&gt; System.out.println(s));只能进行打印，没有保存 //collect对流数据进行收集，生成新的List/Set(Set可以将重复数据自动清除) .collect(Collectors.toList());//可以将转换后的结果保存到新的List中 System.out.println(newList); &#125; //3.将所有奇数从大到小进行排序，且不许出现重复 //Set方法可以清楚重复数据，但没有顺序，排序功能会失效 @Test public void case3()&#123; List&lt;Integer&gt; list = Arrays.asList(1,60,38,21,51,60,51,73); List newList = list.stream().distinct()//去除重复的流数据 .filter(n-&gt;n%2==1) .sorted((a,b)-&gt;b-a) .collect(Collectors.toList()); System.out.println(newList); &#125;&#125; 如何通过oracle官网学习Stream流的方法◇官网地址:百度java.util.stream◇查看每一个方法的作用​","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"https://618dt.github.io/tags/Lambda/"}],"author":"LCG"},{"title":"Java反射","slug":"Java反射","date":"2022-02-03T00:24:00.000Z","updated":"2022-02-21T13:53:15.854Z","comments":true,"path":"p/7c7c.html","link":"","permalink":"https://618dt.github.io/p/7c7c.html","excerpt":"","text":"课程介绍◇介绍反射及作用◇讲解反射四个核心类◇反射在项目中的应用 主要知识点◇反射的作用◇Class类◇Constructor构造方法类◇Method方法类◇Field成员变量类 什么是反射Reflect◇反射(Reflect)是在运行时动态访问类与对象的技术◇反射是JDK1.2版本后的高级特性,隶属于java.lang.reflect◇大多数Java框架都基于反射实现参数配置、动态注入等特性◇反射方法与传统方法对比,传统方法要增加乘法类时需要再写一个if else而反射方法支持动态增加方法的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 传统的创建对象方式 */ public static void case1()&#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入计算类名:&quot;); String op = scanner.next(); System.out.print(&quot;请输入a:&quot;); int a = scanner.nextInt(); System.out.print(&quot;请输入b:&quot;); int b = scanner.nextInt(); MathOperation mathOperation = null; if(op.equals(&quot;Addition&quot;))&#123; mathOperation = new Addition(); &#125;else if(op.equals(&quot;Subtraction&quot;)) &#123; mathOperation = new Subtraction(); &#125;else if(op.equals(&quot;Multiplication&quot;))&#123; mathOperation = new Multiplication(); &#125;else&#123; System.out.println(&quot;无效的计算类&quot;); return; &#125; float result = mathOperation.operate(a, b); System.out.println(result); &#125; /** * 利用反射创建对象更加灵活 */ public static void case2()&#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入计算类名:&quot;); String op = scanner.next(); System.out.print(&quot;请输入a:&quot;); int a = scanner.nextInt(); System.out.print(&quot;请输入b:&quot;); int b = scanner.nextInt(); MathOperation mathOperation = null; try &#123; mathOperation = (MathOperation) Class.forName(&quot;com.lcg.reflect.&quot; + op).newInstance(); &#125;catch(Exception e)&#123; System.out.println(&quot;无效的计算类&quot;); return; &#125; float result = mathOperation.operate(a, b); System.out.println(result); &#125; 反射的核心类◇Class类◇Constructor构造方法类◇Method方法类◇Field成员变量类 Class类◇Class是JVM中代表”类和接口”的类◇Class对象具体包含了某个特定类的结构信息◇通过Class对象可获取对应类的构造方法/方法/成员变量 Class核心方法 利用Class创建对象123456789101112131415161718192021public class ClassSample &#123; public static void main(String[] args) &#123; try &#123; //Class.forName()方法将指定的类加载到jvm,并返回对应Class对象(得到员工类对象) Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;); System.out.println(&quot;Employee已被加载到jvm&quot;); //newInstance通过默认构造方法创建新的对象(实例化),返回Object对象，需要强制转换 Employee emp = (Employee)employeeClass.newInstance(); System.out.println(emp); &#125; catch (ClassNotFoundException e) &#123; //类名与类路径书写错误是抛出&quot;类无法找到&quot;异常 e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; //非法访问异常,当在作用域外访问对象方法或成员变量时抛出 e.printStackTrace(); &#125; catch (InstantiationException e) &#123; //对象无法被实例化,抛出&quot;实例化异常&quot; e.printStackTrace();//抽象类(abstract)无法被实例化 &#125; &#125;&#125; Constructor构造方法类◇Constructor类是对Java类中的构造方法的抽象◇Contructor对象包含了具体类的某个具体构造方法的声明◇通过Constructor对象调用带参构造方法创建对象 Constructor类核心方法 利用Constructor创建对象1234567891011121314151617181920212223242526272829public class ConstructorSample &#123; public static void main(String[] args) &#123; try &#123; //得到员工类的类对象 Class employeeClass = Class.forName(&quot;com.lcg.reflect.entity.Employee&quot;); //得到Employee类中包含有四个参数的构造方法对象,Class[]类型数组 Constructor constructor = employeeClass.getConstructor(new Class[]&#123; Integer.class,String.class,Float.class,String.class &#125;); //通过指定构造方法传入数据,创建对象 Employee employee = (Employee) constructor.newInstance(new Object[]&#123; 100,&quot;李磊&quot;,3000f,&quot;研发部&quot; &#125;); System.out.println(employee); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; //没有找到与之对应格式的方法 e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; //当被调用的方法的内部抛出了异常而没有被捕获时 e.printStackTrace(); &#125; &#125;&#125; Method方法类◇Method对象指代某个类中的方法的描述◇Method对象使用classObj.getMethod()方法获取◇通过Method对象调用指定对象的对应方法 Method类核心方法 利用Method执行方法1234567891011121314151617181920212223242526272829303132/** * 利用Method方法类调用 */public class MethodSample &#123; public static void main(String[] args) &#123; try &#123; Class employeeClass = Class.forName(&quot;com.lcg.reflect.entity.Employee&quot;); Constructor constructor = employeeClass.getConstructor(new Class[]&#123; Integer.class, String.class, Float.class, String.class &#125;); //传入参数时用Object[]对象数组 Employee employee = (Employee) constructor.newInstance(new Object[]&#123; 100, &quot;李磊&quot;, 3000f, &quot;研发部&quot; &#125;); Method updateSalaryMethod = employeeClass.getMethod(&quot;updateSalary&quot;, new Class[]&#123; Float.class &#125;); Employee employee1 = (Employee) updateSalaryMethod.invoke(employee, new Object[]&#123;1000f&#125;); System.out.println(employee1); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Field成员变量类◇Field对应某个具体类中的成员变量的声明◇Field对象使用classObj.getField()方法获取◇通过Field对象可为某对象成员变量赋值/取值 Field类核心方法 利用Field赋值与取值1234567...//获取员工姓名Field成员变量对象Field enameField = employeeClass.getField(&quot;ename&quot;);//成员变量赋值enameField.set(employee,&quot;李雷&quot;);//成员变量取值，参数为对象名String ename = (String)enameField.get(employee); getDeclared系列方法◇getDeclaredConstructor(s)|Method(s)|Field(s)获取对应对象(构造方法，方法，成员变量) ,+s表示获取所有(多个)◇getConstructor(s)|Method(s)|Field(s)只能获取public对象◇访问非作用域内构造方法、方法、成员变量,会抛出异常◇public变量.get()直接获取，非public变量先通过类对象获取到get方法再来调用get方法获取 123456789101112131415161718192021222324Class employeeClass = Class.forName(&quot;com.lcg.reflect.entity.Employee&quot;);Constructor constructor = employeeClass.getConstructor(new Class[]&#123; Integer.class, String.class, Float.class, String.class &#125;);Employee employee = (Employee) constructor.newInstance(new Object[]&#123; 100, &quot;李磊&quot;, 3000f, &quot;研发部&quot; &#125;);//获取当前类所有成员变量Field[] fields = employeeClass.getDeclaredFields();for(Field field : fields)&#123; //System.out.println(field.getName()); //对成员变量区分对待 if(field.getModifiers() == 1)&#123; //pubilc修饰 Object val = field.get(employee); System.out.println(field.getName() + &quot;:&quot; + val); &#125;else if(field.getModifiers() == 2)&#123; //private修饰 //构造出get方法名,eg: getSalary(); String methodName = &quot;get&quot; + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1); Method getMethod = employeeClass.getMethod(methodName);//获取类的get方法; Object ret = getMethod.invoke(employee);//执行get方法 System.out.println(field.getName() + &quot;:&quot; + ret); &#125;&#125; 反射在项目中的应用◇网站的国际化 123456789101112131415161718192021public class Application &#123; public static void say()&#123; Properties properties = new Properties();//加载指定配置文件 //获取配置文件路径 String configPath = Application.class.getResource(&quot;/config.properties&quot;).getPath(); try &#123; configPath = new URLDecoder().decode(configPath,&quot;UTF-8&quot;); properties.load(new FileInputStream(configPath)); //用 Properties.getProperty来读取配置文件里面的(language属性)的属性值 String language = properties.getProperty(&quot;language&quot;); //利用language告知Class获取哪一个指定类并实例化 I18N i18n = (I18N)Class.forName(language).newInstance(); System.out.println(i18n.say()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Application.say(); &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://618dt.github.io/tags/%E5%8F%8D%E5%B0%84/"}],"author":"LCG"},{"title":"工厂模式","slug":"工厂模式","date":"2022-02-03T00:22:00.000Z","updated":"2022-02-21T13:51:57.851Z","comments":true,"path":"p/177d.html","link":"","permalink":"https://618dt.github.io/p/177d.html","excerpt":"","text":"课程介绍◇ 介绍工厂模式的用途与特点◇ 介绍设计模式◇ 掌握工厂模式的项目应用 设计模式◇ 设计模式是前辈总结的设计经验◇ 设计模式的目标是代码更容易理解,更容易维护◇ 通过设计模式可以让代码更加可靠 设计模式的分类◇ 创建型模式◇ 结构型模式◇ 行为型模式 工厂模式◇ 工厂模式用于隐藏创建对象的细节◇ 工厂模式核心:工厂类(Factory)◇ 工厂模式可细分为简单工厂、工厂方法与抽象工厂 简单工厂 项目应用-i18n国际化◇工程结构◇软件类 123456public class Software &#123; public static void main(String[] args) &#123; I18N i18n = I18NFactory.geI18NObject(&quot;China&quot;);//静态的，不需要new，直接调用方法即可 System.out.println(i18n.getTitle()); &#125;&#125; ◇国际化工厂类 12345678910111213public class I18NFactory &#123; public static I18N geI18NObject(String area) &#123;//静态工厂 if(area.equals(&quot;China&quot;)) &#123; return new Chinese(); &#125;else if(area.equals(&quot;UK&quot;)) &#123; return new English(); &#125;else if(area.equals(&quot;Japan&quot;)) &#123; return new Japanese(); &#125;else &#123; return null; &#125; &#125;&#125; ◇语言类 12345public class Chinese implements I18N &#123; public String getTitle() &#123; return &quot;这是中文&quot;; &#125;&#125; ◇接口 123public interface I18N &#123; public String getTitle();&#125; ◇面向接口的开发 项目应用-多端应用切换◇工程目录◇工厂类 12345678910111213public class DeviceFactory &#123; public static Device getDevice(HttpServletRequest req) &#123; String userAgent=req.getHeader(&quot;user-agent&quot;); System.out.println(userAgent); if(userAgent.indexOf(&quot;Windows NT&quot;)!=-1) &#123; return new DesktopDevice(); &#125;else if(userAgent.indexOf(&quot;iPhone&quot;)!=-1 || userAgent.indexOf(&quot;Android&quot;)!=-1) &#123; return new MobileDevice(); &#125;else &#123; return null; &#125; &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"LCG"},{"title":"Maven项目管理","slug":"Maven项目管理","date":"2022-02-02T23:54:00.000Z","updated":"2022-02-21T13:50:27.158Z","comments":true,"path":"p/316f.html","link":"","permalink":"https://618dt.github.io/p/316f.html","excerpt":"","text":"课程介绍 ◇ 介绍Maven的核心特性 ◇ 掌握Maven的依赖管理 ◇ 掌握Maven的打包方式 Maven介绍 ◇ Maven 是项目管理工具,对软件项目提供构建与依赖管理 ◇ Maven是Apache下的Java开源项目 ◇ Maven为Java项目提供了统一的管理方式，已成为业界标准 Maven核心特性◇ 项目设置遵循统一的规则，保证不同开发环境的兼容性 Maven核心特性◇ 强大的依赖管理，项目依赖组件自动下载、自动更新◇ 可扩展的插件机制，使用简单，功能丰富 Maven的安装与配置Maven的坐标 ◇ GroupId：机构或者团体的英文，采用”逆向域名”形式书写 ◇ ArtifactId：项目名称,说明其用途，例如：cms、oa… ◇ Version：版本号，一般采用”版本+单词”形式，例如：1.0.0.RELEASE Maven项目标准结构 Maven依赖管理◇Maven利用dependency(依赖)自动下载、管理第三发jar◇在pom.xml文件中配置项目依赖的第三方组件◇maven自动将依赖从远程仓库下载至本地仓库，并在工程中引用◇maven中央仓库检索网站◇pinyin4j将汉字转换为拼音 配置 12345&lt;dependency&gt; &lt;groupId&gt;com.belerweb&lt;/groupId&gt; &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt;&lt;/dependency&gt; 代码 12345678public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String str = scan.nextLine(); String[] pinyin = PinyinHelper.toHanyuPinyinStringArray(&#x27;李&#x27;); for(String py : pinyin) &#123; System.out.println(py); &#125; &#125; ◇配置多个jar包:依赖本身也依赖于底层jar包，因此有多个jar包 本地仓库与中央仓库 本地仓库目录 ◇创建备份服务器，提高下载速度 12345678&lt;repositories&gt; &lt;repository&gt; &lt;!-- 创建私服的地址 --&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 项目打包 ◇ Maven可将Java项目打包为jar、war包 ◇ Maven项目打包是通过Plugins（插件）技术实现 ◇ Maven输出Jar包插件：maven-assembly-plugin ◇ 配置文件 123456789101112131415161718192021&lt;build&gt; &lt;!-- 配置插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;mainfest&gt; &lt;mainClass&gt;com.lcg.maven.PinyinTestor&lt;/mainClass&gt; &lt;/mainfest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;!-- all in one 在打包时会将所有引用的jar合并到输出的jar文件中 --&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ◇ 配置运行◇ 打包成功后的运行命令 1java -jar maven-1-1.0.0-RELEASE-jar-with-dependencies.jar Maven构建Web工程◇创建maven项目-&gt;配置JRE：JRE System Library-&gt;properties-&gt;Workspace default JRE-&gt;Apply and Close◇修改JDK编译级别：工程名-&gt;properties-&gt;Java Compiler-&gt;Compiler compliance level(编译级别):1.8-OK◇在src/main目录下创建webapp文件夹◇工程名-&gt;properties-&gt;Project Facets-&gt;Convert to faceted form-&gt;勾选Dynamic Web Module 3.1-&gt;Runtimes:指定Apache Tomcat-&gt;Further configuration available-&gt;Content directory:src/main/webapp-&gt;勾选web.xml-OK-&gt;Apply and Close Web工程打包◇遇见错误：将jar文件复制到工程的WEB-INF/lib目录即可◇配置：RunConfigurations-&gt;MavenBuild-&gt;NewConfiguration-&gt;Name:build-war-&gt;Base directory:指向工程-&gt;Goals:package-&gt;Apply-&gt;Run◇pom.xml 1234567891011121314151617181920212223242526272829&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation= &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lcg&lt;/groupId&gt; &lt;artifactId&gt;maven&lt;/artifactId&gt; &lt;version&gt;1.0.0-RELEASE&lt;/version&gt; &lt;!-- packaging代表输出的格式 --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 自定义解压文件名 --&gt; &lt;build&gt; &lt;finalName&gt;maven-web&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Maven常用命令◇需要配置环境变量◇在cmd中使用 修改本地仓库地址◇打开F:\\JAVA\\tool\\apache-maven-3.6.0\\conf中的settings.xml文件◇修改49-52处的代码 12345678910111213修改前 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; 修改后 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository --&gt; &lt;localRepository&gt;G:/maven-repo&lt;/localRepository&gt; ◇Eclipse中配置：Window-&gt;Preferences-&gt;Maven-&gt;User Settings:选择apache-maven-3.6.0\\conf中的settings.xml文件-&gt;Reindex-Apply and Close 在IDEA中配置Maven◇Settings-&gt;Build,Execution-&gt;Build Tools-&gt;Maven-&gt;Maven home directory: ;User settings file: ;Local repository:◇创建Maven项目：New Project-&gt;Maven-&gt;Next-&gt;GroupID;ArtifactID;Version-&gt;Next-&gt;Finish◇IDEA关于Maven的快捷键:点击右边的Maven弹出界面,即Maven的常用命令","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://618dt.github.io/tags/Maven/"}],"author":"LCG"},{"title":"JDBC入门","slug":"JDBC入门","date":"2022-02-02T23:49:00.000Z","updated":"2022-02-21T13:25:08.233Z","comments":true,"path":"p/8791.html","link":"","permalink":"https://618dt.github.io/p/8791.html","excerpt":"","text":"课程介绍◇JDBC快速入门◇精讲JDBC开发细节◇连接池与JDBC进阶使用 主要知识点◇JDBC使用步骤◇数据库查询方法◇数据库写入方法◇SQL注入攻击的应对◇连接池的使用◇Apache Commons DBUtils 什么是JDBC◇Java数据库连接-Java DataBase Connectivity◇JDBC可让Java通过程序操作关系型数据库◇JDBC基于驱动程序实现与数据库的连接与操作 什么是驱动程序 ◇JDBC驱动程序 JDBC的优点◇统一的API,提供一致的开发过程◇易于学习,容易上手,代码结构稳定◇功能强大,执行效率高,可处理海量数据 JDBC开发简要流程0.Navicat创建数据库：字符集采用utf8mb4 1. 加载并注册JDBC驱动◇将MySQL驱动的jar包复制到工程的lib目录-&gt;File-&gt;Project Structure-&gt;Modules(模块)-&gt;Dependencies(依赖)-&gt;’+’-&gt;1-&gt;选择lib目录下的jar包，OK-&gt;勾选Export-&gt;OK 1Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 2. 创建数据库连接12&quot;jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;, &quot;root&quot;,&quot;www.LCG.com&quot; 3. 创建Statement对象12Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(&quot;select * from employee&quot;); 4. 遍历查询结果123456while (rs.next()) &#123; Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置 String ename = rs.getString(&quot;ename&quot;);//获取ename列的数据（数据为String型），按名称 Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); 5. 关闭连接,释放资源123if (conn!=null&amp;&amp;conn.isClosed()==false)&#123;//防止空指针异常 //5. 关闭连接,释放资源 conn.close();//如果conn为空，则会出现空指针异常，如执行1.就报错后，conn为空&#125; JDBC开发详细流程如何获取JDBC驱动Jar◇Mysql官网下载MySQL Connectors -&gt;JDBC Driver for MySQL-&gt;由于是跨平台的，选择任意版本即可Ubuntu Linux-&gt;直接下载 创建数据库连接代码123456789String dbDriver = &quot;com.mysql.cj.jdbc.Driver&quot;; //JDBC驱动类String dbURL = &quot;jdbc:mysql://localhost:3306/gamest&quot; ; //连接字符串String dbUsername = &quot;root&quot;; //数据库用户名String dbPassword = &quot;123456&quot;; //数据库密码//1.加载并初始化JDBC驱动Class.forName(dbDriver);//2.创建数据库连接Connection connection = DriverManager.getConnection(dbURL, dbUsername, dbPassword); Class.forName的作用◇Class.forName用于加载指定的JDBC驱动类◇Class.forName本质是通知JDBC注册这个驱动类◇驱动由数据库厂商自行开发,连接字符串也不同 数据库与连接字符串 DriverManager◇DriverManager用于注册/管理JDBC驱动程序◇DriverManager.getConnection(连接字符串,用户名,密码)◇返回值Connection对象,对应数据库的物理网络连接 Connection对象◇Connection对象用于JDBC与数据库的网络通信对象◇java.sql.Connection是一个接口，具体由驱动厂商实现◇所有数据库的操作都建立在Connection基础上 MySQL连接字符串◇格式: jdbc:mysql://[主机ip][:端口]/数据库名?参数列表◇主机ip与端口是可选设置,默认值为127.0.0.1与3306◇参数列表采用url编码,格式:参数1=值1&amp;参数2=值2&amp;… MySQL连接字符串常用参数 连接数据库的常见问题◇ClassNotFoundException - 类未找到异常◇Connection refuse - 数据库连接被拒绝异常◇Access denied for user - 用户名与密码错误异常 数据库查询操作◇部分代码 1234567891011121314151617181920212223242526272829303132//4. 遍历查询结果 /*rs.next()返回布尔值，代表是否存在下一条记录，若有，返回true 同时提取下一条记录；如果没有，返回false，循环就会停止*/ while (rs.next())&#123; Integer eno = rs.getInt(1);//JDBC中字段索引从1开始 String ename = rs.getString(&quot;ename&quot;);//获取ename列的数据（数据为String型），按名称 Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); &#125; //5.关闭连接，释放资源 try &#123; if(rs!=null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(stmt!=null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null&amp;&amp;!conn.isClosed())&#123;//不为空并且没有关闭 conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; Statement对象◇Statement是用于执行SQL的工具◇查询方法: ResultSet executeQuery(String sql)◇注意: sql参数必须是SELECT 查询SQL语句 ResultSet对象◇ResultSet结果集对象,保存查询结果◇ResultSet采用迭代方式逐行获取每一行表数据◇每一次迭代,使用ResultSet对象的getXXX()方法获取列数据 SQL注入攻击◇SQL注入攻击是指利用SQL漏洞越权获取数据的黑客行为◇SQL注入攻击根源是未对原始SQL中的敏感字符做特殊处理◇解决方法:放弃Statement改用PreparedStatement处理SQL PreparedStatement◇PreparedStatement 预编译Statement是Statement接口的子接口◇PreparedStatement对SQL进行参数化,预防SQL注入攻击◇PreparedStatement比Statement执行效率更高◇原始代码 123456789// 存在SQL注入风险// pdname值为&#x27; or 1=1 or 1=&#x27;时,所有筛选条件均失效// SQL: select * from employee where pdname=&#x27;&#x27; or 1=1 or 1=&#x27;&#x27; ;单引号没有处理String sql = &quot;select * from employee where dname=&#x27;&quot; + pdname + &quot;&#x27;&quot; ;Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery(sql);while(rs.next())&#123;....&#125; ◇PreparedStatement 12345678910// 利用PreparedStatement预防SQL注入风险// 当dname值为&#x27; or 1=1 or 1=&#x27;时 , 查询不到任何结果// SQL: select * from employee where dname=&#x27;\\&#x27; or 1=1 or 1=\\&#x27;&#x27; ;单引号被处理String sql = &quot;select * from employee where dname=?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1,dname); //设置SQL参数,参数从1开始ResultSet rs = pstmt.executeQuery();while(rs.next())&#123;....&#125; ◇示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.lcg.jdbc.hrapp.command;import java.sql.*;import java.util.Scanner;/** * PreparedStatement对象使用方法 */public class PstmtQueryCommand implements Command &#123; @Override public void execute() &#123; System.out.print(&quot;请输入部门名称：&quot;); Scanner in = new Scanner(System.in); String pdname = in.nextLine(); Connection conn = null; //Statement stmt = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; //1. 加载并注册JDBC驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2. 创建数据库连接 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;); //3. 创建PreparedStatement对象 String sql = &quot;select * from employee where dname=? and eno &gt; ?&quot;; pstmt = conn.prepareStatement(sql); pstmt.setString(1, pdname); //注意:参数索引从1开始 pstmt.setInt(2, 3500);//2,即第二个参数 //结果集 rs = pstmt.executeQuery(); //4. 遍历查询结果 //rs.next()返回布尔值，代表是否存在下一条记录 //如果有，返回true,同时结果集提取下一条记录 //如果没有，返回false，循环就会停止 while (rs.next()) &#123; Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0 String ename = rs.getString(&quot;ename&quot;); Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //5. 关闭连接,释放资源 try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (pstmt != null) &#123; pstmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null &amp;&amp; !conn.isClosed()) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 错误的使用方式◇select * from employee where ?=’abc’◇select * from employee where salary = ?+100◇select ? from employee where ename = ? JDBC实现写数据封装DbUtils工具类◇工具类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DbUtils &#123; /** * 在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板 * 创建新的数据库连接 * @return 新的Connection对象 * @throws SQLException * @throws ClassNotFoundException */ public static Connection getConnection() throws SQLException, ClassNotFoundException &#123; //1. 加载并注册JDBC驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2. 创建数据库连接 Connection conn = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;, &quot;root&quot;, &quot;www.LCG.com&quot; ); return conn; &#125; /** * 关闭连接，释放资源 * @param rs 结果集对象 * @param pstmt Statement对象 * @param conn Connection对象 */ public static void closeConnection(ResultSet rs, PreparedStatement pstmt,Connection conn)&#123; try &#123; if(rs!=null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(pstmt!=null)&#123; pstmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null&amp;&amp;!conn.isClosed())&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDBC执行INSERT语句1234567String sql= &quot;insert into employee(eno,ename) values(?,?)&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setInt(1,10);pstmt.setString(2,&quot;张三&quot;);//executeUpdate方法返回记录数int cnt = pstmt.executeUpdate(); //cnt=1,表示sql语句所影响的数据库的行数System.out.println(&quot;数据新增成功&quot;); ◇新增员工数据 12345678910111213141516171819202122232425262728293031323334public class InsertCommand implements Command&#123; @Override public void execute()&#123; Scanner in = new Scanner(System.in); System.out.println(&quot;请输入员工编号&quot;); int eno = in.nextInt(); System.out.println(&quot;请输入员姓名&quot;); String ename = in.next(); System.out.println(&quot;请输入员工薪资&quot;); float salary = in.nextFloat(); System.out.println(&quot;请输入隶属部门&quot;); String dname = in.next(); Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = DbUtils.getConnection(); String sql = &quot;insert into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;; pstmt = conn.prepareStatement(sql); pstmt.setInt(1, eno); pstmt.setString(2, ename); pstmt.setFloat(3, salary); pstmt.setString(4, dname); int cnt = pstmt.executeUpdate();//所有写操作都使用executeUpdate System.out.println(&quot;cnt:&quot;+cnt); System.out.println(ename+&quot;员工入职手续办理成功&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; DbUtils.closeConnection(null,pstmt,conn); &#125; &#125;&#125; JDBC执行UPDATE语句123456String sql= &quot;update employee set salary=salary + 1000 where dname=?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1,&quot;研发部&quot;);//executeUpdate方法返回记录数int cnt = pstmt.executeUpdate();System.out.println(&quot;研发部&quot; + cnt + &quot;名员工提薪1000元&quot;); JDBC执行DELETE语句123456String sql= &quot;delete from employee where eno = ?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setInt(1, 3395);//executeUpdate方法返回记录数int cnt = pstmt.executeUpdate();System.out.println(cnt+&quot;名员工数据已被删除&quot;); JDBC中的事务管理什么是事务◇事务是以一种可靠的、一致的方式，访问和操作数据库的程序单元◇说人话：要么把事情做完，要么什么都不做，不要做一半◇事务依赖于数据库实现,MySQL通过事务区作为数据缓冲地带 事务的提交操作 事务的回滚操作 JDBC两种事务模式◇JDBC允许两种事务模式◇自动提交事务模式◇手动提交事务模式 自动提交事务模式◇自动提交模式是指每执行一次写操作SQL,自动提交事务◇自动提交开启方法: conn.setAutoCommit(true)◇自动事务是JDBC默认行为,此模式无法保证多数据一致性 手动提交事务模式◇手动提交模式是指显式调用commit()与rollback()方法管理事务◇手动提交开启方法: conn.setAutoCommit(false)◇手动提交事务可保证多数据一致性,但必须手动调用提交/回滚方法 实现批量增加员工1234567891011121314151617181920212223242526272829303132333435363738/** * JDBC中的事务机制 */public class TransactionSample &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = DbUtils.getConnection(); //JDBC默认使用自动提交模式 conn.setAutoCommit(false);//设置手动提交 String sql = &quot;insert into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;; for(int i=100;i&lt;200;i++)&#123;/* if(i==105)&#123; throw new RuntimeException(&quot;插入失败&quot;);//模拟抛出异常 &#125;*/ pstmt = conn.prepareStatement(sql); pstmt.setInt(1,i); pstmt.setString(2, &quot;员工&quot; + i); pstmt.setFloat(3, 5000); pstmt.setString(4, &quot;市场部&quot;); pstmt.executeUpdate(); &#125; conn.commit();//当for循环全部完成后，才开始进行提交 &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; if (conn!=null&amp;&amp;!conn.isClosed()) &#123; conn.rollback();//发生异常回滚 &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; DbUtils.closeConnection(null,pstmt,conn); &#125; &#125;&#125; 基于实体类实现分页数据封装◇实体类代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 员工实体类 */public class Employee &#123; /** * 需符合javabean的要求 * 1.具备默认构造函数 * 2.属性私有 * 3.存在getter与setter */ public Employee()&#123;&#125; private Integer eno; private String ename; private Float salary; private String dname; public Integer getEno() &#123; return eno; &#125; public void setEno(Integer eno) &#123; this.eno = eno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public Float getSalary() &#123; return salary; &#125; public void setSalary(Float salary) &#123; this.salary = salary; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125;&#125; ◇分页命令代码 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 分页查询员工数据 */public class PaginationCommand implements Command &#123; @Override public void execute()&#123; Scanner in = new Scanner(System.in); System.out.println(&quot;请输入页号：&quot;); int page = in.nextInt(); Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; List&lt;Employee&gt; list = new ArrayList();//存储查询结果 try &#123; conn = DbUtils.getConnection(); String sql = &quot;select * from employee limit ?,10&quot;;//10代表从？开始往后取10条记录 pstmt = conn.prepareStatement(sql); pstmt.setInt(1,(page-1)*10);//分页公式 rs = pstmt.executeQuery(); while (rs.next())&#123; Integer eno = rs.getInt(&quot;eno&quot;); String ename = rs.getString(&quot;ename&quot;); Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); Employee emp = new Employee(); emp.setEno(eno); emp.setEname(ename); emp.setSalary(salary); emp.setDname(dname); list.add(emp);//将emp实体加到list集合中 &#125; System.out.println(list.size()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; DbUtils.closeConnection(rs, pstmt, conn); &#125; &#125;&#125; JDBC中Date日期对象的处理◇实体类中添加日期 1234567private Date hiredate;public Date getHiredate() &#123; return hiredate; &#125;public void setHiredata(Date hiredate) &#123; this.hiredate = hiredate; &#125; ◇分页命令添加日期 1234//JDBC获取日期使用java.sql.Date,其继承自java.util.Date//所以两者互相兼容Date hiredata = rs.getDate(&quot;hiredate&quot;); emp.setHiredate(hiredate); ◇向数据库中写入日期时需要使用java.sql.Date 12345678910111213141516System.out.println(&quot;请输入入职日期&quot;); String strHiredate = in.next(); //String 到java.sql.Date分为两步 //1.将String转为java.util.Date SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); java.util.Date udHiredate = null; try &#123; udHiredate = sdf.parse(strHiredate); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; //2.将util转为sql long time = udHiredate.getTime();//获取1970年到现在的毫秒数 java.sql.Date sdHiredate = new java.sql.Date(time); pstmt.setDate(5,sdHiredate);//java.sql.Date JDBC数据批处理◇批处理部分代码 1234567891011pstmt = conn.prepareStatement(sql); for(int i=100000;i&lt;200000;i++)&#123; pstmt.setInt(1,i); pstmt.setString(2, &quot;员工&quot; + i); pstmt.setFloat(3, 5000f); pstmt.setString(4, &quot;市场部&quot;); pstmt.addBatch();//将参数加入批处理任务 //pstmt.executeUpdate(); &#125; pstmt.executeBatch();//执行批处理任务 conn.commit();//当for循环全部完成后，才开始进行提交 ◇批处理效率高的原因：在标准方法中，创建了十万个prepareStatement对象，每一个对象都是新增一条数据；而在批处理方法中，是用一个对象新增十万条数据； 连接池与JDBC进阶使用◇连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用 阿里巴巴Druid连接池◇Druid是阿里巴巴开源连接池组件,是最好的连接池之一◇Druid对数据库连接进行有效管理与重用,最大化程序执行效率◇连接池负责创建管理连接,程序只负责取用与归还 Druid连接池配置与使用◇配置.properties文件 1234567//不需要引号和分号,将初始尺寸和最大尺寸设为一致可便于维护driverClassName=url=username=password=initialSize=10 //初始尺寸:连接池默认创建10个数据库连接maxActive=20 //最大尺寸:数据库不够用时，创建的最大连接数，还不够用则需等待 ◇使用连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Druid连接池配置与使用 */public class DruidSample &#123; public static void main(String[] args) &#123; //1.加载属性文件 Properties properties = new Properties(); //作用：获取当前类(DruidSample)路径下对应文件的路径，因为配置文件会随着代码运行而发布到运行文件夹中 String propertyFile = DruidSample.class.getResource(&quot;/druid-cofig.properties&quot;).getPath(); //在上面获取的路径中getPath方法会进行URL编码:空格-&gt;%20 // 如：原始路径：c:\\java code 转换后的路径：c:\\java%20code; // 使用URLDecoder().decode()方法进行容错，将%20还原为空格 try &#123; propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;); properties.load(new FileInputStream(propertyFile));//加载,load参数为文件流 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; try &#123; //2.获取DataSource数据源对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//DataSource选择sql //3.创建数据库连接 conn = dataSource.getConnection(); psmt = conn.prepareStatement(&quot;select * from employee limit 0,10&quot;); rs = psmt.executeQuery(); while (rs.next()) &#123; Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置 String ename = rs.getString(&quot;ename&quot;);//获取ename列的数据（数据为String型），按名称 Float salary = rs.getFloat(&quot;salary&quot;); String dname = rs.getString(&quot;dname&quot;); System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; /** * 不使用连接池：conn.close()关闭连接 * 使用连接池：conn.close()将连接回收至连接池 */ DbUtils.closeConnection(rs,psmt,conn); &#125; &#125;&#125; 扩展知识:C3P0连接池◇配置文件，使用xml且文件名必须为：c3p0-config.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driveClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;www.LCG.com&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; ◇使用 123456789101112public class C3P0Sample &#123; public static void main(String[] args) &#123; //1.加载配置文件 //2.创建DataSource DataSource dataSource = new ComboPooledDataSource(); //3.得到数据库连接 Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; ..... &#125;&#125; Apache Commons DBUtils◇commons-dbutils是Apache提供的开源JDBC工具类库◇它是对JDBC的简单封装,学习成本极低◇使用commons-dbutils可以极大简化JDBC编码工作量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Apache DBUtils + Druid联合使用 */public class DbUtilsSample &#123; private static void query()&#123; Properties properties = new Properties(); String propertyFile = DruidSample.class.getResource(&quot;/druid-config.properties&quot;).getPath(); try &#123; propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;); properties.load(new FileInputStream(propertyFile)); DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); //利用Apache DbUtils大幅简化了数据的提取过程 /** * BeanListHandler将结果集包装成list对象 * Object[]&#123;1&#125;用来传递参数，这里表示？=1 */ QueryRunner qr = new QueryRunner(dataSource); List&lt;Employee&gt; list = qr.query(&quot;select * from employee limit ?,10&quot;, new BeanListHandler&lt;&gt;(Employee.class), new Object[]&#123;1&#125;); for (Employee emp : list) &#123; System.out.println(emp.getEname()+&quot;--&quot;+emp.getSalary()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;//自动关闭数据库连接 &#125; public static void update()&#123; Properties properties = new Properties(); String propertyFile = DruidSample.class.getResource(&quot;/druid-config.properties&quot;).getPath(); Connection conn = null; try &#123; propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;); properties.load(new FileInputStream(propertyFile)); DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); conn = dataSource.getConnection();//创建连接 conn.setAutoCommit(false);//关闭自动提交 String sql1 = &quot;update employee set salary=salary+10000 where eno=?&quot;; String sql2 = &quot;update employee set salary=salary-1000 where eno=?&quot;; QueryRunner qr = new QueryRunner(); qr.update(conn,sql1,new Object[]&#123;1&#125;); qr.update(conn, sql2, new Object[]&#123;100&#125;); conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; if (conn!=null&amp;&amp;!conn.isClosed())&#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally &#123; try &#123; if(conn!=null&amp;&amp;!conn.isClosed())&#123; conn.close();//对数据库连接进行回收，前面手动创建了连接 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; query(); //update(); &#125;&#125;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java数据库开发基础","slug":"Java数据库/Java数据库开发基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"IDEA开发工具入门","slug":"IntelliJ IDEA开发工具入门","date":"2022-02-02T23:44:00.000Z","updated":"2022-02-21T13:19:13.502Z","comments":true,"path":"p/5708.html","link":"","permalink":"https://618dt.github.io/p/5708.html","excerpt":"","text":"导学◇IntelliJ IDEA开发工具![image.png](IntelliJ IDEA开发工具入门/1627031307362-df459f62-a437-412b-98d4-032af338ced4.png)◇JDBC![image.png](IntelliJ IDEA开发工具入门/1627031379177-38c40c23-926b-4f28-b27e-d9b05895bdf0.png) ◇数据库连接池与DBUtils![image.png](IntelliJ IDEA开发工具入门/1627031423402-2d5357f4-8868-460e-bdf3-e131bba797d5.png) IDEA开发工具入门IntelliJ IDEA◇IDEA全称IntelliJ IDEA ,是Java编程公认的最好的IDE◇IDEA提供了大量的智能工具，例如语法提示，代码分析，格式化等◇IDEA最核心的特色是它的快捷键，利用快捷键可以极大提高开发效率 IDEA的特点◇沉浸式开发体验◇超强的快捷键体系◇智能的代码助手◇全栈开发环境◇丰富的模板支持 IDEA快捷键IDEA窗口快捷键◇Find Action即模糊查询所有的功能![image.png](IntelliJ IDEA开发工具入门/1627034483641-291f75af-d7ad-48a5-a4d5-fd4466b7a384.png) 代码快捷键![image.png](IntelliJ IDEA开发工具入门/1627035810111-7868b20d-b5b8-44c3-b520-f7fe08cb09e9.png)![image.png](IntelliJ IDEA开发工具入门/1627035825273-6cfd6292-c04a-4cfa-ac9a-38797269ca46.png) 代码快速定位![image.png](IntelliJ IDEA开发工具入门/1627045126097-c1703455-f245-4358-b636-0bebf19ac62e.png) Live Template◇也可以自定义，自定义方法为：settings-&gt;Editor-&gt;Live Template-&gt;’+’ 2-&gt;’+’1;​ ![image.png](IntelliJ IDEA开发工具入门/1627045672656-22d16bcf-8e69-4516-9915-68c68efec231.png) 运行与打包◇打包方法：File-&gt;Project Structure-&gt;Artifacts-&gt;’+’ -&gt;JAR-&gt;empty-&gt;Create Manifest(定义入口类)-&gt;默认选中-&gt;OK-&gt;选择入口类-&gt;将右侧的compile output双击添加到左侧(即将编译后的类打入JAR包)-&gt;OK-&gt;.MF文件创建成功-&gt;Build-&gt;Build Artifacts -&gt;Action:Bulid-&gt;生成jar包在生成的jar包上右键选中Open in File path( Show in explore在文件管理器中打开)-&gt;在地址栏中删掉地址然后直接输入cmd进入命令行(会自动定位到目录地址)-&gt;键入java -jar 文件名.jar![image.png](IntelliJ IDEA开发工具入门/1627046432804-188ee97a-c21c-4cd5-b9b4-fa4f47c59270.png) 其他快捷键◇查看方法返回类型：Ctrl+q◇查看方法的具体实现：Ctrl+Alt◇方法或类注释：在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板 IDEA开发Web应用◇NewProjece-&gt; Java Enterprise -&gt;服务器选择Tomcat -&gt;勾选WebApplication 3.1-&gt;勾选create web.xml-&gt;Next-&gt;输入工程名称-&gt;finish;◇如何更改URL的上下文路径: 点击Tomcat下拉框-&gt;Edit Configurations -&gt;Deployment-&gt;Application context-&gt;修改-&gt;OK◇热部署(即修改项目后在浏览器能直接查看，只支持在DeBug模式下)：点击Tomcat下拉框-&gt;Edit Configurations -&gt;Server-&gt;On frame deactivation-&gt;Update classes and resources-&gt;OK◇打包Web项目：File-&gt;Project Structure-&gt;Artifacts-&gt;’+’Web Application:Archive-&gt;Empty-&gt;双击compile output添加到左侧war包中-&gt;双击Web facet resource将静态资源放入左侧-&gt;OK-&gt;Build-&gt;Build Artifact -&gt;选择打包文件-&gt;Build -&gt;复制.war文件将其放到Tomcat实际运行环境的webapps目录下-&gt;在Tomcat/bin目录中双击startup.bat文件启动Tomcat-&gt;浏览器输入路径即可![image.png](IntelliJ IDEA开发工具入门/1627096260390-f697c0eb-8644-4516-bc22-fa9ba432d2e0.png)","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java数据库开发基础","slug":"Java数据库/Java数据库开发基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://618dt.github.io/tags/%E5%BC%80%E5%8F%91/"}],"author":"LCG"},{"title":"MySQL综合应用","slug":"MySQL综合应用","date":"2022-01-28T05:44:00.000Z","updated":"2022-02-21T12:48:36.337Z","comments":true,"path":"p/c9e2.html","link":"","permalink":"https://618dt.github.io/p/c9e2.html","excerpt":"","text":"数据库的事务机制避免写入直接操作数据文件 ◇ 如果数据的写入直接操作数据文件是非常危险的事情 利用日志来实现间接写入◇ MySQL总共有5种日志，其中只有redo(重做)日志和undo(撤销)日志与事务有关 事务机制（Transaction）◇ RDBMS = SQL语句 + 事务（ACID）◇ 事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要 么全都执行失败 事务案例◇ 把10部门中MANGER员工调往20部门，其他岗位的员工调往30部门，然后删除10部门 管理事务◇ 默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务◇ 为了让多条SQL语句纳入到一个事务之下，可以手动管理事务 123START TRANSACTION ;//开启事务SQL语句[ COMMIT | ROLLBACK ] ;//提交|回滚 事务的ACID属性 事务的原子性◇ 一个事务中的所有操作要么全部完成，要么全部失败。事务执行后 ，不允许停留在中间某个状态 事务的一致性◇ 不管在任何给定的时间、并发事务有多少，事务必须保证运行结果 的一致性◇ 事务可以并发执行，但是最终MySQL却串行执行 事务的隔离性◇ 隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务是数据库唯一运行的事物◇ 默认情况下A事务，只能看到日志中该事务的相关数据 事务的持久性 ◇事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化 事务的四个隔离级别 修改事务隔离级别◇在Navicat中开启两个sql面板可以模拟两个不同的事务；Mysql默认的隔离级别是REPEATABLE READ◇ READ UNCOMMITTED 代表可以读取其他事务未提交的数据 12SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; ◇ READ COMMITTED 代表只能读取其他事务提交的数据 12SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; ◇ REPEATABLE READ 代表事务在执行中反复读取数据，得到的结果是一致的，不会受其他事务影响 12SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; 业务案例①比如说购票场景里面，由于事务之间是隔离的，所以A、B两事务分别对第一条记录进行操作；A事务修改将其改为已售出，但是A事务未进行提交，因此真实的数据还是未售出状态；B事务将其改为已售出，并且很快进行提交；那么当A进行提交时，发现记录变成了已售出，就会发生回滚，即修改失败；虽然说没有产生有歧义的数据，但是动不动就购票失败，十分影响用户体验；因此在这个场景下我们应当允许事务去读取其他事务的临时状态；B事务可以看到A事务里的临时信息，即修改了第一条记录，但未提交；那么B就无法修改此记录；就不会引发数据冲突了；所以这里使用的隔离级别为:READ UNCOMMITTED②对于银行转账之类的业务场景；就只能让当前事务去读取其他事务已经提交的数据，而不能够去读取其他事务的临时数据;比如说下面的Scott账户，假设B事务执行，需要支出100元，但是还没有提交；而这时A事务进行转账操作，由于可以看到B事务的临时数据，所以A事务看到Scott账户为4900元，提交后，账户变为5900元；但如果B事务由于某些原因回滚的话，原来的操作无效；而此时账户余额却是4900元，凭空少了100元；因此这种场景必须使用READ COMMITTED隔离级别；③又如，A事务进行某商品的下单购票后未提交事务，但是B事务确将商品价格提高了；那么此时A事务应该根据原价购买；所以隔离级别使用REPEATABLE READ；即不受其他任何事务的影响，无论其他事务提交与否； 事务的序列化◇ 由于事务并发执行所带来的各种问题，前三种隔离级别只适用在某些业务场景中，但是序列化的隔离性，只有前面的会话结束后(事务提交后)才能执行下一个事务，即让事务逐一执行，不能够并发地执行事务；但是这样会大大降低数据库的并发能力，所以不太常用； 12SET SESSION TRANSACTION ISOLATION LEVELSERIALIZABLE; 数据导入与导出数据导出与备份的区别◇ 数据导出，导出的纯粹是业务数据◇ 数据备份，备份的是数据文件、日志文件、索引文件等等 数据导出的分类 导出SQL文件◇ mysqldump用来把业务数据导出成SQL文件，其中也包括了表结构 1mysqldump -uroot -p [ no-data ] 逻辑库 &gt; 路径 ◇ 如果业务数据非常多，建议只导出表结构，然后用SELECT INTO OUTFILE把数据导出成文本文档 导入SQL文件◇ source命令用于导入SQL文件，包括创建数据表，写入记录等 12sql &gt; USE demo ;sql &gt; SOURCE backup.sql ;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"}],"author":"LCG"},{"title":"MySQL基本函数","slug":"MySQL基本函数","date":"2022-01-28T05:42:00.000Z","updated":"2022-02-21T12:45:54.506Z","comments":true,"path":"p/8500.html","link":"","permalink":"https://618dt.github.io/p/8500.html","excerpt":"","text":"MySQL的函数 ◇像编程语言利用函数封装业务功能一样，数据库也把一些复杂的功能封装到函数里，供使用者调用 ◇也可以自定义函数 数字函数数字函数（一） 数字函数（二）◇三角函数的参数为弧度 日期函数获取系统时间函数◇NOW()函数能获得系统日期和时间，格式yyyy-MM-dd hh:mm:ss◇CURDATE()函数能获得当前系统日期，格式yyyy-MM-dd◇CURTIME()函数能获得当前系统时间，格式hh:mm:ss 日期格式化函数◇ DATE_FORMAT()函数用于格式化日期，返回用户想要的日期格式 1234DATE_FORMAT( 日期, 表达式)SELECT ename,DATE_FORMAT(hiredate,&quot;%Y&quot;)//获取年份的格式DATE_FORMAT(hiredate,&quot;%Y/%m%d&quot;) //返回2021/07/20这种格式FROM t_emp; 日期计算的注意事项◇ MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减 日期偏移计算 ◇ DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活 1234DATE_ADD( 日期 , INTERVAL 偏移量 时间单位 )SELECT DATE_ADD(NOW(),INTERVAL 15 DAY);SELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE); 计算日期之间相隔的天数◇ DATEDIFF()函数用来计算两个日期之间相差的天数 1DATEDIFF ( 日期 , 日期 ) 课堂练习◇ 利用日期函数，查询明年你的生日是星期几？ 1SELECT DATE_FORMAT(&quot;2020-02-19&quot;,&quot;%w&quot;) ◇ 利用日期函数，查询1981年上半年入职的员工有多少人？ 123SELECT COUNT(*) FROM t_empWHERE DATE_FORMAT(hiredate,&quot;%Y&quot;)=1981AND DATE_FORMAT(hiredate,&quot;%m&quot;)&lt;=6; 字符函数字符函数（一）◇INSERT(“ABC”,1,0,”DE”)数字1表示从前面的字符串ABC的第一个位置插入后面的字符串DE，0表示替换从插入位置起的0个字符；◇REPLACE() 的第二个参数表示被替换的内容，最后一个参数表示替换的内容 字符函数（二）◇截取字符串起始位置从1开始◇填充字符函数第二个参数表示填充到多少字符，而不是填充多少字符； 课堂练习◇将某人的姓名的名用替代 eg: 欧* 1SELECT RPAD(SUBSTRING(&quot;欧宝玉&quot;,1,1),LENGTH(&quot;欧宝玉&quot;)/3,&quot;*&quot;); 条件函数◇ SQL语句中可以利用条件函数来实现编程语言里的条件判断 12IFNULL( 表达式 , 值 )IF( 表达式 , 值1 , 值2 )//如果满足表达式则是值1，否则是值2 条件语句 ◇ 复杂的条件判断可以用条件语句来实现，比IF语句功能更强大 1234CASEWHEN 表达式 THEN 值1 ,WHEN 表达式 THEN 值2 , …… , ELSE 值NEND 课堂练习◇ 中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B， 打印每名员工获得的礼品。 123SELECT FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno,IF(d.dname=&quot;SALES&quot;,&quot;礼品A&quot;,&quot;礼品B&quot;)FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno; ◇ 公司年庆决定组织员工集体旅游，每个部门旅游目的地是不同的。SALES部门去P1地点，ACCOUNTING部门去P2地点 ，RESEARCH部门去P3地点，查询每名员工的旅行地点。 123456789SELECT e.empno,e.ename, CASE WHEN d.dname=&quot;SALES&quot; THEN &quot;P1&quot; WHEN d.dname=&quot;ACCOUNTING&quot; THEN &quot;P2&quot; WHEN d.dname=&quot;RESEARCH&quot; THEN &quot;P3&quot; END AS placeFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno ◇ 公司决定为员工调整基本工资，具体调整方案如下： 1234567891011121314UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptnoLEFT JOIN (SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) tON e.deptno=t.deptnoSET sal=(CASE WHEN d.dname=&quot;SALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&gt;=20 THEN e.sal*1.1 WHEN d.dname=&quot;SALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&lt;20 THEN e.sal*1.05 WHEN d.dname=&quot;ACCOUNTING&quot; THEN e.sal+300 WHEN d.dname=&quot;RESEARCH&quot; AND e.sal&lt;t.avg THEN e.sal+200 WHEN e.deptno IS NULL THEN e.sal+100 END);","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"}],"author":"LCG"},{"title":"MySQL基本操作","slug":"MySQL基本操作","date":"2022-01-28T05:38:00.000Z","updated":"2022-02-21T12:43:54.711Z","comments":true,"path":"p/a881.html","link":"","permalink":"https://618dt.github.io/p/a881.html","excerpt":"","text":"数据操作语言：INSERT语句INSERT语句 ◇ INSERT语句可以向数据表写入记录，可以是一条记录，也可以是多条记录 1234INSERT INTO 表名 ( 字段1, 字段2, …… ) VALUES ( 值1, 值2, …… ) ;INSERT INTO 表名 ( 字段1, 字段2, …… ) VALUES ( 值1, 值2, …… ) , ( 值1, 值2, …… ) ;//插入多条记录 INSERT语句方言 ◇ MYSQL的INSERT语句还有一种方言语法 1INSERT INTO 表名 SET 字段1=值1, 字段2=值2, …… ; IGNORE关键字 ◇ IGNORE关键字会让INSERT只插入数据库不存在的记录 1INSERT [ IGNORE ] INTO 表名 …… ; INSERT中的子查询◇ INSERT语句中可以包含子查询语句，代表把子查询的内容写入到数据表◇ 把人数超过5人的部门记录拷贝到新的部门表 1234567CREATE TABLE t_dept_new LIKE t_dept;INSERT INTO t_dept_new(deptno,dname,loc)(SELECT d.deptno,d.dname,d.loc FROM t_dept d JOIN(SELECT deptno FROM t_emp GROUP BY deptnoHAVING COUNT(*)&gt;=5) tempON d.deptno = temp.deptno); 数据操作语言：UPDATE语句UPDATE语句 ◇ UPDATE语句用于修改表的记录 123456//&quot;IGNORE&quot;关键字在UPDATE语句中表示忽略修改数据时遇到冲突的记录，把不冲突的记录写到数据表里UPDATE [ IGNORE ] 表名SET 字段1=值1, 字段2=值2, ……[ WHERE 条件1, 条件2, …… ] [ ORDER BY …… ] //排序，如果需要将员工编号+1的话，可以先进行降序否则可能引发主键冲突[ LIMIT …… ] //取分页数据 UPDATE语句的表连接◇ 因为WHERE子句中的子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句 12UPDATE 表1 JOIN 表2 ON 条件SET 字段1 = 值1 , 字段2 = 值2 , …… ; ◇ 表连接的UPDATE语句可以修改多张表的记录◇ UPDATE语句的表连接可以演变成下面的样子 123UPDATE 表1 , 表2SET 字段1 = 值1 , 字段2 = 值2 , ……WHERE 连接条件 ; ◇ UPDATE语句的表连接既可以是内连接，又可以是外连接 12UPDATE 表1 [ LEFT | RIGHT ] JOIN 表2 ON 条件SET 字段1 = 值1 , 字段2 = 值2 , …… ; ◇ 把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门 123UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptnoSET e.deptno=20WHERE e.deptno IS NULL OR (d.dname=&quot;SALES&quot; AND e.sal&lt;2000); 课堂练习◇ 把每个员工的编号和上司的编号+1，用ORDER BY子句完成 12UPDATE t_emp SET empno=empno+1,mgr=mgr+1ORDER BY empno DESC ◇ 把月收入前三名的员工底薪减100元，用LIMIT子句完成 123UPDATE t_emp SET sal=sal-100ORDER BY sal+IFNULL(comm,0) DESCLIMIT 3; ◇ 把ALLEN调往RESEARCH部门，职务调整为ANALYST //牵扯到两张表1234//这里不能写连接条件(ON e.deptno=d.deptno)，因为会将A锁定到R部门UPDATE t_emp e JOIN t_dept d SET e.deptno=d.deptno,e.job=&quot;ANALYST&quot;WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot; ◇ 把底薪低于公司平均底薪的员工，底薪增加150元 1234UPDATE t_emp e JOIN(SELECT AVG(sal) AS avg FROM t_emp) t//子查询结果集ON e.sal&lt;t.avgSET e.sal=e.sal+150; 数据操作语言：DELETE语句DELETE语句◇ DELETE语句用于删除记录，语法如下： 1234DELETE [ IGNORE ] FROM 表名//IGNORE:能删则删，不能删则忽略，不会报错[ WHERE 条件1, 条件2, …… ][ ORDER BY …… ] [ LIMIT …… ] ; DELETE语句的表连接◇ 因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造DELETE语句 1234DELETE 表1 , …… FROM 表1 JOIN 表2 ON 条件[ WHERE 条件1 , 条件2 , …… ] [ ORDER BY …… ] [ LIMIT …… ] ; ◇ DELETE语句的表连接既可以是内连接，又可以是外连接 12DELETE 表1 , …… FROM 表1 [ LEFT | RIGHT ] JOIN 表2 ON 条件 …… ; ◇ 删除SALES部门的员工，以及没有部门的员工。 123DELETE eFROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptnoWHERE d.dneme=&quot;SALES&quot; OR e.deptno IS NULL 快速删除数据表全部记录◇ DELETE语句是在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里，然后再删除记录。◇ TRUNCATE语句在事务机制之外删除记录，速度远超过DELETE语句 1TRUNCATE TABLE 表名 ; 课堂练习◇ 删除10部门中，工龄超过20年的员工记录 12DELETE FROM t_empWHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365 ◇ 删除20部门中工资最高的员工记录 1234DELETE FROM t_empWHERE deptno=20ORDER BY sal+IFNULL(comm,0) DESCLIMIT 1; ◇ 删除SALES部门和该部门的全部员工记录 123DELETE e,dFROM t_emp e JOIN t_dept d ON e.deptno=d.deptnoWHERE d.dname=&quot;SALES&quot;; ◇ 删除每个低于部门平均底薪的员工记录 1234DELETE eFROM t_emp e JOIN (SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) tON e.deptno = t.deptno AND e.sal&lt;t.avg ◇ 删除员工KING和他的直接下属的员工记录，用表连接实现。 1234DELETE eFROM t_emp e JOIN (SELECT empno FROM t_emp WHERE ename=&quot;KING&quot;) t//结果集里的数据不能删ON e.mgr=t.empno OR e.empno=t.empno;","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"}],"author":"LCG"},{"title":"SQL简介","slug":"SQL简介","date":"2022-01-28T05:38:00.000Z","updated":"2022-02-21T12:31:34.024Z","comments":true,"path":"p/a804.html","link":"","permalink":"https://618dt.github.io/p/a804.html","excerpt":"","text":"学习目标◇ 管理逻辑库和数据表 创建、删除、修改逻辑库和数据表◇ 了解常用的数据类型和约束 字符串、整数、浮点数、精确数字、日期、枚举。主键约束、非空 约束、唯一约束、外键约束等◇ 掌握索引运行机制和使用原则 排序为什么可以提高数据检索速度？怎么创建和删除索引？什么条 件下使用索引？ 什么是SQL语言 ？◇ SQL 是用于访问和处理数据的标准的计算机语言 SQL语言分类 SQL语句注意事项◇ SQL语句不区分大小写，但是字符串区分大小写◇ SQL语句必须以分号结尾◇ SQL语句中的空白和换行没有限制，但是不能破坏语法 SQL语句的注释◇ SQL语句的注释有两种，分别如下： #这是一段注释/这是另一段注释/ 创建逻辑库 创建数据表12345CREATE TABLE 数据表 (列名1 数据类型 [ 约束 ] [COMMENT 注释] ,列名2 数据类型 [ 约束 ] [COMMENT 注释] , ……) [ COMMENT = 注释 ] ;DROP TABLE 数据表 ; 1234567CREATE TABLE student (id INT UNSIGNED PRIMARY KEY ,name VARCHAR(20) NOT NULL , sex CHAR(1) NOT NULL ,birthday DATE NOT NULL ,tel CHAR(11) NOT NULL ,remark VARCHAR(200)); 数据表的其他操作1234SHOW tables ;DESC student ; //查看表的结构SHOW CREATE TABLE student ;DROP TABLE student ; 数据定义语言：数据类型数据类型：数字◇DECIMAL相当于用字符来保存数字，所以不存在精度的丢失；参数10表示整数+小数为十位参数2表示精确到小数点后两位 不精确的浮点数◇ 十进制的浮点数无法在计算机中用二进制精确表达 数据类型：字符串 数据类型：日期类型 数据定义语言：修改表结构添加字段123ALTER TABLE 表名称ADD 列1 数据类型 [ 约束 ] [COMMENT 注释] , ADD 列2 数据类型 [ 约束 ] [COMMENT 注释] ,…… ; 修改字段类型和约束123ALTER TABLE 表名称MODIFY 列1 数据类型 [ 约束 ] [COMMENT 注释] , MODIFY 列2 数据类型 [ 约束 ] [COMMENT 注释] ,…… ; 修改字段名称1234ALTER TABLE 表名称CHANGE 列1 新列名1 数据类型 [ 约束 ] [COMMENT 注释] ,CHANGE 列2 新列名2 数据类型 [ 约束 ] [COMMENT 注释] ,…… ; 删除字段1234ALTER TABLE 表名称DROP 列1 ,DROP 列2 ，…… ; 修改表名1ALTER TABLE 表名 RENAME 新表名","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库的高级查询","slug":"数据库的高级查询","date":"2022-01-28T05:35:00.000Z","updated":"2022-02-21T12:42:18.041Z","comments":true,"path":"p/1648.html","link":"","permalink":"https://618dt.github.io/p/1648.html","excerpt":"","text":"数据操作语言：聚合函数什么是聚合函数◇ 聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对数 据求和、求最大值和最小值、求平均值等等。◇ 求公司员工的平均月收入是多少？ 1SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp; SUM函数 ◇ SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0 ，日期类型统计结果是毫秒数相加 ◇ SUM函数求和会排除NULL值 MAX函数 ◇ MAX函数用于获得非空值的最大值。 ◇ 问题1：查询10和20部门中，月收入最高的员工？ 12SELECT MAX(sal+IFNULL(comm,0)) FROM t_empWHERE deptno IN(10,20); ◇ 问题2：查询员工名字最长的是几个字符？ 1SELECT MAX(LENGTH(ename)) FROM t_emp; MIN函数 ◇ MIN函数用于获得非空值的最小值。 AVG函数 ◇ AVG函数用于获得非空值的平均值，非数字数据统计结果为0 COUNT函数 ◇ COUNT(*)用于获得包含空值的记录数，COUNT(列名)用于获得包 含非空值的记录数。 ◇ 查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数？ 123SELECT COUNT(*) FROM t_empWHERE deptno IN(10,20) AND sal&gt;=2000AND DATEDIFF(NOW(),hiredate)/365&gt;=15; //DATEDIFF指相差的天数 ◇ 查询1985年以后入职的员工，底薪超过公司平均底薪的员工数量？ 123SELECT COUNT(*) FROM t_empWHERE hiredate&gt;=&quot;1985-01-01&quot;AND sal&gt;AVG(sal);//WHERE 子句不能有聚合函数，这里是错误的？ 数据操作语言：分组查询为什么要分组？ ◇ 默认情况下汇总函数是对全表范围内的数据做统计 ◇ GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干 个小的区域，然后针对每个小区域分别进行数据汇总处理 逐级分组 ◇ 数据库支持多列分组条件，执行的时候逐级分组。 ◇ 查询每个部门里，每种职位的人员数量和平均底薪 对SELECT子句的要求 ◇ 查询语句中如果含有GROUP BY子句，那么SELECT子句中的内容就 必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在SELECT子句中如下sql语句就是错误的： 12SELECT deptno,COUNT(*),AVG(sal),sal //sal字段并不是GROUP BY子句的分组列FROM t_emp GROUP BY deptno; 对分组结果集再次做汇总计算12SELECT deptno,COUNT(*),AVG(sal),MAX(sal),MIN(sal)FROM t_emp GROUP BY deptno WITH ROLLUP; GROUP_CONCAT函数 ◇ GROUP_CONCAT函数可以把分组查询中的某个字段拼接成一个字符串 ◇ 查询每个部门内底薪超过2000元的人数和员工姓名 123SELECT deptno,GROUP_CONCAT(ename),COUNT(*)FROM t_emp WHERE sal&gt;=2000GROUP BY deptno; 各种子句的执行顺序 ◇ 查询语句中，GROUP BY子句应该第几个执行？FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT 数据操作语言：HAVING子句分组查询遇到的困难？ ◇ 查询部门平均底薪超过2000元的部门编号 ◇ 因为WHERE子句先于GROUP BY执行，一旦WHERE子句中出现了 汇总函数，数据库根本不知道按照什么范围计算汇总值 HAVING子句的用途 ◇ 可以将聚集函数写在HAVING子句中 ◇ 查询每个部门中，1982年以后入职的员工超过2个人的部门编号 1234SELECT deptno FROM t_empWHERE hiredate&gt;=&quot;1982-01-01&quot;GROUP BY deptno HAVING COUNT(*)&gt;=2;ORDER BY deptno ASC HAVING子句的特殊用法 ◇ 按照数字1分组，MySQL会依据SELECT子句中的列进行分组， HAVING子句也可以正常使用 12345SELECT deptno,COUNT(*), FROM t_empGROUP BY 1;SELECT deptno,COUNT(*), FROM t_empGROUP BY 1 HAVING deptno IN (10,20); 数据操作语言：表连接查询从多张表中提取数据 ◇ 从多张表中提取数据，必须指定关联的条件。如果不定义关联条件 就会出现无条件连接，两张表的数据会交叉连接，产生笛卡尔积。 ◇ 规定了连接条件的表连接语句，就不会出现笛卡尔积 表连接的分类 ◇ 表连接分为两种：内连接和外连接 ◇ 内连接是结果集中只保留符合连接条件的记录 ◇ 外连接是不管符不符合连接条件，记录都要保留在结果集中 内连接的简介 ◇ 内连接是最常见的一种表连接，用于查询多张关系表符合连接条件 的记录。INNER关键字可省略 内连接的多种语法形式123SELECT …… FROM 表1 JOIN 表2 ON 连接条件 ;SELECT …… FROM 表1 JOIN 表2 WHERE 连接条件 ;SELECT …… FROM 表1 , 表2 WHERE 连接条件 ;//常用 内连接练习 ◇ 查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级？ 123SELECT e.empno,e.ename,d.deptno,e.sal,e.job,s.gradeFROM t_emp e,t_dept d,t_salgrade s WHERE e.deptno=d.deptno AND e.sal BETWEEN s.losal AND s.hisal; ◇ 内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以 ◇ 相同的数据表也可以做表连接 ◇ 结果集也可以作为一张“表”来跟其他表连接 为什么要使用外连接 ◇ 如果说陈浩是一名临时人员，没有固定的部门编制，那么我们想查询每名员工和他的部门名称，用内连接就会漏掉陈浩，所以要引入外连接的语法才能解决这个问题 外连接简介 ◇ 外连接与内连接的区别在于，除了符合条件的记录之外，结果集中 还会保留不符合条件的记录。 左连接和右连接 ◇ 左外连接就是保留左表所有的记录，与右表做连接。如果右表有符 合条件的记录就与左表连接。如果右表没有符合条件的记录，就用 NULL与左表连接。右外连接也是如此。 外连接练习 ◇ 查询每个部门的名称和部门的人数？ 1234SELECT d.dname,COUNT(e.deptno)//忽略右表(t_emp)的NULL记录FROM t_dept d LEFT JOIN t_emp e //保留左表(t_dept)的所有记录ON d.deptno=e.deptnoGROUP BY d.deptno; ◇结果： ◇ 查询每个部门的名称和部门的人数？如果没有部门的员工，部门名称用NULL代替。 123456789(SELECT d.dname,COUNT(e.deptno)FROM t_dept d LEFT JOIN t_emp e ON d.deptno=e.deptnoGROUP BY d.deptno ) UNION //使用UNION关键字进行左外连接和右外连接的合并(SELECT d.dname,COUNT(*) //保留所有有效记录FROM t_dept d RIGHT JOIN t_emp e ON d.deptno=e.deptnoGROUP BY d.deptno ) ◇结果： ◇ 查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司 编号、上司姓名、上司部门？ 12345678SELECT e1.empno AS &#x27;编号&#x27;,e1.ename AS &#x27;姓名&#x27;,d1.dname AS &#x27;部门&#x27;,e1.sal+IFNULL(e1.comm,0) AS &#x27;薪水&#x27;,t.grade AS &#x27;薪资等级&#x27;,FLOOR(DATEDIFF(NOW(),e1.hiredate)/365) AS &#x27;工龄&#x27;,e1.mgr AS &#x27;上司编号&#x27;,e2.ename AS &#x27;上司姓名&#x27;,d2.dname AS &#x27;上司部门&#x27; FROM t_emp e1 LEFT JOIN t_dept d1 ON e1.deptno=d1.deptnoLEFT JOIN t_emp e2 ON e1.mgr=e2.empnoLEFT JOIN t_salgrade t ON e1.sal BETWEEN t.losal AND t.hisalLEFT JOIN t_dept d2 ON e2.deptno=d2.deptno; ◇结果： ◇ UNION关键字可以将多个查询语句的结果集进行合并 ,结果集字段名称、个数需要相同 1( 查询语句 ) UNION ( 查询语句 ) UNION ( 查询语句 ) …… 外连接的注意事项 ◇ 内连接只保留符合条件的记录，所以查询条件写在ON子句和 WHERE子句中的效果是相同的。但是外连接里，条件写在WHERE 子句里，不合符条件的记录是会被过滤掉的,而不是保留下来。①使用ON子句 1234SELECT e.ename,d,dname,d.deptnoFROM t_emp eLEFT JOIN t_dept d ON e.deptno = d.deptnoAND e.deptno=10; 结果： 发现所有记录都被保留，但不符合条件的记录为空②使用WHERE子句 1234SELECT e.ename,d,dname,d.deptnoFROM t_emp eLEFT JOIN t_dept d ON e.deptno = d.deptnoWHERE e.deptno=10; 结果： 数据操作语言：子查询子查询简介 ◇ 子查询是一种查询中嵌套查询的语句 ◇ 查询底薪超过公司平均底薪的员工的信息 123SELECT empno,ename,salFROM t_empWHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); 子查询的分类 ◇ 子查询可以写在三个地方：WHERE子句、FROM子句、SELECT子 句，但是只有FROM子句子查询是最可取的 WHERE子查询 ◇ 这种子查询最简单，最容易理解，但是却是效率很低的子查询 ◇ 查询底薪超过公司平均底薪的员工的信息 用表连接替代WHERE子查询 ◇ 表连接的优点是子查询只执行一次，查询效率特别高 12345SELECT e2.empno,e2.enameFROM t_emp e1 JOIN t_emp e2ON e1.deptno = e2.deptnoAND e2.ename!=&quot;FORD&quot;AND e1.ename=&quot;FORD&quot;; FROM子查询 ◇ 这种子查询只会执行一次，所以查询效率很高，把子查询写在FROM子句中 ◇ 查询底薪超过公司平均底薪的员工的信息 123456SELECT e.empno,e.ename,e.sal,t.avgFROM t_emp e JOIN (SELECT deptno,AVG(sal) as avgFROM t_emp GROUP BY deptno) tON e.deptno=t.deptno AND e.sal&gt;=t.avg; SELECT子查询 ◇ 这种子查询每输出一条记录的时候都要执行一次，查询效率很低 12SELECT e.empno,e.ename,(SELECT dname FROM t_dept WHERE deptno=e.deptno)FROM t_emp e; 相关子查询◇ 查询语句执行的时候要多次的依赖于子查询的结果，这类子查询被 称作相关子查询◇ WHERE子查询和SELECT子查询都属于相关子查询◇ 因为相关子查询要反复多次执行，所以应该避免使用 单行子查询和多行子查询◇ 单行子查询的结果集只有一条记录，多行子查询结果集有多行记录◇ 多行子查询只能出现在WHERE子句和FROM子句中◇ 子查询一般先写出子查询语句◇ 如何用子查询查找FORD和MARTIN两个人的同事？ 123456SELECT FROM t_empWHERE deptno IN //这里子查询结果集为多行记录，所以不能用&quot;=&quot;,而用&quot;IN&quot;表示等于其中一条记录即可(SELECT deptno FROM t_emp WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;))AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;); WHERE子句中的多行子查询◇ WHERE子句中，可以使用IN、ALL、ANY、EXISTS关键字来处理多行表达式结果集的条件判断◇ 查询比FORD和MARTIN底薪都高的员工信息？ 12345SELECT enameFROM t_empWHERE sal&gt;=ALL(SELECT sal FROM t_emp WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;))AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;); EXISTS关键字 ◇ EXISTS关键字是把原来在子查询之外的条件判断，写到了子查询的里面。 1SELECT …… FROM 表名 WHERE [NOT] EXISTS ( 子查询 ) ; ◇ 查询工资等级3和4级的员工信息？ 1234567SELECT empno,ename,salFROM t_empWHERE EXISTS(SELECT grade FROM t_salgradeWHERE sal BETWEEN losal AND hisalAND grade IN(3,4));","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库的基本查询","slug":"数据库的基本查询","date":"2022-01-28T05:33:00.000Z","updated":"2022-02-21T12:36:04.014Z","comments":true,"path":"p/f427.html","link":"","permalink":"https://618dt.github.io/p/f427.html","excerpt":"","text":"数据操作语言：普通查询记录查询◇ 最基本的查询语句是由 SELECT 和 FROM 关键字组成的◇ SELECT语句屏蔽了物理层的操作，用户不必关心数据的真 实存储，交由数据库高效的查找数据 12SELECT * FROM t_student;SELECT id,name,sex FROM t_student; 使用列别名◇ 通常情况下，SELECT子句中使用了表达式，那么这列的名 字就默认为表达式，因此需要一种对列名重命名的机制 12345SELECT ename, sal * 12 AS &quot;annual_salary&quot; FROM emp; ◇ 重命名只在显示输出的时候使用，数据表列名不会真的改变◇ 查询语句的子句执行顺序 数据操作语言：数据分页数据分页◇ 比如我们查看朋友圈，只会加载少量部分信息，不用一次性加载全 部朋友圈，那样只会浪费CPU时间、内存和网络带宽◇ 如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量。 12SELECT …… FROM …… LIMIT 起始位置 , 偏移量 ;SELECT empno,ename FROM t_emp LIMIT 0,20;//20是偏移量而不是终止的 数据分页的简写用法◇如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0◇执行顺序： FROM -&gt; SELECT -&gt; LIMIT 数据操作语言：结果集排序结果集排序◇ 如果没有设置，查询语句不会对结果集进行排序。也就是说，如果 想让结果集按照某种顺序排列，就必须使用ORDER BY子句。 1SELECT …… FROM …… ORDER BY 列名 [ ASC | DESC ] ; 排序关键字 ◇ASC代表升序（默认），DESC代表降序 如果排序列是数字类型，数据库就按照数字大小排序，如果是日期 类型就按照日期大小排序，如果是字符串就按照字符集序号排序。 排序字段内容相同的情况◇ 默认情况下，如果两条数据排序字段内容相同，那么排序会是什么 样子？◇ 如果排序字段内容相同，MySQL会按照主键大小来排序两条数据 多个排序字段 ◇我们可以使用ORDER BY规定首要排序条件和次要排序条件。数据 库会先按照首要排序条件排序，如果遇到首要排序内容相同的记录 ，那么就会启用次要排序条件接着排序 123SELECT empno,ename,sal,hiredateFROM t_empORDER BY sal DESC,hiredate ASC; 排序+分页◇ ORDER BY子句书写的时候放在LIMIT子句的前面 FROM -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT 数据操作语言：去除重复记录◇ 假如我们要查询员工表有多少种职业， 如果我们需要去除重复的数据，可以使用DISTINCT关键字来实现 ； 1SELECT DISTINCT 字段 FROM …… ; ◇ 注意事项 ： ①使用DISTINCT的SELECT子句中只能查询一列数据，如果查询多列， 去除重复记录就会失效。② DISTINCT关键字只能在SELECT子句中使用一次 ； 数据操作语言：条件查询条件查询◇ 很多时候，用户感兴趣的并不是逻辑表里的全部记录，而只是它们 当中能够满足某一种或某几种条件的记录。这类条件要用WHERE子 句来实现数据的筛选 1SELECT …… FROM …… WHERE 条件 [ AND | OR ] 条件 …… ; 四类运算符 WHERE语句中的条件运算会用到以下四种运算符： 算数运算符 比较运算符 逻辑运算符 二进制按位运算◇ 二进制位运算的实质是将参与运算的两个操作数，按对应的二进制数逐位进行逻辑运算。 按位运算符 WHERE子句的注意事项◇ WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把索引条件，或者筛选掉记录最多的条件写在最左侧 12345SELECT empno,ename FROM t_empWHERE ename = &quot;FORD&quot; AND sal &gt;= 2000;SELECT empno,ename FROM t_empWHERE deptno = 10 AND sal &gt;= 2000; 各种子句的执行顺序 条件查询中，WHERE子句应该是第几个执行？ FROM -&gt; WHERE -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库范式","slug":"数据库的范式","date":"2022-01-28T05:28:00.000Z","updated":"2022-02-21T12:34:06.276Z","comments":true,"path":"p/77e3.html","link":"","permalink":"https://618dt.github.io/p/77e3.html","excerpt":"","text":"概念◇ 构造数据库必须遵循一定的规则，这种规则就是范式◇ 目前关系数据库有6种范式，一般情况下，只满足第三范式即可 第一范式：原子性◇ 第一范式是数据库的基本要求，不满足这一点就不是关系数据库◇ 数据表的每一列都是不可分割的基本数据项，同一列中不能有多个值，也不能存在重复的属性。 第二范式：唯一性◇ 数据表中的每条记录必须是唯一的。为了实现区分，通常要为表 加上一个列用来存储唯一标识，这个唯一属性列被称作主键列 第三范式：关联性◇ 每列都与主键有直接关系，不存在传递依赖 ◇依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联 字段约束◇ MySQL中的字段约束共有四种： 主键约束◇ 主键约束要求字段的值在全表必须唯一，而且不能为NULL值◇ 建议主键一定要使用数字类型，因为数字的检索速度会非常快◇ 如果主键是数字类型，还可以设置自动增长 1234CREATE TABLE t_teacher(id INT PRIMARY KEY AUTO_INCREMENT,.......) 非空约束◇ 非空约束要求字段的值不能为NULL值◇ NULL值以为没有值，而不是” “空字符串 12345CREATE TABLE t_teacher(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(200) NOT NULL,married BOOLEAN NOT NULL DEFAULT FALSE //设置默认值为false); 唯一约束◇ 唯一约束要求字段值如果不为NULL，那么在全表必须唯一 1234CREATE TABLE t_teacher(...tel CHAR(11) NOT NULL UNIQUE); 外键约束◇ 外键约束用来保证关联数据的逻辑关系◇ 外键约束的定义是写在子表上的 12345678CREATE TABLE t_emp(empno INT UNSIGNED PRIMARY KEY,ename VARCHAR(20) NOT NULL,sex ENUM(&quot;MAN&quot;,&quot;WOMAN&quot;) NOT NULL,deptno INT UNSIGNED NOT NULL,hiredate DATE NOT NULL,FOREIGN KEY (deptno) REFERENCES t_dept(deptno)); ** 外键约束的闭环问题 **◇ 如果形成外键闭环，我们将无法删除任何一张表的记录 数据定义语言：索引数据排序的好处◇ 一旦数据排序之后，查找的速度就会翻倍，现实世界跟程 序世界都是如此 数据表的索引◇ MySQL利用二叉树结构，对数据表的记录排序，从而加速 数据的检索速度 如何创建索引123CREATE TABLE 表名称 ( ……，INDEX [ 索引名称 ] ( 字段 ) ……//给哪一个字段设置索引) ; 如何添加与删除索引1234CREATE INDEX 索引名称 ON 表名( 字段 ) ；ALTER TABLE 表名称 ADD INDEX [ 索引名 ]( 字段 ) ;SHOW INDEX FROM 表名 ; //查看索引情况DROP INDEX 索引名称 ON 表名 ; 索引的使用原则◇ 数据量很大，而且经常被查询的数据表可以设置索引◇ 索引只添加在经常被用作检索条件的字段上面◇ 不要在大字段上创建索引","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"数据库简介","slug":"数据库简介","date":"2022-01-28T05:26:00.000Z","updated":"2022-02-21T12:29:33.997Z","comments":true,"path":"p/f849.html","link":"","permalink":"https://618dt.github.io/p/f849.html","excerpt":"","text":"学习目标了解关系型数据库的重要性 -为什么会出现关系型数据库？有哪些常见的关系型数据库？掌握MySQL的安装和配置 -怎么安装MySQL数据库？怎么配置MySQL的字符集、端口号、IP 地址绑定、数据目录等等？实践用户创建、分配权限和密码找回 如何创建root之外的帐户并分配权限？忘记数据库密码，应该如何 找回？ 课程内容操作系统中数据存放的载体◇ Windows、Linux和MacOS都是基于文件的操作系统◇ 文件能保存数据，为什么不用文件来管理数据？什么是(关系型)数据库系统？◇ 数据库系统（DBMS）是指一个能为用户提供信息服务 的系统。它实现了有组织地、动态地储存大量相关数据 的功能，提供了数据处理和信息资源共享的便利手段。◇ 关系型数据库系统（RDBMS）是指使用了关系模型的数 据库系统◇ 关系模型中，数据是分类存放的，数据之间可以有联系 关系型数据库的应用◇ 关系型数据库被应用在非常多的领域 关系型数据库可以有效组织和管理大量复杂的数据，所 以关系型数据库才是最重要的数据库产品◇数据库的大规模应用◇主流关系型数据库 什么是NoSQL数据库系统？◇ NoSQL数据库指的是数据分类存放，但是数据之间没有关联关系的数据库系统◇ 主流NoSQL数据库 用户管理◇MySQL客户端 Navicat 重设root密码◇ 密码忘记后◇ 创建一个TXT文件，定义修改密码的SQL语句 12ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY&#x27;123456&#x27; ; ◇以管理员身份打开PowerShell窗口◇ 修改my.ini文件，删除之前添加的参数C:\\ProgramData\\MySQL\\MySQL Server 8.0，先打开隐藏文件；◇ 重启MySQL服务，用新密码登陆root帐户 MySQL配置文件◇ 在my.ini文件中，我们可以设置各种MySQL的配置，例 如字符集、端口号、目录地址等等 12345678910111213141516171819202122232425262728[client]port=3306 [mysql]no-beep #关闭蜂鸣器[mysqld]port=3306 #端口号datadir=C:/ProgramData/MySQL/MySQL Server 8.0\\Data #数据目录default_authentication_plugin=mysql_native_password #密码认证插件default-storage-engine=INNODB #默认存储引擎sql-mode=&quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION&quot; #开启严格模式log-output=FILE #用文件记录日志general-log=0 #关闭日志输出general_log_file=&quot;LAPTOP-3NL7HPNI.log&quot; #日志文件名称slow-query-log=1 #开启慢查询日志slow_query_log_file=&quot;LAPTOP-3NL7HPNI-slow.log&quot; #慢查询日志文件名称long_query_time=10 #大于多少秒的执行SQL被记录在慢查询log-error=&quot;LAPTOP-3NL7HPNI.err&quot; #错误日志名称log-bin=&quot;LAPTOP-3NL7HPNI-bin&quot;server-id=1 #数据库ID，集群时用到report_port=3306lower_case_table_names=1 #把表名转换成小写secure-file-priv=&quot;C:/ProgramData/MySQL/MySQL Server 8.0/Uploads&quot; #导入导出数据的目录地址max_connections=151 #最大连接数table_open_cache=2000tmp_table_size=21Mthread_cache_size=10 #线程数量.......","categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"LCG"},{"title":"Freemaker","slug":"FreeMarker","date":"2022-01-26T12:06:00.000Z","updated":"2022-02-21T11:57:34.672Z","comments":true,"path":"p/f1c8.html","link":"","permalink":"https://618dt.github.io/p/f1c8.html","excerpt":"","text":"模板引擎与Freemaker项目实战什么是模板引擎◇模板引擎的目标是”数据+模板=结果”◇模板引擎将数据与展现有效”解耦” 主流模板引擎◇Java Servlet Page◇Fremarker◇Beetl Fremarker◇Fremarker是免费开源的模板引擎技术◇Fremarker脚本为Fremarker Template Language◇Fremarker提供了大量内建函数来简化开发 JSP与Fremarker Fremarker快速上手代码演示ftl：${site}-${url} 1234567891011121314151617181920212223public class FreemarkerSample1 &#123; public static void main(String[] args) throws TemplateNotFoundException, MalformedTemplateNameException, ParseException, IOException, TemplateException &#123; // TODO Auto-generated method stub //1.加载模板 //1.1创建核心配置对象 Configuration config = new Configuration(Configuration.VERSION_2_3_31); //1.2设置加载的目录 config.setClassForTemplateLoading(FreemarkerSample1.class, &quot;&quot;); //1.3得到模板对象 Template t = config.getTemplate(&quot;sample1.ftl&quot;); //2.创建数据 Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;(); data.put(&quot;site&quot;, &quot;百度&quot;); data.put(&quot;url&quot;, &quot;http://www.baidu.com&quot;); //3.产生输出 //转换类将System.out输出字节流转换为字符输出流 t.process(data, new OutputStreamWriter(System.out)); &#125;&#125; FTL取值◇${属性名} 取值，可对属性进行计算◇${属性名!默认值} 使用默认值 eg：${author!”不存在的属性”}◇${属性名?string} 格式化输出eg：${date?string(“yyyy年MM月dd日HH:mm:ss”)} 分支判断◇if分支判断◇switch分支判断 123456789101112131415161718192021&lt;#if computer.state==1&gt;状态:正在使用&lt;#elseif computer.state==2&gt;状态:闲置&lt;#elseif computer.state==3&gt;状态:已作废&lt;/#if&gt; &lt;#-- 闭合 --&gt;&lt;#switch computer.state&gt; &lt;#case 1&gt; 状态:正在使用 &lt;#break&gt; &lt;#case 2&gt; 状态:闲置 &lt;#break&gt; &lt;#case 3&gt; 状态:已作废 &lt;#break&gt; &lt;#default&gt; 状态:无效状态 &lt;/#switch&gt; list迭代列表 –格式 1234&lt;#--student被迭代的集合；stu迭代变量 --&gt;&lt;#list student as stu&gt;&lt;li&gt;$&#123;stu_index&#125;-$&#123;stu.name&#125;&lt;/li&gt;&lt;/#list&gt; –代码演示 12345678910111213141516171819202122232425262728&lt;#list computers as c&gt;序号:$&#123;c_index + 1&#125; &lt;#-- 迭代变量_index保存了循环的索引,从0开始 --&gt;SN:$&#123;c.sn&#125;型号:$&#123;c.model&#125;&lt;#switch c.state&gt;&lt;#case 1&gt;状态:使用中&lt;#break&gt;&lt;#case 2&gt;状态:闲置&lt;#break&gt;&lt;#case 3&gt;状态:已作废&lt;#break&gt;&lt;/#switch&gt;&lt;#if c.user??&gt;用户:$&#123;c.user&#125;&lt;/#if&gt;采购日期:$&#123;c.dop?string(&quot;yyyy-MM-dd&quot;)&#125;采购价格:$&#123;c.price?string(&quot;0.00&quot;)&#125;-------------------------------------------&lt;/#list&gt;==========================================&lt;#list computer_map?keys as k &gt;$&#123;k&#125;-$&#123;computer_map[k].model&#125;$&#123;computer_map[k].price?string(&quot;0.00&quot;)&#125;&lt;/#list&gt; list迭代Map –格式 123&lt;#list map?keys as key&gt; $&#123;key&#125;:$&#123;map[key]&#125;&lt;/#list&gt; 内建函数 代码示例： 1234567891011121314151617181920$&#123;name?cap_first&#125;$&#123;brand?upper_case&#125;$&#123;brand?length&#125;$&#123;words?replace(&quot;blood&quot; , &quot;*****&quot;)&#125;$&#123;words?index_of(&quot;blood&quot;)&#125;&lt;#-- 利用?string实现三目运算符的操作 --&gt;$&#123;(words?index_of(&quot;blood&quot;) != -1)?string(&quot;包含敏感词汇&quot;,&quot;不包含敏感词汇&quot;)&#125;$&#123;n?round&#125;$&#123;n?floor&#125;$&#123;n?ceiling&#125;公司共有$&#123;computers?size&#125;台电脑第一台:$&#123;computers?first.model&#125;最后一台:$&#123;computers?last.model&#125;&lt;#-- 集合排序 ?reverse代表反转，将默认的升序排列改为降序 --&gt;&lt;#list computers?sort_by(&quot;price&quot;)?reverse as c&gt; $&#123;c.sn&#125;-$&#123;c.price&#125;&lt;/#list&gt; ◇Freemarker参考手册 Freemarker与Servlet整合代码演示 –xml配置FreemarkerServlet 12345678910111213141516&lt;!-- 配置freemarker类，和配置servlet一样 在配置class上可以按住Ctrl若路径出现蓝色下划线则说明路径正确 通过设置初始化参数来说明FreemarkerServlet加载哪个目录 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; –Employee类提供员工类信息 12345678public class Employee &#123; private Integer empno; private String ename; private String department; private String job; private Float salary; /*省略构造函数*/ &#125; –ListServlet为界面准备数据 1234567891011protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; List list = new ArrayList(); list.add(new Employee(2020,&quot;关浩&quot;,&quot;市场部&quot;,&quot;客户代表&quot;,6000f)); list.add(new Employee(2021,&quot;右磊&quot;,&quot;研发部&quot;,&quot;运维工程师&quot;,6500f)); list.add(new Employee(2022,&quot;方传输&quot;,&quot;运输部&quot;,&quot;交通工程师&quot;,8500f)); list.add(new Employee(2023,&quot;才刚&quot;,&quot;董事会&quot;,&quot;CEO&quot;,120000f)); request.setAttribute(&quot;employee_list&quot;, list); //请求转发到ftl文件上 request.getRequestDispatcher(&quot;/employee.ftl&quot;).forward(request, response); &#125; –ftl显示页面 123456789101112&lt;#-- 遍历集合，将数据填到每一行 --&gt; &lt;#list employee_list as emp&gt; &lt;tr&gt; &lt;td&gt;$&#123;emp_index+1&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.empno?string(&quot;0&quot;)&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.department&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.job&#125;&lt;/td&gt; &lt;td style=&quot;color: red;font-weight: bold&quot;&gt; ￥$&#123;emp.salary?string(&quot;0.00&quot;)&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; 效果图","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Freemaker","slug":"Freemaker","permalink":"https://618dt.github.io/tags/Freemaker/"}],"author":"LCG"},{"title":"监听器","slug":"监听器","date":"2022-01-26T12:03:00.000Z","updated":"2022-02-21T11:24:50.906Z","comments":true,"path":"p/83aa.html","link":"","permalink":"https://618dt.github.io/p/83aa.html","excerpt":"","text":"监听器 - Listener◇监听器是J2EE Servlet模块下的组件◇Listener的作用是对Web应用对象的行为进行监控◇通过Listener监听自动触发指定的功能代码 三种监听对象◇ServletContext - 对全局ServletContext及其属性进行监听◇HttpSession - 对用户会话及其属性操作进行监听◇ServletRequest - 对请求及属性操作进行监听 过滤器与监听器的区别◇过滤器的职责是对URL进行过滤拦截，是主动的执行◇监听器的职责是对Web对象进行监听，是被动触发 开发监听器三要素◇实现XxxListener接口，不同接口对应不同监听对象◇实现每个接口中独有的方法，实现触发监听的后续操作◇在web.xml中配置是使听器生效代码演示 123456789101112131415@WebListener//使用注解配置public class FirstListener implements ServletContextListener&#123; @Override public void contextDestroyed(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(&quot;已销毁&quot;); &#125; @Override public void contextInitialized(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(&quot;已初始化&quot;); &#125; –使用xml配置 123&lt;listener&gt; &lt;listener-class&gt;com.lcg.listener.FirstListener&lt;/listener-class&gt; &lt;/listener&gt; 六种常用监听接口内置对象监听接口◇ServletContextListener - 监听ServletContext对象创建、销毁等操作◇HttpSessionListener - 监听HttpSession对象创建、销毁等操作◇ServletRequestListener - 监听 HttpServletRequest对象创建、销毁等操作 属性监听接口◇ServletContextAttributeListener - 监听全局属性操作◇HttpSessionAttributeListener -监听用户会话属性操作◇ServletRequestAttributeListener -监听请求属性操作 监听器的应用场景请求流量分析代码演示： –监听器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*导包部分省略*/public class RequestTotalListener implements ServletContextListener,ServletRequestListener&#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; // TODO Auto-generated method stub &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; // TODO Auto-generated method stub /*排除/rt这个url的访问统计*/ HttpServletRequest request = (HttpServletRequest)sre.getServletRequest(); String url = request.getRequestURL().toString(); if(url.endsWith(&quot;/rt&quot;)==true) &#123; return; &#125; /*请求初始化，每来一个新的请求，监听器都会执行此方法。则应当在此方法中记录变化的值 * 存储结构：TimeList: 10:02 10:03 ... 访问时间 * ValueList: 5 7 ... 访问次数 * */ //先获取全局属性，再记录 List&lt;String&gt; timeList = (List)sre.getServletContext().getAttribute(&quot;timeList&quot;); List&lt;Integer&gt; valueList = (List)sre.getServletContext().getAttribute(&quot;valueList&quot;); Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm&quot;); String time = sdf.format(date); if(timeList.indexOf(time)==-1) &#123; timeList.add(time);//如果时间不存在，则追加 valueList.add(1); sre.getServletContext().setAttribute(&quot;timeList&quot;, timeList); sre.getServletContext().setAttribute(&quot;valueList&quot;, valueList); &#125;else &#123; int index = timeList.indexOf(time);//若存在，则返回时间的索引值 int value = valueList.get(index);//根据时间的索引获取value值 valueList.set(index, value+1); sre.getServletContext().setAttribute(&quot;valueList&quot;, valueList); &#125; &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; // TODO Auto-generated method stub &#125; @Override public void contextInitialized(ServletContextEvent sce) &#123; // TODO Auto-generated method stub //全局初始化时间和值两个属性，一个保存时间，一个保存数值 List timeList = new ArrayList(); List valueList = new ArrayList(); //两个属性的值会随着请求变化 sce.getServletContext().setAttribute(&quot;timeList&quot;, timeList); sce.getServletContext().setAttribute(&quot;valueList&quot;, valueList); &#125;&#125; –Servlet 1234567891011121314151617181920212223242526272829303132333435363738394041/*导包部分省略*/@WebServlet(&quot;/rt&quot;)public class RequestTotalServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public RequestTotalServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext(); List&lt;String&gt; timeList = (List)context.getAttribute(&quot;timeList&quot;); List&lt;Integer&gt; valueList = (List)context.getAttribute(&quot;valueList&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); /* response.getWriter().println(timeList.toString()); response.getWriter().println(&quot;&lt;br&gt;&quot;); response.getWriter().println(valueList.toString());*/ //将原来的数据封装成JSON Map result = new HashMap(); result.put(&quot;timeList&quot;, timeList); result.put(&quot;valueList&quot;, valueList); String json = JSON.toJSONString(result); response.getWriter().println(json); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; –统计页面◇EChart数据可视化插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showChart()&#123; //ajax获取./rt的数据，成功后将json数据的数组代替原来的数组 $.ajax(&#123; url:&quot;./rt&quot;, type:&quot;get&quot;, dataType:&quot;json&quot;, success: function(json)&#123; console.log(json.timeList); console.log(json.valueList); // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(&#x27;main&#x27;)); // 指定图表的配置项和数据 var option = &#123; title : &#123; //标题 text : &#x27;请求流量分析&#x27; // 标题文本 &#125;, tooltip : &#123;&#125;, legend : &#123; data : [ &#x27;访问量&#x27; ] &#125;, xAxis : &#123; //x轴坐标数据 data : json.timeList //json.timeList类型正好是数组 &#125;, yAxis : &#123;&#125;, series : [ &#123; name : &#x27;访问量&#x27;, type : &#x27;line&#x27;,//图表形式,bar代表柱状图,line表示折线图 data : json.valueList &#125; ] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &#125;) &#125; window.setInterval(&quot;showChart()&quot;,1000);//每一秒执行showChart()函数 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态数据预处理 ◇创建类来定义结构 ◇创建监听器初始化和设置属性 ◇利用jst-l来获取属性，展示在页面​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Listener","slug":"Listener","permalink":"https://618dt.github.io/tags/Listener/"}],"author":"LCG"},{"title":"过滤器","slug":"过滤器","date":"2022-01-26T12:01:00.000Z","updated":"2022-02-21T11:55:41.521Z","comments":true,"path":"p/cb9.html","link":"","permalink":"https://618dt.github.io/p/cb9.html","excerpt":"","text":"基础初识过滤器◇过滤器(Filter)是J2EE servlet模块下的组件◇Filter的作用是对URL进行统一的拦截处理◇Filter通常用于应用程序层面进行全局处理◇过滤链，正向传递请求，最终有ServletJSP处理，然后逆向响应； 开发过滤三要素◇任何过滤器都要实现javax.servlet.Filter接口◇在Filter接口的doFilter()方法中编写过滤器的功能代码◇在web.xml中对过滤器进行配置，说明拦截URL的范围 开发第一个过滤器代码演示：1.任何过滤器都要实现javax.servlet.Filter接口；在Filter接口的doFilter()方法中编写过滤器的功能代码 1234567891011121314151617181920212223public class MyFirstFilter implements Filter&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器已生效&quot;); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 2.在web.xml中对过滤器进行配置，说明拦截URL的范围 123456789101112&lt;!-- filter标签用于说明哪个类是过滤器，并在启动时自动加载 --&gt;&lt;filter&gt; &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lcg.filter.MyFirstFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;!-- filter-mapping标签用于说明过滤器对URL应用的范围，要点有二：1.filter-name 过滤器名称与filter.filter-name保持一致2.url-pattern 说明过滤作用范围，/*代表对所有URL进行过滤 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器生命周期 ◇代码演示 1234567891011121314151617181920212223public class MyFirstFilter implements Filter&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器已销毁&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器已生效&quot;); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub System.out.println(&quot;过滤器初始化&quot;); &#125;&#125; ◇运行结果:启动Tomcat后，过滤器自动初始化； 在浏览器进行访问时，如果访问的地址符合过滤策略，则过滤器会生效； 当关闭Tomcat后，过滤器自动销毁； 过滤器特性◇过滤器对象在Web应用启动时被创建且全局唯一◇唯一的过滤器对象在并发环境中采用”多线程”提供服务 过滤器的配置形式◇在xml中配置 过滤器的注解形式◇在class中注解 1@WebFilter(filterName=&quot;MyAnnoationFilter&quot;,urlPatterns=&quot;/*&quot;) 配置与注解如何选择◇配置形式维护性更好，适合应用全局过滤◇注解形式开发体验更好，适用于小型项目敏捷开发◇尽量避免混合使用 过滤器开发开发字符集过滤器◇web中文乱码的解决◇缺点：每一个servlet都要单独设置，无法统一设置；◇使用字符集过滤器解决： 1234567891011@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub //必须强制转换为HttpServletResponse，与Servlet底层机制有关 HttpServletRequest req = (HttpServletRequest)request; req.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponse res = (HttpServletResponse)response; res.setContentType(&quot;text/html;charset=utf-8&quot;); chain.doFilter(request, response); &#125; ServletRequest接口 过滤器参数化◇过滤器为了增强灵活性，允许配置信息放在web.xml◇在web.xml中配置设置过滤器参数◇优化字符集过滤器 代码演示： –xml配置 12345678&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lcg.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;!--参数名--&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;!--参数值--&gt; &lt;/init-param&gt;&lt;/filter&gt; –过滤器使用 123456789101112131415161718 private String encoding;//类中的全局私有变量 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub encoding = filterConfig.getInitParameter(encoding);//获取前面设置的参数 &#125;@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub //必须强制转换为HttpServletResponse，与Servlet底层机制有关 HttpServletRequest req = (HttpServletRequest)request; req.setCharacterEncoding(&quot;encoding&quot;); HttpServletResponse res = (HttpServletResponse)response; res.setContentType(&quot;text/html;charset=&quot;+ encoding); chain.doFilter(request, response); &#125; –注解形式配置 123456@WebFilter(filterName=&quot;CharacterEncodingFilter&quot;,urlPatterns=&quot;/*&quot;,initParams= &#123; @WebInitParam(name=&quot;encoding&quot;,value=&quot;UTF-8&quot;), @WebInitParam(name=&quot;p1&quot;,value=&quot;v1&quot;), @WebInitParam(name=&quot;p2&quot;,value=&quot;v2&quot;)&#125;) url-pattern设置过滤范围url-pattern常用写法◇/index.jsp - 执行资源精准匹配◇/servlet/* - 以前缀进行模糊匹配◇*.jsp - 以后缀进行模糊匹配/映射的问题◇/值映射Web应用根路径，且只对Servlet生效◇默认首页index.jsp会让/失效◇/与/含义不同，前者指向根路径，后者代表所有◇设置默认首页index.jsp，会隐式的跳转到默认根路径：”/“，则会使配置的过滤器失效。◇设置多个过滤页面，就编写多个标签◇注解形式@WebFilter(filterName=””,urlPattrens={“/“, “/servlet/“, “*.jsp”}) 过滤链开发注意事项◇每一个过滤器应具有单独职能◇过滤器的执行顺序以的书写前后顺序为准◇调用chain.doFilter()将请求向后传递◇会逆向返回，把输出语句放在chain.doFilter()语句后面，会发现过滤器倒序输出。如代码： 12chain.doFilter(request, response);System.out.println(&quot;I&#x27;m Filter A&quot;); 因为此时先执行chain.doFilter()方法，就会先将请求向后传递，而不先执行打印方法；直到不再向后传递请求后(即到了C)，才执行打印方法，进行逆向的返回；因此会看到打印是C-B-A的逆序；◇使用注解形式的执行顺序，按照类名的名称执行； 项目中过滤器的应用场景◇多端设备自动匹配 –代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.imooc.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class DeviceAdapterFilter implements Filter&#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub HttpServletRequest req = (HttpServletRequest)request; HttpServletResponse res = (HttpServletResponse)response; /* /index.html PC: /desktop/index.html MOBILE: /mobile/index.html /test.html PC: /desktop/test.html MOBILE: /mobile/test.html */ String uri = req.getRequestURI(); System.out.println(&quot;URI:&quot; + uri); //startWith判断是否以&quot;&quot;开头 if(uri.startsWith(&quot;/desktop&quot;) || uri.startsWith(&quot;/mobile&quot;)) &#123; //如果输入的是正确的手机端和电脑端的uri,则不需处理,直接向后请求 chain.doFilter(request, response); &#125;else &#123; //否则,根据设备访问特定的uri String userAgent = req.getHeader(&quot;user-agent&quot;).toLowerCase(); String targetURI=&quot;&quot;; if(userAgent.indexOf(&quot;android&quot;)!=-1 || userAgent.indexOf(&quot;iphone&quot;) != -1) &#123; targetURI = &quot;/mobile&quot; + uri; System.out.println(&quot;移动端设备正在访问,重新跳转URI:&quot; + targetURI); //sendRedirect()方法将页面重定向到指定的URL地址上 res.sendRedirect(targetURI); &#125;else &#123; targetURI = &quot;/desktop&quot; + uri; System.out.println(&quot;PC端设备正在访问,重新跳转URI:&quot; + targetURI); res.sendRedirect(targetURI); &#125; &#125; &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Filter","slug":"Filter","permalink":"https://618dt.github.io/tags/Filter/"}],"author":"LCG"},{"title":"Java正则表达式","slug":"Java正则表达式","date":"2022-01-26T11:54:00.000Z","updated":"2022-02-21T11:53:27.672Z","comments":true,"path":"p/830d.html","link":"","permalink":"https://618dt.github.io/p/830d.html","excerpt":"","text":"什么是正则表达式◇正则表达式是检查、匹配字符串的表达式◇正则表达式是描述规则，主流语言都有良好支持◇字符串校验、查找与替换是正则表达式的主要使用场景 正则表达式案例◇检查输入身份证号是否合法(15位，18位)◇示例：522725200012140613◇正则表达式：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 字符串匹配范围 元字符◇eg：3213.383219 匹配四个整数，六个小数正则表达式1：[0-9][0-9][0-9][0-9].[0-9][0-9][0-9][0-9][0-9][0-9]可以看出原始方法过于繁琐正则表达式2：\\d\\d\\d\\d.\\d\\d\\d\\d\\d\\d 多次重复匹配 定位匹配 贪婪模式◇在满足条件的情况下尽可能多匹配到字符串（默认）◇eg：111222333 正则： \\d{6,8} 结果：11122233 非贪婪模式◇在满足条件的情况下尽可能少匹配到字符串◇eg：111222333 正则： \\d{6,8}? 结果：111222 表达式分组◇分组将”正则”分组为多个子表达式◇示例：abababcdcdcd◇正则表达式： (ab){3}(cd){3} JavaScript表单验证 –代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;frmInfo&quot;&gt; &lt;div id=&quot;err&quot; style=&quot;color:red&quot;&gt; &lt;/div&gt; &lt;div&gt; 姓名:&lt;input id=&quot;name&quot; name=&quot;name&quot;/&gt; &lt;/div&gt; &lt;div&gt; 身份证:&lt;input id=&quot;idno&quot; name=&quot;idno&quot;/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/div&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;frmInfo&quot;).onsubmit = function()&#123; //在JS中定义正则表达式只需在 /正则表达式/ var regex1 = /^[\\u4e00-\\u9fa5]&#123;2,8&#125;$/; var regex2 = /^[1234568]\\d&#123;16&#125;[0-9xX]$/ var name = document.getElementById(&quot;name&quot;).value; var idno = document.getElementById(&quot;idno&quot;).value; //利用正则校验数据，true表示匹配 if(regex1.test(name)==false)&#123; document.getElementById(&quot;err&quot;).innerHTML=&quot;无效姓名&quot;; return false;//在onsubmit中，return false代表表单不提交 &#125;else if(regex2.test(idno)==false)&#123; document.getElementById(&quot;err&quot;).innerHTML=&quot;无效身份证号&quot;; return false; &#125; else&#123; alert(&quot;success&quot;); return true; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Java中Web页面信息提取 ◇html 12345678910111213141516171819202122232425262728&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;国际主要城市&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;国际主要城市&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;纽约NewYork&lt;/li&gt; &lt;li&gt;伦敦London&lt;/li&gt; &lt;li&gt;东京Tokyo&lt;/li&gt; &lt;li&gt;巴黎Paris&lt;/li&gt; &lt;li&gt;香港HongKong&lt;/li&gt; &lt;li&gt;新加坡Singapore&lt;/li&gt; &lt;li&gt;悉尼Sydney&lt;/li&gt; &lt;li&gt;米兰Milano&lt;/li&gt; &lt;li&gt;上海Shanghai&lt;/li&gt; &lt;li&gt;北京Beijing&lt;/li&gt; &lt;li&gt;马德里Madrid&lt;/li&gt; &lt;li&gt;莫斯科Moscow&lt;/li&gt; &lt;li&gt;首尔Seoul&lt;/li&gt; &lt;li&gt;曼谷Bangkok&lt;/li&gt; &lt;li&gt;台北Taipei&lt;/li&gt; ... &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; ◇regex类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.lcg.regex;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStreamReader;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexSample &#123; public static void main(String[] args) &#123; StringBuilder content = new StringBuilder(); try &#123; FileInputStream fis = new FileInputStream(&quot;F:\\\\JAVA\\\\workspace\\\\regex\\\\WebContent\\\\sample.html&quot;); //将二进制流转换为可读的字符串流 InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;); //缓冲流，提高对原始文件的读取效率 BufferedReader bufferedReader = new BufferedReader(isr); String lineText=&quot;&quot;; while((lineText=bufferedReader.readLine())!=null) &#123; content.append(lineText+&quot;\\n&quot;);//将读取到的每一行数据追加到content中 &#125; bufferedReader.close(); //System.out.println(content); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //1.创建正则表达式对象 //在字符串中\\前增加一个\\表示原义输出 Pattern p = Pattern.compile(&quot;&lt;li&gt;([\\\\u4e00-\\\\u9fa5]&#123;2,10&#125;)([a-zA-Z]+)&lt;/li&gt;&quot;); //2.匹配正则表达式 Matcher m = p.matcher(content); //3.查找匹配结果 while( m.find()) &#123; //m.group(0)是匹配的完整字符串,1是第一个分组。 // System.out.println(m.group(0)); String chs = m.group(1); String eng = m.group(2); System.out.println(chs+&quot;-&quot;+eng); &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://618dt.github.io/tags/%E6%AD%A3%E5%88%99/"}],"author":"LCG"},{"title":"JQuery与Ajax入门","slug":"JQuery与Ajax入门","date":"2022-01-26T11:53:00.000Z","updated":"2022-02-21T11:52:12.269Z","comments":true,"path":"p/b52a.html","link":"","permalink":"https://618dt.github.io/p/b52a.html","excerpt":"","text":"JQueryJavaScript库◇为了简化JavaScript开发，第三发厂商开发了JavaScript库◇主流JavaScript库有：JQuery, Vue.js, AngularJS, React… jQuery介绍◇jQuery是一个轻量级的JS库，使用简单◇jQuery的核心是选择器，用于获取页面元素◇jQuery提供了大量高效方法，开发速度大幅提升 jQuery选择器实验室12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html &gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;jQuery实验室&lt;/title&gt;&lt;style&gt;.myclass &#123; font-style: italic; color: darkblue;&#125;/* 高亮css类 */.highlight &#123; color: red; font-size: 30px; background: lightblue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;section&quot;&gt; &lt;h2&gt;jQuery选择器实验室&lt;/h2&gt; &lt;input style=&quot;height: 24px&quot; id=&quot;txtSelector&quot; /&gt; &lt;button id=&quot;btnSelect&quot; style=&quot;height: 30px&quot;&gt;选择&lt;/button&gt; &lt;hr /&gt; &lt;div&gt; &lt;p id=&quot;welcome&quot;&gt;欢迎来到选择器实验室&lt;/p&gt; &lt;ul&gt; &lt;li&gt;搜索引擎：&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;span&gt; &lt;a style=&quot;color: darkgreen&quot; href=&quot;http://www.so.com&quot;&gt;360&lt;/a&gt; &lt;/span&gt; &lt;/li&gt; &lt;li&gt;电子邮箱：&lt;a href=&quot;http://mail.163.com&quot;&gt;网易邮箱&lt;/a&gt; &lt;span&gt; &lt;a style=&quot;color: darkgreen&quot; href=&quot;http://mail.qq.com&quot;&gt;QQ邮箱&lt;/a&gt; &lt;/span&gt; &lt;/li&gt; &lt;li&gt;中国名校：&lt;a href=&quot;http://www.tsinghua.edu.cn&quot;&gt;清华大学&lt;/a&gt; &lt;span&gt; &lt;a style=&quot;color: darkgreen&quot; href=&quot;https://www.pku.edu.cn/&quot;&gt;北京大学&lt;/a&gt; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;myclass &quot;&gt;我是拥有myclass类的span标签&lt;/span&gt; &lt;p class=&quot;myclass&quot;&gt;我是拥有myclass的p标签&lt;/p&gt; &lt;form id=&quot;info&quot; action=&quot;#&quot; method=&quot;get&quot;&gt; &lt;div&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;admin&quot; /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;upsd&quot; value=&quot;123456&quot; /&gt; &lt;/div&gt; &lt;div&gt; 婚姻状况： &lt;select id=&quot;marital_status&quot;&gt; &lt;option value=&quot;1&quot;&gt;未婚&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;已婚&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;离异&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;丧偶&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;left clear-left&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* id选择器使用&quot;#id值&quot;进行选择 css选择器使用&quot;.css类名&quot;进行选择 $(&quot;.myclass&quot;).addClass(&quot;highlight&quot;); */ //单击事件 document.getElementById(&quot;btnSelect&quot;).onclick = function()&#123; var selector = document.getElementById(&quot;txtSelector&quot;).value;//获取文本框的值 //jquery的选择器方法 //()里是选择器表达式 $(&quot;*&quot;).removeClass(&quot;highlight&quot;);//清除高亮类 $(selector).addClass(&quot;highlight&quot;);//selector本身是字符串，故不用加&quot;&quot; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Web页面开发的两个要素◇在使用HTML开发页面时，有两个基本点： *选择HTML页面上在哪些元素 *在这些元素上做哪些动作 jQuery选择器◇jQuery选择器用于选中需要操作的页面元素◇语法1：jQuery(选择器表达式)◇语法2：$(选择器表达式) 基本选择器◇基本选择器是jQuery最基础也是最常用的选择器表达式–代码演示 1234$(&quot;#marital_status&quot;).addClass(&quot;highlight&quot;);$(&quot;.myclass&quot;).addClass(&quot;highlight&quot;);$(&quot;a&quot;).addClass(&quot;highlight&quot;);$(&quot;.myclass,a,#marital_status&quot;).addClass(&quot;highlight&quot;); 层叠选择器◇层叠选择器是根据元素的位置关系来获取元素的选择器表达式◇后代选择器：选择所有后代◇子选择器：只选择直接后代◇兄弟选择器：选择prev之后的同级 属性选择器◇属性选择器是根据元素的属性值来选择元素的选择器表达式eg：$(“a[href=’http://www.baidu.com&#39;]&quot;) 位置选择器与表单选择器（了解即可）◇位置选择器是通过位置获取指定的元素，例如”获取第3个元素”eg：$(“.myclass:first”)◇表单选择器是获取表单元素的简化形式，例如：获取所有文本框 操作元素属性◇attr(name|properties|key) - 获取或设置元素属性◇removeAttr(name) - 移除元素属性代码示例： 12345678910&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var href_attr = $(&quot;a[href*=&#x27;163&#x27;]&quot;).attr(&quot;href&quot;);//获取href属性 alert(href_attr); $(&quot;a[href*=&#x27;163&#x27;]&quot;).attr(&quot;href&quot; , &quot;http://www.163.com&quot;);//传递两个参数，则为设置属性 var attr = $(&quot;a&quot;).attr(&quot;href&quot;);//获取当前网页的所有超链接 alert(attr); $(&quot;a&quot;).removeAttr(&quot;href&quot;); &lt;/script&gt; ◇var attr = $(“a”).attr(“href”);如果选中多个属性，在用attr获取多个属性值的时候，默认返回第一个href属性值，而设置则会把所有超链接都设置。总之，在获取属性值时，只会返回第一个符合要求的属性值；而设置属性值时，将所有属性值设置。 操作元素的CSS样式◇css() -获取或设置匹配元素的样式属性◇addClass() -为每个匹配的元素添加指定的类名◇removeClass() - 从所有匹配的元素中删除全部或者指定的类代码示例： 12345678&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;a&quot;).css(&quot;color&quot;,&quot;red&quot;);//将当前页面所有超链接改成红色 //一次性设置多个属性值 $(&quot;a&quot;).css(&#123;&quot;color&quot;:&quot;red&quot;,&quot;font-weight&quot;:&quot;bold&quot;,&quot;font-style&quot;:&quot;italic&quot;&#125;); var color = $(&quot;a&quot;).css(&quot;color&quot;);//获取匹配元素(第一个)属性值 $(&quot;li&quot;).addClass(&quot;highlight&quot;);//添加类，多个类用空格分开 &lt;/script&gt; 设置元素内容◇val() -获取或设置输入项的值◇text() -获取或设置元素的纯文本◇html() -获取或设置元素内部的HTML代码示例： 12345678910111213&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script &gt; //设置文本框的数据 $(&quot;input[name=&#x27;uname&#x27;]&quot;).val(&quot;adminstrator&quot;); //获取文本框的数据 var n = $(&quot;input[name=&#x27;uname&#x27;]&quot;).val(); /*text与html方法最大的区别在于对于文本中的html标签是否 进行转义*/ $(&quot;span.myclass&quot;).text(&quot;男儿何不带吴钩&quot;); $(&quot;p.myclass&quot;).html(&quot;&lt;b&gt;收取关山五十州&lt;/b&gt;&quot;); //获取属性 var m = $(&quot;p.myclass&quot;).html(); &lt;/script&gt; jQuery事件处理方法◇on(“click”, function) - 为选中的页面元素绑定单击事件◇click(function) - 是绑定事件的简写形式◇处理方法中提供了event参数包含了事件的相关信息代码示例： 1234567891011121314151617&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot; &gt;&lt;/script&gt; &lt;script &gt; $(&quot;p.myclass&quot;).on(&quot;click&quot;,function()&#123; //$(this)是指当前事件产生的对象 $(this).css(&quot;background-color&quot;,&quot;yellow&quot;); &#125;) //简化方法 $(&quot;span.myclass&quot;).click(function()&#123; $(this).css(&quot;background-color&quot;,&quot;pink&quot;); &#125;) //键盘事件,输入空格显示红色警告 $(&quot;input[name=&#x27;uname&#x27;]&quot;).keypress(function(event)&#123; if(event.key==&quot; &quot;)&#123; $(this).css(&quot;color&quot;,&quot;red&quot;); &#125; &#125;) &lt;/script&gt; AjaxAjax介绍◇Asynchronous JavaScript And XML(异步的JavaScript和XML)◇Ajax可以在不刷新页面的前提下，进行页面局部更新◇Ajax不是新的技术，Ajax并不是W3C的标准 Ajax的使用流程◇创建XmlHttpRequest对象 -XmlHttpRequest用于在后台与服务器交换数据，是AJAX的核心 -XmlHttpRequest并不是W3C的标准，不同浏览器创建方式不同 -通用创建代码： 12345678var xmlhttp; if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();//火狐，谷歌等新版本浏览器 &#125;else&#123; //IE5,IE6等老版本浏览器代码 xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; ◇发送Ajax请求 -xmlhttp.open()用于创建请求 -xmlhttp.send()用于发送请求 -代码： 123//发送Ajax请求 xmlhttp.open(&quot;GET&quot;, &quot;/ajax/content&quot;, &quot;ture&quot;);//true表示此请求为异步方式 xmlhttp.send(); ◇处理服务器响应 -xmlhttp.onreadystatechange()事件用于监听AJAX的执行过程 -xmlhttp.readyState属性说明XMLHttpRequest当前状态 -xmlhttp.status属性服务器响应状态码， 200：成功 ；404：未找到 … -代码示例： 123456789//处理服务器响应xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState == 4&amp;&amp; xmlhttp.status == 200)&#123; var t = xmlhttp.responseText; alert(t); //处理服务器响应文本 document.getElementById(&quot;divContent&quot;).innerHTML = t; &#125;&#125; 利用Ajax实现新闻列表 开发模式： ①创建新闻类，设置新闻的格式框架 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lcg.ajax;public class News &#123; private String title; private String date; private String source; private String content; public News() &#123; &#125; public News(String title, String date, String source, String content) &#123; super(); this.title = title; this.date = date; this.source = source; this.content = content; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getSource() &#123; return source; &#125; public void setSource(String source) &#123; this.source = source; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; &#125; ②创建Servlet，初始化新闻数据，并将数据序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lcg.ajax;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.alibaba.fastjson.JSON;/** * Servlet implementation class NewsListServlet */@WebServlet(&quot;/newslist&quot;)public class NewsListServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public NewsListServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; List list = new ArrayList(); list.add(new News(&quot;TIOBE:2018年5月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年6月份全球编程语言排行榜&quot;,&quot;2018-6-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年7月份全球编程语言排行榜&quot;,&quot;2018-7-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年8月份全球编程语言排行榜&quot;,&quot;2018-8-1&quot;,&quot;TIBOE&quot;,&quot;...&quot;)); //转换为json对象 String json = JSON.toJSONString(list);//fastjson为java提供的json对象 System.out.print(json); response.setContentType(&quot;text/html;charset=UTF-8&quot;); //list集合在早期采用转换为xml传输，现在使用json来序列化， response.getWriter().println(json); &#125;&#125; ③实现页面，将json转为html输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //1.创建XMLHttpRequest var xmlhttp; if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();//火狐，谷歌等新版本浏览器 &#125;else&#123; //IE5,IE6等老版本浏览器代码 xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2.发送Ajax请求 xmlhttp.open(&quot;GET&quot;, &quot;/ajax/newslist&quot;, &quot;ture&quot;);//true表示此请求为异步方式 xmlhttp.send(); //3.处理服务器响应 xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState == 4&amp;&amp; xmlhttp.status == 200)&#123; var text = xmlhttp.responseText; console.log(text); var json = JSON.parse(text);//JavaScript内置的JSON对象 console.log(json); var html =&quot; &quot;; //循环输出新闻 for(var i = 0;i&lt;json.length;i++)&#123; var news = json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h1&gt;&quot;; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h2&gt;&quot;;//&amp;nbsp表示空格 html=html+&quot;&lt;hr/&gt;&quot;;//分割 &#125; //处理服务器响应文本,实现动态加载 document.getElementById(&quot;container&quot;).innerHTML=html; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同步与异步的区别◇同步：只有前面的执行完成后，后面的才能执行，代码处于阻塞状态；◇异步：在网络发送过程中，不进行代码的阻塞； Ajax函数jQuery对Ajax的支持◇jQuery对Ajax进行封装，提供了$.ajax()方法◇语法：$.ajax(options) jsonp：解决数据跨域传输问题函数使用方法–Servlet1234567891011121314151617181920212223242526@SuppressWarnings(&quot;null&quot;)protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取传递参数?t=pypl|tiobe String type = request.getParameter(&quot;t&quot;); List list = new ArrayList(); if (type != null &amp;&amp; type.equals(&quot;pypl&quot;)) &#123; list.add(new News(&quot;PYPL:2018年4月份全球编程语言排行榜&quot;, &quot;2018-5-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); list.add(new News(&quot;PYPL:2018年5月份全球编程语言排行榜&quot;, &quot;2018-6-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); list.add(new News(&quot;PYPL:2018年6月份全球编程语言排行榜&quot;, &quot;2018-7-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); list.add(new News(&quot;PYPL:2018年7月份全球编程语言排行榜&quot;, &quot;2018-8-1&quot;, &quot;PYPL&quot;, &quot;...&quot;)); &#125; else if (type != null &amp;&amp; type.equals(&quot;tiobe&quot;)) &#123; list.add(new News(&quot;TIOBE:2018年4月份全球编程语言排行榜&quot;, &quot;2018-5-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年5月份全球编程语言排行榜&quot;, &quot;2018-6-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年6月份全球编程语言排行榜&quot;, &quot;2018-7-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年7月份全球编程语言排行榜&quot;, &quot;2018-8-1&quot;, &quot;TIBOE&quot;, &quot;...&quot;)); &#125; String json = JSON.toJSONString(list);// fastjson为java提供的json对象 System.out.print(json); response.setContentType(&quot;text/html;charset=UTF-8&quot;); response.getWriter().println(json);&#125; -jquery_news.html123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //jQuery对Ajax的支持$(function()&#123; $.ajax(&#123; &quot;url&quot; : &quot;/ajax/newslist&quot;, &quot;type&quot; : &quot;get&quot; , &quot;data&quot; : &#123;&quot;t&quot;:&quot;pypl&quot;, &quot;abc&quot;:&quot;123&quot;, &quot;uu&quot;:&quot;777&quot;&#125;, //&quot;data&quot;:&quot;t=pypl&amp;abc=123&amp;uu=777&quot;,多个参数时可用json格式写，但最终还是转换为这种形式 &quot;dataType&quot; : &quot;json&quot; , &quot;success&quot; : function(json)&#123; console.log(json); for(var i = 0 ; i &lt; json.length ; i++)&#123; $(&quot;#container&quot;).append(&quot;&lt;h1&gt;&quot; + json[i].title + &quot;&lt;/h1&gt;&quot;); &#125; &#125;, //xmlhttp对象，errorText错误文本 &quot;error&quot;:function(xmlhttp,errorText)&#123; console.log(xmlhttp); console.log(errorText); //根据错误状态码显示错误信息 if(xmlhttp.status==&quot;405&quot;)&#123; alert(&quot;无效的请求方式&quot;); &#125;else if(xmlhttp.status==&quot;404&quot;)&#123; alert(&quot;未找到URL资源&quot;); &#125;else if(xmlhttp.status==&quot;500&quot;)&#123; alert(&quot;服务器内部错误，请联系管理员&quot;); &#125; &#125; &#125;)&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现二级联动菜单①类实现123456789101112131415161718192021222324252627package com.lcg.ajax;public class Channel &#123; private String code; private String name;public Channel() &#123; &#125;public Channel(String code, String name) &#123; super(); this.code = code; this.name = name;&#125;public String getCode() &#123; return code;&#125;public void setCode(String code) &#123; this.code = code;&#125;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125; &#125; ②数据初始化123456789101112131415161718192021222324252627282930313233 /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String level = request.getParameter(&quot;level&quot;);//根据level判断查询哪一频道 String parent = request.getParameter(&quot;parent&quot;); List chlist = new ArrayList(); if(level.equals(&quot;1&quot;)) &#123; chlist.add(new Channel(&quot;ai&quot;,&quot;前沿/区块链/人工智能&quot;)); chlist.add(new Channel(&quot;web&quot;,&quot;前端/小程序/JS&quot;)); &#125;else if(level.equals(&quot;2&quot;)) &#123; if(parent.equals(&quot;ai&quot;)) &#123; chlist.add(new Channel(&quot;micro&quot; , &quot;微服务&quot;)); chlist.add(new Channel(&quot;blockchain&quot; , &quot;区块链&quot;)); chlist.add(new Channel(&quot;other&quot; , &quot;...&quot;)); &#125;else if(parent.equals(&quot;web&quot;))&#123; chlist.add(new Channel(&quot;html&quot; , &quot;HTML&quot;)); chlist.add(new Channel(&quot;css&quot; , &quot;CSS&quot;)); chlist.add(new Channel(&quot;other&quot; , &quot;...&quot;)); &#125; &#125; //JSON序列化 String json = JSON.toJSONString(chlist); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(json); &#125;&#125; ③页面显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //页面就绪函数 $(function()&#123; $.ajax(&#123; &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:&#123;&quot;level&quot;:&quot;1&quot;&#125;, &quot;type&quot;:&quot;get&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)&#123; for(var i=0;i&lt;json.length;i++)&#123; var ch = json[i]; $(&quot;#lv1&quot;).append(&quot;&lt;option value=&#x27;&quot;+ch.code+&quot;&#x27;&gt;&quot;+ch.name+&quot;&lt;/option&gt;&quot;) &#125; &#125; &#125;) &#125;) //页面就绪函数，联动二级频道的数据 $(function()&#123; $(&quot;#lv1&quot;).on(&quot;change&quot;,function()&#123; var parent = $(this).val(); $.ajax(&#123; &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:&#123;&quot;level&quot;:&quot;2&quot;, &quot;parent&quot;:parent&#125;, &quot;type&quot;:&quot;get&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)&#123; //清除lv2下的原始option选项 $(&quot;#lv2&gt;option&quot;).remove(); for(var i=0;i&lt;json.length;i++)&#123; var ch = json[i]; $(&quot;#lv2&quot;).append(&quot;&lt;option value=&#x27;&quot;+ch.code+&quot;&#x27;&gt;&quot;+ch.name+&quot;&lt;/option&gt;&quot;) &#125; &#125; &#125;) &#125;) &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 一级栏目 --&gt; &lt;select id=&quot;lv1&quot; style=&quot;width:200px;height:30px&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;请选择&lt;/option&gt; &lt;/select&gt; &lt;!-- 二级栏目 --&gt; &lt;select id=&quot;lv2&quot; style=&quot;width:200px;height:30px&quot;&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://618dt.github.io/tags/Ajax/"}],"author":"LCG"},{"title":"JSON入门","slug":"JSON入门","date":"2022-01-26T10:08:00.000Z","updated":"2022-02-21T11:24:50.903Z","comments":true,"path":"p/2e67.html","link":"","permalink":"https://618dt.github.io/p/2e67.html","excerpt":"","text":"导学◇JSON入门◇jQuery与Ajax◇正则表达式◇过滤器 JSON语法规则JSON介绍◇JavaScript Object Notation(JavaScript对象表示法)◇JSON是轻量级的文本数据交换格式◇JSON独立于语言，具有自我描述性，更易理解◇示例代码： 123456&#123; &quot;sites&quot;:[ &#123;&quot;name&quot;:&quot;张珊&quot;,&quot;age&quot;:&quot;22&quot;&#125;, &#123;&quot;name&quot;:&quot;李肆&quot;,&quot;age&quot;:&quot;21&quot;&#125; ]&#125; JSON语法规则◇数据由键(key)/值(value)描述，由逗号分隔；键和值均用””包裹。◇大括号代表一个完整的对象，拥有多个键/值对◇中括号保存数组，多个对象之间使用逗号分隔，最后一个不用 代码演示 –在JavaScript中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; var json = [ &#123; &quot;empno&quot;: &quot;2023&quot;, &quot;ename&quot;: &quot;李才刚&quot;, &quot;job&quot;: &quot;首席执行官&quot;, &quot;hiredate&quot;: &quot;2025-06-18&quot;, &quot;salary&quot;: &quot;500000&quot;, &quot;dname&quot;: &quot;董事会&quot; &#125;, &#123; &quot;empno&quot;: &quot;2021&quot;, &quot;ename&quot;: &quot;石磊&quot;, &quot;job&quot;: &quot;客服经理&quot;, &quot;hiredate&quot;: &quot;2028-01-26&quot;, &quot;salary&quot;: &quot;8000&quot;, &quot;dname&quot;: &quot;市场部&quot;, &quot;customers&quot;: [ &#123; &quot;cname&quot;: &quot;吴浩&quot; &#125;, &#123; &quot;cname&quot;: &quot;方传书&quot; &#125; ] &#125; ]; //在浏览器控制台中对json内容进行输出 console.log(json); //在浏览器页面进行输出 for(var i = 0 ; i &lt; json.length ; i++)&#123; var emp = json[i]; document.write(&quot;&lt;h1&gt;&quot;); document.write(emp.empno); document.write(&quot;,&quot; + emp.ename); document.write(&quot;,&quot; + emp.job); document.write(&quot;,&quot; + emp.hiredate); document.write(&quot;,&quot; + emp.salary); document.write(&quot;,&quot; + emp.dname); document.write(&quot;&lt;/h1&gt;&quot;); if(emp.customers != null)&#123; document.write(&quot;&lt;h2&gt;---&quot;) for(var j = 0 ; j &lt; emp.customers.length ; j++)&#123; var customer = emp.customers[j]; document.write(customer.cname + &quot;,&quot;) &#125; document.write(&quot;&lt;/h2&gt;&quot;) &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; JSON与字符串互相转换(在js中)◇JSON.parse()方法将字符串转换为JSON对象◇JSON.stringify()方法将JSON对象转换为字符串eg： 123456&lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;&#123;\\&quot;class_name\\&quot;:\\&quot;五年级三班\\&quot;&#125;&quot;; var json=JSON.parse(str); console.log(str); console.log(json);&lt;/script&gt; ◇原始的字符串和json对象打印显示在浏览器控制台中；第一行是原始的字符串；下面就是json对象(Object);json对象中包含一个class_name的属性，值为”五年级三班” 1234&lt;script type=&quot;text/javascript&quot;&gt; var json=&#123;&quot;class_name&quot;:&quot;五年级三班&quot;&#125;; var str = JSON.stringify(json); &lt;/script&gt; –初始化json的另一种方法 123var json =&#123;&#125;;//先定义json.class_name=&quot;五年级三班&quot;;json.teacher=&quot;王老师&quot;; JSON与Java交互FastJson工具包◇Java的JSON工具包还有FastJson、Jackson、Gson、Json-lib…◇FastJson是阿里著名的JSON序列化与反序列工具包◇FastJson国内拥有大量使用者，拥有API简单，效率高等优点 FastJson序列化与JSON注解 –单个 123456@JSONField(format=&quot;yyyy-MM-dd&quot;)//注解，格式化输出日期private Date hdate;@JSONField(serialize=false)//不对下面的dname成员序列化private String dname;String json = JSON.toJSONString(employee);Employee emp = JSON.parseObject(json,Employee.class);//将JSON反序列化 –多个 1234567891011121314151617181920212223242526package com.lcg.json;import java.util.ArrayList;import java.util.List;import com.alibaba.fastjson.JSON;public class FastJsonSample2 &#123; public static void main(String[] args) &#123; List emplist = new ArrayList(); //模拟100个员工 for(int i =1;i&lt;=100;i++) &#123; Employee employee = new Employee(); employee.setEmpno(2020+i); employee.setEname(&quot;员工&quot;+i); emplist.add(employee); &#125; String json = JSON.toJSONString(emplist); //将转换后的字符解析成链表 List&lt;Employee&gt; emps = JSON.parseArray(json,Employee.class); for(Employee e:emps) &#123; System.out.println(e.getEmpno()+&quot;:&quot;+e.getEname()); &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://618dt.github.io/tags/JSON/"}],"author":"LCG"},{"title":"JSTL与EL表达式","slug":"JSTL与EL表达式","date":"2022-01-24T16:00:00.000Z","updated":"2022-02-21T08:53:03.259Z","comments":true,"path":"p/5d7.html","link":"","permalink":"https://618dt.github.io/p/5d7.html","excerpt":"","text":"初识EL表达式EL表达式◇EL(Expression Language)表达式语言，用于简化JSP的输出◇EL表达式的基本语法：${表达式}eg： 12JSP：&lt;h1&gt;学生姓名：&lt;%=student.name%&gt; &lt;/h1&gt;EL：&lt;h1&gt;学生姓名：$&#123;student:name&#125;&lt;/h1&gt; ◇代码演示 –学生信息类 12345678910111213141516171819package com.gamest.el;public class Student &#123; private String name; private String mobile; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; &#125; –Servlet初始化 123456789101112protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Student stu = new Student(); stu.setName(&quot;李与析&quot;); stu.setMobile(&quot;HUAWEI&quot;); String grade = &quot;A&quot;; //info.jsp用来展现学生信息，studentservlet用来初始化 request.setAttribute(&quot;student&quot;, stu); request.setAttribute(&quot;grade&quot;, grade); request.getRequestDispatcher(&quot;/info.jsp&quot;).forward(request, response); &#125; –JSP显示信息(传统方法) 123456789&lt;body&gt; &lt;% Student stu = (Student)request.getAttribute(&quot;student&quot;); String grade = (String)request.getAttribute(&quot;grade&quot;); out.println(&quot;&lt;h1&gt;姓名：&quot;+stu.getName()+&quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h2&gt;手机：&quot;+stu.getMobile()+&quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;h1&gt;教师等级：&quot;+grade+&quot;&lt;/h1&gt;&quot;); %&gt;&lt;/body&gt; –EL表达式方法 12345&lt;body&gt; &lt;h1&gt;姓名：$&#123;requestScope.student.name&#125;&lt;/h1&gt; &lt;h1&gt;手机：$&#123;requestScope.student.mobile&#125;&lt;/h1&gt; &lt;h1&gt;评级：$&#123;requestScope.grade&#125;&lt;/h1&gt;&lt;/body&gt; 作用域对象◇EL表达式内置四种作用域对象代码示例： –将学生信息放在session会话中 123456789101112protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Student stu = new Student(); stu.setName(&quot;李与析&quot;); stu.setMobile(&quot;HUAWEI&quot;); String grade = &quot;A&quot;; //将学生信息放在session会话中 HttpSession session = request.getSession(); session.setAttribute(&quot;student&quot;, stu); session.setAttribute(&quot;grade&quot;, grade); request.getRequestDispatcher(&quot;/info.jsp&quot;).forward(request, response); &#125; –则应当使用sessionScope 12345&lt;body&gt; &lt;h1&gt;姓名：$&#123;sessionScope.student.name&#125;&lt;/h1&gt; &lt;h1&gt;手机：$&#123;sessionScope.student.mobile&#125;&lt;/h1&gt; &lt;h1&gt;评级：$&#123;sessionScope.grade&#125;&lt;/h1&gt;&lt;/body&gt; –EL也可以忽略作用域对象 它会自动按作用域从小到大的顺序获取(page -&gt; application)若都没有，则会输出空字符串； 12345&lt;body&gt; &lt;h1&gt;姓名：$&#123;student.name&#125;&lt;/h1&gt; &lt;h1&gt;手机：$&#123;student.mobile&#125;&lt;/h1&gt; &lt;h1&gt;评级：$&#123;grade&#125;&lt;/h1&gt;&lt;/body&gt; EL表达式输出◇语法: ${[作用域].属性名.[子属性]}◇EL表达式支持将运算结果进行输出◇EL支持绝大多数对象输出，本质是调用toString()方法eg：${title} //将自定义属性title输出${emp.salary + 300} //算术运算${1&lt;=3&amp;&amp;2&gt;4}​ 通过改写toString()方法可以就可以使用EL表达式按照自定义的格式输出对象: 123456publie String toString()&#123; return name + &quot;:&quot; + moblie;&#125;直接输出对象，student具有子属性；$&#123;student&#125;; EL输出参数值◇EL表达式内置param对象来简化参数的输出◇语法:${param.参数名} eg：${param.teacher}； 浏览器输入：?teacher=王老师 JSTLJSTL标签库◇JSTL(JSP Standard Tag Library),JSP标准标签库◇JSTL用于简化JSP开发，提高代码可读性与可维护性◇JSTL由SUN(Oracle)定义规范，由Apache Tomcat团队实现 下载JSTL标签库◇官方地址：http://tomcat.apache.org◇JSTL v1.2.5组件介绍 如果需要默认支持JSTL，则需将前两个包复制到Tomcat\\apache-tomcat-8.5.34\\lib目录中；仅工程目录的话，就复制到工程文件的lib中。 JSTL的标签库种类◇JSTL按功能划分可分为五类标签库引用JSTL核心库◇核心标签库(Core)是JSTL最重要的标签库，提供了JSTL的基础功能◇&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core&quot; prefix=”c” %&gt;◇JSTL核心标签库在taglibs-standard-impl,jar由META-INF/c.tld定义 判断标签◇JSTL核心库提供了两组判断的标签◇&lt;c:if&gt; -单分支判断◇&lt;c:choose&gt; 、&lt;c:when&gt;、&lt;c:otherwise&gt; - 多分支判断◇代码演示： –Servlet数据端 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;score&quot;, 100); request.setAttribute(&quot;grade&quot;, &quot;A&quot;); request.getRequestDispatcher(&quot;/core.jsp&quot;).forward(request, response); &#125; –JSP 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!--在java或者jsp文件中按住Alt+/可以出现智能提示 --&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;requestScope.score&#125;&lt;/h1&gt; &lt;!-- EL表达式 --&gt; &lt;c:if test =&quot;$&#123;score&gt;=90&#125;&quot;&gt; &lt;!-- 单分支判断 --&gt; &lt;h1 style = &quot;color:green&quot;&gt;恭喜，你已通过考试&lt;/h1&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;score&lt;90&#125;&quot;&gt; &lt;h1 style = &quot;color:red&quot;&gt;很遗憾，请再接再厉&lt;/h1&gt; &lt;/c:if&gt; &lt;!-- choose when otherwise --&gt; $&#123;grade&#125; &lt;c:choose&gt; &lt;!-- 多分支 --&gt; &lt;c:when test=&quot;$&#123;grade==&#x27;A&#x27;&#125;&quot;&gt;&lt;h2&gt;你很优秀&lt;/h2&gt;&lt;/c:when&gt; &lt;c:when test=&quot;$&#123;grade==&#x27;B&#x27;&#125;&quot;&gt;&lt;h2&gt;你很不错&lt;/h2&gt;&lt;/c:when&gt; &lt;c:when test=&quot;$&#123;grade==&#x27;C&#x27;&#125;&quot;&gt;&lt;h2&gt;勉强及格&lt;/h2&gt;&lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h2&gt;再接再厉&lt;/h2&gt;&lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; 遍历集合◇&lt;c:forEach&gt;标签用于遍历集合(Collection)中的每一个对象◇代码演示 –Java创建公司类 12345678910111213141516171819202122package com.lcg.jstl;public class Company &#123; private String cname; private String url; public Company(String cname,String url) &#123; this.cname=cname; this.url=url; &#125; public String getCname() &#123; return cname; &#125; public void setCname(String cname) &#123; this.cname = cname; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125;&#125; –Servlet初始化 123456789protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ArrayList&lt;Company&gt; list=new ArrayList&lt;Company&gt;(); list.add(new Company(&quot;百度&quot;,&quot;www.baidu.com&quot;)); list.add(new Company(&quot;腾讯&quot;,&quot;www.tencent.com&quot;)); list.add(new Company(&quot;交通&quot;,&quot;www.gamest.link&quot;)); request.setAttribute(&quot;companies&quot;, list); request.getRequestDispatcher(&quot;/core.jsp&quot;).forward(request, response); &#125; –core.jsp使用 12345678910&lt;!-- forEach标签用于遍历集合 java代码实现 List companies =(List)request.getAttribute(&quot;companies&quot;); for(Company c : companies)&#123; out.print(&quot;...&quot;) &#125; --&gt; &lt;!--items数据来源 var 数据变量 varStatus变量状态(第几个) --&gt; &lt;c:forEach items=&quot;$&#123;requestScope.companies&#125;&quot; var=&quot;c&quot; varStatus=&quot;idx&quot;&gt; &lt;h2&gt;$&#123;idx.index+1&#125;.$&#123;c.cname&#125;--$&#123;c.url&#125;&lt;/h2&gt; &lt;/c:forEach&gt; 格式化标签库◇fmt格式化标签库 URL:http://java.sun.com/jsp/jstl/fmt◇&lt;fmt:formatDate value=”” pattern =”” &gt; 格式化日期标签◇&lt;fmt:formatNumber value=”” pattern =”” &gt; 格式化数字标签◇代码演示 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% request.setAttribute(&quot;amt&quot;,1575101.585); request.setAttribute(&quot;now&quot;,new java.util.Date()); request.setAttribute(&quot;html&quot;, &quot;&lt;a href=&#x27;index.html&#x27;&gt;index&lt;/a&gt;&quot;); request.setAttribute(&quot;nothing&quot;,null); %&gt; &lt;!-- formatDate pattern yyyy -四位年 MM - 两位月 dd - 两位日 HH - 24小时制 hh - 12小时制 mm - 分钟 ss - 秒数 sss - 毫秒 --&gt; &lt;!--格式化日期--&gt; &lt;h2&gt; &lt;fmt:formatDate value=&quot;$&#123;requestScope.now&#125;&quot; pattern=&quot;yyyy年MM月dd日HH时mm分ss秒&quot;/&gt; &lt;/h2&gt; &lt;!--格式化数字 0.00表示保留两位小数 0,00.00表示按百分位用&#x27;,&#x27;分割--&gt; &lt;h2&gt; &lt;fmt:formatNumber value=&quot;$&#123;requestScope.amt&#125;&quot; pattern=&quot;0.00&quot;/&gt; &lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; ◇默认值，与转义 –defalut设置默认值，escapeXml表示是否进行转义，若转义，则将标签的链接显示出来， 123&lt;h2&gt;null默认值：&lt;c:out value=&quot;$&#123;nothing&#125;&quot; default=&quot;无&quot;&gt;&lt;/c:out&gt;&lt;/h2&gt;&lt;h2&gt;&lt;c:out value=&quot;$&#123;html&#125;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt;&lt;/h2&gt; 综合训练◇创建Dynamic web工程；◇导入静态页面demo文件，放在项目主目录employee下；◇静态的页面◇导入jstl的声明jar包和实现jar包，放入到WEB-INF\\lib目录下；◇新增员工实体类 12345678public class Employee &#123; private Integer empno; private String ename; private String department; private String job; private Float salary; //get和set方法&#125; ◇新建ListServlet初始化数据； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.lcg.employee;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class ListServlet */@WebServlet(&quot;/list&quot;)public class ListServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ListServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext(); if(context.getAttribute(&quot;employees&quot;)==null) &#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); Employee emp = new Employee(2020,&quot;吴浩&quot;,&quot;市场部&quot;,&quot;客户代表&quot;,6000f); list.add(emp); list.add(new Employee(2021,&quot;石磊&quot;,&quot;研发部&quot;,&quot;交通工程师&quot;,8000f)); context.setAttribute(&quot;employees&quot;, list); &#125; //跳转到员工信息页 request.getRequestDispatcher(&quot;/employee.jsp&quot;).forward(request, response); &#125;&#125; ◇将静态的html页面改为动态的jsp页面输出员工信息； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;员工列表&lt;/title&gt; &lt;link href=&quot;css/bootstrap.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/link&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .pagination &#123; margin: 0px &#125; .pagination &gt; li &gt; a, .pagination &gt; li &gt; span &#123; margin: 0 5px; border: 1px solid #dddddd; &#125; .glyphicon &#123; margin-right: 3px; &#125; .form-control[readonly] &#123; cursor: pointer; background-color: white; &#125; #dlgPhoto .modal-body&#123; text-align: center; &#125; .preview&#123; max-width: 500px; &#125; &lt;/style&gt; &lt;script&gt; $(function () &#123; $(&quot;#btnAdd&quot;).click(function () &#123; $(&#x27;#dlgForm&#x27;).modal() &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h1 style=&quot;text-align: center&quot;&gt;交通控股员工信息表&lt;/h1&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;clearfix panel-heading &quot;&gt; &lt;div class=&quot;input-group&quot; style=&quot;width: 500px;&quot;&gt; &lt;button class=&quot;btn btn-primary&quot; id=&quot;btnAdd&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-zoom-in&quot;&gt;&lt;/span&gt;新增 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;职务&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;--利用循环以及EL表达式输出每一个员工的信息 --&gt; &lt;c:forEach items=&quot;$&#123;applicationScope.employees&#125;&quot; var=&quot;emp&quot; varStatus=&quot;idx&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;idx.index+1&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.empno&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.department &#125;&lt;/td&gt; &lt;td&gt;$&#123;emp.job &#125;&lt;/td&gt; &lt;td style=&quot;color: red;font-weight: bold&quot;&gt; ￥&lt;fmt:formatNumber value=&quot;$&#123;emp.salary&#125;&quot; pattern=&quot;0,000.00&quot;&gt;&lt;/fmt:formatNumber&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 表单 --&gt;&lt;div class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; id=&quot;dlgForm&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;新增员工&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form action=&quot;/employee/create&quot; method=&quot;post&quot; &gt; &lt;!-- action表单存放地址 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;empno&quot;&gt;员工编号&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;empno&quot; class=&quot;form-control&quot; id=&quot;empno&quot; placeholder=&quot;请输入员工编号&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;ename&quot;&gt;员工姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;ename&quot; class=&quot;form-control&quot; id=&quot;ename&quot; placeholder=&quot;请输入员工姓名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;部门&lt;/label&gt; &lt;select id=&quot;dname&quot; name=&quot;department&quot; class=&quot;form-control&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;请选择部门&lt;/option&gt; &lt;option value=&quot;市场部&quot;&gt;市场部&lt;/option&gt; &lt;option value=&quot;研发部&quot;&gt;研发部&lt;/option&gt; &lt;option value=&quot;后勤部&quot;&gt;后勤部&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;职务&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;job&quot; class=&quot;form-control&quot; id=&quot;sal&quot; placeholder=&quot;请输入职务&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sal&quot;&gt;工资&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; class=&quot;form-control&quot; id=&quot;sal&quot; placeholder=&quot;请输入工资&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; style=&quot;text-align: center;&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/body&gt;&lt;/html&gt; ◇实现新增功能，创建新的servlet用于创建员工; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lcg.employee;import java.io.IOException;import java.util.List;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class CreateServlet */@WebServlet(&quot;/create&quot;)public class CreateServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CreateServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ //表单通过post提交; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); String empno = request.getParameter(&quot;empno&quot;);//empno是在jsp中设置的name属性; String ename = request.getParameter(&quot;ename&quot;); String department = request.getParameter(&quot;department&quot;); String job = request.getParameter(&quot;job&quot;); //尽管salary是float类型，但getParameter接收时须为String类型 String salary = request.getParameter(&quot;salary&quot;); Employee emp = new Employee(Integer.parseInt(empno),ename,department,job,Float.parseFloat(salary)); /*将emp对象保存到原始数据中，原始数据由应用全局对象保存， 注意属性employees来自于context.setAttribute(&quot;employees&quot;, list);*/ ServletContext context = request.getServletContext(); //获取初始的数据 List employees = (List)context.getAttribute(&quot;employees&quot;); //添加数据 employees.add(emp); //再将添加完成后的数据放回去 context.setAttribute(&quot;employees&quot;, employees); request.getRequestDispatcher(&quot;/employee.jsp&quot;).forward(request, response); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"EL","slug":"EL","permalink":"https://618dt.github.io/tags/EL/"}],"author":"LCG"},{"title":"Servlet与JSP进阶","slug":"Servlet与JSP进阶","date":"2022-01-23T16:00:00.000Z","updated":"2022-02-21T08:52:49.559Z","comments":true,"path":"p/e24.html","link":"","permalink":"https://618dt.github.io/p/e24.html","excerpt":"","text":"请求与响应的结构HTTP请求的结构◇HTTP请求包含三部分：请求行，请求头，请求体 ◇请求行：第一行，表明请求方法，请求URL及HTTP协议版本。◇常用请求头：Accept；User-Agent(说明操作系统和浏览器的环境)等等；◇只有POST才有请求体；◇F12可以查看请求头等信息 巧用请求头开发多端应用◇在新建JAVA类时，可以直接新建Servlet，它会自动映射到地址；◇代码演示 123456789101112131415protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub String userAgent = request.getHeader(&quot;User-Agent&quot;);//获取浏览器配置信息 response.setContentType(&quot;text/html;charset=utf-8&quot;);//编码方式，支持中文 response.getWriter().println(userAgent); String output = &quot;&quot;; //indexof()方法进行字符串查找，如果找到，则返回大于大于等于0的数字，若未找到，则返回-1； if(userAgent.indexOf(&quot;Windows NT&quot;) != -1) &#123; //!= -1表明找到 output = &quot;&lt;h1&gt;这是ＰＣ端首页&lt;/h1&gt;&quot;; &#125;else if(userAgent.indexOf(&quot;iPhone&quot;) != -1 || userAgent.indexOf(&quot;Android&quot;) != -1) &#123; output = &quot;&lt;h1&gt;这是移动端首页&lt;/h1&gt;&quot;; &#125; response.getWriter().println(output);//对外输出 &#125; 响应的结构◇HTTP响应包含三部分：响应行、响应头、响应体； HTTP常见状态码 ContentType的作用◇ContentType决定浏览器采用何种方法对响应体进行处理 MIME类型 描述 text/plain 纯文本 text/html HTML文档 text/xml XML文档 application/x-msdownload 需要下载的资源 image/jpeg image/gif image/… 图片资源 ◇代码示例 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String output = &quot;&lt;h1&gt;&lt;a href =&#x27;http://www.baidu.com&#x27;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/h1&gt;&quot;; response.setContentType(&quot;application/x-msdownload;charset=utf-8&quot;);//设置类型 response.getWriter().println(output); &#125; 请求转发与重定向使用◇多个Serclet(JSP)之间跳转有两种方式： ◇request.getRequestDispatcher().forward() - 请求转发 ◇response.sendRedirect() - 响应重定向创建一个servlet –运行后登陆：http://localhost:8080/request-struc/direct/check 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;);//在控制台打印显示 //实现了请求转发功能,跳转到首页去 request.getRequestDispatcher(&quot;/direct/index&quot;).forward(request, response); &#125; ◇结果：http://localhost:8080/request-struc/direct/check 地址没有改变； 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;);//在控制台打印显示 //响应重定向需要增加contentPath：/request-struc response.sendRedirect(&quot;/request-struc/direct/index&quot;); &#125; ◇结果： http://localhost:8080/request-struc/direct/index 地址变为跳转界面的url地址；◇分析： –可以看到，请求转发后并没有改变页面地址，而响应重定向却改变了；因为请求转发功能是在服务器，也就是Tomcat内部把请求从第一个Servlet转发到第二个Servlet上；而重定向不同，它是在第一次处理完请求后，由浏览器重新发送一个新的请求，因而改变了地址； 原理请求转发◇请求转发是服务器跳转，只会产生一次请求◇请求转发语句是:request.getRequestDispatcher().forward();响应重定向◇重定向则是浏览器端跳转，会产生两次请求◇响应重定向的语句：response.sendRedirect(); 设置请求自定义属性◇请求允许创建自定义属性◇设置请求属性：request.setAttribute(属性名，属性值)◇获取请求属性：Object attr = request.getAttribute(属性名)◇代码演示 –请求端 Servlet1 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;);//在控制台打印显示 request.setAttribute(&quot;username&quot;, &quot;admin&quot;);//将用户信息保存到请求中 //实现了请求转发功能 request.getRequestDispatcher(&quot;/direct/index&quot;).forward(request, response); &#125; –目的端Servlet2 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取属性,需强制转换 String name = (String)request.getAttribute(&quot;username&quot;); response.getWriter().println(&quot;this index page!current username is &quot; + name); &#125; ◇响应重定向由于会产生两个请求，当它发送第一个请求时，会把自定义属性传递给Tomcat，但第二次重新创建的请求并不包含自定义属性（因为这是新的请求并且直接请求Servlet2了）；因此使用响应重定向时，会看到username is null;如果在Servlet2里增加 request.setAttribute(“username”, “servlet2”);则会显示 username is servlet2； 浏览器Cookie ，Session-用户会话Cookie◇Cookie(小甜饼)是浏览器保存在本地的文本内容◇Cookie常用于保存登录状态，用户资料等小文本◇Cookie具有时效性，Cookie内容会伴随请求发送给Tomcat◇Cookie如果不设置有效期，则默认存在于浏览器窗口中，当浏览器关闭，则自动销毁。◇Cookie是以文件形式保存在电脑本地的: C:\\Users\\ASUS\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cookies文件；–代码演示–登录端，创建Cookie 12345678protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;用户登录成功&quot;); Cookie cookie = new Cookie(&quot;user&quot; , &quot;admin&quot;); cookie.setMaxAge(60*60*24*7);//以秒为单位，设置有效期为一周 response.addCookie(cookie);//添加cookie response.getWriter().print(&quot;login success&quot;); &#125; –首页端，获取Cookie 1234567891011121314151617181920protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cs = request.getCookies();//获取Cookie，返回数组 if(cs == null)&#123; response.getWriter().print(&quot;user not login&quot;); return;//为空，终止程序 &#125; String user = null; for(Cookie c : cs) &#123; System.out.print(c.getName()+&quot;:&quot;+c.getValue()); if(c.getName().equals(&quot;user&quot;)) &#123; user=c.getValue();break; &#125; &#125; if(user==null) &#123; response.getWriter().print(&quot;user not login&quot;); &#125;else &#123; response.getWriter().print(&quot;user:&quot;+user); &#125; &#125; Session-用户会话◇Session(用户会话)用于保存于“浏览器窗口”对应的数据；◇Session的数据存储在Tomcat服务器的内存中，具有时效性(30min)；◇Session通过浏览器Cookie的Sessionid值提取用户数据；◇代码演示 –首页端 123456789protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); String sessionId = session.getId();//获取SessionId System.out.println(sessionId); String name = (String)session.getAttribute(&quot;name&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(&quot;这是首页，当前用户为：&quot;+ name); &#125; –登录端 1234567891011protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.print(&quot;用户登录成功&quot;); //获取到用户会话Session对象,登录端和首页的session是同一个对象 HttpSession session = request.getSession(); String sessionId = session.getId();//获取SessionId System.out.println(sessionId); session.setAttribute(&quot;name&quot;, &quot;李&quot;); //请求转发 request.getRequestDispatcher(&quot;/session/index&quot;).forward(request, response); &#125; ◇对于session而言，形象的看成是一个和浏览器窗口绑定的对象；对于这一个浏览器窗口中所产生的数据，Tomcat会创建一个单独的存储空间；每个浏览器窗口所对应的存储空间都是不同的，存储空间的标识符就是sessionId；因此，同一个窗口中，登录和首页两个servlet共用一个存储空间，因此sessionId是一样的，而当切换一个窗口后，sessionId改变； Session实现原理◇对于第一个浏览器窗口，它在向Tomcat发送请求的时候，Tomcat发现这是一个全新的请求，就会自动的在Tomcat的内存中开辟一段存储空间，并给它一个id号；当servlet调用setAttribute()方法的时候，就会将 name=张三 的数据保存在存储空间中，Tomcat就会把刚才生成的SessionId:7U809JP返回给浏览器；浏览器就会把这个id值存储到cookie中； 当浏览器再次请求的时候，就会附带这个sessionId，Tomcat就会根据这个ID去查找到对应的存储空间；假如servlet调用了getAttribute()方法,数据就会从存储空间中获得；◇如果是一个新的浏览器窗口，就会创建新的session; ServletContext◇ ServletContext(Servlet上下文对象)，是Web应用全局对象◇ 一个Web应用只会创建一个ServletContext对象◇ ServletContext随着Web应用启动而自动创建◇代码实现 –初始化 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext(); context.setAttribute(&quot;copyright&quot;,&quot;@2021 gamest.link 京ICP备xxxxxx&quot;); context.setAttribute(&quot;title&quot;, &quot;个人开发网站&quot;); response.getWriter().print(&quot;init susess&quot;); &#125; –默认页 12345678protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext();//获取应用程序全局对象 String copyright = (String)context.getAttribute(&quot;copyright&quot;); String title = (String)context.getAttribute(&quot;title&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().print(&quot;&lt;h1&gt;&quot;+title+&quot;&lt;/h1&gt;&quot;+copyright); &#125; Java Web三大作用域对象◇HttpServletRequest -请求对象 生命周期最短，当请求送往Tomcat，请求对象就会被创建，当Servlet处理完成后，产生响应并返回给浏览器，则就被销毁。​ ◇HttpSession - 用户会话对象 第一次用户发来请求时被创建，一般30分钟内不被访问则会被销毁​ ◇ServletContext - web应用全局对象 Web应用启动时创建，关闭或重启时销毁 问题解决Web应用的中文乱码由来◇Tomcat默认使用字符集ISO-8859-1，属于西欧字符集◇解决乱码的核心思路是将ISO-8859-1转换为UTF-8◇Servlet中请求与响应都需要设置UTF-8字符集​ ◇代码实现 –Get&amp;Post方法分别实现 12345678910111213141516171819202122232425262728protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //对于Tomcat8.x的版本，默认get请求发送中文就是UTF-8的格式，因此无需转换 String ename = request.getParameter(&quot;ename&quot;); String address = request.getParameter(&quot;address&quot;); System.out.println(ename + &quot;:&quot; + address); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(ename + &quot;:&quot; + address); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //request.setCharacterEncoding方法用于将请求体中的字符集转换为UTF-8，方法简单 //但对于get方法无效 request.setCharacterEncoding(&quot;UTF-8&quot;);//一定要写在post方法的第一行 // TODO Auto-generated method stub String ename = request.getParameter(&quot;ename&quot;);//获取基本参数 String address = request.getParameter(&quot;address&quot;); System.out.println(ename + &quot;:&quot; + address); //转换语句，但过于麻烦 //String utf8Ename = new String(ename.getBytes(&quot;iso-8859-1&quot;) , &quot;utf-8&quot;); //String utf8Address = new String(address.getBytes(&quot;iso-8859-1&quot;) , &quot;utf-8&quot;); //System.out.println(utf8Ename + &quot;:&quot; + utf8Address); &#125; web.xml常用配置◇修改web应用默认首页◇Servlet通配符映射及初始化参数◇设置404、500等状态码默认页面​ ◇代码实现–不用指定具体地址，默认访问的页面 12345678&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; //如果index.html存在，则优先访问此页面 &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; ◇Servlet通配符映射(*) –XML 12345678&lt;servlet&gt; &lt;servlet-name&gt;patternServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lcg.servlet.pattern.PatternServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;patternServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/pattern/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; –Java 1234567891011121314151617181920212223242526272829303132333435package com.lcg.servlet.pattern;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class PatternServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //查询员工的基本信息 //获取当前访问的URL String url = request.getRequestURL().toString(); System.out.println(url); //lastIndexOf()方法获取最后一次字符参数出现的位置，substring()方法从指定位置截取字符 String id = url.substring(url.lastIndexOf(&quot;/&quot;) + 1); int eid = Integer.parseInt(id); response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); out.println(id); if(eid == 1) &#123; out.println(&quot;张三&quot;); &#125;else if(eid == 2) &#123; out.println(&quot;李四&quot;); &#125;else &#123; out.println(&quot;其他员工&quot;); &#125; &#125; &#125; ◇配置全局参数(应用程序的基本全局配置项目用context-param标签实现) –XML配置 12345678&lt;context-param&gt; &lt;param-name&gt;copyright&lt;/param-name&gt; &lt;param-value&gt;© 2018 gamest.com 京ICP备 XXXXXXXX号-22&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;title&lt;/param-name&gt; &lt;param-value&gt;无产阶级联合起来！&lt;/param-value&gt; &lt;/context-param&gt; –Java端使用 12345678910protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = request.getServletContext();//获取 //获取在web.xml中设置的全局参数使用getInitParameter()方法 String copyright = context.getInitParameter(&quot;copyright&quot;); context.setAttribute(&quot;copyright&quot;, copyright); String title = context.getInitParameter(&quot;title&quot;); context.setAttribute(&quot;title&quot;, title); response.getWriter().println(&quot;init success&quot;); &#125; ◇指定错误页面 123456789&lt;!-- 指定错误页面 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/404.html&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/500.html&lt;/location&gt;&lt;/error-page&gt; JSP九大内置对象◇对于JSP来说，平时我们使用的时候它内置了一些对象来简化我们的操作；◇最重要的一个对象pageContext◇代码实现 12345678910111213141516171819202122232425262728293031&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% //内置对象，可直接拿来使用;因为在经过Tomcat转义为java文件后, //可以发现前面已经定义了HttpServletRequest request String url = request.getRequestURL().toString(); // 即HttpServletRequest对象 response.getWriter().println(url);//HttpServletResponse %&gt; &lt;% out.println(&quot;&lt;br&gt;ABCCC&quot;); session.setAttribute(&quot;user&quot;, &quot;张三&quot;); out.println((String)session.getAttribute(&quot;user&quot;)); %&gt; &lt;% String cp = application.getInitParameter(&quot;copyright&quot;) ; //ServletContext out.println(&quot;&lt;hr/&gt;&quot;); out.println(cp); //pageContext相当于一个中转站,通过它来获取当前页面的其他内置对象; pageContext.getRequest(); pageContext.getResponse(); pageContext.getSession(); pageContext.getServletContext(); %&gt;&lt;/body&gt;&lt;/html&gt; –显示错误信息方法 isErrorPage=”true”表示当前jsp是用来显示错误的页面 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot; isErrorPage=&quot;true&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 服务器内部错误，请联系管理员 ,错误信息如下： &lt;% //应用异常对象 String msg = exception.getMessage(); out.print(&quot;&lt;br&gt;&quot; + exception.getClass().getSimpleName() + &quot;:&quot; + msg); %&gt;&lt;/body&gt;&lt;/html&gt; Java Web打包与发布◇Java Web应用采用war包进行发布◇发布路径为：{TOMCAT_HOME}/webapps◇Eclipse支持war包导出​ ☆打包步骤 File -&gt; Export -&gt; Web -&gt; WAR file -&gt; Destination(指定保存文件路径后缀不能少eg:servlet_test.war) -&gt;finish☆使用方法将.war文件复制到Tomcat\\apache-tomcat-8.5.34\\webapps路径中，然后启动Tomcat\\apache-tomcat-8.5.34\\bin中的startup.bat文件​ ☆Tomcat配置文件修改◇找到Tomcat\\apache-tomcat-8.5.34\\conf中的servlet.xml文件，在63行，将8080改为80，则以后访问不需要加localhost:8080也不要加localhost:80; 1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; ◇将path路径后面只留”/“，则访问以后直接localhost即可 1&lt;Context docBase=&quot;F:\\JAVA\\Tomcat\\apache-tomcat-8.5.34\\webapps\\request-struc&quot; path=&quot;/&quot; reloadable=&quot;true&quot; source=&quot;org.eclipse.jst.jee.server:request-struc&quot;/&gt;&lt;/Host&gt; reloadable:是否自动加载​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://618dt.github.io/tags/JSP/"}],"author":"LCG"},{"title":"JSP入门","slug":"JSP入门","date":"2022-01-22T16:00:00.000Z","updated":"2022-02-21T08:52:34.696Z","comments":true,"path":"p/121d.html","link":"","permalink":"https://618dt.github.io/p/121d.html","excerpt":"","text":"基础简介Servlet开发的痛点◇简单的页面却工作量太大，繁琐；◇静态HTML与动态Java代码混合在一起，难以维护；◇Servlet利用out.println()语句输出，开发效率低下；◇Eclipse很难在开发过程中发现错误，调试困难； JSP介绍◇JSP全称是(Java Servlet Pages),java服务器页面◇JSP是J2EE的功能模块，由Web服务器执行◇JSP的作用就是降低动态网页开发难度 JSP特点◇JSP可将Java代码与HTML分离，降低开发难度◇JSP的本质就是Servlet JSP运行要求◇可正常运行的Tomcat◇所有JSP页面扩展名必须是.jsp◇JSP页面应放在Web应用程序目录下 JSP代码示例◇案例描述；公司薪资制度：新入职员工：基本工资1500元工作5年内员工：每年工资上浮基本工资的10%工作5-10年员工：每年工资上浮基本工资的20%工作10年以上员工：每年工资上浮基本工资的25%要求列出工资试算表； ◇在WebContent目录下创建一个salaty.jsp文件，在一个jsp文件中用&lt;% %&gt;嵌入java代码实现开发效率，输出员工各个工龄的工资； 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;year&lt;/th&gt; &lt;th&gt;salary&lt;/th&gt; &lt;/tr&gt; &lt;% for(int i=0;i&lt;=50;i++)&#123; //五十年 out.println(&quot;&lt;tr&gt;&quot;);//每一行 out.println(&quot;&lt;td&gt;&quot;+i+&quot;&lt;/td&gt;&quot;);//第一列:年份 int sal=0; if(i&lt;=5)&#123; sal=1500+i*150; &#125;else if(i&gt;5&amp;&amp;i&lt;=10)&#123; sal=1500+150*5+300*(i-5); &#125;else if(i&gt;10)&#123; sal=1500+150*5+300*5+375*(i-10); &#125; out.println(&quot;&lt;td&gt;&quot;+sal+&quot;&lt;/td&gt;&quot;);//第二列:工资 out.println(&quot;&lt;/tr&gt;&quot;); &#125; %&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; JSP的执行过程◇浏览器访问JSP首先将请求发送给Tomcat，Tomcat在应用目录中找到对应的jsp，然后将jsp转换为标准的Servlet源代码，编译成字节码； JSP的转译过程◇&lt;%=a%&gt;即把a打印输出；◇在apache-tomcat-8.5.34\\work\\Catalina\\localhost\\项目名\\org\\jsp中可以查看转译后的salary_jsp.java JSP的基本语法◇JSP语法按功能分为以下四种①JSP代码块 ②JSP声明构造块③JSP输出指令 ④JSP处理指令 JSP代码块◇JSP代码块用于JSP中嵌入Java代码◇JSP代码块语法：&lt;%java代码块%&gt; JSP声明构造块◇JSP声明构造用于声明变量或方法◇JSP声明构造块语法：&lt;%! 声明语句 %&gt;◇eg：声明方法，&lt;%! public int add(int a,int b){return a+b;} %&gt; JSP输出指令◇JSP输出指令用于在JSP页面中显示java代码执行结果◇JSP输出指令语法：&lt;%= java代码 %&gt;eg: &lt;%=”“+name+”“%&gt; %=即out.println的简化形式 JSP处理指令◇JSP处理指令用于提供JSP执行过程中的辅助信息◇JSP处理指令语法：&lt;%@ jsp指令 %&gt;◇eg: &lt;%@ page import=”java.util.*” %&gt; jsp常用处理指令123&lt;%@ page %&gt; //定义当前JSP页面的全局设置&lt;%@ include %&gt;//将其他JSP页面与当前JSP页面合并&lt;%@ taglib %&gt;//引入JSP标签库 JSP中注释的区别◇&lt;%– 注释–%&gt; JSP注释，被注释语句不做任何处理◇// , /../ 用于注释&lt;%%&gt;java代码，被注释代码不执行◇ HTML注释，被注释的语句不会被浏览器解释 综合训练质数算法◇列出1000以内的质数(除1外，只能被1和自身整除的自然数)◇要求：使用List保存所有有效的质数，将结果打印到页面，格式为”X是质数“◇综合运用JSP语法； 1234567891011121314151617181920212223242526272829303132333435&lt;%@page import=&quot;java.util.*&quot; contentType=&quot;text/html;charset=utf-8&quot;%&gt; &lt;%! boolean isPrime(int num) &#123; boolean flag = true; for (int j = 2; j &lt; num; j++) &#123; if (num % j == 0) &#123; flag = false; break; &#125; &#125; return flag; &#125; %&gt; &lt;% List&lt;Integer&gt; primes = new ArrayList(); for (int i = 2; i &lt;= 1000; i++) &#123; boolean flag = isPrime(i); if (flag) &#123; /* out.println(&quot;&lt;h1&gt;&quot; + i + &quot;&lt;/h1&gt;&quot;); */ primes.add(i); &#125; &#125;%&gt;&lt;% for(int p : primes)&#123; //out.println(&quot;&lt;h1 style=&#x27;color:pink&#x27;&gt;&quot; + p + &quot;是质数&lt;/h1&gt;&quot;);%&gt; &lt;h1 style=&#x27;color:blue&#x27;&gt;&lt;%=p %&gt;是质数 &lt;/h1&gt;&lt;% &#125;%&gt; contentType=”text/html;charset=utf-8”%&gt; 设置字体能显示中文； JSP页面重用◇利用JSP指令进行引用 12345678&lt;%@page contentType=&quot;text/html;charset=utf-8&quot; %&gt;&lt;%@include file=&quot;header.jsp&quot; %&gt;//引用页头&lt;% out.println(&quot;&lt;h1&gt;新闻标题&lt;/h1&gt;&quot;); out.println(&quot;&lt;p&gt;新闻正文&lt;/p&gt;&quot;);%&gt;&lt;%@include file=&quot;footer.jsp&quot; %&gt;引用页脚","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://618dt.github.io/tags/JSP/"}],"author":"LCG"},{"title":"Servlet入门","slug":"Servlet入门","date":"2022-01-21T16:00:00.000Z","updated":"2022-02-21T08:52:17.066Z","comments":true,"path":"p/1d42.html","link":"","permalink":"https://618dt.github.io/p/1d42.html","excerpt":"","text":"软件结构发展史单机时代-桌面应用◇软件所有数据都保存在电脑本地硬盘中◇优点：易于使用，结构简单◇缺点：数据难以共享，安全性差，更新不及时。eg：Word，eclipse； 联机时代（Client-Server模式）◇Client/Server结构（C/S结构）是指客户端和服务器结构◇优点：数据方便共享，安全性高◇缺点：必须安装客户端，升级与维护困难。eg：QQ，微信，支护宝 互联网时代（Browser-Server模式）◇Browser-Server（B/S）模式及浏览器和服务器架构模式◇优点：开发简单，无需安装客户端，数据易于共享◇缺点：相较于C/S模式，执行速度与用户体验较弱eg：百度网，新浪微博； Tomcat与ServletB/S模式执行流程 请求与响应◇从浏览器发出送给服务器的数据包称为”请求（Request）”◇从服务器返回给浏览器的结果称为”响应（Response）”◇请求和响应对称出现 J2EE简介◇J2EE（Java 2 Platform Enterprise Edition） 是指”Java 2 企业版”◇开发BS应用程序就是J2EE最核心的功能◇J2EE由13个功能模块组成 J2EE中的13个功能模块 Apache Tomcat◇Tomcat是一个Web应用服务器程序 J2EE与Tomcat的关系◇J2EE是一组技术规范与指南，具体实现由软件厂商决定◇Tomcat是J2EE Web（Servlet 与JSP）标准的实现者◇J2SE是J2EE运行的基石，运行Tomcat离不开J2SE Servlet◇Servelt与Tomcat的作用如下图，Servlet相当于服务器主机代码 Eclipse整合Tomcat◇下载Eclipse 64位的压缩包，下载Eclipse IDE for Java EE Developers版本；然后解压，运行eclipse.exe即可；打开后；Window-&gt;Preferences-&gt;搜索jre-&gt;Installed JREs-&gt;Add-&gt;Standard VM-&gt;选择安装的jdk1.8.0_181-&gt;finish-&gt;OK;◇Window-&gt;Show View-&gt;Servers-&gt;OK-&gt;Servers下的链接-&gt;Apache-&gt;Tomcat v8.5 Server(自定义安装的版本)-&gt;next-&gt;Browse(选择安装路径)-&gt;apache-tomcat的安装路径-&gt;JRE:jdk1.8.0_181-&gt;Next-&gt;Finish-&gt;双击Tomcat v8.5-&gt;Server Locations:选择第二项Use Tomcat installation-&gt;Depoly path: \\apache-tomcat-8.5.34\\webapps-&gt;保存即可； 第一个Servlet创建应用程序◇新建一个Dynamic Web Project对象-&gt;Project name:FirstServlet-&gt;-Next-&gt;Next-&gt;勾选Generate web.xml-Finish;◇在自动生成的Java Resources\\src目录下创建一个class,包名为com.lcg.servlet，类名为:FirstServlet; 12345678910111213141516171819202122232425262728293031323334package com.lcg.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class FirstServlet extends HttpServlet&#123; public FirstServlet()&#123; System.out.println(&quot;正在创建FirstServlet对象&quot;); &#125; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;正在初始化FirstServlet对象&quot;); &#125; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接收请求发来的参数 String name = request.getParameter(&quot;name&quot;); String html = &quot;&lt;h1 style=&#x27;color:red&#x27;&gt;hi,&quot; + name +&quot;!&lt;/h1&gt;&lt;hr/&gt;&quot;; System.out.println(&quot;返回给浏览器的响应数据为：&quot; + html); PrintWriter out = response.getWriter(); out.println(html);//将html发送回浏览器 &#125; @Override public void destroy() &#123; System.out.println(&quot;正在销毁servlet对象&quot;); &#125;&#125; ◇配置web.xml，绑定URL 123456789101112&lt;!-- 声明Servlet --&gt;&lt;servlet&gt; &lt;!-- servlet的别名 --&gt; &lt;servlet-name&gt;first&lt;/servlet-name&gt; &lt;servlet-class&gt;com.imooc.servlet.FirstServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 将Servlet与URL绑定 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;first&lt;/servlet-name&gt; &lt;url-pattern&gt;/hi&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ◇浏览器输入localhost:8080/FirstServlet/hi?name=Jackson 图解执行流程◇在地址栏输入地址以后,这个信息通过请求发送给Tomcat，然后Tomcat就根据发送来的url地址在web.xml中去查找与/hi匹配的servlet，这里查找匹配到name=first的servlet，然后根据这个name继续在web.xml中查找与之对应的类，这里与之对应的类为FirstServlet,Tomcat就会创建FirstServlet对象,并且执行其中的service方法;◇service方法将name拼接成html字符串,Tomcat会将这个字符串通过response原封不动的发送给浏览器，浏览器再展示在页面上； 标准Java Web工程结构◇index.html放在WebContent目录下 Servlet开发步骤◇创建Servlet类，继承HttpServlet◇重写service方法，编写程序代码 1234567public class SampleServlet extends HttpServlet&#123; public void service(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; PrintWriter out = response.getWriter();//向浏览器输出的数据流，返回PrintWriter对象 out.println(&quot;&lt;a href=&#x27;http://www.gamest.link&#x27;&gt;COF&lt;/a&gt;&quot;); &#125;&#125; ◇配置web.xml，绑定URL 12345678910&lt;!-- 声明servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;sample&lt;/servlet-name&gt;&lt;!-- servlet的别名 ，Tomcat通过别名绑定URL，提高安全性--&gt; &lt;servlet-class&gt;com.gamest.servlet.SampleServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 将servlet于URL绑定 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sample&lt;/servlet-name&gt; &lt;url-pattern&gt;/sample&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet访问方法◇http://IP地址：端口（8080）/context-path(eclipse的工程名称)/url-mapping◇远程访问使用IP地址，本地访问localhost(127.0.0.1)◇context-path成为”上下文路径”，默认为工程名 请求参数◇请求参数是指浏览器通过请求向Tomcat提交的数据◇请求参数通常是用户输入的数据，待Servlet进行处理◇参数名1=值1&amp;参数名2=值2&amp;参数名n=…eg:name=lcg&amp;mobile=15751015885&amp;sex=male&amp;spec=Program&amp;spec=Swimming 获取参数◇student.html文件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;学员信息登记表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;学员信息登记表&lt;/h1&gt; &lt;!-- 表单提交的后台路径,请求方法--&gt; &lt;form action=&quot;/FirstServlet/sample&quot; method=&quot;get&quot; &gt; 姓名：&lt;input name=&quot;name&quot;/&gt; &lt;br/&gt; 电话：&lt;input name=&quot;mobile&quot;/&gt; &lt;br/&gt; 性别： &lt;select name=&quot;sex&quot; style=&quot;width:100px;padding:5px;&quot;&gt; &lt;option value=&quot;male&quot; &gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 特长: &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;English&quot;/&gt;英语 &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;Program&quot;/&gt;编程 &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;Speech&quot;/&gt;演讲 &lt;input type=&quot;checkbox&quot; name=&quot;spec&quot; value=&quot;Swimming&quot;/&gt;游泳 &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 获取单个参数： 123String name = request.getParameter(&quot;name&quot;);String mobile = request.getParameter(&quot;mobile&quot;);String sex = request.getParameter(&quot;sex&quot;); 获取多个：如上面的spec特长数据； 1String[] specs = request.getParameterValues(&quot;spec&quot;);//多个值的，用数组 在页面显示参数： 1234567out.println(&quot;&lt;h1&gt;name:&quot;+name+&quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;mobile:&quot;+mobile+&quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;sex:&quot;+sex+&quot;&lt;/h1&gt;&quot;); for(int i=0;i&lt;specs.length;i++) &#123; out.print(&quot;&lt;h2&gt;spec:&quot;+specs[i]+&quot;&lt;/h2&gt;&quot;); &#125; out.println(&quot;&lt;a href=&#x27;http://www.gamest.link&#x27;&gt;COF&lt;/a&gt;&quot;); Get与Post请求方法◇Get方式是将数据通过在URL附加数据显性向服务器发送数据 eg：http://localhost:8080/FirstServlet/sample?name=Lcg◇Post方法会将数据存放在”请求体”中隐性向服务器发送数据 eg：http://localhost:8080/FirstServlet/sample 请求体：name=Lcg◇区别：二者数据格式一样的，存放数据地址不一样，可以通过F12键Network来查看。post存放在了不可见的请求体中；◇Service是请求处理的核心方法，无论是get或者post都会被service方法处理，request。在Java中getMethod（）方法可以获取是那种方法。 设置方法◇设置表单的请求方法 1&lt;form action=&quot;/FirstServlet/sample&quot; method=&quot;post|get&quot; &gt; ◇设置请求参数，通过设置表单中input,select等标签的name属性。只有设置了name属性的表单元素才能在提交表单时传递它们的值； 12345性别：&lt;select name=&quot;sex&quot; style=&quot;width:100px;padding:5px;&quot;&gt; &lt;option value=&quot;male&quot; &gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt;&lt;/select&gt; Get与Post处理方式◇所有请求 - service()方法； 12345678910111213141516171819public class SampleServlet extends HttpServlet &#123; //service是请求处理的核心方法，无论是get或者post都会被service（）方法处理 public void service(HttpServletRequest request , HttpServletResponse response) throws IOException&#123; String methodName = request.getMethod();//得到请求的方法; String name = request.getParameter(&quot;name&quot;); String mobile = request.getParameter(&quot;mobile&quot;); String sex = request.getParameter(&quot;sex&quot;); String[] specs = request.getParameterValues(&quot;spec&quot;); PrintWriter out = response.getWriter();//向浏览器输出的数据流 out.println(&quot;&lt;h1&gt;method:&quot; + methodName + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;name:&quot; + name + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;mobile:&quot; + mobile + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;h1&gt;sex:&quot; + sex + &quot;&lt;/h1&gt;&quot;); for(int i = 0 ; i &lt; specs.length ; i++)&#123; out.println(&quot;&lt;h2&gt;spec:&quot; + specs[i] + &quot;&lt;/h2&gt;&quot;); &#125; out.println(&quot;&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;Baidu&lt;/a&gt;&quot;); &#125;&#125; ◇Get请求 - doGet()方法； 1234public void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String name = request.getParameter(&quot;name&quot;); response.getWriter().println(&quot;&lt;h1 style=&#x27;color:green&#x27;&gt;&quot;+name+&quot;&lt;/h1&gt;&quot;); ◇Post请求 - doPost()方法； 123456//处理Post请求 public void doPost(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String name = request.getParameter(&quot;name&quot;); response.getWriter().println(&quot;&lt;h1 style=&#x27;color:red&#x27;&gt;&quot;+name+&quot;&lt;/h1&gt;&quot;); &#125; Get与Post应用场景◇Get常用于不包含敏感信息的查询功能 *例如：https://www.baidu.com/s?wd=imooc&amp;rsv_spt=1◇Post用于安全性要求较高的功能或者服务器的”写”操作 *用户登录 *用户注册 *更新新公司账目 Servlet生命周期◇装载 -web.xml ◇创建 - 构造函数◇初始化 - init() ◇提供服务 - service()|doGet()|doPost◇销毁 - destory() //应用重启或关闭的时候执行代码： 123456789101112131415161718192021222324public class FirstServlet extends HttpServlet&#123; public FirstServlet() &#123; System.out.println(&quot;正在创建FirstServlet对象&quot;); &#125; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;正在初始化FirstServlet对象&quot;); &#125; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter(&quot;name&quot;); String html = &quot;&lt;h1 style=&#x27;color:pink&#x27;&gt;hi,&quot;+name+&quot;!&lt;/h1&gt;&quot;; System.out.println(&quot;返回给浏览器的响应数据为：&quot;+ html); //response.getWriter()相当于从服务器向浏览器返回的输出流 PrintWriter out = response.getWriter(); out.println(html);//将html发送回浏览器 &#125; @Override public void destroy() &#123; System.out.print(&quot;正在销毁FirstServlet对象&quot;); &#125;&#125; 服务端：正在创建FirstServlet对象正在初始化FirstServlet对象返回给浏览器的响应数据为：hi,lcg!返回给浏览器的响应数据为：hi,lcg!五月 13, 2021 11:28:02 上午 org.apache.catalina.core.StandardContext reload信息: Reloading Context with name [/FirstServlet] has started正在销毁FirstServlet对象​ ◇可以看到在访问浏览器页面后就会自动创建和初始化对象，而且每一个Servlet有且仅有一个对象；当更改信息后，并保存（相当于应用重启或关闭）后就会销毁对象。 注解简化配置 及启动时加载Servlet使用注解简化配置◇Servlet 3.x之后引入了”注解Annotation”特性◇注解用于简化Web应用程序的配置过程◇Servlet有且仅有一个核心注解：@WebServlet 代码实现：12345678910@WebServlet(&quot;/anno&quot;)public class AnnotationServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().println(&quot;I&#x27;m annotation servlet!&quot;); &#125; &#125; ◇写了@WebServlet(“/anno”) 后，就不用再在web.xml里面进行配置了。它告诉我们映射的地址就是/anno 启动时加载Servlet◇web.xml使用设置启动加载◇0~9999 其中数字代表优先级，0位最高，有多个Servlet需要启动时加载，则优先加载优先级高的。◇启动时加载在工作中常用于系统的预处理。◇这种Servlet不需要提供服务，因此不用绑定URL 代码实现传统方法重写init()方法 123public void init() throws ServletException &#123; System.out.print(&quot;正在创建数据库&quot;); &#125; 分析Servlet 12345&lt;servlet&gt; &lt;servlet-name&gt;create&lt;/servlet-name&gt; &lt;servlet-class&gt;com.gamest.servlet.CreateServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; 注解方法12345678//在使用注解开发时，强制要求必须设置一个URL，可以任意设置，只要不与其它冲突（可能不会用到，但一定要设置）@WebServlet(urlPatterns=&quot;/unused&quot;,loadOnStartup=0)public class CreateServlet extends HttpServlet &#123; @Override public void init() throws ServletException &#123; System.out.print(&quot;正在创建数据库&quot;); &#125; &#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://618dt.github.io/tags/Servlet/"}],"author":"LCG"},{"title":"XML入门","slug":"XML入门","date":"2022-01-20T16:00:00.000Z","updated":"2022-02-21T08:51:28.045Z","comments":true,"path":"p/f394.html","link":"","permalink":"https://618dt.github.io/p/f394.html","excerpt":"","text":"课程简介XML重点知识 Servlet入门 JSP入门 Servlet与JSP进阶 JSTL与EL表达式XML ◇XML介绍与用途； ◇XML的语法规则◇XML语义约束； ◇Java解析XML◇XPath路径表达式 XML是什么◇ XML的全称是EXtensible Markup Language,可扩展标记语言 ◇ 编写XML就是编写标签，与HTML非常类似，扩展名.xml ◇ 良好的人机可读性 123456#hr.xml&lt;employee&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;31&lt;/age&gt;&lt;height&gt;178&lt;/height&gt;&lt;/employee&gt; XML与HTML的比较◇XML与HTML非常相似，都是编写标签◇XML没有预定义标签，HTML存在大量预定义标签◇XML重在保存与传输数据，HTML用于显示信息◇eg： 1234567891011xml: &lt;school&gt; &lt;class no=&quot;G3N1&quot;&gt; &lt;grade&gt;三年级&lt;/grade&gt; &lt;name&gt;1班&lt;/name&gt; &lt;/class&gt; &lt;class no=&quot;G3N2&quot;&gt; &lt;grade&gt;三年级&lt;/grade&gt; &lt;name&gt;2班&lt;/name&gt; &lt;/class&gt;&lt;/school&gt; 1234html:&lt;body&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;&lt;/body&gt; XML用途◇Java程序的配置描述文件；在程序开发过程中会遇到各种各样的设置项，如果把这些设置项写死在程序中，每次修改配置的时候需要对代码进行修改并重新编译，非常的麻烦；这个时候就可以考虑将这些配置写在xml文件中保存；例如下面的web应用配置文件； 123456789101112131415web.xml - web应用配置文件&lt;web-app&gt;&lt;servlet&gt;&lt;servlet-name&gt;InitTest&lt;/servlet-name&gt;&lt;servlet-class&gt;moreservlets.InitServlet&lt;/servlet-class&gt;&lt;init-param&gt;&lt;param-name&gt;param1&lt;/param-name&gt;&lt;param-value&gt;value1&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;param2&lt;/param-name&gt;&lt;param-value&gt;2&lt;/param-value&gt;&lt;/init-param&gt;&lt;/servlet&gt;&lt;/web-app&gt; ◇用于保存程序产生的数据；因为xml拥有良好的人机可读性，所以xml可以用来对数据进行存储和转移；◇网络间的数据传输；即在网络传输的过程中，发送方可以将数据组织成xml，接收方对xml进行解析就可以了；如： 12345678webservice底层soap协议：&lt;Envelope&gt; &lt;Body&gt; &lt;m:reverse xmlns:m=&quot;urn:strings-com:IString&quot;&gt; &lt;theString&gt;Hello,World&lt;/theString&gt; &lt;/m:reverse&gt; &lt;/Body&gt;&lt;/Envelope&gt; XML的文档结构◇第一行必须是XML声明◇有且只有一个根节点◇XML标签的书写规则与HTML完全相同 XML标签书写规则◇合法的标签名 1234&lt;abc&gt;abc&lt;/abc&gt; × (无意义的)&lt;考试$&gt;数学期末&lt;/考试$&gt; × (不可包含特殊字符)&lt;class&gt;&lt;class&gt;班级&lt;/class&gt;&lt;/class&gt; × (父标签子标签不可同名)&lt;shop-cart&gt;&lt;item&gt;相册&lt;/item&gt;&lt;/shop-cart&gt; √ ◇适当的注释与缩进； 适当的注释与缩进可以让XML文档更容易阅读。 1234567&lt;!-- 员工信息 --&gt; &lt;employee&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;31&lt;/age&gt; &lt;!--身高cm--&gt; &lt;height&gt;178&lt;/height&gt;&lt;/employee&gt; ◇合理使用属性 123456789101112&lt;shop-cart&gt; &lt;item sn=&quot;771938&quot; category=&quot;电器&quot;&gt; &lt;name&gt;XX空调&lt;/name&gt; &lt;price&gt;2000.00&lt;/price&gt; &lt;num&gt;1&lt;/num&gt; &lt;/item&gt; &lt;item sn=&quot;890321&quot; category=&quot;食品&quot;&gt; &lt;name&gt;法式面包&lt;/name&gt; &lt;price&gt;10.00&lt;/price&gt; &lt;num&gt;5&lt;/num&gt; &lt;/item&gt;&lt;/shop-cart&gt; ◇特殊字符与CDATA标签；– 标签体中，出现”&lt;”、”&gt;”特殊字符，会破坏文档原有的结构 ；– 解决方案1：使用实体引用。 – 解决方案2：使用CDATA标签。 12345无效的XML：&lt;exam&gt; &lt;question&gt;1+4&lt;3是否正确？&lt;/question&gt;&lt;!--出现小于号&lt;会别认为是特殊字符 --&gt; &lt;question&gt;3+5&gt;8是否正确？&lt;/question&gt;&lt;/exam&gt; ◇ XML支持五种实体引用 ◇修改后的XML 1234&lt;exam&gt; &lt;question&gt;1+4&amp;lt;3是否正确？&lt;/question&gt;&lt;!--出现小于号&lt;会别认为是特殊字符 --&gt; &lt;question&gt;3+5&amp;gt;8是否正确？&lt;/question&gt;&lt;/exam&gt; ◇实体引用的方法只适用于特殊字符少的情况；解决批量的问题用CDATA标签；◇ CDATA 指的是不应由 XML 解析器进行解析的文本数据 ◇ 从”“结束 ◇如我们想要标签的内容原义输出；则可使用CDATA包裹； 12345678910&lt;lesson&gt; &lt;content&gt; &lt;![CDATA[ 本节我们来学习html中a标签的使用： &lt;body&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt; &lt;/body&gt; ]]&gt; &lt;/content&gt;&lt;/lesson&gt; ◇有序的子元素，在XML多层嵌套的子元素中，标签前后顺序应保持一致。 123456789101112&lt;shop-cart&gt;&lt;item sn=&quot;771938&quot; category=&quot;电器&quot;&gt;&lt;name&gt;XX空调&lt;/name&gt;&lt;price&gt;2000.00&lt;/price&gt;&lt;num&gt;1&lt;/num&gt;&lt;/item&gt;&lt;item sn=&quot;890321&quot; category=&quot;食品&quot;&gt;&lt;name&gt;法式面包&lt;/name&gt;&lt;price&gt;10.00&lt;/price&gt;&lt;num&gt;5&lt;/num&gt;&lt;/item&gt;&lt;/shop-cart&gt; XML声明◇XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行。 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 其中，version代表版本号1.0(初始版本)/1.1(升级版本)；encoding UTF-8设置字符集，用于支持中文；​ XML语义约束◇ XML文档结构正确，但可能不是有效的。 – 例如，员工档案XML中绝不允许出现”植物品种” 标签。XML语义约束就是用于规定XML文档中允许 出现哪些元素。 – XML语义约束有两种定义方式:DTD与XML Schema。 DTD简介◇ DTD(Document Type Definition，文档类型定义)是 一种简单易用的语义约束方式。 ◇ DTD文件的扩展名为.dtd。 123456hr.dtd&lt;!ELEMENT hr (employee+)&gt;&lt;!ELEMENT employee (name,age,salary,department)&gt;&lt;!ATTLIST employee no CDATA &quot;&quot;&gt;&lt;!ELEMENT name (#PCDATA)&gt;... DTD定义结点◇利用DTD中的&lt;!ELEMENT&gt;标签，定义XML文档中允许出现的节点及数量；eg: ①定义hr节点下只允许出现一个employee子节点 ： 1&lt;!ELEMENT hr (employee)&gt; ②employee节点下必须包含以下四个节点，且按顺序出现： 1&lt;!ELEMENT employee(name,age,salary,department)&gt; ③定义name标签只能是文本，#PCDATA代表文本元素。 1&lt;!ELEMENT name(#PCDATA) DTD定义节点数量◇如某个子节点需要多次重复出现，则需要在子节点后增加相应的描述符。eg：①hr节点下最少出现1个employee子节点： 1&lt;!ELEMENT hr(employee+)&gt; ②hr节点下可出现0..n个employee子节点： 1&lt;!ELEMENT hr(employee*)&gt; ③hr节点下最多可出现1个employee子节点： 1&lt;!ELEMENT hr(employee?)&gt; XML引用DTD文件◇在XML使用&lt;!DOCTYPE&gt;标签来引用DTD文件书写格式: 123&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt;eg:&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt; XML Schema◇XML Schema比DTD更为复杂，提供了更多功能。◇XML Schema提供了数据类型、格式限定、数据范围等特性。◇XML Schema是W3C标准。◇eg 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;element name=&quot;hr&quot;&gt; &lt;!-- complexType标签含义是复杂节点，包含子节点时必须使用这个标签 这里表示hr下有子节点 --&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!--队列 说明前后顺序--&gt; &lt;element name=&quot;employee&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;9999&quot;&gt; &lt;complexType&gt; &lt;!--employee下有子节点 --&gt; &lt;sequence&gt; &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;age&quot;&gt; &lt;simpleType&gt; &lt;restriction base=&quot;integer&quot;&gt; &lt;minInclusive value=&quot;18&quot;&gt;&lt;/minInclusive&gt; &lt;maxInclusive value=&quot;60&quot;&gt;&lt;/maxInclusive&gt; &lt;/restriction&gt; &lt;/simpleType&gt; &lt;/element&gt; &lt;element name=&quot;salary&quot; type=&quot;integer&quot;&gt;&lt;/element&gt; &lt;element name=&quot;department&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;dname&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;address&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;attribute name=&quot;no&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt;&lt;!--required表示必须存在no这个属性--&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/schema&gt; DOM模型与Dom4jDOM文档对象模型◇DOM(Document Object Moder) 定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构来查看，能够通过DOM树来读写所有元素。 Dom4j◇Dom4j是一个易用的、开源的库，用于解析XML。它应用于java平台，具有性能优异、功能强大和极其易使用的特点。◇Dom4j将XML视为Document对象◇XML标签被Dom4j定义为Element对象 利用Dom4j遍历XML◇在xml工程中src存储了xml文件以及dtd和xsd文件；新建一个lib文件用于引入dom4j的依赖；即将dom4j-2.1.1.jar文件复制到lib中，然后右键Build Path-&gt;Add to Build Path即可；◇hr.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt;&lt;!-- 人力资源管理系统 --&gt;&lt;hr&gt; &lt;employee no=&quot;3301&quot;&gt; &lt;name&gt;李铁柱&lt;/name&gt; &lt;age&gt;37&lt;/age&gt; &lt;salary&gt;3600&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;人事部&lt;/dname&gt; &lt;address&gt;XX大厦-B105&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no=&quot;3302&quot;&gt; &lt;name&gt;林海&lt;/name&gt; &lt;age&gt;50&lt;/age&gt; &lt;salary&gt;7000&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;财务部&lt;/dname&gt; &lt;address&gt;XX大厦-B106&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no=&quot;3303&quot;&gt; &lt;name&gt;安娜&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;salary&gt;4600&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;人事部&lt;/dname&gt; &lt;address&gt;XX大厦-B105&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt;&lt;/hr&gt; ◇新建包com.lcg.dom4j，创建类HrReader读取xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lcg.dom4j;import java.util.List;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class HrReader &#123; public void readXml()&#123; String file = &quot;d:/workspace/xml/src/hr.xml&quot;; //SAXReader类是读取XML文件的核心类，用于将XML解析后以“树”的形式保存在内存中。 SAXReader reader = new SAXReader(); try &#123; //read方法解析出一个document对象; Document document = reader.read(file); //获取XML文档的根节点，即hr标签 Element root = document.getRootElement(); //elements方法用于获取指定的标签集合 List&lt;Element&gt; employees = root.elements(&quot;employee&quot;); for(Element employee : employees)&#123; //element方法用于获取唯一的子节点对象 Element name = employee.element(&quot;name&quot;); String empName = name.getText();//getText()方法用于获取标签或者属性的文本 System.out.println(empName); //直接打印,不赋值; System.out.println(employee.elementText(&quot;age&quot;)); //elementText方法和getText()方法一样; System.out.println(employee.elementText(&quot;salary&quot;)); Element department = employee.element(&quot;department&quot;); System.out.println(department.element(&quot;dname&quot;).getText()); System.out.println(department.element(&quot;address&quot;).getText()); //attribute方法用于获取属性; Attribute att = employee.attribute(&quot;no&quot;); System.out.println(att.getText()); &#125; &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrReader reader = new HrReader();//实例化HrReader方法; reader.readXml(); &#125; &#125; 利用Dom4j更新XML◇新建类HrWriter 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lcg.dom4j;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class HrWriter &#123; public void writeXml()&#123; String file = &quot;d:/workspace/xml/src/hr.xml&quot;; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); Element root = document.getRootElement(); //增加新的子节点employee; Element employee = root.addElement(&quot;employee&quot;); //增加节点的属性; employee.addAttribute(&quot;no&quot;, &quot;3311&quot;); Element name = employee.addElement(&quot;name&quot;);//增加name子节点; name.setText(&quot;李铁柱&quot;);//设置文本; employee.addElement(&quot;age&quot;).setText(&quot;37&quot;);//合成一行代码; employee.addElement(&quot;salary&quot;).setText(&quot;3600&quot;); Element department = employee.addElement(&quot;department&quot;); department.addElement(&quot;dname&quot;).setText(&quot;人事部&quot;); department.addElement(&quot;address&quot;).setText(&quot;XX大厦-B105&quot;); //把文件的输出流转换为Writer对象 Writer writer = new OutputStreamWriter(new FileOutputStream(file) , &quot;UTF-8&quot;); //将dom模型写入到对应文件中; document.write(writer); writer.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrWriter hrWriter = new HrWriter(); hrWriter.writeXml(); &#125;&#125; XPath表达式XPath路径表达式◇XPath路径表达式是XML文档中查找数据的语言。◇掌握XPath可以极大提高在提取数据时的开发效率。◇学习XPath本质就是掌握各种形式表达的使用技巧。 XPath基本表达式◇最常用的基本表达式 表达式 描述 nodename 选取此节点的所有子节点 / 从根节点选取 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 XPath基本表达式案例 XPath谓语表达式◇谓语表达式统一使用中括号，里面再加一个谓语表示； Xpath实验室Jaxen介绍◇Jaxen是一个java编写的开源的XPath库。这是适应多种不同的对象模型，包括DOM，XOM,dom4j和JDOM。◇Dom4j底层依赖Jaxen实现XPath查询◇Jaxen下载地址:meaven.aliyun.com在阿里云的仓库中搜索下载 代码演示◇引入jaxen依赖；◇创建类XPathTestor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.lcg.dom4j;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;public class XPathTestor &#123; public void xpath(String xpathExp)&#123; String file = &quot;E:/lianxi/xml/hr.xml&quot;; SAXReader reader = new SAXReader(); try &#123; //获取document对象 Document document = reader.read(file); /*selectNodes方法用来执行xpath表达式;对于xpath表达式来说,不仅可以查询标签本身, 还可以查询属性,Node是标签和属性的一个父类,因此返回的是一个Node; */ List&lt;Node&gt; nodes = document.selectNodes(xpathExp); for(Node node : nodes)&#123; Element emp = (Element)node;//把node转换为Element对象; //输出相关信息; System.out.println(emp.attributeValue(&quot;no&quot;)); System.out.println(emp.elementText(&quot;name&quot;)); System.out.println(emp.elementText(&quot;age&quot;)); System.out.println(emp.elementText(&quot;salary&quot;)); System.out.println(&quot;==============================&quot;); &#125; &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; XPathTestor testor = new XPathTestor();// testor.xpath(&quot;/hr/employee&quot;);// testor.xpath(&quot;//employee&quot;);// testor.xpath(&quot;//employee[salary&lt;4000]&quot;); 工资小于4000的职员// testor.xpath(&quot;//employee[name=&#x27;李铁柱&#x27;]&quot;);// testor.xpath(&quot;//employee[@no=3304]&quot;);// testor.xpath(&quot;//employee[1]&quot;);// testor.xpath(&quot;//employee[last()]&quot;); //testor.xpath(&quot;//employee[position()&lt;3]&quot;); testor.xpath(&quot;//employee[3] | //employee[8]&quot;); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"}],"tags":[{"name":"xml","slug":"xml","permalink":"https://618dt.github.io/tags/xml/"}],"author":"LCG"},{"title":"删除功能出现的BUG","slug":"异常处理BUG","date":"2021-12-09T07:34:46.961Z","updated":"2021-12-09T09:48:49.661Z","comments":true,"path":"p/de80.html","link":"","permalink":"https://618dt.github.io/p/de80.html","excerpt":"","text":"功能简介​ 开发一个删除油画功能模块，要求能够在前台中点击某一油画进行删除后，弹出对话框进行确认删除，若确认则发送ajax请求到后台，然后后台根据发送过来的id进行相应的删除，并且使用json对象返回处理的结果； 实现思路​ 对于底层的数据删除，使用dom4j进行对xml的删除操作；首先根据id筛选出指定的节点p；然后根据此节点获取到其父节点，使用父节点的remove方法来删除此节点；代码如下： 12//得到P的根节点然后用根节点删去P;p.getParent().remove(p); ​ 然后就是根据MVC的调用要求，依次创建Dao、Service、Controller中的方法；在Controller方法中进行与前台的交互即可； 出现的BUG​ 当在前台页面点击删除油画后，发现删除成功，然后不刷新页面。再次删除此油画，这幅油画实际上已经被删除了，所以根据后台的逻辑，应该会删除失败，并提示该油画已经被删除或者不存在；但是前台确提示删除成功，按F12查看浏览器控制台打印的json对象如下: 这说明在控制器中根本没有执行catch块里的代码，而是执行了try里的代码，没有捕捉到XmlDataSource中抛出的异常；后端控制台打印的信息如下： 1234567891011121314151617181920212223242526272829303132333435获取ajax请求发送过来的id为:16/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xmljava.lang.RuntimeException: 编号为16的油画不存在或已删除 at com.lcg.mgallery.utils.XmlDataSource.delete(XmlDataSource.java:186) at com.lcg.mgallery.dao.PaintingDao.delete(PaintingDao.java:68) at com.lcg.mgallery.service.PaintingService.delete(PaintingService.java:69) at com.lcg.mgallery.controller.ManagementController.delete(ManagementController.java:247) at com.lcg.mgallery.controller.ManagementController.doGet(ManagementController.java:64) at com.lcg.mgallery.controller.ManagementController.doPost(ManagementController.java:73) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source)/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xml成功执行了删除的操作 ​ 可以发现确实出现了异常，但出现异常后确仍然打印出”成功执行了删除的操作”；这是什么原因呢？为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常？我们来分析一下后台的代码； 对Xml文件进行直接操作的XmlDataSource类中的删除方法代码如下： 1234567891011121314151617public static void delete(Integer id) &#123; try &#123; document = reader.read(dataFile); List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting[@id=&quot; + id + &quot;]&quot;); if(nodes.size() == 0) &#123; throw new RuntimeException(&quot;编号为&quot; + id + &quot;的油画不存在或已删除&quot;); &#125; //省略执行删除操作代码.. &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); throw new RuntimeException(&quot;编号为&quot; + id + &quot;的油画不存在或已删除&quot;); &#125;finally &#123; //...部分代码 reload(); &#125; &#125; ​ 控制器中的删除方法代码如下(控制器中调用的是Service中的delete方法，按照MVC的架构模式会逐级调用到XmlDataSource中的方法) 123456789101112131415161718192021//删除油画private void delete(HttpServletRequest request,HttpServletResponse response) throws IOException &#123; String id = request.getParameter(&quot;id&quot;);//获取ajax请求发送过来的参数 System.out.println(&quot;获取ajax请求发送过来的id为:&quot;+id); Map result = new HashMap(); try &#123; //调用方法进行油画的删除 paintingService.delete(Integer.parseInt(id)); result.put(&quot;code&quot;, &quot;0&quot;); result.put(&quot;msg&quot;, &quot;success&quot;); System.out.println(&quot;成功执行了删除的操作&quot;); &#125;catch(Exception e) &#123; e.printStackTrace(); result.put(&quot;code&quot;, &quot;1&quot;); result.put(&quot;msg&quot;, e.getMessage()); System.out.println(&quot;遇到了异常&quot;); &#125; String json = JSON.toJSONString(result); response.setContentType(&quot;text/html;charset=UTF-8&quot;); response.getWriter().println(json);&#125; ​ 通过对控制台中的打印结果分析想到，既然在Controller中并没有捕捉到，那么为什么会打印出异常的信息呢？很快就想到可能在XmlDataSource中就把异常给捕捉了，于是在XmlDataSource中将catch块中的e.printStackTrace();注释掉，在前台执行重复删除的操作，发现后台果然没有打印出异常信息! BUG解决方法​ 在知道了为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常后，就能想到出错的原因在哪里了；因为在XmlDataSource的删除方法中，前面的一些代码也会抛出异常，为了寻求方便我索性使用Exception来捕捉这些异常，这就导致将我们自定义的异常给捕获并处理了（因为RuntimeException继承自Exception），进而在Controller中无法捕捉到异常，给前台的反馈消息总是删除成功的； ​ 所以解决方法是分别捕捉可能出现的每一种异常(除RuntimeException以外)；修改后的方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940public static void delete(Integer id) &#123; SAXReader reader = new SAXReader(); Writer writer = null; Document document; try &#123; document = reader.read(dataFile); List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting[@id=&quot; + id + &quot;]&quot;); if(nodes.size() == 0) &#123; throw new RuntimeException(&quot;编号为&quot; + id + &quot;的油画不存在或已删除&quot;); &#125; Element p = (Element)nodes.get(0); //得到P的根节点然后用根节点删去P; p.getParent().remove(p); //修改后的数据回写到原来的xml文件中; writer = new OutputStreamWriter(new FileOutputStream(dataFile),&quot;UTF-8&quot;); document.write(writer); &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; reload(); &#125; &#125; ​ 这样以后，成功解决了前面出现的问题；这里附上前台页面的代码，弹出窗口使用了SweetAlert 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt;//提示删除 function del(previewObj)&#123; var preview = $(previewObj).attr(&quot;data-preview&quot;);//获取自定义属性 var pname = $(previewObj).attr(&quot;data-pname&quot;); var id = $(previewObj).attr(&quot;data-id&quot;); Swal.fire(&#123; title: &#x27;删除&#x27;+pname+&#x27;?&#x27;, html: &quot;&lt;img src=&#x27;&quot; + preview + &quot;&#x27; style=&#x27;width:361px;height:240px&#x27;&gt;&quot;, icon: &#x27;warning&#x27;, showCancelButton: true, confirmButtonColor: &#x27;#3085d6&#x27;, cancelButtonColor: &#x27;#d33&#x27;, confirmButtonText: &#x27;是的&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(function(isConfirm)&#123; if (isConfirm.value) &#123; //发送ajax请求 $.ajax(&#123; &quot;url&quot; : &quot;/management?method=delete&quot;, &quot;type&quot; : &quot;post&quot;, &quot;data&quot; : &#123;&quot;id&quot;:id&#125;, &quot;dataType&quot; : &quot;json&quot;, &quot;success&quot; : function(json)&#123; console.log(json); if(json.code==&quot;0&quot;)&#123; Swal.fire(&#x27;删除成功!&#x27;,&#x27;油画已经成功删除&#x27;,&#x27;success&#x27;).then(function(isConfirm)&#123; if (isConfirm.value)&#123; //点击确认后刷新页面 window.location.reload(); &#125; &#125;) &#125;else&#123; Swal.fire(&#x27;删除失败!&#x27;,json.msg,&#x27;error&#x27;).then(function(isConfirm)&#123; if (isConfirm.value)&#123; //点击确认后刷新页面 window.location.reload(); &#125; &#125;) &#125; &#125; &#125;) &#125; &#125;) &#125;&lt;/script&gt; &lt;!-- 省略部分代码 --&gt;&lt;a class=&quot;oplink&quot; data-id=&quot;$&#123;painting.id&#125;&quot; data-preview=&quot;$&#123;painting.preview&#125;&quot; data-pname=&quot;$&#123;painting.pname&#125;&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;del(this)&quot;&gt;删除&lt;/a&gt; 总结​ try-catch-finally执行的基本步骤是：如果try块中出现了异常,不管是自定义抛出的还是系统抛出的，在catch块中只要符合捕捉的范围，都会对该异常进行处理，最后执行finally块中的代码； 如果没有出现异常，则直接执行try块中的代码，然后执行finally中的代码；因此在开发过程中不要一时图方便，将捕捉异常的范围扩大，还应当业务逻辑进行仔细分析，采用最佳的处理方法；","categories":[{"name":"Java开发","slug":"Java开发","permalink":"https://618dt.github.io/categories/Java%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://618dt.github.io/tags/BUG/"}],"author":"LCG"},{"title":"递归逆置链表","slug":"递归翻转链表","date":"2021-12-03T13:20:20.644Z","updated":"2021-12-09T07:39:08.914Z","comments":true,"path":"p/bac2.html","link":"","permalink":"https://618dt.github.io/p/bac2.html","excerpt":"","text":"实验内容 对于一个不带头结点的单链表，设计递归算法逆置所有结点。 实验原理 1.递归介绍 ​ 程序调用自身的编程技巧称为递归；一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。递归必须具备两个条件，一个是调用自己，一个是有终止条件。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方如下面的代码一样: 123456void recursion(参数0) &#123; if (终止条件) &#123; return; &#125; recursion(参数1);&#125; 2.逆置方法 ​ 对于单链表的递归逆置虽然只有几行代码，但刚开始接触可能会有点绕，所以我尽可能详细的把思路理出来； ​ 对于有n个结点的链表的逆置，利用递归的思想可以先将前n-1个结点逆置；当链表为空或者链表只有一个结点的时候终止递归；每一次调用逆置函数R()完成后返回链表已经逆置完成的部分的第一个结点(设为newNode)；因为在当前结点(设为p)前面的结点都已经完成了逆置，所以当前结点指向的下一个结点(p-&gt;next)，成为了已经逆置完成的部分的最后一个结点；如果要进行逆置的话，当前结点应该要变成最后一个结点；所以将p-&gt;next的下一个结点设置为当前结点，即指向p：p-&gt;next-&gt;next=p; p变为最后一个结点后，其下一个结点为空，即p-&gt;next=NULL;这样就完成了以当前结点为第一个结点的链表部分的逆置，返回当前的第一个结点，继续进行逆置，直到所有递归函数调用完毕； ​ 我们来看一个例子，比如要对链表a-&gt;b-&gt;c-&gt;d进行逆置；调用逆置函数R(a),R(a)中会递归调用R(a-&gt;next)即R(b),而R(b)中又会调用R(b-&gt;next)即R(c);这样依次下来：（递归完成部分加粗显示，按照调用完成的顺序） ①R(d),对d进行逆置，由于d-&gt;next为空，所以直接返回d;此时有newNode=d, a-&gt;b-&gt;c-&gt;d-&gt;NULL; ②R(c),对c-&gt;d进行逆置,当前结点为c，要进行逆置，c应该为最后一个结点，则有：c-&gt;next(d)-&gt;next=c;c-&gt;next=NULL; 此时有newNode=d,d-&gt;c-&gt;NULL; a-&gt;b-&gt;c-&gt;NULL;注意这里没有任何结点指向d了，因为已经将c-&gt;next设置为空； ③R(b),对b-&gt;c-&gt;d进行逆置，由于c-&gt;d部分已经逆置成d-&gt;c-&gt;NULL了，所以只需要将b设置为最后一个结点即可；b-&gt;next(c)-&gt;next=b; b-&gt;next=NULL;返回d；此时有newNode=d,d-&gt;c-&gt;b-&gt;NULL; a-&gt;b-&gt;NULL; ④R(a),对a-&gt;b-&gt;c-&gt;d进行逆置,由于b-&gt;c-&gt;d部分已经逆置成d-&gt;c-&gt;b-&gt;NULL，所以像③一样，a-&gt;next(b)-&gt;next=a, a-&gt;next=NULL;至此，所有的递归函数都已经调用完毕；得到了newNode=d，d-&gt;c-&gt;b-&gt;a-&gt;NULL完成了所有节点的逆置； 代码演示完整代码运行结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;typedef struct Node &#123; int data; struct Node* next;&#125; LinkNode;LinkNode* CreateList(int a[],int n) &#123; if (n &lt; 0) return NULL; LinkNode* head = new LinkNode(); LinkNode* p = new LinkNode(); p = head; head-&gt;data = a[0]; int i = 0; for (i = 1; i &lt; n; i++) &#123; LinkNode* node = new LinkNode(); node-&gt;data = a[i]; p-&gt;next = node; p = node; &#125; p-&gt;next = NULL; // 尾结点next域置为空 return head;&#125;void DispList(LinkNode* ln) &#123; cout &lt;&lt; &quot; &quot;; if (ln != NULL) &#123; cout &lt;&lt; ln-&gt;data; DispList(ln-&gt;next); &#125;&#125;LinkNode* Release(LinkNode* ln) &#123; if (ln == NULL || ln-&gt;next == NULL) return ln; else &#123; LinkNode* newNode = Release(ln-&gt;next); ln-&gt;next-&gt;next = ln;//将当前结点接在逆置完成部分的最后结点后面,使其成为最后结点 ln-&gt;next = NULL;//逆置后，最后一个结点的下一个结点为空 return newNode;//返回逆置完成部分的第一个结点 &#125;&#125;int main() &#123; int a[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; int n = sizeof(a) / sizeof(a[0]); LinkNode* L, *N; L = CreateList(a,n); cout &lt;&lt; &quot;初始链表:&quot; &lt;&lt; endl; DispList(L); cout &lt;&lt; endl; cout &lt;&lt; &quot;逆置链表:&quot; &lt;&lt; endl; N = Release(L); DispList(N); cout &lt;&lt; endl; delete L; delete N; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://618dt.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://618dt.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"【转载】如何成为优秀的程序员","slug":"如何成为优秀的程序员","date":"2021-11-25T11:28:36.430Z","updated":"2021-12-06T11:41:54.751Z","comments":true,"path":"p/6380.html","link":"","permalink":"https://618dt.github.io/p/6380.html","excerpt":"","text":"​ 本文转自:http://www.akaedu.org/pages/news_detail.php?id=294 ​ 我们的老师每天都要应对报名者和学员提出的很多同样的问题，以下是这类典型问题的汇总：嵌入式行业（或者IT业）有没有前途？我听说编程编到三十五 岁就没人要了，一定要转行找出路是吗？做驱动开发和做应用开发哪个更有前途？我一开始看什么书都看不懂，怎么才能理出一个学习顺序？诸如此类。这使我迫切 地感觉到，应该总结这样一份非具体技术问题的FAQ了。本文仅代表我个人观点，有问题欢迎Email: songjinshan@akaedu.org。 ​ 在看这份FAQ之前，你必须先读完ESR的《如何成为一名黑客》（本文末尾附有中译版），该文所讲过的道理我不再重复。该文用很大的篇幅讲什么是黑客文 化，虽然态度和信仰的确是成功的最关键因素，但是你肯定会想，做不做黑客跟我没关系，我只是想学个一技之长，找个好工作而已，对吧？那么肯定更希望获得一 些具体的可操作的指导。 1、各种软件技术之间是怎样的关系？ 我把软件技术分为三个层次： 问题域：计算机图形学、音视频编码、信息安全、模式识别、信息检索、自然语言分析、人工智能、科学计算等； 系统集成：C++和Java等面向对象语言、Python等解释型语言、LISP等函数式编程语言、GUI、中间件、编译器与解释器、虚拟机、数据库、网络服务、并行计算、集群、Peer2Peer、系统管理等； 系统功能：硬件描述语言、计算机体系结构与编程模型、指令集与汇编语言、C语言、内核、文件系统、设备驱动、网络协议、POSIX等。 ​ 计算机最终是做什么用的呢？最终是通过问题域的各种技术为用户解决问题的，这些技术都包含很高深的算法，然而它们必须在一个平台上运行，它们需要利用平台 提供的各种基础设施，比如计算能力、I/O能力和网络互联能力。系统功能和系统集成层就是用来实现这个平台的。系统功能层实现计算、I/O和网络的基本功 能，系统集成层对这些基本功能做一些抽象和包装，提供更方便灵活的接口。 2、为什么要学习嵌入式技术？​ 在亚嵌的学习期间，你将详细了解系统功能层的各部分是如何工作的，也会在面向对象编程、GUI、数据库、网络服务等系统集成层的技术方向进行探索。嵌入式 系统可说是麻雀虽小五脏俱全，虽然没有PC和服务器那么复杂，但计算机系统的各种组成一样也不缺。因此，以嵌入式系统作为切入点开始学习软件技术是非常好 的选择，避开不必要的复杂性，把握计算机系统最根本的概念和技术要点。打下扎实的基础之后，你的职业发展则完全不必局限于嵌入式领域，即使你日后做PC或 服务器开发，在亚嵌所学的知识和技能同样使你终生受益。正如庖丁解牛，心中有全牛，自然就能游刃有余。 ​ 另一方面，你一定见到各大网站都有大量的宣传，说现在嵌入式行业前景空前的好，嵌入式人才紧缺，有几百万职位空缺等等。这些说法也是对的，但我们需要更深 入地理解这说明了什么问题。刚才我们说，嵌入式系统也是一个完整的计算机系统，和PC或服务器没有本质的区别，事实上，嵌入式、PC和服务器的界限已经越 来越模糊了。以前的嵌入式就是单片机，只能做简单的运算处理，现在的ARM处理器性能比从前的奔腾还强，打游戏、看电影都没问题，谁能说它不是PC呢？另 外有些专用的嵌入式系统已经在充当服务器的功能了，而集群技术更是可以使许多廉价的处理器组合在一起发挥大型服务器的作用。由于嵌入式越来越多地应用到电 器、汽车和各种设施上，无处不在，并且与PC、服务器呈融合的趋势，所以嵌入式行业前景空前的好。 ​ 那么，为什么说嵌入式人才紧缺呢？其实，学嵌入式系统就是学计算机系统，本质上并没有什么特殊的只有嵌入式系统才有的技术。说嵌入式人才紧缺，其实质上是 说真正懂计算机的人才紧缺。现在很多学校的所谓“软件学院”培养的软件人才都是一叶障目不见泰山的：只懂J2EE和.NET，没学过C和汇编；只会调库函 数sort()，而对各种排序算法一无所知；设计模式、软件工程讲得头头是道，却不知道好的软件还是要靠牛人靠智商来做的。培养人像蒸包子一样一屉一屉地 出，靠软件工程搭一条生产线，然后让熟练工人站在生产线上拧螺丝，幻想着这样就能生产出好的软件，那是把软件工程和程序员的作用本末倒置了。现在嵌入式开 发对程序员的素质要求更高了，以上这类“软件人才”不能胜任了，因此说嵌入式人才紧缺。亚嵌的就业班虽然只有几个月，但培养目标是有完整的计算机系统概念 的软件人才，而不是只会拧螺丝的软件工人，这正得益于我们始终坚持做嵌入式培训而不是Java或.NET培训。 3、有人说软件技术变化太快，现在学的东西过两年就要完全淘汰，是吗？​ 你知道这话是什么人说的吗？必然是已经被淘汰的人说的。比如Delphi、BCB、PB这些开发工具和语言，都曾经很是风光了一阵，但现在已经完全被 Java和.NET取代了。那么Java和.NET会不会被取代呢，也许在相当长的时间内还不会，但是我看好Python。 ​ 这些被淘汰的程序员有一些共同的特点：只会用鼠标拖拽控件，离开IDE就不知道如何工作，学点儿花拳绣腿的功夫就想吃一辈子，对学习新技术不感兴趣，做一 天和尚撞一天钟。现在请回头看看FAQ1，在整个软件技术领域，这些变化快的技术其实只占了很小的一块，却成了这些人的全部看家本领，这样的人能不被淘汰 吗？ ​ 与这些流行的开发工具和语言相反，很多技术和思想是很少变化的。比如，POSIX和SUS标准规定了一套系统函数接口和基本命令的语义，只有实现了这些才 可以称作UNIX，因此今天的Linux、Solaris跟20多年前的UNIX在系统功能层上是基本一致的。而指导计算机科学发展的数学理论，甚至是老 祖宗们在计算机还没诞生的年代就替我们想好的：布尔代数发表于19世纪，直到一个世纪后发明了计算机和数字电路才有了用武之地；数论在17世纪就出现了， 一直都被数学家们当成一套好玩的理论，但只是好玩而已，直到计算机密码学诞生后才发现它的实际用处。 ​ 各种流行的开发工具和高级语言虽然变化很快，但是底层的编程语言却非常稳定，各种操作系统的内核都是用C语言写的，以前是这样，以后也不会改变。另一方 面，各种编程语言的设计思想也是非常稳定的。其实世界上只有两种编程语言，一种是C，一种是LISP，前者是imperative的，是对计算机模型的抽 象，后者是functional的，是对数学函数模型的抽象。面向对象是一种重要的软件工程思想，却算不上一种新的语言模型，应该归在C的一类。属于同一 类的各种语言其实都大同小异，一个精通C++的人学习Java需要多长时间？熟悉语法一个星期，熟悉类库三个星期，一个月足矣，以往的经验都可以套到新的 编程语言上。然而要想习得深厚的算法功底、逻辑思维和抽象思维修养，能够真正说清楚“系统”是什么，如何分析和设计“系统”，需要多长时间？恐怕要数十 年。 4、C和Java哪种语言更好？​ 计算机科学与编程语言无关，甚至与计算机本身也没太大关系，它研究的对象并不是计算机，而是人分析问题解决问题的方法论。程序写出来最主要不是为了给计算 机执行的，而是为了给人看的，使用编程语言和使用自然语言一样是为了表达和交流，只不过程序还可以顺便给计算机执行而已。 ​ 以上这些话并不是我说的，而是一位著名的计算机科学家说的。所以，在编程语言的层面上争论是没有意义的。很多初学者错误地认为掌握了编程语言就等于学会了 计算机，一种编程语言都还没有掌握好，更没有上升到方法论的层面，只有这种无知的人才会去争论哪种语言好的问题。掌握了编程语言远远不等于学会了计算机， 而只是最开始的一步，最简单的一步，到了工作中，用到什么语言就去学什么语言，什么语言过时了就丢掉，编程语言不需要积累因为它太简单了，真正需要积累的 是方法论。 ​ 很多人喜欢参与到这类争论之中，毫无例外，每个人都在为自己熟练掌握的编程语言辩护，就是“我会的语言最好，我不会的语言都不好”，其实这些人真正想说的 是“我会的语言最好是千秋万代，我就不必学新的语言，不必适应新的变化了”，概括起来说就是一个字，懒。真正的高手都是会很多编程语言的，国外有些做技术 咨询的，每年都要学好几门新的编程语言，这样才能应对市场的变化。不断丢掉旧的编程语言学习新的，看起来好像完全是白费力气，没有积累，其实，每种编程语 言的设计都有独到之处，体现了每种语言的精髓，在融汇百家之后积累下来的正是方法论。 ​ 争论哪种语言能做的事情更多、功能更强是没有意义的。从理论上说，任何一种符合图灵机模型的编程语言，加上适当的I/O扩展都可以做任何事情，用 shell脚本也可以写出很像样的游戏来。只不过各种语言的设计目标不同，表达能力不同，做不同的事情所需的代码量不同而已。 ​ 另外一种错误认识是：哪种语言的市场最大，开发人员最多，哪种语言就最好。单从这种意义上说，Java的确比C更好，所以往届有学员问我们为什么只教C语 言。请你注意，操作系统内核是用C写的，各种底层的应用程序包括Java虚拟机也是用C写的。如果你想学Java，在亚嵌的学习完成后你将有能力分析 Java虚拟机的实现，站在计算机系统的高度来学Java才会使你成为真正的Java高手。如果你只想速成，想早点学成一门技术去做拧螺丝的工作，那么亚嵌不适合你。 ​ 在FAQ3里说过，世界上有C和LISP两种编程语言，你现在学了C，以后学了C++、Java、.NET等等，也仍然只认识了半个世界。LISP和 Haskell构成了另外半个世界，现在很常见的Python和JavaScript等解释型语言也借用了functional programming的思想。如果你只管闷着头写代码，而不去广泛涉猎，那么你将错过很多精彩。 5、我听说编程编到三十五岁就没人要了一定要转行找出路是吗？​ 这个观点虽然很流行，但根本不值一驳。现在三十五岁转行的那些人，都具有前面所说的那些特征，对学习新技术不感兴趣，对探索计算机的本质不感兴趣，得过且 过，下了班就是打游戏、看电视，总之就是懒。如果是开出租、摆摊，勤快人懒人都有饭吃，而IT这一行对懒人是非常无情的，懒人就不该入IT这一行，不从自 身找原因，却到处散布这种言论，怪社会不好，打击新人的信心，着实可恨。 ​ 另外一种情况，编程编到三十五岁，进入公司的管理层，或者自己创业，这都是很勤快的人，如果他们把这种勤快用在技术上肯定也可以做得更好，所以也无法证明编程编到三十五岁会因为没有出路而转行。 ​ 编程不是个体力活，需要高强度的思考和智力投入，分析能力、思考能力都需要时间积累起来，所以并不是越年轻干得越好。相反，我认为三十岁以前写的代码都是 垃圾，三十岁以后才能写出像样的程序来。如果希望一辈子走技术的道路而不会被迫转行，就要不断地把自己的工作性质从“体力活”变成“脑力活”。什么叫“不 断地”变呢？这里的“体力活”并不是指种地、盖房子这种劳动，而是指简单重复地编写代码，这时你会感觉，派给你的工作都能凭以往的经验轻松应付了，但是千 万不要满足于现状，就像温水煮青蛙一样，这是危险的处境！要摆脱这种处境就需要学习、思考、提高，让公司派给你更有挑战性的工作，在工作中应用新学到的知 识和技术就是“脑力活”了，但是用得久了又会变成简单重复的“体力活”，这时就需要再学习、再提高，所以叫做“不断地”把自己的工作性质从“体力活”变成 “脑力活”。如果有一天你发现，自己长期陷于简单重复的劳动之中，并且业余时间非常少，无法学习提高，这说明公司不会用人，你就该考虑跳糟了。 ​ 从另外一个角度来说，如果希望一辈子走技术的道路，就要有自己的核心竞争力，这个核心竞争力决不是凭以往的经验能够做某些工作的能力，而是学习能力、思考 能力和解决有挑战性的新问题的潜力。在IT这一行，凭借以往的经验干重复的活是干不长久的，原因很简单，一个问题不会被解决两次，当你发现你的经验能够解 决一类问题时，别人早把解决这一类问题的套路编写成framework，新上手的人即使不具备你的这些经验也可以调用framework中的类和函数来解 决问题，然后在这个framework的基础上积累新的经验解决新的问题。正因为如此，全世界开发人员的经验才会积累起来，促使软件技术发展得如此迅速。 这并不是说经验完全没有用，最关键的，学习和思考也是建立在以往经验的基础之上的。另一方面，现有的framework并不一定是某方面开发经验的完美整 合，也需要不断发展，用新的办法重新解决老问题，以Web开发为例，从早期的ASP、PHP到后来的.NET、J2EE，到现在的Ruby on Rails、Django等等，这些framework解决的是同一问题，就是如何快速有效地开发Web应用，这方面的经验被不断重新整合，推陈出新。总 结一下，什么才是核心竞争力呢？应该是在经验的基础上学习新技术、解决新问题的能力。 6、做驱动开发还是做应用开发更有前途？​ 意思就是说，“你告诉我哪个更有前途，我就好好学哪个，另外一个就不用学了”。问这种问题的学员往往会同时问另外一些问题：我以后就想做驱动开发，你教我这些应用开发的技术有什么用？C++用得多吗？学了有什么用？我以后不想做GUI，你教我Qt有什么用？ ​ 学习最忌讳的就是“有用的就学，没有用的就不学”这种功利的态度。两个问题：第一，在你还没学进去、还不了解这种技术时，要如何判断这种技术学了有没有 用？只能是根据道听途说，看各种论坛上都怎么说的，岂不知论坛上参与这种讨论的100%都是菜鸟，有的水平还不如你。第二，就算你学的技术没有用上，有什 么损失吗？从亚嵌毕业的学员从事各种各样的开发工作，有做驱动的，有做系统编程的，有做GUI的，有做Web开发的，只要确定了做一类工作，就不可能把在 亚嵌四个月学的知识都用上，但至少也用得上3/4的知识，假设剩下的1/4你一辈子也没机会用上了，那也就损失你一个月的学习时间而已，相比于你的收获， 这算是很大的损失吗？请注意，上面的假设是不成立的，没用上的那1/4也只是暂时没用上而已，程序员要换工作或者换项目是很常见的，任何人都不可能只涉及 一类开发工作，只要有扎实的基础、完备的知识体系，任何工作都能轻松上手。 ​ 扎实的基础，完备的知识体系，我们在安排就业班课程体系的时候，正是以这两点为依据的。有的课程内容很少有学员在以后工作中会用到，但是缺了这一环就不成 为一个完备的知识体系，例如MMU和Cache，那这种课该不该上呢？毫无疑问该上。有的课程培养一种基本的编程思想，例如通过C++来讲面向对象编程， 通过Qt来讲面向对象、事件驱动和状态机编程，这些编程思想是程序员必备的基本素质，而C++和Qt可能有些学员以后工作用不到，那这种课该不该上呢？毫 无疑问该上。至于还有些人争论说C++不如Java用得多，Qt不如GTK用得多，请翻回去看FAQ4，这种争论是无意义的，有工夫争论谁优谁劣，不如把 两种都学了，会更有收获。 ​ 回到做驱动开发还是做应用开发更有前途的问题。我只能说，做好了都有前途，做不好都没有前途，只会做一样而完全不懂另一样是最没前途的。不要以为内核开发 者就不写应用程序，Linus写了一个源代码管理系统git来维护内核，因为觉得现有的源代码管理系统都不好用。牛人都是这样，需要什么就写什么，才不管 是kernel space还是user space。同样，做应用开发如果不懂内核，也没有办法很好地利用内核提供的服务写出性能最优的程序。做内核难，因为调试难，要跟踪大量的并发线程，因为 入门难，要写一个hello world都需要学很多知识。做应用也难，回头去看FAQ1，计算机科学从理论到实践大部分都在上面两层做文章。所以不存在哪个更难哪个更有前途的问题， 任何关于哪个更难的讨论都是too naive的。 7、我一开始看什么书都看不懂，怎么才能理出一个学习顺序？​ 以前有个学员在学C语言时说，“C语言很多地方都很奇怪，都得用内核的知识去解释，可是你又不先教我内核，我没法学C语言。我只好自己看操作系统的书，看 内核代码，可是看不懂。”当然看不懂了，内核代码都是用C写的，如果不学内核就没法学C语言，那不学C语言又怎么可能看懂内核？看来这是一个鸡生蛋还是蛋 生鸡的问题。 ​ 懒真的是人的本性，就连学习的过程都希望是一条路顺利地走下去，不用动脑就能学会的：身后走过的路都是“已知”，每走一步就把眼前新的“未知”变成“已 知”，如此一路走来，把所有的“未知”都变成“已知”就算学成了。可惜，知识不是一条路，而是一个圈，你从任何一个地方跳进这个圈开始走，身后都是“未 知”，眼前也都是“未知”。有的人就是不能容忍自己的身后是“未知”：看一本书，一个新的概念A是用我不了解的概念B、C来解释的，我连B、C都不懂怎么 学A？没法学了！ 不是人家书写得不好，而是没有任何办法能把一个圈扯成一条直线的。学习的过程本质上就是一个循环往复的过程，唯一的办法就是“存疑”：在本子上记着，有 B、C这样两个概念是我暂时不理解的，然后就不再去想这回事，而是相信自己已经理解了B、C，基于自己的理解和假设去学习A，由A再去理解X、Y，这样学 下去，走完一圈之后再回来，自然就明白当初对B、C的假设正确不正确了，理解了这两个概念，就从本子上划掉，这时需要再走一圈，把原来的一些错误认识纠正 过来。所以，任何书都要至少看两遍，第二遍看的时候你会对很多概念有新的认识，因为你看过这个概念后面的章节，在此基础上产生了新的认识。古人早就明白这 个道理，所以提出了“温故而知新”。 ​ 亚嵌的课程体系经过多年教学实践的锤炼，已经很好地理顺了知识之间的关系，使你从最佳的位置跳进这个圈开始学习，所谓“最佳位置”是指，在你初学的时候需 要容忍的“未知”尽可能少，需要做的假设尽可能少，但要想消除所有的“未知”是不可能的，例如没有学内核就要学C语言。根据你以往的经验和一些运气因素， 你对内核的一些假设可能正确也可能错误，但这并不影响你学C语言，对内核的一些错误假设可能会导致在学C语言的过程中有些误解，但没关系，只要跟着我们的 课程体系一步一步走下来，这些误解和错误的假设最终都会纠正过来。 8、有哪些好书可以推荐一下吗？​ 能问出这个问题的都是聪明的学员。看书学习是入门过程中非常重要的一环，如果用一本烂书入门，浪费时间还是小事，如果被误导了就麻烦了，如果形成的错误认 识不能及时纠正，变得根深蒂固了就更麻烦了。所以，看书一定要有“品牌意识”，在决定看书学习一门技术时先问问这一领域最权威的书是哪本，这里列举一些 Bible级别的书： The C Programming Language, 2nd Edition；* C++ Primer, 4th Edition； Structure and Interpretation of Computer Programs, 2nd Edition； Introduction to Algorithms, 2nd Edition； Compilers: Principles, Techniques, and Tools； Advanced Programming in the UNIX Environment, 2nd Edition； TCP/IP Illustrated, Volume 1: The Protocols； UNIX Network Programming Volume 1, 3rd Edition: The Sockets Networking API； Understanding the Linux Kernel, 3rd Edition； Linux Device Drivers, 3rd Edition。* 在学习过程中，眼界一定要开阔，不要学到一点东西就沾沾自喜，坐井观天，以为这就是技术的全部。要多和别人交流，多了解别人在看什么书、别人对技术的认识是怎样的。书是看不完的，活到老学到老，对于程序员来说尤其如此。 9、如何处理打游戏和学习的关系？​ ESR的文章中也说过，黑客们都有一些特别的业余爱好，并且往往是非理性思维的爱好，大概是需要换换脑子吧。典型的例子是因滑翔机事故去世的 Stevens，他写了FAQ8所推荐的Bible当中的三本。爱打游戏的优秀程序员肯定大有人在，有一些还成了优秀的游戏开发人员。但是我认为，要想成 为优秀的程序员，必须有两点基本素质，一是对编程非常感兴趣，二是对所有别的事情都不感兴趣，或者都不如对编程感兴趣。有人说，人的一天有24小时，8小时休息，8小时上班，另外的8小时在干什么就决定了你以后有多大发展。一有时间就看书学习，这就是一个程序员应该做的。今天打游戏，明天看电影，后天炒股，那么你就等着三十五岁下岗。如果你不能够认同编程和思考是比其它事情更有吸引力的，那么你不必学编程，集中精力去做最喜欢的事情或许会有更大的成就。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://618dt.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://618dt.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"author":"宋劲杉"},{"title":"ThreadLocal源码解读","slug":"ThreadLocal源码解读","date":"2021-11-25T02:12:52.383Z","updated":"2021-12-06T11:43:05.462Z","comments":true,"path":"p/4fbd.html","link":"","permalink":"https://618dt.github.io/p/4fbd.html","excerpt":"","text":"ThreadLocal源码解读一、ThreadLocal的set方法​ set()方法的作用是把想要保存或者是想要共享的我们实际需要的成员变量(例如用户信息user等等)存入ThreadLocal中，以便后续拿到；那么是如何实现的呢？通过下面的源码可以看到，首先得到当前线程的对象，然后再得到ThreadLocalMap对象；如果为空的话，就以获取的当前线程为键，自定义的对象为值来创建；如果不为空，就覆盖掉原来的值； 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 下面来看看getMap()方法的实现：看到它直接返回threadLocals；而threadLocals是每一个线程都拥有的成员变量；注意：这个map以及map中的key和value都是保存在线程中的，而不是保存在ThreadLocal中； 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 二、ThreadLocal的get方法​ get()方法是用来获取到ThreadLocal对象自己set的成员变量，那么get()是如何实现的呢？以下就是get()方法的实现；可以看到它首先通过currentThread()方法获取到当前的线程；然后在去看当前线程中的ThreadLocalMap是否为空；如果map为空，说明前面没有对其进行初始化，则执行InitialValue()来进行初始化；反之，则使用getEntry()方法将当前的ThreadLocal在map键值对中对应的值获取到； 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 三、ThreadLocal的remove方法​ remove方法用来删除保存的实际需要的成员变量；这里要注意的是，从线程中获取到的ThreadLocalMap对象是包含了很多个ThreadLocal的，但需要删除的只是当前的ThreadLocal对象，所以使用this引用作为参数执行m.remove()方法； 12345public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"https://618dt.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://618dt.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"测试文章","slug":"测试文章","date":"2021-10-23T05:49:43.000Z","updated":"2021-12-09T07:34:20.874Z","comments":true,"path":"p/1023.html","link":"","permalink":"https://618dt.github.io/p/1023.html","excerpt":"","text":"测试标题这是一个测试页面,以下内容为余华的《活着》 &emsp;&emsp; 我比现在年轻十岁的时候，获得了一个游手好闲的职业，去乡间收集民间歌谣。那一年的整个夏天，我如同一只乱飞的麻雀，游荡在知了和阳光充斥的村舍田野。 &emsp;&emsp; 我喜欢喝农民那种带有苦味的茶水，他们的茶桶就放在田埂的树下，我毫无顾忌地拿起漆满茶垢的茶碗舀水喝，还把自己的水壶灌满，与田里干活的男人说上几句废话，在姑娘因我而起的窃窃私笑里扬长而去。我曾经和一位守着瓜田的老人聊了整整一个下午，这是我有生以来瓜吃得最多的一次，当我站起来告辞时，突然发现自己像个孕妇一样步履艰难了。然后我与一位当上了祖母的女人坐在门槛上，她编着草鞋为我唱了一支《十月怀胎》。我最喜欢的是傍晚来到时，坐在农民的屋前，看着他们将提上的井水泼.在地上，压住蒸腾的尘土，夕阳的光芒在树梢上照射下来，拿一把他们递过来的扇子，尝尝他们和盐一样咸的咸菜，看看几个年轻女人，和男人们说着话。 &emsp;&emsp; 我头戴宽边草帽，脚上穿着拖鞋，一条毛巾挂在身后的皮带上，让它像尾巴似的拍打着我的屁股。我整日张大嘴巴打着呵欠，散漫地走在田间小道上，我的拖鞋吧哒吧哒，把那些小道弄得尘土飞扬，仿佛是车轮滚滚而过时的情景。 &emsp;&emsp; 我到处游荡，已经弄不清楚哪些村庄我曾经去过，哪些我没有去过。我走近一个村子时，常会听到孩子的喊叫： &emsp;&emsp; “那个老打呵欠的人又来啦。” print &quot;hello world&quot; 123for(int i=0;i=100;i++)&#123; cout&lt;&lt;&quot;这是第&quot;&lt;&lt;i+1&lt;&lt;&quot;次&quot;&lt;&lt;循环&lt;&lt;endl;&#125;","categories":[{"name":"分类测试","slug":"分类测试","permalink":"https://618dt.github.io/categories/%E5%88%86%E7%B1%BB%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试标签","slug":"测试标签","permalink":"https://618dt.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}],"author":"LCG"}],"categories":[{"name":"Java数据库","slug":"Java数据库","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux与Redis基础","slug":"Java数据库/Linux与Redis基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Linux%E4%B8%8ERedis%E5%9F%BA%E7%A1%80/"},{"name":"OA系统项目","slug":"Java数据库/OA系统项目","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/OA%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"},{"name":"MyBaits","slug":"Java数据库/MyBaits","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MyBaits/"},{"name":"框架前置知识","slug":"Java数据库/框架前置知识","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A1%86%E6%9E%B6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"name":"Java数据库开发基础","slug":"Java数据库/Java数据库开发基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"name":"MySQL基础","slug":"Java数据库/MySQL基础","permalink":"https://618dt.github.io/categories/Java%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://618dt.github.io/categories/JavaWeb/"},{"name":"Java开发","slug":"Java开发","permalink":"https://618dt.github.io/categories/Java%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://618dt.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂谈","slug":"杂谈","permalink":"https://618dt.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"多线程","slug":"多线程","permalink":"https://618dt.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"分类测试","slug":"分类测试","permalink":"https://618dt.github.io/categories/%E5%88%86%E7%B1%BB%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://618dt.github.io/tags/Redis/"},{"name":"Linux","slug":"Linux","permalink":"https://618dt.github.io/tags/Linux/"},{"name":"MyBaits","slug":"MyBaits","permalink":"https://618dt.github.io/tags/MyBaits/"},{"name":"Lambda","slug":"Lambda","permalink":"https://618dt.github.io/tags/Lambda/"},{"name":"反射","slug":"反射","permalink":"https://618dt.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"Maven","slug":"Maven","permalink":"https://618dt.github.io/tags/Maven/"},{"name":"数据库","slug":"数据库","permalink":"https://618dt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"开发","slug":"开发","permalink":"https://618dt.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"MySQL","slug":"MySQL","permalink":"https://618dt.github.io/tags/MySQL/"},{"name":"Freemaker","slug":"Freemaker","permalink":"https://618dt.github.io/tags/Freemaker/"},{"name":"Listener","slug":"Listener","permalink":"https://618dt.github.io/tags/Listener/"},{"name":"Filter","slug":"Filter","permalink":"https://618dt.github.io/tags/Filter/"},{"name":"正则","slug":"正则","permalink":"https://618dt.github.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"Ajax","slug":"Ajax","permalink":"https://618dt.github.io/tags/Ajax/"},{"name":"JSON","slug":"JSON","permalink":"https://618dt.github.io/tags/JSON/"},{"name":"EL","slug":"EL","permalink":"https://618dt.github.io/tags/EL/"},{"name":"JSP","slug":"JSP","permalink":"https://618dt.github.io/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"https://618dt.github.io/tags/Servlet/"},{"name":"xml","slug":"xml","permalink":"https://618dt.github.io/tags/xml/"},{"name":"BUG","slug":"BUG","permalink":"https://618dt.github.io/tags/BUG/"},{"name":"递归","slug":"递归","permalink":"https://618dt.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"程序员","slug":"程序员","permalink":"https://618dt.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"源码","slug":"源码","permalink":"https://618dt.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"测试标签","slug":"测试标签","permalink":"https://618dt.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}]}