[{"title":"Java内存区域","url":"/p/89f2.html","content":"## 运行时数据区域\n\n◇JVM包含{% wavy 两个子系统 %}和{% wavy 两个组件 %}，共4个组成部分，两个子系统分别为：{% wavy 类加载器 %}(ClassLoader) 、{% wavy 执行引擎 %}(Execution Engine)、两个组件分别为：{% emp 运行时数据区 %}(Runtime Data Area)、{% wavy 本地接口 %}(Native interface)。如下图所示：\n\n![image-20220603211313124](Java内存区域/image-20220603211313124.png)\n\n◇运行时数据区域分为几个区域，其中{% emp 线程共享 %}的区域有：方法区、堆区。{% emp 线程私有 %}的区域有：虚拟机栈、本地方法栈、程序计数器。\n\n### 程序计数器\n\n◇程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。主要作用如下：①**字节码解释器**通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。②用于**保存当前线程执行的内存地址**。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。\n\n◇如果线程正在执行的是一个{% u Java %}方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是{% u 本地 %}(Native)方法，这个计数器值则为空。\n\n◇程序计数器区域是唯一一个在《Java虚拟机规范》中没有规定任何OOM情况的区域。\n\n### Java虚拟机栈\n\n◇虚拟机栈描述的是Java{% u 方法执行 %}的线程内存模型。每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧入栈到出栈的过程。\n\n◇局部变量表存放了{% wavy 编译期 %}可知的各种Java虚拟机**基本数据类型**(共8种)、**对象引用类型**(reference类型，它并不等同于对象本身，可能是一个指向对象{% wavy 起始地址 %}的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关位置)以及**returnAddress类型**(指向了一条字节码指令的地址)。\n\n◇这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的long和double占用两个槽，其余类型占用一个。局部变量表所需的内存在编译期间完成分配。当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量的大小(这里大小指的是局部变量槽的数量，具体使用多大的内存，即一个变量槽使用32bit还是64bit视具体虚拟机的实现而定)。\n\n◇在虚拟机栈区域，有{% emp 两种 %}内存异常情况：①如果线程请求的栈深度大于虚拟机所允许的深度，如方法递归调用没有正确结束时，就会造成StackOverflowError异常。②如果Java虚拟机栈的容量可以动态扩展，那么当栈扩展时无法申请到足够的内存就会抛出OutOfMemoryError异常。比如当创建的线程越来越多，而又长时间运行不销毁时，这些线程就会申请大量的虚拟机栈内存。\n\n### 本地方法栈\n\n◇本地方法栈的作用和虚拟机栈非常相似。其区别在于虚拟机栈是为虚拟机执行Java方法(也就是字节码，JVM只执行字节码文件)服务，而本地方法栈是为虚拟机使用到的本地方法服务。\n\n◇所谓本地方法，就是非Java语言编写的代码接口，需要在我们的Java程序中进行调用。\n\n### Java堆区\n\n◇对于Java应用程序来说，Java堆是虚拟机所管理的{% wavy  内存最大 %}的一块，在Java中几乎所有的对象实例都会在该区域分配内存，并且Java堆是垃圾回收器管理的内存区域。\n\n◇根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在{% wavy 逻辑上 %}它应该被视为连续的。因为对于数组对象等大对象而言，多数虚拟机出于实现简单，存储高效的考虑，会要求连续的内存空间来存储大对象。\n\n◇Java堆可以设置成固定大小，也可以实现动态扩展。通过参数-Xms限定堆内存的最小值，-Xmx限定最大值。当在Java堆中没有内存完成对象的实例分配时，并且也无法扩展时就会抛出OOM异常。\n\n### 方法区\n\n◇方法区用于存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译后的代码缓存**等数据，在Java中所有的类都会被加载到方法区。当方法区无法满足新的内存分配需求时，JVM会抛出OOM异常。\n\n◇注意方法区和永久代不能混为一谈。《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的。 方法区和永久代的关系如同Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，使用堆中的内存。方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。并且在JDK1.8之后，HotSpot虚拟机取消了永久代对方法区的实现，改为了元空间，而元空间使用的是直接内存。\n\n### 运行时常量池\n\n◇运行时常量池是{% emp 方法区 %}中的一部分。在java字节码文件(.class)中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是{% wavy 常量池表 %}，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\n◇字面量：以右值出现，由字母、数字组成的数值或字符，如String  a = \"123\"，123就是右值，作为字面量。符号引用：以一组符号来描述所引用的目标，因为在JVM编译的时候并不知道引用的地址，所以就用符号代替。\n\n◇**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。如下面的代码，会发现a,b两字符串引用变量相等。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str_a = \"best\";//放入字符串常量池中\n        String str_b = \"best\";//会从常量池中查找\n        //结果为true，因为两引用的地址相同\n        System.out.println(str_a == str_b);\n    }\n}\n```\n\n◇但如果我们是重新创建一个字符串对象的话，由于在堆中的地址不同，所以两个引用变量的值也不同，如下面代码所示。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str_a = \"best\";\n        String str_b = new String(\"best\");//新创建了一个对象\n        //结果为false，因为两引用的地址不同\n        System.out.println(str_a == str_b);\n    }\n}\n```\n\n◇总的来说，对于{% u 编译期可以确定值的字符串 %}，也就是{% wavy 常量字符串 %} ，JVM会将其存入字符串常量池。观察下面的代码\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String str1 = \"str\";\n        String str2 = \"ing\";\n        String str3 = \"str\" + \"ing\";//常量池中的对象\n        String str4 = str1 + str2; //在堆上创建的新的对象\n        String str5 = \"string\";//常量池中的对象\n        System.out.println(\"str3=str4?: \"+(str3 == str4));//false\n        System.out.println(\"str3=str5?: \"+(str3 == str5));//true\n        System.out.println(\"str4=str4?: \"+(str4 == str5));//false\n    }\n}\n```\n\n◇结果如下：\n\n![image-20220604163941026](Java内存区域/image-20220604163941026.png)\n\n◇在上面的代码中，str1和str2在创建时会被放入常量池中，因为在Java中String类型本身是{% emp 不可变 %}的，所以{% wavy 直接使用字符串赋值 %}的话就说明在编译期该变量(这里即str1，str2)是确定的，会放入常量池。\n\n◇因为在Java中有编译优化的技术{% wavy 常量折叠 %}，会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(因为代码优化几乎都在即时编译器中进行)。并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以，如①八种基本数据类型，②字符串常量，③final修饰的基本数据类型和字符串变量，④字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）。所以对于str3而言，编译器会将其优化成String str3 = “string”；则str3也是会放入常量池中的，所以有str3==str5。\n\n◇str4是一个引用变量，而引用变量的值在程序编译期是无法确定的，编译器无法对其进行优化。对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder调用append()之后调用toString()得到一个String对象 。如下面的代码\n\n```java\nString str4 = new StringBuilder().append(str1).append(str2).toString();\n```\n\n因此，str4并不是字符串常量池中存在的对象，而是属于堆上的新对象，和str3、str5的地址不同。不过，对于str1和str2两个变量我们可以使用final关键字修饰，那么编译器就会将其当做常量处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。在这里也就是说，str1被final修饰之后，str1就等价于\"str\"，能够进行常量折叠了，str2同理。这样，str4也就相当于str3了。如下面的代码：\n\n```\n    public static void main(String[] args) {\n        //加上final修饰，str1就是不可变的\n        final String str1 = \"str\";\n        final String str2 = \"ing\";\n        String str3 = \"str\" + \"ing\";\n        String str4 = str1 + str2; \n        String str5 = \"string\";\n        System.out.println(\"str3=str4?: \"+(str3 == str4));//true\n        System.out.println(\"str3=str5?: \"+(str3 == str5));//true\n        System.out.println(\"str4=str4?: \"+(str4 == str5));//true\n    }\n```\n\n◇运行结果\n\n![image-20220604170650810](Java内存区域/image-20220604170650810.png)\n\n◇注意，如果编译器在运行时才能知道其确切值的话，即使加了final关键字修饰，编译器也不会进行优化，如下面的代码：\n\n```java\n    public static void main(String[] args) {\n        final String str1 = \"str\";\n        //str2在编译期无法确定\n        final String str2 = getStr();\n        String c = \"str\" + \"ing\";// 常量池中的对象\n        String d = str1 + str2; // 在堆上创建的新的对象\n        System.out.println(c == d);// false\n    }\n    public static String getStr() {\n        return \"ing\";\n    }\n```\n\n◇JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。因为对于字符串常量这种创建完成用几次就不被使用的对象，是很容易被回收的。而要进行频繁垃圾回收的地方是堆空间， 因此在JDK7就把字符串常量池移动到堆空间中了。\n\n◇除了字符串常量池，Java 基本类型的包装类的大部分都实现了常量池技术。Byte、Short、Integer、Long这 4 种包装类默认创建了数值[-128,127]范围内的相应类型的缓存数据，Character创建了数值在[0,127]范围内的缓存数据，Boolean直接返回True 或 False。两种浮点数类型的包装类 Float、Double并{% u 没有实现常量池 %}技术。\n\n### 直接内存\n\n◇直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。\n\n◇JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区(Buffer)的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。\n\n◇显然，本机内存分配不会受到Java堆大小的限制，但既然是内存，则会受到本机总内存大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，如果忽略了直接内存的话，可能会造成配置的各个内存区域的总和大于物理内存限制，从而导致动态扩展时出现OOM异常。\n\n## HotSpot虚拟机中的对象\n\n### 对象的创建\n\n◇Java创建对象的过程如下图所示：\n\n![image-20220604214253895](Java内存区域/image-20220604214253895.png)\n\n#### 类加载检查\n\n◇{% u 类加载检查 %}：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n\n#### 分配内存\n\n◇在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小{% wavy 在类加载完成 %}后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “{% emp 指针碰撞 %}” 和 “{% emp 空闲列表 %}” 两种。\n\n◇假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存放在另一边，中间放在一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针指向空闲空间的方向移动一段与对象大小相等的距离，这就是指针碰撞的分配方式。\n\n◇如果Java堆中内存并不是规整的，已被使用内存和空闲内存相互交错在一起，那就不能简单的移动指针了。这时候虚拟机就需要维护一个列表，记录上哪些内存块是可用的，在分配内存的时候从列表找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种方式就是空闲列表。\n\n◇选择哪一种分配方式，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是\"标记-清除\"，还是\"标记-整理\"（也称作\"标记-压缩\"），此外，复制算法内存也是规整的。\n\n◇在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全。**①CAS+失败重试**： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**②TLAB**： 为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。\n\n#### 初始化零值\n\n◇内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n\n#### 设置对象头\n\n◇初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在{% emp 对象头 %}中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n\n#### 执行init方法\n\n◇在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，即Class文件中的\\<init\\>()方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行\\<init\\>()方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n### 对象的内存布局\n\n◇在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充。\n\n◇对象头部分包括两类信息：第一类是用于存储对象自身的运行时数据(官方称为“Mark Word”)，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。第二类是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n◇实例数据部分是对象真正存储的有效信息，即我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录下来。这部分的存储顺序会受到JVM分配策略参数和字段在Java源码中定义顺序的影响。\n\n◇对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n\n### 对象的访问定位\n\n◇Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有{% emp 使用句柄 %}和{% wavy 直接指针 %}两种。\n\n◇如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n\n![image-20220604223030473](Java内存区域/image-20220604223030473.png)\n\n◇如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。\n\n![image-20220604223127944](Java内存区域/image-20220604223127944.png)\n\n◇这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变{% u 句柄中的实例数据指针 %}，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。在HotSpot虚拟机中主要采用直接指针的访问方式。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["JVM"],"categories":["Java虚拟机"]},{"title":"Docekr部署项目","url":"/p/fa8a.html","content":"## 一、打包SpringBoot项目\n◇这里的项目以[医点通](https://gamest.link/p/ea75.html)项目中的service-cmn服务模块为例，首先在需要进行打包的模块(即有启动类的服务模块和网关模块)中进行打包的配置，注意统一的实体类等不需要打包的模块不要配置。配置如下：\n```xml\n <!--在build中配置resource,来防止资源导出失败问题-->\n    <build>\n        <!--配置springboot打包插件-->\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.yml</include>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes> <include>**/*.yml</include>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n        </resources>\n    </build>\n```\n◇然后点击在IDEA右侧的Maven->找到service-cmn模块->双击package或install进行单独打包(可以在父项目中一次性打包多个子模块)。\n![image.png](Docker部署项目/1646983118953-0fdee5bd-9075-4d2f-89bb-9ff74757b54c.png)\n◇package打包成功后可以看到如下提示：\n\n```properties\n[INFO] --- spring-boot-maven-plugin:2.2.12.RELEASE:repackage (repackage) @ service_cmn ---\n[INFO] Replacing main artifact with repackaged archive\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 24.464 s\n[INFO] Finished at: 2022-03-11T15:58:24+08:00\n[INFO] Final Memory: 64M/454M\n[INFO] ------------------------------------------------------------------------\n```\n## 二、Docker部署\n◇Docker的安装见前面的文章：[Docekr应用](https://gamest.link/p/e1be.html)。\n◇由于service-cmn模块使用到了MySQL数据库，如果在虚拟机中运行该服务的话，就需要更改服务配置MySQL数据库的部分，将localhost改为Windows主机的ip地址，并且修改MySQL为允许远程连接，具体操作请看[虚拟机连接主机MySQL](https://blog.csdn.net/mingxin95/article/details/78832129)。\n◇也可以直接在Docker中拉取一个MySQL的镜像，这样数据库配置可以直接写localhost。\n\n```properties\n#启动docker\nsystemctl start docker\n#搜索mysql镜像\ndocker search mysql\n#下载5.7的版本\ndocker pull mysql:5.7\n#根据镜像创建mysql容器,密码为123456\ndocker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7\n```\n◇在主机的Navicat数据库管理工具中连接到虚拟机中的数据库，并将service-cmn服务对应的数据库appointment-cmn复制到虚拟机中。\n![image.png](Docker部署项目/1646995120902-67a47c9f-66bd-41f1-bfa1-efc084e3fb10.png)\n◇在docker目录中新建一个service目录，将前面打好的jar包上传到虚拟机的service中。使用xftp，如果没有权限，使用命令chmod 777 service授权。\n\n```properties\n#进入docker目录\n[root@master docker]# cd /var/lib/docker\n#创建service目录\nmkdir service\n#开启权限(在docker的上一级目录lib中)\n[root@master lib]# chmod 777 service\n```\n◇然后创建Dockerfile文件（vim Dockerfile），内容如下:\n```properties\nFROM java:8 \n# 将jar包添加到容器中并更名为app.jar\nADD service_cmn-0.0.1-SNAPSHOT.jar app.jar \n# 设置端口号，此处只开放一个端口8202\nEXPOSE 8202\n# 执行命令，此处运行app.jar\nRUN bash -c 'touch /app.jar'\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]  \n```\n◇查看Dockerfile文件\n```properties\n[root@master service]# vim Dockerfile\n[root@master service]# cat Dockerfile\nFROM java:8 \nADD service_cmn-0.0.1-SNAPSHOT.jar app.jar \nEXPOSE 8202\nRUN bash -c 'touch /app.jar'\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n[root@master service]# \n```\n◇为什么要在docker目录下新建一个目录存放jar包和Dockerfile呢? 是因为如果直接在docker目录下构建镜像的话，会使生成的发送给Docker守护进程的上下文过大。上下文是根据Dockerfile文件所在目录生成的，而docker目录下本来就有很多子目录，这就导致问题产生。\n```properties\nSending build context to Docker daemon 4.309 GB\n```\n◇如果不想新建子目录的话，就要创建一个.dockerignore文件，在里面配置生成忽略的目录：\n```properties\n./builder\n./containerd\n./image\n#...这样显然过于麻烦\n```\n◇最后先启动cmn模块需要的一些服务，如nacos、redis，然后构建cmn的镜像并生成容器启动。\n```properties\n#构建镜像,镜像名为:service_cmn,v1.0表示版本,可省略; .表示当前路径,不可省;\n[root@master service]# docker build -f Dockerfile -t service_cmn:v1.0 .\nSending build context to Docker daemon  75.16MB\nStep 1/5 : FROM java:8\n ---> d23bdf5b1b1b\nStep 2/5 : ADD service_cmn-0.0.1-SNAPSHOT.jar app.jar\n ---> c7cafd276296\nStep 3/5 : EXPOSE 8202\n ---> Running in 002409c6c02b\nRemoving intermediate container 002409c6c02b\n ---> b184e8ae5522\nStep 4/5 : RUN bash -c 'touch /app.jar'\n ---> Running in 891f96a44e21\nRemoving intermediate container 891f96a44e21\n ---> d1a1996ba764\nStep 5/5 : ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n ---> Running in d18f642aaab4\nRemoving intermediate container d18f642aaab4\n ---> a0e08a0ced11\nSuccessfully built a0e08a0ced11\nSuccessfully tagged service_cmn:v1.0\n#查看镜像列表\n[root@master service]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nservice_cmn         v1.0                a0e08a0ced11        12 minutes ago      794MB\nmysql               5.7                 11d8667108c2        2 days ago          450MB\nrabbitmq            management          799381c528ac        5 weeks ago         254MB\nmongo               latest              ee13a1eacac9        2 months ago        696MB\njava                8                   d23bdf5b1b1b        5 years ago         643MB\n[root@master service]# \n# --net=host表示和宿主机共用网络,-d表示后台运行 -p后面有两个端口,分别是:宿主机端口:容器端口\n# 即用主机8202端口映射容器端口，这里容器端口要和cmn服务中配置的端口一致\n# --name=cmn 表示容器名称,最后面为容器使用的镜像\n[root@master service]# docker run    --net=host  --name=cmn -d -p 8202:8202 service_cmn:v1.0\nWARNING: Published ports are discarded when using host network mode\n55f440226120da0097961fc87e36a8c86555eff580308f8491ad3515f1e32292\n#查看运行的容器\n[root@master service]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n55f440226120        service_cmn:v1.0    \"java -jar /app.jar\"     40 seconds ago      Up 39 seconds                                           cmn\na807a6c90bec        mysql:5.7           \"docker-entrypoint.s…\"   About an hour ago   Up About an hour    0.0.0.0:3306->3306/tcp, 33060/tcp   mysql\nd9a024b9bffc        mongo               \"docker-entrypoint.s…\"   6 weeks ago         Up About an hour    0.0.0.0:27017->27017/tcp            mymongo\n[root@master service]# \n```\n◇然后在主机浏览器中通过swagger进行测试，访问:http://192.168.222.137:8202/swagger-ui.html#/ 查看服务是否正常启动。\n![image.png](Docker部署项目/1647000064738-737f863a-ceb2-4260-b8b3-3fcaaf71e576.png)\n◇可以发现项目成功启动了，那下面测试方法能否调用成功。我们根据findByDictCode()方法查询所有省级地区数据。\n![image.png](Docker部署项目/1647000366843-bff5d73e-9db9-48b2-9549-b560be3b4cab.png)\n◇至此，service-cmn服务已经成功部署在docker中了，对于其他的服务模块采用同样的方法部署即可。\n◇如果要删除镜像，则需要先停止容器并删除容器，最后删除镜像。\n\n```properties\n#查看容器\n[root@master service]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\nb69ba027734a        service_cmn:v1.0    \"java -jar /app.jar\"     29 minutes ago      Up 29 minutes                                           cmn\n#停止容器\n[root@master service]# docker stop b69ba027734a\nb69ba027734a\n#根据容器ID删除容器\n[root@master service]# docker rm b69ba027734a\n#查看镜像\n[root@master service]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nservice_cmn         v1.0                9d61dae6888c        32 minutes ago      794MB\n#根据镜像ID删除镜像\n[root@master service]# docker rmi 9d61dae6888c\n```\n## 三、需要注意的地方\n◇整体搭建过程比较简单，但也有一些要注意的点:\n1.容器的端口号要和我们在服务中配置的端口号一致，最好容器的宿主机映射的端口号也保持一致。\n\n2.注意实例化容器的时候需要采用host的方式去启动项目容器，否则会连接不上MySQL数据库，这是因为docker会自动给每个容器分配ip，但是项目里配置的mysql地址是localhost，在容器内连接localhost是连接容器本身而不是宿主机的localhost，所以一直找不到mysql。因此采用host的网络方式将容器与宿主机共用一个Network Namespace,这样容器内localhost就是宿主机的localhost了。\n\n3.注意不要将Dockerfile文件直接放在docker目录下，否则有可能生成过大的context。\n\n4.如果成功启动镜像后无法访问虚拟机，则需要使用防火墙放行相关端口，如这里需要放行8202端口。\n\n```properties\n#启动防火墙\n[root@master service]# systemctl start firewalld\n#查看端口是否放行,no表示未放行\n[root@master service]# firewall-cmd --query-port=8202/tcp\nno\n#放行端口\n[root@master service]# firewall-cmd --add-port=8202/tcp --permanent\nsuccess\n#重启防火墙服务\n[root@master service]# firewall-cmd --reload\nsuccess\n[root@master service]# firewall-cmd --query-port=8202/tcp\nyes\n```\n\n5.最后，对于微服务项目而言，由于有多个服务需要多个docker容器，可以将这多个容器由Docker Compose来统一配置，Docker Compose通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。\n","tags":["Docker"],"categories":["技术杂谈"]},{"title":"医点通项目介绍","url":"/p/ea75.html","content":"## 一、项目简介与特点\n### 1.项目简介\n​\t◇医点通预约挂号系统是一项便民服务系统,一点即通,方便患者挂号就医!\n\n​\t◇[项目开发笔记](https://www.yuque.com/u21068845/qxdaub)\n\n​\t◇[项目完整代码](https://github.com/618dt/Hospital)\n\n### 2.项目特点\n\n- 友好的代码结构及注释，便于阅读及二次开发\n- 实现前后端分离，请求接口封装，错误码统一处理\n- 前端采用Element-ui框架，极大的提高了开发效率\n- 引入swagger文档支持，方便编写API接口文档\n- 项目采用分布式架构，每个子项目可独立部署，扩展灵活，易于维护\n- 使用NoSQL型数据库，将医院等不需要经常写操作的信息存储在MongoDB中，提高数据的查询速度\n- 使用SpringCloudGateway进行统一网关校验和请求转发，并解决跨域问题\n### 3.项目业务流程\n◇项目业务流程如图：\n![image.png](预约挂号平台项目/1646032002195-72f9eee8-5c59-459a-8a96-f42ce5d4e009.png)\n\n## 二、项目模块介绍\n### 1.项目模块组成\n◇如下图所示，整个项目（appointment-parent）由多个子项目（service,common等）聚合而成，每个子项目各是一个独立可部署的JavaWeb项目（可以放到Tomcat中运行），各项目通过SpringCloud实现项目间服务调用，使得整个项目可以实现分布式部署。这种架构是分布式Java项目常采用的架构模型。\n![image.png](预约挂号平台项目/1645796126400-bcfa17df-bfea-49c0-a3e3-e8fd342ebdc8.png)\n◇其中common模块包括了项目所需的基础工具类，如全局异常类，统一返回结果状态信息类，Redis配置类，service模块所需的服务类等。hospital-manage是医院系统模块。service是各个微服务的父模块，包含了cmn数据字典服务，医院服务，短信服务，订单服务等。service_client模块包含了远程服务提供者提供者的服务接口。service_gateway是网关模块，配置有请求的统一转发，请求过滤等信息。\n\n### 2.项目服务架构\n◇项目微服务架构图如下\n![image.png](预约挂号平台项目/1646033456298-faa05956-b620-48d1-9758-dba5e702dea8.png)\n\n## 三、项目主要技术\n### 1.前端技术\n◇[Vue.js](https://cn.vuejs.org/index.html)：是一套用于构建用户界面的渐进式JavaScript框架。 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（[SPA](https://baike.baidu.com/item/SPA/17536313)）提供驱动。\n◇[Element-ui](https://element.eleme.cn/#/zh-CN)：网站快速成型工具，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。\n◇[Nuxt.js](https://www.nuxtjs.cn/)：基于 Vue.js 的轻量级应用框架,可用来创建服务端渲染 (SSR) 应用,也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特性。\n\n### 2.后端技术\n#### 2.1 开发框架\n◇[SpringBoot](https://start.spring.io/)：简化spring的搭建和开发过程的全新框架。\n◇[MyBatis-Plus](https://baomidou.com/)：一个[MyBatis](https://mybatis.org/mybatis-3/)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n#### 2.2 数据库\n◇[MongoDB](https://www.mongodb.com/)：一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。\n◇[MySQL](https://www.mysql.com/)：关系型数据库。\n◇[Redis](https://redis.io/)：一个基于内存的高性能key-value数据库。\n#### 2.3 SpringCloud微服务\n◇[Nacos](https://nacos.io/zh-cn/docs/quick-start.html)：使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务的发现、管理、共享、组合更加容易。\n◇[Gateway](https://spring.io/projects/spring-cloud-gateway)：为微服务架构提供一种简单而有效的统一的API路由管理方式。\n◇[Feign](https://spring.io/projects/spring-cloud-openfeign)：一个声明式的Web服务客户端，使用Feign可使得Web服务客户端的写入更加方便。\n#### 2.4 其他\n◇消息中间件[RabbitMQ](https://www.rabbitmq.com/)：一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。\n◇Api接口文档工具[Swagger](https://swagger.io/)：一款RESTFUL接口的文档在线自动生成+功能测试功能软件。\n## 四、项目主要功能\n### 1.用户模块\n#### 1.1 登录注册以及认证\n◇用户首页，可以根据医院名称进行模糊查询，输入文字后可根据文字模糊查询出医院列表显示在下拉框中，点击可跳转至医院页面进行预约挂号。\n![image.png](预约挂号平台项目/1645848378064-376da2a5-bb38-47e1-b66f-817e09887a76.png)\n◇用户注册功能，可以使用邮箱和微信登录。\n![image.png](预约挂号平台项目/1645848554735-d1d00e1e-5593-4f4d-8de2-cc15c850f0b9.png)\n![image.png](预约挂号平台项目/1645848532112-11c06114-0ef0-4ba4-9d5c-088cf1a0bf3c.png)\n◇登录成功后默认用户名为邮箱号，需要进行实名认证才能挂号。![image.png](预约挂号平台项目/1645849579723-0e8294d2-51bd-4820-81f1-1a3822898ea5.png)\n◇用户实名认证功能，通过填写姓名，证件信息以及证件照方式进行实名认证，由平台管理员进行认证审批。\n![image.png](预约挂号平台项目/1645850174586-36b13918-81b2-40dd-84af-cc5af2067d47.png)\n\n#### 1.2 用户就诊人管理\n◇用户就诊人管理，用户能够对就诊人进行基本的增删改查操作。\n![image.png](预约挂号平台项目/1645851170039-13512702-62f8-4507-8913-5c1f19ddca23.png)\n◇添加就诊人的相关信息。\n![image.png](预约挂号平台项目/1645851321787-bfb725df-9a46-4b87-b59b-35a84649a4af.png)\n◇实现省市区三级联动下拉框以便就诊人选择住址![image.png](预约挂号平台项目/1645851481528-59663a73-f4b7-4b57-b25f-1fbb31ed2e70.png)\n\n#### 1.3 预约挂号功能\n◇预约挂号功能，能够根据自身情况选择对应的医院科室进行预约挂号。\n![image.png](预约挂号平台项目/1645851076761-33ed8ac3-282e-4766-a21c-939356597052.png)\n◇点击剩余按钮后进入确认挂号页面，选择就诊人进行预约挂号。\n![image.png](预约挂号平台项目/1645851700157-b3f19c99-600b-43e7-ad63-b09a9470a54a.png)\n◇当点击确认挂号后能够收到邮件提醒，预约成功后不进行支付可以直接取消。\n![image.png](预约挂号平台项目/1645861133423-78d4bcb1-3a74-4c03-bad1-5fb7b3e1d445.png)\n◇预约成功跳转到待支付页面。\n![image.png](预约挂号平台项目/1645852676324-b396e243-17d8-407d-abcf-5d25dd8742aa.png)\n◇使用微信支付![image.png](预约挂号平台项目/1645852702905-5e0507a6-a190-4348-a7f4-c4e98c44c6b9.png)\n◇支付成功后订单状态变为已支付。\n![image.png](预约挂号平台项目/1645852803503-4d2d84c4-475b-4377-86ad-06261ec0e2e6.png)\n◇支付成功后取消预约能够进行全额退款，取消预约后也会有邮件提醒。\n![Screenshot_20220226_141911_com.tencent.mm.png](预约挂号平台项目/1645857008975-26865b8c-2324-48b8-b741-484c9d542dec.png)\n\n### 2.平台管理模块\n#### 2.1 医院设置管理功能\n◇查看医院设置列表；能够进行分页显示，以及按医院名称，医院编号条件查询；医院设置即对平台上的医院进行相关信息的设置，如医院的api基础路径，用于和医院系统交互；医院方的联系人等；以及对医院的锁定删除等功能。\n![image.png](预约挂号平台项目/1645800514957-52204880-53d8-484b-a323-79067e7fc769.png)\n◇医院设置添加![image.png](预约挂号平台项目/1645800626630-99025846-2d27-4fcb-b7e7-6ad6a2fb0fa2.png)\n◇医院设置修改，点击医院设置列表的修改操作就会跳转到编辑页面，并将数据回填。![image.png](预约挂号平台项目/1645800658163-9e50629d-8a7f-4d12-9f20-29255f65eae2.png)\n◇医院列表\n![image.png](预约挂号平台项目/1645846066005-25f3ea6f-4701-4b44-9fc6-12949cfd5dcb.png)\n◇查看医院详情\n![image.png](预约挂号平台项目/1645846228516-f88570a6-88b6-4221-bf7d-022f996cb126.png)\n◇点击排班可以按日期、科室显示相关排班信息。\n![image.png](预约挂号平台项目/1645846159147-0985aab6-f80b-455b-a0c7-67d922121766.png)\n\n#### 2.2 数据字典\n◇数据字典树形懒加载\n![image.png](预约挂号平台项目/1645846326135-aa5adeea-d77d-40cd-b23c-c808a241089f.png)\n\n#### 2.2 用户管理功能\n◇用户列表\n![image.png](预约挂号平台项目/1645846715543-c24e6ed8-f597-46b8-864d-fb49b2ff1144.png)\n◇用户审批列表\n![image.png](预约挂号平台项目/1645850460179-24293546-ab4b-4d36-a62d-a711542881c6.png)\n◇用户信息查看\n![image.png](预约挂号平台项目/image.png)\n\n#### 2.3 订单查看及统计功能\n◇平台能够查看所有的订单信息并且对订单数据进行统计。\n![image.png](预约挂号平台项目/1645959395125-c2fab051-87a4-4f55-97e3-754e43cd26b2.png)\n![image.png](预约挂号平台项目/1645941809992-a033e8bc-8fe1-4d74-9751-8d7de2ccac5b.png)\n\n### 3.医院系统模块\n◇医院设置功能;设置医院的编码、医院签名和统一预约挂号平台的基础路径；医院签名用于和挂号平台进行校验，基础路径即调用平台相关的接口路径。\n![image.png](预约挂号平台项目/1645799932699-12c569b8-3d34-4137-a63e-065b1c9d0a2c.png)\n◇医院信息及上传医院信息功能，通过JSON数据的方式上传医院信息；若要修改医院信息，在医院编号不变的情况下重新添加数据即可。\n![image.png](预约挂号平台项目/1645800177789-2ca6bdfc-1b20-44ce-9d3b-687190928669.png)\n![image.png](预约挂号平台项目/1645800316594-c4540778-12cc-48aa-bedf-5e6f625f2eb3.png)\n◇科室列表与上传科室功能；上传科室的方式也是通过JSON数据上传。\n![image.png](预约挂号平台项目/1645800351792-d8b7cfa4-658c-49b3-a2b2-90013520e9ea.png)\n◇医院排班列表以及上传排班功能和前面类似。\n\n## 五、项目运行\n\n### 1.虚拟机\n◇启动虚拟机，在虚拟机中运行nacos、redis、mongoDB，rabbitMQ；\n```properties\n#启动nacos,目录:cd /usr/local/Nacos/nacos/bin\n[root@master bin]# sh startup.sh -m standalone\n/usr/java/jdk8u282-b08/bin/java  -Xms512m -Xmx512m -Xmn256m -Dnacos.standalone=true -Djava.ext.dirs=/usr/java/jdk8u282-b08/jre/lib/ext:/usr/java/jdk8u282-b08/lib/ext:/usr/local/Nacos/nacos/plugins/cmdb:/usr/local/Nacos/nacos/plugins/mysql -Xloggc:/usr/local/Nacos/nacos/logs/nacos_gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -Dnacos.home=/usr/local/Nacos/nacos -Dloader.path=/usr/local/Nacos/nacos/plugins/health -jar /usr/local/Nacos/nacos/target/nacos-server.jar  --spring.config.location=classpath:/,classpath:/config/,file:./,file:./config/,file:/usr/local/Nacos/nacos/conf/ --logging.config=/usr/local/Nacos/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288\nnacos is starting with standalone\nnacos is starting，you can check the /usr/local/Nacos/nacos/logs/start.out\n#启动redis,目录:cd /usr/local/redis-5.0.0/bin\n[root@master bin]# ./redis-server redis.conf\n1917:C 20 Feb 2022 18:06:36.715 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n1917:C 20 Feb 2022 18:06:36.715 # Redis version=5.0.0, bits=64, commit=00000000, modified=0, pid=1917, just started\n1917:C 20 Feb 2022 18:06:36.715 # Configuration loaded\n#启动mongoDB和rabbitMQ\n#启动docker 任意目录\n[root@master bin]# systemctl start docker\n#进入mongoDB\n[root@master bin]# docker exec -it mymongo /bin/bash\nroot@d9a024b9bffc:/# mongo\n> show dbs\nadmin             0.000GB\nappointment_hosp  0.001GB\nconfig            0.000GB\nlocal             0.000GB\ntest              0.000GB\n> \n#rabbitmq\n[root@master bin]# docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management\na4f4c63a827bc83627289f42cada49f12f8d2d7c69af07be80e74ca12cb4ab0a\n#docker ps -a 查看容器列表; docker start xxxxxx --启动已经建立的容器号\n[root@master bin]# \n```\n◇如果Xshell突然连接不上虚拟机查看22端口是否放行\n```properties\n#启动防火墙\n[root@master bin]# systemctl start firewalld\n#查看端口8848是否放行,no表示未放行\n[root@master bin]# firewall-cmd --query-port=20/tcp\nno\n#放行8848端口\n[root@master bin]# firewall-cmd --add-port=20/tcp --permanent\nsuccess\n#重启防火墙服务\n[root@master bin]# firewall-cmd --reload\nsuccess\n[root@master bin]# \n```\n◇或者是因为使用任务管理器强制退出VM时，导致虚拟机网络配置被重置，需要重新配置网络；具体方法见[Centos7虚拟机安装](https://blog.csdn.net/rao991207823/article/details/102877118)，本机的配置文件为ens32；\n### 2.后端项目\n◇运行service模块中各个子模块的启动类；运行hospital-manage模块的启动类；\n◇解决端口占用(在cmd中)\n```properties\n#查看占用端口的进程号\nC:\\Users\\ASUS>netstat -ano|findstr \"8201\"\n  TCP    0.0.0.0:8201           0.0.0.0:0              LISTENING       16488\n  TCP    [::]:8201              [::]:0                 LISTENING       16488\n#查看进程详情\ntasklist|findstr 16488\n#终止进程  /F 指定强制终止进程,/T 终止指定的进程和由它启用的子进程\nC:\\Users\\ASUS>taskkill /pid 16488 /F\n成功: 已终止 PID 为 16488 的进程。\n```\n### 3.前端项目\n\n◇启动命令:npm run dev\n\n![image-20220228223215283](预约挂号平台项目/image-20220228223215283.png)\n\n## 六、BUG修改\n\n### 1.用户前端页面报错\n◇打开用户前端页面报错如下，\n![image.png](预约挂号平台项目/1645498796901-14977c39-accf-426d-9b79-9b67ff1a83f7.png)\n◇报错原因，因为在用户前端的首页index.vue中数据是异步渲染的，报错是因为没有获取到数据，检查后发现是因为后台网关服务模块没有启动；\n\n### 2.阿里云oss上传文件\n◇获取不到阿里云oss上传文件的url，需要设置跨域规则；\n![image.png](预约挂号平台项目/1645750849434-28ef8c12-296b-4d58-888f-7abca5fbefe0.png)\n\n### 3.请求医院接口报错\n![image.png](预约挂号平台项目/1645755033752-05371c24-d801-4185-8a36-83673bbdca59.png)\n◇原因，医院系统的端口为9998；在数据库中将端口改为9998即可；\n\n### 4.调用OrderMapper接口方法报错\n◇在统计预约挂号信息时，service-order模块报错如下，提示找不到OrderMapper；\n```properties\norg.apache.ibatis.binding.BindingException: Invalid bound statement (not found): \ncom.lcg.appointment.order.mapper.OrderMapper.selectOrderCount\n```\n\n◇当仔细比对相关路径后，发现还是报错；查看[博客](https://blog.csdn.net/weixin_43654123/article/details/121469145)发现是因为mybatis的配置文件默认应当放入resource目录下，但是这里将配置文件放在了java目录下，所以无法导出配置文件，进而在target文件夹中没有mapper的配置文件；\n\n![image.png](预约挂号平台项目/1645938655960-5f029006-c7e0-41e5-805b-cd256d874ea7.png)\n◇解决方法，需要手动配置资源过滤，让它把java目录下的properties和xml等配置文件的过滤开启，使它们能够被导出，统一在service模块下的pom.xml配置文件中开启过滤；\n\n```xml\n  <!--在build中配置resource,来防止资源导出失败问题-->\n  <build>\n      <plugins>\n          <plugin>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-maven-plugin</artifactId>\n          </plugin>\n      </plugins>\n      <resources>\n          <resource>\n              <directory>src/main/java</directory>\n              <includes>\n                  <include>**/*.yml</include>\n                  <include>**/*.properties</include>\n                  <include>**/*.xml</include>\n              </includes>\n              <filtering>false</filtering>\n          </resource>\n          <resource>\n              <directory>src/main/resources</directory>\n              <includes> <include>**/*.yml</include>\n                  <include>**/*.properties</include>\n                  <include>**/*.xml</include>\n              </includes>\n              <filtering>false</filtering>\n          </resource>\n      </resources>\n  </build>\n```\n\n◇配置好后，clean一下service-order模块![image.png](预约挂号平台项目/1645939173770-82d79ae5-b86e-44f4-ad08-22ca792f3f99.png)\n◇然后重新启动order模块，可以看到mapper配置文件存在了\n![image.png](预约挂号平台项目/1645939480775-ff963827-f869-4636-b9e6-f6072b442fa8.png)\n\n### 5.Feign调用报错\n◇Feign调用时报错，需要在统计模块中远程调用订单模块接口获取订单列表，测试时发现如下错误；\n```properties\nfeign.codec.DecodeException: Type definition error: [simple type, class com.baomidou.mybatisplus.core.metadata.IPage]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.baomidou.mybatisplus.core.metadata.IPage` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information\n at [Source: (PushbackInputStream); line: 1, column: 1]\n```\n◇报错原因，feign返回复杂对象时需要有无参构造函数，而在MyBatis-Plus中，IPage是接口，接口是没有构造方法的。而Page是其实现类，所以解决方法是将IPage接口对象转换为Page。\n```java\n@PostMapping(\"inner/{page}/{limit}\")\npublic Page<OrderInfo> OrderList(@PathVariable Long page, @PathVariable Long limit, @RequestBody OrderQueryVo orderQueryVo) {\n    //设置分页参数:页号,每页记录数\n    Page<OrderInfo> pageParam = new Page<>(page,limit);\n    IPage<OrderInfo> pageModel = orderService.selectPage(pageParam, orderQueryVo);\n    /*远程服务调用需要返回Page类型*/\n    BeanUtils.copyProperties(pageModel,pageParam);\n    return pageParam;\n}\n```\n\n","tags":["项目"],"categories":["Java开发"]},{"title":"SpringCloud开发入门","url":"/p/8a2d.html","content":"## Spring Cloud简介\n◇ 成熟的微服务框架，定位为开发人员提供工具，以快速构建分布式系统  \n◇核心组件\n![image.png](SpringCloud入门/1637201478519-93f45ace-901c-442c-9163-9e6624fd8722.png)\n\n## 项目整体设计\n### 接口设计\n◇课程列表\n◇单个课程价格\n◇整合课程列表和价格；首先会通过远程调用获取整个课程列表，然后遍历课程，补充课程价格；\n### 系统数据流向\n![image.png](SpringCloud入门/1637237174459-c8165a19-bc27-46cf-a455-4f6b3583dc22.png)\n### 数据库设计\n◇课程表course\n\n```sql\nCREATE TABLE `course`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `course_id` int(11) NOT NULL,\n  `name` varchar(50)  NOT NULL COMMENT '课程名',\n  `vaild` int(1) NOT NULL COMMENT '是否上架',\n  PRIMARY KEY (`id`)\n) ENGINE = InnoDB;\n```\n\n![image.png](SpringCloud入门/1637237679549-0044ab1b-fb71-4db3-b500-900344d40c98.png)\n◇课程价格表course_price\n\n```sql\nCREATE TABLE `course_price` (\n`id` int(11) NOT NULL AUTO_INCREMENT,\n`course_id` int(11) NOT NULL,\n`price` int(11) NOT NULL,\nPRIMARY KEY(`id`)\n)ENGINE = INNODB;\n```\n\n![image.png](SpringCloud入门/1637237804357-252adc06-25d6-48cf-8b03-e9ee6434947c.png)\n\n## 项目基础开发\n◇选择Spring Initalizr项目\n![image.png](SpringCloud入门/1637238522858-02cc690b-3f8b-47a8-8fee-7c8ba43125aa.png)\n![image.png](SpringCloud入门/1637238754507-9fc39092-aec3-40b9-ba7a-138c3680851f.png)\n◇因为是多个模块，所以删除掉src目录；\n◇右键新建一个module，选择maven；项目名：course-service；然后在course-service里面将src删除，并新建一个模块，course-list,Parent选择course-service；同样的方法在course-service下创建新模块course-price;\n![image.png](SpringCloud入门/1637240760861-d17948bd-126d-4e5b-a407-a0ff6ba4fdfd.png)\n\n### course-list模块\n◇配置course-list的pom.xml文件，增加相关依赖和插件\n```xml\n <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>2.1.1</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n```\n◇在course-list模块中新建包com.lcg.course,新建应用入口类CourseListApplication；\n```java\npackage com.lcg.course;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n/**\n * 项目启动类\n */\n@SpringBootApplication\npublic class CourseListApplication {\n    public static void main(String[] args) {\n        //启动项目\n        SpringApplication.run(CourseListApplication.class, args);\n    }\n}\n```\n◇在course-list的resources目录下新建application.properties进行基础配置\n```properties\nserver.port=8081\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/course?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=123456\nlogging.pattern.console=%clr(%d{${LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:%wEx}\nmybatis.configuration.map-underscore-to-camel-case=true\nspring.application.name=course-list\n```\n◇新建entity包，创建实体类Course;注意实体类需要接入Serializable接口并实现tostring方法以实现序列化；\n◇新建service包，创建接口CourseListService，然后创建其实现类\n◇和数据库打交道也需要Mapper类；创建dao包，新建CourseMapper接口；\n```java\n@Mapper\n@Repository\npublic interface CourseMapper {\n\n    @Select(\"SELECT * FROM course WHERE valid = 1\")\n    List<Course> findValidCourses();\n}\n```\n◇新建controller包，创建CourseListController类\n```java\n/**\n * 描述：     CourseListController课程列表Controller\n */\n@RestController\npublic class CourseListController {\n\n    @Autowired\n    CourseListService courseListService;\n\n    @GetMapping(\"/courses\")\n    public List<Course> courseList() {\n        return courseListService.getCourseList();\n    }\n}\n```\n### course-price模块\n◇配置文件pom与course-list相同；\n◇新增各个包\n![image.png](SpringCloud入门/1637308280783-9d5b99df-41d4-4c4c-9265-108a72dce8bb.png)\n◇新建mapper类根据课程id查询课程价格\n\n```java\n/**\n * 描述：     课程价格Mapper类\n */\n@Mapper\n@Repository\npublic interface CoursePriceMapper {\n\n    @Select(\"SELECT * FROM course_price WHERE course_id = #{courseId}\")\n    CoursePrice findCoursePrice(Integer courseId);\n}\n```\n## Eureka\n### 介绍\n◇Eureka(服务注册与发现)是Netflix的核心子模块；主要作用是用于定位服务；有了它以后，只需要使用服务的标识符就可以访问到该服务了；其他服务可以使用Eureka的客户端来连接到Eureka的服务端，并且维持心跳链接；这样Eureka可以维护各个模块的实时信息；一个新的服务也可以通过Eureka来找到组件的各个服务的地址；\n◇为什么需要服务注册与发现；如果没有服务注册与发现，我们开发B服务，需要使用到A服务，那么就需要在B服务中配置A服务的IP地址以便访问；但是如果A服务的IP地址变化，我们在B服务中的配置也要相应的改变，所以就会造成难以维护；\n◇服务提供者把自己的服务地址提供到服务注册中心，当调用者调用该服务时，通过服务注册中心查询到最新的服务地址进行调用；\n\n### Eureka架构\n◇Eureka Server and Eureka Client\n![image.png](SpringCloud入门/1637312280257-2cc61536-9d50-471c-92ab-f8f50ef2458d.png)\n◇最先启动的就是服务注册中心。然后服务提供者启动，它会去找到配置在服务注册中心的地址，然后把服务内容注册上去；可以进行更新，注销服务等操作；然后就是消费者调用服务，首先会在服务注册中心得到注册表(Get Registry)，拿到最新的服务信息，然后远程调用服务；(注意不是通过服务注册中心调用服务)\n◇集群架构\n![image.png](SpringCloud入门/1637312645740-4c63b167-f761-4ce4-a7bf-d1b20b460ea2.png)\n◇服务注册中心为了提高容灾能力，有多个节点(服务器)；服务提供者可以在不同的服务器节点注册，但注册信息时共享的，消费者找到任一节点即可；\n\n### 引入Eureka\n◇新建模块eureka-server\n◇引入依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <parent>\n    <artifactId>spring-cloud-course-practice</artifactId>\n    <groupId>com.imooc</groupId>\n    <version>0.0.1-SNAPSHOT</version>\n  </parent>\n  <modelVersion>4.0.0</modelVersion>\n\n  <artifactId>eureka-server</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>jar</packaging>\n\n  <!-- 模块名及描述信息 -->\n  <name>course-eureka-server</name>\n  <description>Spring Cloud Eureka</description>\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n```\n◇对于spring-cloud的版本，各个模块都应该统一，所以在最外层的pom文件中增加配置spring-cloud版本\n```xml\n <!--标识Spring Cloud的版本-->\n  <dependencyManagement><!--依赖管理-->\n    <dependencies>\n      <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Greenwich.SR5</version>\n        <type>pom</type><!--类型-->\n        <scope>import</scope><!--范围，导入时生效-->\n      </dependency>\n    </dependencies>\n  </dependencyManagement>\n```\n◇配置文件application.properties\n```properties\nspring.application.name=eureka-server\nserver.port=8000\neureka.instance.hostname=localhost\n#fetch-registry：获取注册表。不需要同步其他节点数据。\neureka.client.fetch-registry=false\n#register-with-eureka代表是否将自己注册到Eureka Server，默认是true。\neureka.client.register-with-eureka=false\n#服务提供的地址\neureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n◇启动注解,创建启动类\n```java\n@EnableEurekaServer //标识Eureka服务的启动类\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n```\n◇输入:http://127.0.0.1:8000/ ;查看Eurea的默认管理界面\n![image.png](SpringCloud入门/1637389180166-bdb1d1d0-589b-4d59-9eaa-761573bc4205.png)\n\n### 注册服务\n◇在course-list中，添加spring-cloud依赖\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n```\n◇然后在application配置文件中增加eureka服务器连接的配置，这样course-list服务启动后就会自动的在服务注册中心进行注册\n```java\neureka.client.service-url.defaultZone=http://localhost:8000/eureka/\n```\n◇先启动eureka服务，然后启动course-list，然后查看服务注册中心页面\n![image.png](SpringCloud入门/1637390984269-a49a7553-e76c-4bb4-b527-e2aefe87cb25.png)\n◇可以看到我们的课程列表服务成功注册上去\n◇对于course-price服务也是一样的配置\n\n## OpenFeign  \n### 介绍\n◇使用此组件可以用来调用远程服务，就像调用本地服务一样方便；\n![image.png](SpringCloud入门/1637392295068-9d336030-c77b-452d-805d-923209ce6177.png)\n◇提供服务的生产者首先在服务注册中心进行注册，然后使用服务的消费者把服务注册中心的它能够调用的所有服务的地址获取到，而OpenFeign封装了一个发送网络请求的一个工具，然后就利用它去调用服务；\n\n### 集成Feign\n◇引入依赖；因为是在cours-price中调用course-list服务，所以在course-price中进行相关依赖的引入\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-openfeign</artifactId>\n    </dependency>\n```\n◇新建一个course-list的客户端接口\n```java\n/**\n *  课程列表的Feign客户端,需要参考调用服务的原来用法\n */\n@FeignClient(\"course-list\")\npublic interface CourseListClient {\n    @GetMapping(\"/courses\")\n    List<Course> courseList();\n}\n```\n◇Course引入course-list模块中的实体，这样pom文件会自动增加配置\n```java\n    <dependency>\n      <groupId>com.lcg</groupId>\n      <artifactId>course-list</artifactId>\n      <version>0.0.1-SNAPSHOT</version>\n      <scope>compile</scope>\n    </dependency>\n```\n◇注解；在course-price的启动类上增加@EnableFeignClients 注解\n◇调用上面创建的client，在CoursePriceController中新增方法\n\n```java\n@Autowired\nCourseListClient courseListClient;\n@GetMapping(\"/courseInPrice\")\npublic List<Course> getCourseListInPrice(Integer courseId) {\n    List<Course> courses = courseListClient.courseList();\n    return courses;\n}\n```\n## 负载均衡\n### 两种类型\n◇客户端负载均衡(Ribbon);\n◇服务端负载均衡(Nginx)；对于所有的请求，都应该先达到Nginx节点，有它进行分发转发；\n◇以上两个负载均衡可以同时存在的，比如一个大型服务，用户的请求就会先达到Nginx上；而Ribbon主要用于服务内部，即服务之间也会进行相互调用，就没有必要通过Nginx，直接采用Ribbon；\n### 负载均衡策略\n◇RandomRule 表示随机策略，每次回随机进行调用\n◇RoundRobinRule 表示轮询策略，即周而复始的循环；这种策略可以比较好的平衡各个节点的压力；\n◇ResponseTimeWeightedRule加权， 根据每一个 Server 的平均响应时间动态加权 \n◇如果要配置不同的负载均衡方式可以在application文件中对 Ribbon.NFLoadBalancerRuleClassName  进行设置；\n```properties\n#在客户端course-price中指定模块course-list的负载均衡方式\ncourse-list.ribbon.NFLoadBanlancerRuleClassName=com.netflix.loadbalancer.RoundRobinRule\n```\n## 断路器\n### 为什么需要断路器\n◇我们在远程调用服务的时候，如果某一个服务出现了延迟，就会导致整体项目的延迟；如左下图，一个用户的请求依赖于多个服务，其中红色的代表出现了延迟；假设服务I的功能是找到用户信息，而其他是下单之类的功能；那么在没有得到用户信息之前，是无法进行下单的，这样一来用户请求就会卡在订单处；\n◇又或者如右下图，服务I服务于多个用户，当该服务出现延迟后，这些用户请求都会卡住，并且用户请求前面的服务的资源也得不到释放，比如前面的服务A是连接数据库的，而数据库的连接池有上限，若有大量用户卡在I处，但是用户的连接数不会释放，这样数据库就会资源耗尽，导致系统不可用；\n![image.png](SpringCloud入门/1637407392505-057e0933-53ae-4670-b52f-7ea0d8b56bc7.png)\n◇断路器的作用就是将出现故障的单元隔离开，防止其影响到其他单元进而导致整个系统不可用；如在淘宝双十一活动时如果下单业务出现故障，只是当前无法下单，而不会整个系统卡死；\n\n### Hystrix\n◇Hystrix可以快速的构建一个断路功能；当某一个服务发生故障的时候我们会返回一个默认的响应，而不是长时间的让用户去等待，这样就不会让我们的线程去调用故障服务，又调用不通导致其占用的资源不能释放，避免在分布式系统中故障的蔓延；\n### 编码实现断路器\n◇给course-price增加断路器功能；在pom中引入依赖\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n    </dependency>\n```\n◇进行配置，开启断路器\n```properties\nfeign.hystrix.enabled=true\n```\n◇在启动类上增加@EnableCircuitBreaker注解，表示断路器\n◇因为是调用的课程列表服务，所以就在CourseListClient接口的注解中指明断路后执行的类\n```java\n//设置服务的value,以及指定断路器实现类\n@FeignClient(value = \"course-list\",fallback = CourseListClientHystrix.class )\n@Primary //即当同类型的bean有多个的时候,手动的设置去注入哪一个(实现接口的类也算一个bean)\npublic interface CourseListClient {\n    @GetMapping(\"/courses\")\n    List<Course> courseList();\n}\n```\n◇断路实现类\n```java\n/**\n *  断路器实现类,出错返回一个空的课程列表\n */\n@Component\npublic class CourseListClientHystrix implements CourseListClient {\n    @Override\n    public List<Course> courseList() {\n        return Collections.emptyList();\n    }\n}\n```\n◇关闭course-list服务就能够模拟断路；\n## 整合两个服务\n◇course-price模块中新增实体类\n```java\n/**\n * 课程与价格的融合类\n */\npublic class CourseAndPrice implements Serializable {\n    Integer id;\n    Integer courseId;\n    String name;\n    Integer price;\n}\n```\n◇service中新增方法及其实现；得到课程价格对象\n```java\n//接口方法\nList<CourseAndPrice> getCourseAndPrice();\n```\n--实现\n```java\n@Override\n    public List<CourseAndPrice> getCourseAndPrice() {\n        List<Course> courses = courseListClient.courseList();\n        List<CourseAndPrice> courseAndPrices = new ArrayList<>();\n        //遍历得到的课程\n        for (Course course:courses) {\n            if (course != null) {\n                //拿到的不为空的课程,根据课程的id查询到它的价格\n                CoursePrice coursePrice = getCoursePrice(course.getCourseId());\n                CourseAndPrice courseAndPrice = new CourseAndPrice();\n                //进行课程和价格的拼接\n                courseAndPrice.setPrice(coursePrice.getPrice());\n                courseAndPrice.setName(course.getName());\n                courseAndPrice.setCourseId(course.getCourseId());\n                courseAndPrice.setId(course.getId());\n                courseAndPrices.add(courseAndPrice);\n            }\n        }\n        return courseAndPrices;\n    }\n```\n◇在course-price模块的控制器类中增加方法调用service服务\n## 网关Zuul\n### 为什么需要网关\n◇签名校验、登录校验冗余问题；为了保证系统的安全就不得不在每一个模块中加入校验的逻辑，判断用户账号密码正确与否；如果没有网关去做统一的校验我们就得在每个模块都编写同样的校验代码，造成冗余；维护性也比较差；\n◇Spring Cloud Zuul是Spring Cloud中的一个组件，它会和Eureka进行整合，它本身是Eureka的一个client，会注册到Eureka上；有了Zuul以后，假设其端口号是8083，那么用户可以直接访问8083端口而不做模块的区分，然后网关去区分不同的模块，另一作用就是统一校验；\n### Zuul介绍\n![image.png](SpringCloud入门/1637415602338-e1dc1b10-b6fd-4fcd-b91c-e3e06c2845e0.png)\n◇如上图，手机即代表用户；用户在访问的时候并不会直接访问到我们的服务，而是先访问到网关；网关在从服务注册中心获取到各个服务模块提前注册好的信息；这样网关就知道各个模块在哪里，然后对用户的请求进行正确的转发；\n\n### 集成Zuul\n◇把Zuul注册到Eureka服务注册中心；需要新建一个模块course-zuul\n◇pom文件引入依赖\n```xml\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n◇新建启动类\n```java\n/**\n * 描述：     网关启动类\n */\n@EnableZuulProxy\n@SpringCloudApplication\npublic class ZuulGatewayApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ZuulGatewayApplication.class, args);\n    }\n}\n```\n◇配置路由地址等信息\n```properties\nspring.application.name=course-gateway\nserver.port=9000\n#配置日志\nlogging.pattern.console=%clr(%d{${LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:%wEx}\nmybatis.configuration.map-underscore-to-camel-case=true\n    \neureka.client.service-url.defaultZone=http://localhost:8000/eureka/\n\n#配置zuul的统一前缀\nzuul.prefix=/lcg  \n#配置各个模块的前缀\nzuul.routes.course-list.path=/list/**\n#指定服务名\nzuul.routes.course-list.service-id=course-list\n\nzuul.routes.course-price.path=/price/**\nzuul.routes.course-price.service-id=course-price\n```\n◇访问course-list模块：127.0.0.1:9000/lcg/list即可；\n### 利用网关实现过滤器\n◇ pre 过滤器在路由请求之前运行 \n◇ route 过滤器可以处理请求的实际路由 \n◇ post 路由请求后运行过滤器 \n◇ error 如果在处理请求的过程中发生错误，则过滤器将运行  \n◇新建包filter；然后新建两个过滤器；\n◇pre过滤器，这里用来记录请求的时间\n```java\n/**\n * 描述：     记录请求时间\n */\n@Component\npublic class PreRequestFilter extends ZuulFilter {\n\n    @Override\n    public String filterType() {\n        //过滤器的类型\n        return FilterConstants.PRE_TYPE;\n    }\n\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        //是否启用过滤器,在这里也可以写一些逻辑对需要过滤的url进行过滤\n        return true;\n    }\n\n    @Override\n    public Object run() throws ZuulException {\n        //获取上下文\n        RequestContext currentContext = RequestContext.getCurrentContext();\n        //记录当前时间\n        currentContext.set(\"startTime\", System.currentTimeMillis());\n        System.out.println(\"过滤器已经记录时间\");\n        return null;\n    }\n}\n```\n◇post过滤器\n```java\n/**\n * 描述：     请求处理后的过滤器\n */\n@Component\npublic class PostRequestFilter extends ZuulFilter {\n\n    @Override\n    public String filterType() {\n        return FilterConstants.POST_TYPE;\n    }\n\n    //通过int值来定义过滤器的执行顺序,默认为0,数字越大,优先级越低\n    @Override\n    public int filterOrder() {\n        //过滤器请求最后的位置(默认1000) - 1 即在它之前一点点的时机运行\n        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() throws ZuulException {\n        //获取上下文\n        RequestContext currentContext = RequestContext.getCurrentContext();\n        Long startTime = (Long) currentContext.get(\"startTime\");//获取请求时间\n        long duration = System.currentTimeMillis() - startTime;\n        String requestURI = currentContext.getRequest().getRequestURI();//获取uri\n        System.out.println(\"uri:\" + requestURI + \",处理时长：\" + duration);\n        return null;\n    }\n}\n```\n\n","tags":["SpringCloud"],"categories":["分布式与微服务"]},{"title":"微服务基础","url":"/p/1b72.html","content":"## 微服务基础介绍\n### 要点\n1. 什么是微服务 \n2. 微服务的特点 \n3. 微服务优缺点\n4. 微服务的两大门派 SpringCloud和Dubbo\n5. 微服务拆分 \n6. 微服务扩展 \n7. 微服务重要模块    \n### 单体应用的缺点\n◇部署效率低下；单体应用的代码会越来越多，依赖也越来越多；pom配置文件会特别长，则导致部署时间变长。\n◇团队协作开发成本高。\n◇系统高可用性差，因为最后所有功能都会部署到同一个包里面，且共用一个进程。那么如果一个功能出现问题很有可能整个系统出现问题。\n\n### 什么是服务化\n◇ 把传统的单机应⽤中通过JAR包依赖产⽣的本地⽅法调⽤，改造成通过RPC、HTTP产⽣的远程⽅法调⽤ 。\n◇ 把模块从单体应⽤中拆分出来，独⽴成⼀个服务部署 。\n◇ 模块就可以独⽴开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。\n\n### 从单体到微服务架构\n◇单体到微服务的架构图。在微服务架构中，无论请求是手机端还是web端，都先将请求发送到网关，再由网关将请求转发到对应的微服务模块中。\n![image.png](微服务基础/1637134734874-79b80c53-5584-4a39-bd81-eb55d900aea1.png)\n\n### 什么是微服务\n◇微服务是一种架构风格\n◇开发单个应用作为一系列小型服务的套件，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信， 这通常是HTTP的资源API。 \n◇这些服务是围绕着业务功能构建的，并且可以通过完全{% wavy 自动化的部署 %}机制进行独立部署\n◇这些服务的集中式管理做到了最小化（例如docker相关技术），每一种服务都可以通过不同的编程语言进行编写，并且可以使用不同的数据存储技术。  \n\n### 微服务的特点\n◇组件以{% emp 服务形式 %}来提供\n◇产品而不是项目\n◇轻量级通信、独立进程\n◇分散治理、去中心化治理\n◇容错性设计\n◇会带来团队的组织架构的调整；如有原来水平团队变成垂直的团队，微服务下一个业务就有整套技术人员；\n![image.png](微服务基础/1637135262247-ccfb963f-6436-48a4-88a7-9f91c1a87450.png)\n\n### 微服务优缺点\n**优点**\n◇服务简单、便于学习和上手，相对易于维护\n◇独立部署，灵活扩展\n◇技术栈丰富，包括开发工具，数据库，中间件等；\n**缺点**\n◇运维成本过高\n◇接口可能不匹配;因为以前我们进行本地方法调用的时候，不会出现接口不匹配的问题，在本地可以直接查看接口的返回类型；但变成微服务之后，假设我们都不知道对方的代码，只能通过简单的描述，就有可能造成接口不匹配；\n◇代码可能重复\n◇架构复杂度提高\n\n◇在不同系统复杂度的情况下单体应用(Monolith)和微服务应用(Microservice)的优势区别\n![image.png](微服务基础/1637154816697-fc8ca31e-ad8b-47e5-b35a-0a67dd393543.png)\n\n## 微服务的两大门派\n### 介绍\n◇Spring Cloud：众多子项目；比如说像网关、配置中心、智能路由等等；\n◇Dubbo：高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡， 以及服务自动注册和发现 ；\n◇Dubbo提供的能力只是Spring Cloud的一部分子集\n◇表格中Dubbo中无是指不提供该功能，但可以通过其他框架组合实现；比如说在Dubbo中分布式配置功能可以采用百度的disconf或者淘宝的diamond实现；利用京东开源的Hydra实现服务跟踪；当当开源的Elastic-Job实现批量任务等等；\n\n| 核心组件     | Dubbo     | SpringCloud                |\n| ------------ | --------- | -------------------------- |\n| 服务注册中心 | Zookeeper | Eureka、 Nacos             |\n| 服务调用方式 | RPC       | REST API                   |\n| 服务网关     | 无        | Spring Cloud Gateway、Zuul |\n| 断路器       | 不完善    | Hystrix                    |\n| 分布式配置   | 无        | Spring Cloud Config、Nacos |\n| 服务跟踪     | 无        | Spring Cloud Sleuth        |\n| 消息总线     | 无        | Spring Cloud Bus           |\n| 数据流       | 无        | Spring Cloud Stream        |\n| 批量任务     | 无        | Spring Cloud Task          |\n\n### 通信协议对比\n◇Dubbo基于RPC，Spring Cloud基于REST\n◇RPC 服务提供方与调用方接口依赖方式太强\n◇RPC服务对平台敏感，难以简单复用\n◇ 效率RPC更高  \n\n### 文档质量对比\n◇ Dubbo的文档可以说在国内开源框架中算是一流的，提供了中文与英文两种版本  \n◇ Spring Cloud文档体量大，更多的是偏向整合，更深入的使用方法还是需要查看其整合组件的详细文档  \n### 总结\n◇Dubbo诞生于阿里系，其他组件不够全面；而Spring Cloud专注于企业级的微服务框架，开发便利；生态上Spring Cloud更强大；\n◇Dubbo就像组装电脑，有很高的自由度，但是需要承担兼容性的风险；Spring Cloud相当于品牌机，保证了一套系统的稳定性；\n◇需要根据自身的研发水平和所处阶段选择\n\n## 微服务拆分\n### 什么时候进行服务化拆分\n◇第一阶段的主要目标是快速开发和验证想法，即采用单体应用模式快速开发应用上线；\n◇进一步增加更多的新特性来吸引更多的目标用户\n◇同时进行开发的人员超过10人(视业务大小决定人数)，这个时候就该考虑进行服务化拆分\n### 不适合拆分的情况\n◇小团队，技术基础比较薄弱\n◇流量不高，压力小，业务变化也不大；比如企业内部的系统，虽然功能多，但是只是企业内部员工使用，流量不是很高；\n◇对延迟很敏感的低延迟高并发系统；对于微服务而言，延迟是很高的，因为各个模块间的调用是通过网络通信完成的；\n### 服务化拆分的两种姿势\n◇纵向拆分；按照业务维度去拆分，比如说关联程度比较近的拆分为一个微服务，功能比较独立的拆分为一个微服务；如社交APP，评论功能是一个微服务，消息通知是一个微服务，个人主页是一个微服务；\n◇横向拆分；按照公共领域拆分；比如说上面的评论，消息通知，个人主页都有公共的需求，都需要用到用户模块；则把用户服务作为一个横向拆分出来，并且把功能提供给各个模块，这样一来用户服务就得到了大量的复用；\n◇结合业务综合分析\n## 微服务扩展\n### 服务扩展\n◇ x 轴-水平复制；就是单体应用的典型扩展方式，把整个系统作为一个整体重新部署几套然后在前面加几个负载均衡器即可；水平复制往往效果不好，而且造成资源浪费；\n◇ y 轴-功能解耦 ；即指微服务的拆解，效率比X轴的维度高；\n◇ z 轴-数据分区 ；在我们系统过大后，存储空间可能不足；所以就需要进行数据库的拆分；\n![image-20220527091247939](微服务基础/image-20220527091247939.png)\n\n### 自动按需扩展\n◇ 根据CPU负载程度、特定时间（比如周末）、消息中间件的队 列长度、业务具体规则、预测等来决定是否扩展 \n◇ 自动分配一个新的服务实例，提高可用性 \n◇ 提高了可伸缩性（双11之后，自动减少服务器） \n◇ 具有最佳使用率，节约成本  \n\n## 微服务重要模块\n◇服务描述；我们服务提供方需要把自己的服务描述出来，比如是什么类型的服务，接口是什么类型等等；\n◇注册中⼼；服务提供方需要到注册中心进行注册；\n◇服务框架；采用什么协议（TCP、UDP），传输的方式是同步还是异步，数据是否需要压缩等等内容由服务框架进行统一；\n◇负载均衡；服务提供方有很多个，需要有负载均衡技术；\n◇熔断和降级；保证整体的可用性，不因某一个服务瘫痪导致整个系统故障；\n◇网关；当服务增多之后，用户是不可能每一个请求达到不同的地址上去，需要一个统一的网关接收用户的请求，然后进行分发；具有统一转换，权限控制等功能；\n\n","tags":["微服务"],"categories":["分布式与微服务"]},{"title":"RabbitMQ入门","url":"/p/ef1a.html","content":"## 课程简介\n1. 初识RabbitMQ，使用Erlang语言； \n2. RabbitMQ的安装和启动 \n3. RabbitMQ管理后台  \n4. 实战案例演示 \n5. 交换机工作模式  fanout、direct、topic、headers\n6. Spring Boot整合RabbitMQ  \n## RabbitMQ  \n### RabbitMQ简介\n◇核心思想：接收并转发消息。你可以把它想象成一个邮局  \n![image.png](消息队列RabbitMQ/1636948836013-8a24cfff-1bce-419c-8c00-f82a7ae88a78.png)\n◇producer：消息的生产者(发送者)，\n◇queue：保存P发过来的消息，队列可以无限延长，存储多个P的信息，同时也被多个消费者消费；\n◇consumer：消费者，从q中获取信息\n\n### RabbitMQ的特点\n◇开源、跨语言\n◇Erlang语言编写，一般用在通信行业，性能良好；\n◇应用广泛\n◇社区活跃、API丰富\n## 消息队列\n### 什么叫消息队列\n◇消息队列是一种先进先出的结构；Enqueue&Dequeue；\n### 消息队列的特性\n◇业务无关，不需要考虑上层业务的逻辑，只做好消息转发即可；\n◇FIFO，先进先出\n◇容灾，对于接收的消息可以进行持久化处理，即存储下来，即便出现服务器故障，也可以在恢复服务后找到还原出队的消息；\n◇性能良好；\n\n### 为什么要用消息队列\n◇系统解耦，在没有使用消息中间件的时候我们的消息发送是直接调用模块的方法，但是在模块比较多的时候，会调用很多模块，增加系统复杂性，而消息通过消息队列来进行转发能够有效解耦；\n◇异步调用；假设我们有一个链路，从A调用B，调用C再调用D,因为每一个步骤都是需要时间的，所以整个链路下来花的时间较多，不过很多步骤是可以异步的；异步即我告诉你要做这件事然后不等你做完我就可以直接返回了；同步的话需要等你做完之后我才能返回；比如说点外卖的时候，作为用户我下单以后平台系统要做的事情很多，比如通知店家，骑手等；对于用户而言，不需要考虑这些系统要处理的事，所以通过消息来完成异步的调用；即当用户下单以后，系统将消息发送到消息中间件中，然后就返回消息给用户，让用户知道下单成功；然后MQ会对消息进行分发，通知商家、骑手接单，支付模块收款等；\n◇流量削峰；有时候我们的请求量会突然上升，就叫做出现了流量高峰；消息队列会把这些大量的请求存储在队列里面，然后以我们能够接受的速度发送给我们；相当于对高流量做一下缓冲；\n## AMQP协议\n◇ Advanced Message Queuing Protocol  \n![image.png](消息队列RabbitMQ/1636966039817-3852b10f-3a92-4d47-8097-ab691f9ed195.png)\n◇左侧的publisher即对应生产者，Consumer对应消费者；右边一大块是指RabbitMQ的服务器(Server)；Virtual host虚拟主机，一个RabbitMQ可以给很多的完全独立的用户提供服务，那么每一个用户就可以利用虚拟主机来划分，它们之间是互不影响的；在虚拟主机里面有一个Exchange,是交换机的意思；交换机会与下面的消息队列MQ连通，它们是一个绑定的关系；\n\n## RabbitMQ核心概念\n◇RabbitMQ的整体架构图\n![image.png](消息队列RabbitMQ/1636966789125-6b5d1068-08dc-442b-b12c-ded43f46c103.png)\n◇Server：服务\n◇connection：与server建立连接，封装了socket协议相关部分逻辑；\n◇ channel：信道，Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销；\n◇ message：消息，在RabbitMQ中消息由properties(对消息进行额外的修饰，如消息的优先级，队列的延迟或者消息的其他属性)和body(消息的实体)组成 ； \n◇ virtual host：虚拟主机，作用是顶层隔离，比如说有A、B两个项目，必须先指定把消息投递到A还是B，也就是说投递到A的虚拟主机还是B的虚拟主机，这是最顶层的隔离然后才会包含后面交换机的内容。同一个虚拟主机下，不能有重复的交换机和queue，如果是不同的虚拟主机，则可以有相同的交换机和queue；\n◇ Exchange：交换机，接收生产者的消息的，然后根据指定的路由器去把消息转发到所绑定的队列上  \n◇ routing key：路由键，路由规则。用于发送消息的时候，交换机判断将此消息发送给哪一个队列。\n◇ binding key：绑定交换机和队列。交换机和队列通过绑定键进行绑定，当消息过来时，根据消息中的路由键来与绑定键做匹配。在直连的交换机模式下，绑定键和路由键是一样的，所以可以设置为同一个。  \n◇ queue：队列，消费者只需要监听队列来消费消息，不需要关注消息来自于哪个Exchange  \n◇ Exchange和Message Queue存在着绑定的关系，一个 Exchage可以绑定多个消息队列  \n\n## 消息的流转过程\n![image.png](消息队列RabbitMQ/1636967373386-5d044d36-ad4f-4946-93b9-f5b41530633d.png)\n◇最开始是生产者产生一个消息，然后放到Exchange中去，Exchange下有三个MQ，在绑定的时候需要指定一个路由键；假设Exchange和Qi使用的路由键是Ki；那么在生产者发送消息的时候就需要指定一个路由键，比如说消息的路由键是K1，那么Exchange就把消息发送给Q1(左起第一个队列)；对于消费者而言，会监听消息，一旦MQ中有了从交换机发送过来的消息消费者就会提取到消息并且进行后续的处理；\n\n## RabbitMQ的安装和启动\n### 安装Erlang语言\n◇方法一：安装erlang-rpm包，该包经过RabbitMQ官方处理，去掉了一些无用的依赖；\n```yaml\n#配置源\nvim /etc/yum.repos.d/rabbitmq_erlang.repo\n    #在配置文件中\n    [rabbitmq-erlang]\n    name=rabbitmq-erlang\n    baseurl=https://dl.bintray.com/rabbitmq-erlang/rpm/erlang/22/el/7\n    gpgcheck=1\n    gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc\n    repo_gpgcheck=0\n    enabled=1\n#:wq退出保存\n#进行清理\nyum clean all\n#下载所需要的缓存\nyum makecache\n#进行安装\nyum install erlang\n#确认源是\"rabbitmq_erlang\"\n   Y\n#确认安装\n   Y\n#查看版本\nerl -version\n#进入语言环境\nerl\nctrl+c退出\n```\n◇方法二：使用Erlang Solutions源安装完整的版本；\n◇方法三： 使用EPEL(\"Extra Packages for Enterprise Linux\")进行安装， 版本可能不合适 ；\n\n### 安装RabbitMQ\n```yaml\n#导入密钥\nrpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n\n#下载rpm安装包：\nwget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.2/rabbitmq-server-3.8.2-1.el7.noarch.rpm\n#如果速度比较慢，就用：\nwget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.2/rabbitmq-server-3.8.2-1.el7.noarch.rpm\n#下载完成后，安装：\nyum install rabbitmq-server-3.8.2-1.el7.noarch.rpm\n#一路Y\n#如果出现解压错误，说明下载了多次，用ls -la看一下有几个文件，\n#如果有多个安装包，要把多余的删掉，把正确的改名为rabbitmq-server-3.8.2-1.el7.noarch.rpm，再执行yum install来安装\n```\n### 启动RabbitMQ\n◇RabbitMQ常用命令\n```yaml\n#启动RabbitMQ\nsystemctl start rabbitmq-server\n#看看端口有没有起来，查看状态\nrabbitmqctl status \n#要检查RabbitMQ服务器的状态，请运行：\nsystemctl status rabbitmq-server\n#开启web管理界面\nrabbitmq-plugins enable rabbitmq_management\n\n#停止RabbitMQ\nrabbitmqctl stop\n#设置开机启动\nsystemctl enable rabbitmq-server \n```\n## RabbitMQ管理后台\n◇启动管理后台： rabbitmq-plugins enable rabbitmq_management\n◇新建用户:  rabbitmqctl add_user admin password //用户名：admin；密码：password;可自定义\n◇设置用户权限:  rabbitmqctl set_user_tags admin administrator  //将admin用户设为管理员\n◇浏览器登录管理后台： ip+默认端口15672;    192.168.222.133:15762;\n◇Info下的disc表示RabbitMQ默认采用磁盘存储；交换机是RabbitMQ默认生成的；\n◇在Admin界面添加用户：Add a user； Montioring：可以登录控制台，也可以看到RabbitMQ的相关节点信息，如进程数，内存使用情况等等；但新建用户，创建管理员这些就没有权限；None：权限最低，就是普通的生产者，消费者；\n◇默认会有一个虚拟主机；点击虚拟主机的name可以给虚拟主机添加管理员用户；\n\n## 案例演示\n### 新建项目\n◇创建maven项目，命名为rabbitmq\n◇导入依赖\n```xml\n<dependencies>\n    <!-- rabbitmq客户端依赖 -->\n    <dependency>\n      <groupId>com.rabbitmq</groupId>\n      <artifactId>amqp-client</artifactId>\n      <version>5.8.0</version>\n    </dependency>\n    <!-- 记录日志的依赖 -->\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-nop</artifactId>\n      <version>1.7.29</version>\n    </dependency>\n  </dependencies>\n```\n◇新建helloworld包，创建类Send；\n```java\npackage helloworld;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n/*hello world 的发送类，连接到RabbitMQ服务端，然后发送一条消息，最后退出*/\npublic class Send {\n    //指定队列名字,在接收的时候也要使用此队列\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] argv) throws Exception {\n        //创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        //设置 RabbitMQ 地址,即服务端IP;用户名;密码\n        factory.setHost(\"xxx.xx.xxx.xxx\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"password\");\n        //建立连接\n        Connection connection = factory.newConnection();\n        //获得信道\n        Channel channel = connection.createChannel();\n        //声明队列(队列名，队列是否需要持久，是否独有，是否自动删除，参数填null即可)\n          //持久即服务重启后是否还保存此队列，独有即此队列是否仅被当前连接使用\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        //发布消息\n        String message = \"Hello World!\";\n           //(交换机'这里忽略'，路由键：队列名，消息配置：null，消息体：需要声明编码方式)\n       //忽略交换机名字的话,RabbitMQ会使用默认的交换机根据队列的名字QUEUE_NAME作为路由键进行查找\n        channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\n        System.out.println(\"发送了消息：\" + message);\n        //关闭连接\n        channel.close();//关闭信道\n        connection.close();//关闭连接\n    }\n}\n\n```\n◇创建接收消息类Recv\n```java\npackage helloworld;\n\nimport com.rabbitmq.client.AMQP;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.DefaultConsumer;\nimport com.rabbitmq.client.Envelope;\nimport java.io.IOException;\n\n//接收消息并打印，持续运行\npublic class Recv {\n\n    private final static String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"xxx.xx.xxx.xxx\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"password\");\n        //建立连接\n        Connection connection = factory.newConnection();\n        //获得信道\n        Channel channel = connection.createChannel();\n        //声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        System.out.println(\"开始接收消息\");\n\n        //消费信息(队列名，是否自动确认收到，处理消息函数)\n        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) {\n            //收到信息后会执行的函数\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                    AMQP.BasicProperties properties, byte[] body)//重写handleDelivery方法\n                    throws IOException {\n                String message = new String(body, \"UTF-8\");//实例化消息\n                System.out.println(\"收到消息：\" + message);\n            }\n        });\n    }\n}\n```\n### 多个消费者\n◇创建新的包workqueues,新建NewTask类发送多个消息\n```java\npackage workqueues;\n//任务由所耗时，多个任务\npublic class NewTask {\n\n    private static final String TASK_QUEUE_NAME = \"task_queue\";\n\n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        //factory.setHost(\"localhost\");若是在本机的话，不需要设置用户名和密码\n        factory.setHost(\"xxx.xx.xxx.xxx\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"password\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);\n        //构建多个消息\n        for (int i = 0; i < 10; i++) {\n            String message;\n            message = i + \"....\";\n            //发送消息\n            channel.basicPublish(\"\", TASK_QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\" [x] Sent '\" + message + \"'\");\n        }\n        channel.close();\n        connection.close();\n    }\n}\n\n```\n◇创建Worker类接收消息\n```java\npackage workqueues;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\n\n//接收前面的批量消息\npublic class Worker {\n\n    private static final String TASK_QUEUE_NAME = \"task_queue\";\n\n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"xxx.xx.xxx.xxx\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"password\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n        //声明队列\n        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);\n        //System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");\n        System.out.println(\"开始接收消息\");\n        channel.basicConsume(TASK_QUEUE_NAME, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                    AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"收到了消息\"+message);\n                try {\n                    doWork(message);\n                } finally {\n                    System.out.println(\"消息处理完毕\");\n                }\n            }\n        });\n    }\n\n    /*执行任务方法;定义消费特点:如果字符为\".\"则处理时间为1s,这样设计为后续消息区分做铺垫*/\n    private static void doWork(String task) {\n        for (char ch : task.toCharArray()) {//遍历字符数组\n            if (ch == '.') {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException _ignored) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }\n}\n```\n◇上述方法处理消息会比较慢，我们可以在执行一个worker类，即让两个worker去接收消息；需要先进行配置:Edit Configurations->Allow parallerl run(允许并行执行); 这样两个worker就会平均的接收消息，即有10条消息，每个消费者会接收到5条；\n◇下面考虑每条消息的处理时间不同的情况如何合理的给worker分配压力；\n◇在发送消息的时候修改为\n```java\nfor (int i = 0; i < 10; i++) {\n            String message;\n            if(i%2==0){\n               message = i + \"....\";\n            }else{\n               message = String.valueOf(i);//把int类型的i字符串化;\n            }\n            \n            //发送消息\n            channel.basicPublish(\"\", TASK_QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\n            System.out.println(\" [x] Sent '\" + message + \"'\");\n        }\n```\n◇在这种情况下，如果运行两个worker的话，就会造成双方压力不同；那么如何实现公平派遣呢？\n◇实现公平派遣需要加入消息确认机制，让RabbitMQ知道这个消息处理完毕，然后再去分配新任务；\n◇对消费者进行改造\n```java\npackage workqueues;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\n\n//接收前面的批量消息\npublic class Worker {\n\n    private static final String TASK_QUEUE_NAME = \"task_queue\";\n\n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"xxx.xx.xxx.xxx\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"password\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n        //声明队列\n        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);\n        //System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");\n        System.out.println(\"开始接收消息\");\n        channel.basicQos(1);//在消费消息之前,设置希望处理的消息数量\n        //消费消息,将自动确认接收改为false\n        channel.basicConsume(TASK_QUEUE_NAME, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                    AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"收到了消息\"+message);\n                try {\n                    doWork(message);\n                } finally {\n                    System.out.println(\"消息处理完毕\");\n                    //确认接收完消息(模板,是否同时确认多个消息)\n                    channel.basicAck(envelope.getDeliveryTag(), false);\n                }\n            }\n        });\n    }\n\n    /*执行任务方法;定义消费特点:如果字符为\".\"则处理时间为1s,这样设计为后续消息区分做铺垫*/\n    private static void doWork(String task) {\n        for (char ch : task.toCharArray()) {//遍历字符数组\n            if (ch == '.') {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException _ignored) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }\n}\n```\n## 交换机工作模式\n### fanout模式\n◇ fanout：广播，这种模式只需要将队列绑定到交换机上即可， 是不需要设置路由键的  \n![image.png](消息队列RabbitMQ/1637064167756-57971c5b-5a5d-4ac5-8eb0-4ff4886608de.png)\n◇最左侧是一个P，即生产者；然后是X交换机；由于是fanout模式，只要绑定了这些队列，后续凡是送到这个交换机X的消息X都会分发到与其绑定的队列中；比如说，我们有两个程序，第一个程序是负责发送日志消息，第二个负责接收；假设日志需要保存到文件中也需要打印到屏幕上，则有多处地方使用了日志消息，即形成了一对多的关系，则使用fanout模式的交换机；\n**代码演示**\n◇新建fanout包，在包下创建EmitLog日志类\n\n```java\npackage fanout;\n\n//发送日志信息\npublic class EmitLog {\n\n    //定义交换机的名字\n    private static final String EXCHANGE_NAME = \"logs\";\n    \n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n        //声明交换机(交换机名字,交换机类型)\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);\n\n        String message = \"info: Hello World!\";\n        //发送消息(交换机，路由键，...,指定编码的消息体)\n        channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n        System.out.println(\"发送了消息\"+message);\n        channel.close();\n        connection.close();\n    }\n}\n```\n◇创建接收类ReceiveLogs，有多个接收者去接收一样的消息;对于日志而言，只对当前发生的事感兴趣，对以前的日志没有必要保存，有很高的时效性，可能保存不超过3天就删除了；那么我们可以创建全新的空队列，让RabbitMQ自动生成队列的名字，并且此队列是非持久的，会自动删除的；即当接收者不复存在的时候，队列也会被删除，来节省我们的空间；如下图所示\n![image.png](消息队列RabbitMQ/1637065115512-1776acf2-32dc-4403-8a0d-5de585db90e8.png)\n◇执行多个ReceiveLogs模拟多个消费者\n\n```java\npackage fanout;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\n\npublic class ReceiveLogs {\n\n    private static final String EXCHANGE_NAME = \"logs\";\n\n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);\n        //通过getQueue()方法可以得到一个非持久的空队列\n        String queueName = channel.queueDeclare().getQueue();\n        //将队列绑定到交换机上,绑定键为空;\n        channel.queueBind(queueName, EXCHANGE_NAME, \"\");\n        System.out.println(\"开始接收消息\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                    AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"收到消息\" + message);\n            }\n        };\n        //消费消息\n        channel.basicConsume(queueName, true, consumer);\n    }\n}\n```\n### direct模式\n◇ direct：直接，根据 RoutingKey 匹配消息路由到指定的队列\n![image.png](消息队列RabbitMQ/1637065419610-cbebc186-6d43-4c93-abc2-66e96e14e007.png)\n◇应用场景：比如对于日志而言，为了节省空间我们不一定要把所有的日志都存储下来，我们的日志会分为不同的等级，磁盘只存储error类型的日志；那么这样就不能再使用fanout的交换机，因为这样它会把所有日志无差别的保存下来；我们的要求是只存储error类型日志，但是需要打印全部类型的日志到前台；即对应不同的消费者接受不一样的消息；\n◇允许把相同的路由键绑定到不同的消息队列中，如下图\n![image.png](消息队列RabbitMQ/1637065758191-7c11dffc-1920-423a-867b-d885f2aa819c.png)\n◇在实际的生产中，C1接受error类型用于存储，C2接受所有类型用于打印，如下图\n![image.png](消息队列RabbitMQ/1637065834878-74011671-eb9b-4749-a575-f1fdc60a5218.png)\n**代码演示**\n**◇**新建包direct包，创建EmitLogDirect日志类\n\n```java\npackage direct;\n\nimport com.rabbitmq.client.BuiltinExchangeType;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.Channel;\n\npublic class EmitLogDirect {\n\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] argv) throws Exception {\n\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        String message = \"Hello World!\";\n\n        String severity = \"info\";\n        channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(\"UTF-8\"));\n        severity = \"warning\";\n        channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(\"UTF-8\"));\n        System.out.println(\"发送了消息\" + message + \"等级为:\"+severity);\n        severity = \"error\";\n        channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(\"UTF-8\"));\n        System.out.println(\"发送了消息\" + message + \"等级为:\"+severity);\n\n        channel.close();\n        connection.close();\n    }\n\n}\n```\n◇新建接收者类ReceiveLogsDirect1\n```java\npackage direct;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\n\npublic class ReceiveLogsDirect1 {\n\n    private static final String EXCHANGE_NAME = \"direct_logs\";\n\n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n        //生成一个随机的临时的queue\n        String queueName = channel.queueDeclare().getQueue();\n\n        //一个交换机同时绑定三个queue\n        channel.queueBind(queueName, EXCHANGE_NAME, \"info\");\n        channel.queueBind(queueName, EXCHANGE_NAME, \"warning\");\n        channel.queueBind(queueName, EXCHANGE_NAME, \"error\");\n\n        System.out.println(\"开始接收消息\");\n\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                    AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"收到消息\"+message);\n            }\n        };\n        channel.basicConsume(queueName, true, consumer);\n    }\n}\n```\n◇创建接收类ReceiveLogsDirect2，只接收error类型的日志；\n### topic模式\n◇ topic：生产者指定 RoutingKey 消息根据消费端指定的队列通过模糊匹配的方式进行相应转发；\n◇*可以代替一个单词，#可以代替0个或者多个单词；\n![image.png](消息队列RabbitMQ/1637066701851-8ab3afb1-92e6-42b2-82e9-a73bb57af8e8.png)\n◇上图有三个维度：速度，颜色，种类；Q1对颜色为橙色的动物都感兴趣；Q2对种类为兔子的感兴趣以及有关懒惰动物的一切；\n**代码演示**\n◇新建包topic,创建类EmitLogTopic发送消息\n\n```java\npackage topic;\n\npublic class EmitLogTopic {\n\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] argv) {\n        Connection connection = null;\n        Channel channel = null;\n        try {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.setHost(\"localhost\");\n\n            connection = factory.newConnection();\n            channel = connection.createChannel();\n\n            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n\n            String message = \"Animal World\";\n            //数组来表示不同类型的动物\n            String[] routingKeys = new String[9];\n            routingKeys[0] = \"quick.orange.rabbit\";\n            routingKeys[1] = \"lazy.orange.elephant\";\n            routingKeys[2] = \"quick.orange.fox\";\n            routingKeys[3] = \"lazy.brown.fox\";\n            routingKeys[4] = \"lazy.pink.rabbit\";\n            routingKeys[5] = \"quick.brown.fox\";\n            routingKeys[6] = \"orange\";//测试单个属性\n            routingKeys[7] = \"quick.orange.male.rabbit\";//增加无关属性male\n            routingKeys[8] = \"lazy.orange.male.rabbit\";\n            for (int i = 0; i < routingKeys.length; i++) {\n                channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null,\n                        message.getBytes(\"UTF-8\"));\n                System.out.println(\"发送了\"+message+\"路由键为:\"+routingKeys[i]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (Exception ignore) {\n                }\n            }\n        }\n    }\n}\n\n```\n◇新建接收者ReceiveLogsTopic1\n```java\npackage topic;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\n\npublic class ReceiveLogsTopic1 {\n\n    private static final String EXCHANGE_NAME = \"topic_logs\";\n\n    public static void main(String[] argv) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        String queueName = channel.queueDeclare().getQueue();\n\n        //指定bindingKey,通过绑定键和消息的路由键做模糊匹配\n        String bindingKey = \"*.orange.*\";\n        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);\n\n        System.out.println(\"开始接收消息\");\n\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                    AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"收到消息:\"+message+\"路由键为:\"+envelope.getRoutingKey());\n            }\n        };\n        channel.basicConsume(queueName, true, consumer);\n    }\n}\n\n```\n◇创建第二个接收者\n```java\nString routingKey1 = \"*.*.rabbit\";\nchannel.queueBind(queueName, EXCHANGE_NAME, routingKey1);\n\nString routingKey2 = \"lazy.#\";\nchannel.queueBind(queueName, EXCHANGE_NAME, routingKey2);\n```\n### headers模式\n◇ headers：头交换机（headers exchange）使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。在消息的properties中设置头信息。\n\n## Spring Boot整合RabbitMQ\n◇创建两个SpringBoot项目->Add as Maven Project->一个Consumer->一个Producer；\n### 生产者\n◇对配置文件进行修改；把springboot版本改为2.2.2.1；引入RabbitMQ所需的依赖\n```java\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n◇配置生产者的application.properties文件\n```java\nserver.port=8080\nspring.application.name=producer\n\nspring.rabbitmq.addresses='ip地址':5672\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=password\nspring.rabbitmq.virtual-host=/\nspring.rabbitmq.connection-timeout=15000  超时时间\n```\n◇新建一个配置类(声明交换机，队列等)\n```java\npackage com.lcg.springbootrabbitmqproducer;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.core.TopicExchange;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * 描述：     rabbitmq配置类\n */\n@Configuration\npublic class TopicRabbitConfig {\n\n    @Bean\n    public Queue queue1() {\n        return new Queue(\"queue1\");//队列\n    }\n\n    @Bean\n    public Queue queue2() {\n        return new Queue(\"queue2\");\n    }\n\n    @Bean\n    TopicExchange exchange() {\n        return new TopicExchange(\"bootExchange\");//交换机\n    }\n\n    @Bean\n    Binding bingdingExchangeMessage1(Queue queue1, TopicExchange exchange) {\n        //交换机和队列绑定\n        return BindingBuilder.bind(queue1).to(exchange).with(\"dog.red\");\n    }\n\n    @Bean\n    Binding bingdingExchangeMessage2(Queue queue2, TopicExchange exchange) {\n        return BindingBuilder.bind(queue2).to(exchange).with(\"dog.#\");\n    }\n}\n```\n◇发送消息类\n```java\npackage com.lcg.springbootrabbitmqproducer;\n\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n/**\n * 描述：     发送消息\n */\n@Component//把普通的java对象实例化到spring容器中，相当于配置文件中的<bean id=\"\" class=\"\"/>\npublic class MsgSender {\n\n    @Autowired\n    private AmqpTemplate rabbitmqTemplate;//引入Amqp协议\n\n    public void send1() {\n        String message = \"This is message 1, routing key is dog.red\";\n        System.out.println(\"发送了：\"+message);\n        this.rabbitmqTemplate.convertAndSend(\"bootExchange\", \"dog.red\", message);\n    }\n\n    public void send2() {\n        String message = \"This is message 2, routing key is dog.black\";\n        System.out.println(\"发送了：\"+message);\n        this.rabbitmqTemplate.convertAndSend(\"bootExchange\", \"dog.black\", message);\n    }\n}\n```\n◇增加测试类\n```java\npackage com.lcg.springbootrabbitmqproducer;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass SpringBootRabbitmqProducerApplicationTests {\n\n\t@Autowired\n\tMsgSender msgSender;\n\n\t@Test\n\tpublic void send1() {\n\t\tmsgSender.send1();\n\t}\n\n\t@Test\n\tpublic void send2() {\n\t\tmsgSender.send2();\n\t}\n}\n```\n### 消费者\n◇更改springboot版本，引入RabbitMQ依赖；\n◇增加配置，和生产者一样的配置内容，但是端口不一样，这里改为8081\n◇新建类Receiver1接收消息\n```java\npackage com.lcg.springbootrabbitmqconsumer;\n\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * 描述：     消费者1\n */\n@Component\n@RabbitListener(queues = \"queue1\") //利用注解指定队列\npublic class Receiver1 {\n\n    @RabbitHandler\n    public void process(String message) {\n        System.out.println(\"Receiver1: \" + message);\n    }\n}\n\n```\n◇Receiver2绑定queue2\n​\n","tags":["RabbitMQ"],"categories":["分布式与微服务"]},{"title":"Nginx入门","url":"/p/e129.html","content":"## 介绍\n1.Nginx介绍\n2.Nginx的安装\n3. 常用命令讲解和演示  \n4.配置文件讲解\n5.场景实战：搭建一个静态的Nginx服务\n6.总结\n## Nginx介绍\n### Nginx是什么、适用场景\n◇HTTP的反向代理服务器\n◇正向代理；指的是普通的代理转发，在我们的客户端和服务器之间加了一个代理服务器；作为客户端，会将消息传到代理服务器上，而代理服务器将客户端的请求进行转发；代理服务器提供安全功能，代理服务器拥有一个防火墙，可以使客户端拥有其不具备的安全检测的功能；可以通过代理服务器隐藏自身的信息；\n![image.png](Nginx/1636529487131-62ea6235-13bf-400a-8180-184d04c7504d.png)\n◇反向代理；反向代理通常位于服务端中；指我们客户端去访问的时候，不直接访问到我们所要访问的服务器，而是在这些服务器之前加一个统一的反向代理服务器，对于客户端而言，访问的服务器信息是看不到的；反向代理服务器除了和代理服务器一样提供安全功能外，还有一个功能是在后端多个服务器之间提供负载均衡，或者是对比较慢的服务器提供缓存，把经常访问的内容缓存到代理服务器中；\n![image.png](Nginx/1636529533636-4e6b7695-7f6c-4d92-8e6d-1e15090f0dc5.png)\n◇{% wavy Nginx的作用正是反向代理 %}![image.png](Nginx/1636721331582-10fe5345-9841-4302-b5f8-4b60a551ab84.png)\n\n◇正向+反向代理\n![image.png](Nginx/1636721836068-00257156-75a8-40a4-8953-f23dd51ece1c.png)\n◇动态静态资源分离\n   作为后端服务器需要给前端提供一些资源，但这些资源可能包含了逻辑代码也可能包含css静态资源；对于静态资源，其实没有必要由我们后台服务器去提供，不进行分离的话访问会变慢；\n  静态资源无需经过Tomcat，Tomcat只负责处理动态请求，这样访问速度就会提高；如后缀为gif的时候，Nginx会直接获取到当前请求的文件并返回；\n  Nginx本身就是一个静态资源服务器；比如我们只有静态资源的时候，如个人主页，公司简介这些都可以作为静态资源网站去实现，就可以直接使用Nginx作为服务器；\n\n### Nginx的优点\n◇高并发、高性能\n◇可扩展性好, Nginx的第三方生态圈非常丰富；\n◇高可靠性，即Nginx可以在服务器上不断的运行，长达数年之久；用户直接访问到Nginx；\n◇热部署，不停止服务的情况下对自身进行升级或修改完善；\n◇开源、可商用\n\n## Nginx的安装\n◇Linux的安装\n```java\nyum install yum-utils\n#新建文件输入源信息;\nvim /etc/yum.repos.d/nginx.repo\n#以下就是配置信息:\n    [nginx-stable]\n    name=nginx stable repo\n    baseurl=http://nginx.org/packages/centos/7/$basearch/\n    gpgcheck=1\n    enabled=1\n    gpgkey=https://nginx.org/keys/nginx_signing.key\n    module_hotfixes=true\n\n    [nginx-mainline]\n    name=nginx mainline repo\n    baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/\n    gpgcheck=1\n    enabled=0\n    gpgkey=https://nginx.org/keys/nginx_signing.key\n    module_hotfixes=true\n#查看源,stable代表稳定版本,\nyum list | grep nginx\n#开始下载,版本选择第一个稳定的版本\nyum install nginx 1:1.16.1-1.el7.ngx\ny确认下载\ny确认验证\n#检查是否安装成功\nnginx -v\nwhereis nginx\n```\n◇Windows不推荐安装，因为服务器通常不是Windows下的；\n## 常用命令讲解和演示  \n◇启动命令: /usr/sbin/nginx \n◇查看是否启动成功,查看进程判断：ps -aux |grep nginx或直接访问nginx的网站80端口\n◇nginx -h //查看命令帮助\n◇-c 读取指定配置文件\n\n```java\ncd /etc/nginx  //查看配置文件\nls\nnginx -s stop  //如果前面有启动的话，先关闭再指定配置文件\nnginx -c /etc/nginx/nginx.conf   //指定配置文件为nginx.conf\n```\n◇-t 测试，主要用来测试配置文件是否正确\nnginx -t   //进行测试\n◇在nginx启动后，也可以用上面这个命令查看nginx的配置文件是哪一个；\n◇-v 简要版本信息； -V 详细版本信息；\n◇where is   或者   ps aux|grep nginx  //找到正在运行的nginx的路径\n◇-s 信号\n\n```java\nstop  //立即停止\nquit  //优雅停止,不在接收新的请求，但会将已经送达的请求处理完再关闭\nreload //重启:先检查配置文件的有效性，无效的话不会重启；有效的话就会启动一个新的进程，直到旧的\n      进程把它的任务处理完毕后，再让旧进程退出；\nreopen //更换日志文件,即日志过长的话,新建一个文件用来记录日志\n```\n## 配置文件讲解\n### 配置文件语法\n◇以  ;  结尾\n◇  {}组织多条指令\n◇include 用于引入相关依赖\n◇用 #注释\n◇$开头的表示一个变量\n\n### 配置文件讲解\n◇nginx.conf\n```yaml\n# 运行用户，默认是nginx\nuser  nginx;\n# nginx进程数,一般设置为和cpu核数一样\nworker_processes  1;\n\n# 全局错误日志路径\nerror_log  /var/log/nginx/error.log warn;\n# 进程pid路径\npid        /var/run/nginx.pid;\n\n\nevents {\n# 最大连接数\n    worker_connections  1024;\n}\n\n\n# 设置http服务器\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n# 设置日志的格式\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n# 访问日志的路径\n    access_log  /var/log/nginx/access.log  main;\n\n# 开启高效传输模式\n    sendfile        on;\n    #tcp_nopush     on;\n# 长连接超时时间，单位是秒\n    keepalive_timeout  65;\n#传输时是否压缩，压缩的话需要解压，但是传的大小就小了\n    #gzip  on;\n#加载其他的配置文件，形成一带多的内容\n    include /etc/nginx/conf.d/*.conf;\n}\n```\n◇ etc/nginx/conf.d/default.conf\n```yaml\nserver {\n    listen       80; #端口号\n    server_name  localhost; #服务器名字\n\n    access_log  /var/log/nginx/host.access.log  main;\n    \n    location / {  #/路径\n        root   /usr/share/nginx/html/; #默认转发的路径\n        index  index.html index.htm;  #默认主页,index.html或index.htm\n    }\n\n    error_page   500 502 503 504  /50x.html;  #错误请求跳转的页面\n    location = /50x.html {  #/50x.html路径\n        root   /usr/share/nginx/html;  #当路径想要请求某些错误文件的时候，会转发到此地址\n    }\n\n}\n```\n## 场景实战\n### 搭建一个静态文件的Nginx服务\n◇上传网页文件到服务器(在本地主机的终端执行)\n```yaml\n#scp命令用于上传 -r表示上传文件夹，上传文件夹静态网页的所有内容则直接在后面+/; root后面加上要上传的地址\nscp -r /文件的路径/静态网页/ root@[服务器的ip地址](192.xxx.[xxx.xxx[) :/usr/share/nginx/web/\n```\n◇查看是否上传成功 ：ls、cat\n◇打开配置文件并进行修改，否则无法通过浏览器访问到上传的静态资源\n\n```yaml\n# vim /etc/nginx/conf.d/default.conf\n#主要修改location的部分,两处都修改\n location / {  \n        root   /usr/share/nginx/web/; #将html改为web\n        index  index.html index.htm; \n    }\n    \nlocation = /50x.html {  \n        root   /usr/share/nginx/web;  #也改成web\n    }\n\n```\n◇重启nginx\n```yaml\nnginx -t  #测试配置文件是否正确\nnginx -s reload #重启\n```\n◇此时进入浏览器就能够访问到静态文件了。\n\n","tags":["Nginx"],"categories":["分布式与微服务"]},{"title":"Docker应用","url":"/p/e1be.html","content":"## 简介\n1. 基本概念、用途、核心思想 \n2. Docker的组成、架构、重要概念 \n3. Docker的安装  \n4. 第一个Docker容器 \n5. 运行Nginx镜像，并访问到Docker容器内部 \n6. 制作自己的Docker容器，dockerfile实战  \n## Docker的基本概念、用途、核心思想 \n### Docker应用广泛 \n◇京东618：15万个Docker实例，所有业务全部容器化；\n◇蘑菇街等等\n\n### Docker是什么？\n◇ Docker是一个用来装程序及其环境的容器，属于Linux容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux容器解决方案。  \n◇在之前其实更多的是对一个程序进行打包，比如只把jar包上传到服务器上 ；但是Docker不仅打包程序，还将程序{% wavy 所需要的环境 %}依赖一起打包。\n◇通过简单的接口就可以和Docker进行交互，将程序及其环境放入Docker容器中。\n\n### 为什么需要Docker  \n◇没有Docker之前：环境配置的难题，如程序在本机可运行但到了其他主机无法正常运行；\n◇虚拟机来解决配置难题，但是虚拟机资源占用很多，且虚拟机运行的是一整套操作系统；使用虚拟机之前还需要用户登录之类的步骤，而这些步骤对于我们应用程序运行来讲都不是必须的；且虚拟机启动较慢；\n◇Docker的基础-Linux容器。Linux容器和虚拟机不一样，仅仅是对进程进行隔离，即在正常运行的进程外面套一个保护层；相比于虚拟机，Linux容器启动更快、占用资源更少，体积更小；\n\n### Docker的用途 \n◇提供统一的环境\n◇提供快速拓展、弹性伸缩的云服务；如当双十一来的时候需要快速扩展服务器；\n◇防止其他用户的进程把服务器资源占用过多；比如说，在宿舍使用同一个共享网络时，一个在打游戏而另一个在看电影占了大部分网络资源，就会造成游戏网络卡；当服务器跑两个不同的服务时，一个服务陷入死循环，就有可能把CPU全部占满，或者是由于其他问题导致占取大量服务器资源，导致正常的服务无法运行；那么通过Docker能够很好的解决；每一个Docker运行一个服务，来进行{% wavy 服务间的隔离 %}。\n\n### Docker的特点 \n◇标准化：\n\t\t运输方式（把程序和环境从一个机器运到另一个机器的方式）标准化\n\t\t存储方式  (程序和环境的存储) 标准化；\n\t\tAPI接口标准化（不需要Tomcat等应用的命令，都标准化了）\n◇灵活：即使是最复杂的应用也可以集装箱化；\n◇轻量级：容器利用并共享主机内核；\n◇便携式：可以在本地构建，部署到云，并放在任何地方运行；\n\n### Docker带来的好处  \n◇开发团队得到和好处，可以完全的控制我们的运行环境；降低开发风险，因为开发的应用程序会在同一个镜像运行；\n◇如下图，左侧是我们的容器对象，这个镜像会被推到镜像仓库中；测试人员会对程序进行各种测试，而这些测试都是基于同一个镜像实现的；\n![image.png](Docker应用/1636360800370-3412ac44-8665-43a1-90fa-d300f5a3f435.png)\n\n## Docker的组成、架构、重要概念  \n◇整体架构图\n![image.png](Docker应用/1636361288481-65ced84d-6279-4a2c-a280-7041e21aaff7.png)\n◇DOCKER_HOST可以理解为Docker服务，最左侧是指我们的客户端；客户端会连接到Docker服务并进行一系列操作；docker build、docker pull、docker run即前面所提到的API接口，利用这些统一的API去对Docker进行操作；最右侧就是我们的镜像仓库；这个仓库有各种各样的镜像；作为Docker服务，需要什么类型的镜像就从镜像仓库中获取，然后对镜像生成Container(容器)；\n◇三者关系\n![image.png](Docker应用/1636361805251-ea9ee177-b3d3-48c4-be01-dae675544586.png)\n\n### image镜像\n◇镜像本质是一系列文件；\n◇Linux存储技术：联合文件系统，UnionFS；可以把不同的目录挂到同一个虚拟系统下；把多个文件夹或者是多个文件集合起来，通过这种方式实现文件的分层；\n◇下图就描绘了Docker镜像分层的情况；最下面一层是操作系统的引导；Debian是一种操作系统，再往上就是我们自己的应用；\n![image.png](Docker应用/1636362797320-f690aa0e-ba68-4d00-aa37-fb5a05601273.png)\n◇上一层是以下一层作为基础的；最终多层共同组成了一个文件系统；不同的镜像可能有相同的底层(如操作系统，JDK)等；\n![image.png](Docker应用/1636362964075-09a20eb4-0ad4-4ef0-ae78-4ba9d2851874.png)\n\n### 容器\n◇镜像类似于java中的类，而容器就是实例；\n◇在java中有很多很多的类，比如说我们自己写的一个person类，有两个属性：姓名和年龄；在没有实例化类之前，这些属性都是固定的；如前面的镜像分层图：最上面一层有一个writeable，表示可写的；说明在镜像中只有最上层可写，其它层都是只读的；这是因为底层环境需要完整性，所以不可写，而对于一些环境的配置却需要修改，所以容器就在镜像的最上层创建了一个可读可写的系统；这样在程序运行的时候如果要写镜像里的文件就会写在最上层；比如说我修改了系统的一个文件，而此文件本身是属于Apache的，那么就有可能有两份这个文件(一个在最上层，一个在Apache环境层)；容器在找这个文件的时候，会先从最上层开始找，如果最上层没有就会往下一层找，找到之后由于之前对于Apache的文件进行了修改，所以实际上这个修改就是将该文件复制到最上层，那么最上层就有了一个已经修改过的副本；因此容器的这一层是可以修改的，而镜像是不可以修改的；只不过我们在把镜像运行起来(实例化)之后，上面会增加一个可读可写的层；\n◇同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰；\n\n### 仓库\n◇构建镜像的目的就是让别人的电脑拥有和自己本地项目一样的运行环境；仓库作为我们镜像传输的中转站；\n◇Docker官方仓库[hub.docker.com](https://hub.docker.com)\n◇仓库的备选方案：https://c.163yun.com/hub/#/m/home/\n◇仓库有公有和私有两种；\n\n### client和deamon\n◇client：提供给用户一个终端，用户输入Docker提供的命令来管理本地或者远程的服务器；\n◇deamon：服务端守护进程，接收Client发送的命令并执行相应的操作；\n## Docker的安装\n◇Linux (Centos) \n◇安装命令：\n\n```git\n#进入管理员权限\nsu root\n#查看版本\ncat /etc/redhat-release\n#配置国内yum源,wget是从网络上获取资源,/etc/yum.repos.d 是放入资源的地址,CentOS-Base.repo\n是源的基础配置文件,将这个文件替换为来自国内阿里云的C7版本的配置文件;\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n#清理原来的软件源\nyum clean all\n#读取新的软件源\nyum makecache\n#卸载旧版本,下面全部复制即可\nyum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n#更新yum\nyum check-update #查看哪些需要更新\nyum update #执行更新\n#安装Docker所需的软件包\nyum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n#使用以下命令来设置稳定的存储库\nsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n#查看Docker可以安装的版本\nyum list docker-ce --showduplicates | sort -r\n#安装指定的版本\nyum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io\n#Docker是服务器----客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动\nsystemctl start docker #systemctl是linux中关于服务的命令,执行后开启Docker服务而不会有提示\n#安装完成后，运行下面的命令，验证是否安装成功\ndocker version #查看版本\n#或者\ndocker info \n```\n## 第一个Docker容器\n◇下载镜像：docker pull [OPTIONS] NAME[:TAG]  //TAG代表一个标记；\n◇docker images [OPTIONS] [REPOSITORY[:TAG]] //显示本机有哪些镜像,[]代表可选项\n◇执行docker pull hello-world命令\n\n```java\nUsing default tag: latest   //使用默认的tag\nlatest: Pulling from library/hello-world //路径\n2db29710123e: Pull complete \nDigest: sha256:37a0b92b08d4919615c3ee023f7ddb068d12b8387475d64c622ac30f45c29c51\nStatus: Downloaded newer image for hello-world:latest\n```\n◇执行docker images\n```java\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              feb5d9fea6a5        6 weeks ago         13.3kB\n```\n◇运行镜像：docker run \t[OPTIONS] IMAGE [COMMAND] [ARG...]\n◇执行命令 docekr run hello-world\n\n```java\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n◇Client 执行docker run hello-world命令，Docker daemon收到命令后就会在images中找到hello-world这个镜像（前提是已经从仓库中将该镜像下载到本地了）,然后生成实例容器，最后将hello-world的信息打印到终端；\n## 运行Nginx镜像访问到Docker容器内部\n◇前台，后台；\n◇拉取Nginx镜像: docker pull hub.c.163.com/library/nginx:1.13.0\n◇运行镜像：docker run hub.c.163.com/library/nginx：1.13.0\n◇在另一个控制台中，查看容器列表：docker ps \n◇如果要停止运行镜像，则按Ctrl+C；或者：docker stop 容器ID\n◇后台运行Nginx镜像：docker run -d hub.c.163.com/library/nginx:1.13.0\n◇另一个终端，进入容器内部：docker exec [OPTIONS] CONTAINER COMMAND [ARG...]// i的意思是让我们的容器输入有效，t表示分配一个终端，那么-it的意思就是把容器内部的终端映射到我们当前的终端，这样我们在这个窗口输入的命令就会到创建容器的那个窗口去；后面跟着的是容器id，而且容器的id不一定要全部输入，一般输入前几位能够区分其他容器就行了；bash对应COMMAND，意思是启动终端，执行以后会发现开头的提示符已经改变；变为root@a5cef18b0d8f:/# ，说明进入了容器内部；eg：docker exec -it a5cef18b0d8f bash\n◇进入容器内部后就可以执行以下命令，如 touch 1//新建名为1的文件； ls查看文件列表；\n◇root@a5cef18b0d8f:/# which nginx    //查看nginx的目录\n◇exit    //退出并关闭容器\n\n## Docker的网络模式\n### 三种模式\n◇Bridge；最常用的一种模式；相当于在Docker容器里面和外面的宿主机搭建了一座桥，容器和外部是独立的，使用这座桥进行连接；\n◇Host；这种模式下容器不会获得独立的网络，而是和主机使用同一个网络；\n◇None；即无网络连接\n\n### 实操\n◇端口映射：对于Bridge模式，有可能内部和外部的端口不一致，这时候就需要进行端口映射；\n◇访问nginx内部；\n◇docker run -d -p 8088:80 hub.c.163.com/library/nginx:1.13.0  //表示在本机的8080端口映射到容器的80端口\n◇然后ps查看容器列表时可以看到PORTS将映射关系也打印了出来；\n◇在宿主机上查看端口是否生效了: netstat -na|grep 8088\n◇在浏览器上访问ip地址+8088如果是阿里云服务器的话还需要进行网络安全组的配置才能进行访问；即添加安全组规则，方向：入方向；端口范围：8088；授权对象：0.0.0.0/0(表示所有的IP都可以访问)；其他均默认\n◇访问成功页面：\n![image.png](Docker应用/1636462684735-79b1a320-b0ef-44b9-a8a9-327d4a6e604f.png)\n◇docker run -d -P hub.c.163.com/library/nginx:1.13.0//这里会吧容器内部的所有端口都进行映射，即随机产生一个宿主机的端口来对容器内部端口进行映射；当然Nginx只有80一个端口；\n\n## 制作自己的Docker容器\n### dockerfile作用\n◇dockerfile就是用来告诉docker我们要怎么制作镜像，制作镜像的每一个步骤是什么；即dockerfile是用来配置镜像的；我们制作镜像往往是在已有的镜像上去添砖加瓦，加上个性化的配置形成我们自己的镜像；\n### 使用dockerfile的好处\n◇使用dockerfile来描述我们的环境有以下好处：可以把文件放在版本控制之下，这样我们对于环境所做的修改就可以被追踪到，总是知道一个程序运行在什么样的环境之下；而且，有了这个dockerfile之后，我们可以知道程序的运行需要什么样的环境，里面装了哪些软件，怎么配置的；通过dockerfile来维护环境而不是自己配置的话，可以保证该文件始终是新的，这样如果有新的同事加入后，只需要看这个文件就了解到项目的配置情况；\n### 写自己的dockerfile\n◇FROM alpine:latest //创建一个新的镜像，FROM后是一个基础的镜像；alpine是专门针对Docker来做的一个极小型的Linux环境；\n◇MAINTAINER lcg// 表示这个镜像的维护者；\n◇CMD echo 'hello my dockerfile'//终端中打印''里的语句；\n◇具体步骤\n\n```java\ncd /root\ntouch Dockerfile\nvim Dockerfile\n在Dockerfile中： 按i进入编辑模式\nFROM alpine:latest\nMAINTAINER lcg\nCMD echo 'hello lcg'\nEsc退出编辑模式；键入:wq 保存;\ncat Docekrfile 查看文件\n//下面制作镜像;-t指定名字; .代表就在当前路径下创建\ndocker build -t hello_docker .\ndocker images//查看镜像是否创建成功\n```\n◇运行镜像 docker run hello_docker 查看终端是否打印信息；\n","tags":["Docker"],"categories":["分布式与微服务"]},{"title":"分布式基础","url":"/p/38b2.html","content":"## 介绍\n1. 什么是分布式 \n2. 分布式的作用 \n3. 分布式和单体结构的对比  \n4. CAP定理 \n5. 集群、分布式、微服务的区别  \n## 什么是分布式\n◇权威定义： 利用物理架构形成多个自治的处理元素，不共享主内存，但是通过发送信息合作。——Leslie Lamport  \n◇饭店厨师的例子；一个顾客(用户)来到饭店(网站服务器)点餐；对于顾客而言，只需要点菜；对于饭店而言，尽可能准确地满足顾客的要求；如上菜时间短(性能好)，菜品卫生(系统安全), 添加调料(系统拓展性好)， 营业时间24小时(系统高可用);这些服务在顾客数量不多的时候能够尽可能满足，所以请了一个厨师(单体系统)来复制洗菜，炒菜等等；但由于顾客数量增多，那么一个厨师忙不过来；所以聘请多个厨师，但厨师的任务任然是洗菜，炒菜等，当顾客多的时候，哪个厨师空闲，就安排那个厨师干活；在计算机中的例子就是集群部署，将一个单体系统部署到不同的服务器上去；但是，这样的话厨师执行的任务多了，无法专注于某一个领域，因此，术业有专攻，根据不同的任务聘请不同的工人：洗菜工，配菜师，炒菜师；\n◇ 实际项目的演进过程 \n一个项目，大而全\n多台机器，部属同样的应用，即每台服务器上的代码一样；但实际上这是一种资源的浪费，因为不是每一个系统的使用频率都比较高；\n分布式：权限系统、员工系统、请假系统  \n\n## 分布式的作用\n### 为什么需要分布式\n◇实际工作中的痛点：工程臃肿、测试，上线繁琐、开发效率低；\n### 单体应用的问题\n◇应用代码耦合严重，功能扩展难\n◇新需求开发交互周期长，测试工作量大\n◇新加入的开发人员需要很长时间才能熟悉系统\n◇升级维护也很困难(改动任何一点地方都有升级整个系统)\n◇系统性能提升艰难，可用性低，不稳定\n### 分布式的好处\n◇增大系统容量\n◇加强系统可用\n◇因为模块化，所以系统模块重用度更高\n◇因为软件服务模块被拆分，开发和发布速度可以并行而变得更快\n◇系统扩展性更高\n◇团队协作流程也会得到改善\n◇技术升级\n\n## 分布式和单体结构的对比\n![image.png](分布式基础/1636207103509-c347cb09-8899-4441-90ae-768c30b0d74b.png)\n![image.png](分布式基础/1636290374648-8b006cf0-5d96-4d77-868b-abdd893c114e.png)\n![image.png](分布式基础/1636290406131-35f96600-5400-46f7-beec-7e0e1ed3e619.png)\n\n##  CAP定理  \n1. CAP的重要性 \n2. CAP理论是什么？ \n3. 分区容错  \n4. 一致性 \n5. 可用性 \n6. CAP怎么选择？\n### CAP的重要性 \n◇是分布式系统设计中最基础最关键的理论；它指明分布式不可能同时满足CAP这三个条件；\n### CAP理论是什么 \nC（Consistency，一致性）：读操作是否总能读到前一个写操作的结果 \nA（Availability，可用性）：非故障节点应该在合理的时间内作出合理的响应（不是错误或超时的响应），但是可能不是最新的数据 \nP（Partition tolerance，分区容错性）：当出现网络分区现象后，系统能够继续“履行职责”， 尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。    \n◇三者只能选其二,是因为在分布式系统中分区容错是不可避免的，否则就相当于单体应用了。\n◇分区容错(P)：指结点之间通信可能出错；且分区容错是不可避免的；\n◇一致性(C);一个内容被改变后，第二个人能读到这种改变；\n如：client(客户)发消息给服务器G1，将v0改为v1;并且G1给client一个返回说明更改成功；\n![image.png](分布式基础/1636291535088-d9aa0a2c-0f00-44c2-802c-66d0dac34b27.png)\n然后client去读取服务器G2的与G1保存的相同参数v的值，如果返回的是v0的话，说明G2与G1不一致，没有达到一致性；\n![image.png](分布式基础/1636291664444-c7477db9-ffc2-499e-8fd6-5ad4f8a0eaa9.png)\n为了让G1和G2保持一致性，他们之间是需要发送消息来保持同步的；\n![image.png](分布式基础/1636291888103-328d2f70-7fa7-4918-88a4-135fa042d40d.png)\n◇可用性(A); 非故障节点应该在合理的时间内作出合理的响应（不是错误或超时的响应)，但是可能不是最新的数据,因为如果一致性不能保证的话就拿不到最新的数据；\n\n### CAP怎么选择\n◇火车票；如果火车票很紧张，抢票的人很多，那这个时候售票系统就需要保持一致性；如果不保持一致性的话，就会导致两个人购买了同一张票；\n◇银行转账；我们在跨行转账的时候在一致性上可以有延迟，但一定能够成功转账，所以银行转账系统需要保证可用性；\n◇由于P即分区容错一定存在，所以只能有两种选择：CP或者AP。\n◇在什么场合，可用性高于一致性？比如一个网站需要更新，可以让一些用户使用老版本，一些用户使用新版本，这种一致性可以慢慢达到，但是必须保证可用性，即用户都能够访问到网站。\n◇总之就是根据具体的业务场景进行选择。\n\n## 集群、分布式、微服务的区别\n### 集群和分布式的区别\n◇集群：同一个业务，部署在多个服务器上  \n◇集群的多个服务器可以没有通信，但分布式不同的服务器之间需要互相通信；\n◇分布式：一个业务分拆多个子业务，部署在不同的服务器上 \n### 集群和微服务的区别\n◇集群：分散压力\n◇微服务：分散能力\n\n### 分布式和微服务的区别\n◇分布式是系统部署方式，是{% emp 物理上 %}的架构\n◇微服务是架构设计方式，是一种{% emp 逻辑上 %}的架构\n◇微服务是一种架构设计方式，把一个大的服务拆分成一个小的服务，每个小的服务只有一个功能，能够独立开发，测试以及部署，服务之间通过通信进行调用；\n◇微服务是通过分布式实现的；\n\n","tags":["分布式"],"categories":["分布式与微服务"]},{"title":"ThreadLocal","url":"/p/4b81.html","content":"## 简介\n![image.png](ThreadLocal/1636029314385-0925d930-5ccd-4a82-acfe-d85f4b01778b.png)\n## 两大使用场景\n### 典型场景1\n◇每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）多个线程共享同一个静态工具类是有风险的，所以需要使用ThreadLocal来帮每一个线程制作一个独享的对象，让线程和线程之间拥有的工具类对象是不同的实例；\n◇每个线程需要一个独享的对象；每个Thread内有自己的实例副本，不共享；例如：教材只有一本，一起做笔记有线程安全问题，而复印后没问题；\n ◇SimpleDateFormat的进化之路；两个线程分别用自己的SimpleDateFormat；一共有两个线程，都需要去打印日期，所以都需要使用到SimpleDateFormat这个工具类；\n![image.png](ThreadLocal/1636030209415-975b6792-edab-46f9-ab36-cd6f8a2ca8db.png)\n\n```java\n/**\n * 描述：     两个线程打印日期\n */\npublic class ThreadLocalNormalUsage00 {\n\n    public static void main(String[] args) {\n        //第一个线程\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String date = new ThreadLocalNormalUsage00().date(10);//10s以后的时间是多少\n                System.out.println(date);\n            }\n        }).start();\n        //第二个线程\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String date = new ThreadLocalNormalUsage00().date(104707);\n                System.out.println(date);\n            }\n        }).start();\n    }\n\n    public String date(int seconds) {\n        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时\n        Date date = new Date(1000 * seconds);\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return dateFormat.format(date);\n    }\n}\n```\n◇如果当需求变成了1000个，那么必然要用线程池(否则消耗内存太多)；\n![image.png](ThreadLocal/1636031239944-aa331fd8-8081-4f33-bd58-0a986e0c6e7e.png)\n\n```java\n    //固定10个数量的线程池\n    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 1000; i++) {\n            int finalI = i;\n            threadPool.submit(new Runnable() {\n                @Override\n                public void run() {\n                    //调用date()方法就会创建一个SimpleDateFormat对象\n                    String date = new ThreadLocalNormalUsage02().date(finalI);\n                    System.out.println(date);\n                }\n            });\n        }\n        threadPool.shutdown();//关闭线程池\n    }\n```\n◇1000个任务新建了1000个SimpleDateFormat对象，这样开销太大了，占用堆内存，而且增加垃圾回收的压力；应该优化代码，不需要每一个任务都新建SimpleDateFormat对象；即在外部创建一个静态的全局的SimpleDateFormat对象，每一次执行任务时直接使用，而不新建；\n```java\nstatic SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\npublic String date(int seconds) {\n        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时\n        Date date = new Date(1000 * seconds);\n        return dateFormat.format(date);\n    }\n```\n◇但是这样就会出现前面提到过的线程安全问题，导致会出现打印出相同的时间(我们的目的是每一次打印的时间都会增加1s)；即所有的线程都共用同一个SimpleDateFormat对象就有可能产生线程安全；\n![image.png](ThreadLocal/1636033488916-943cfbef-0f5d-47b3-a6dd-b02b99be9c6e.png)\n◇尝试利用加锁的方法来解决线程安全问题；锁应该加在危险的代码行，即return dateFormat.format(date)处；这样就能避免多个线程共同使用SimpleDateFormat对象；\n\n```java\n        String s = null;\n        //类锁\n        synchronized (ThreadLocalNormalUsage04.class) {\n            s = dateFormat.format(date);\n        }\n        return s;\n```\n◇通过加锁的方式能够有效避免多个线程共同使用SimpleDateFormat对象；但是这样的方法会导致线程使用对象时排队，这样效率就比较低;那么，更好的解决方案是使用ThreadLocal；即给每一个线程内部使用一个df(dateformate)；线程池有十个线程，那就创建十个dateformate对象；\n```java\n/**\n * 描述：利用ThreadLocal，给每个线程分配自己的dateFormat对象，保证了线程安全，高效利用内存\n */\npublic class ThreadLocalNormalUsage05 {\n\n    public static ExecutorService threadPool = Executors.newFixedThreadPool(10);\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 5; i++) {\n            int finalI = i;\n            threadPool.submit(new Runnable() {\n                @Override\n                public void run() {\n                    String date = new ThreadLocalNormalUsage05().date(finalI);\n                    System.out.println(date);\n                }\n            });\n        }\n        threadPool.shutdown();\n    }\n\n    public String date(int seconds) {\n        //参数的单位是毫秒，从1970.1.1 00:00:00 GMT计时\n        Date date = new Date(1000 * seconds);\n//       利用get()方法获取dateFormat对象\n//       相当于前面的SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal2.get();\n        return dateFormat.format(date);\n    }\n}\n//创建线程安全的对象\nclass ThreadSafeFormatter {\n\n    //创建静态的ThreadLocal,即想调用就调用\n    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>() {\n        @Override\n        protected SimpleDateFormat initialValue() {//重写初始化函数\n            return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        }\n    };\n\n    /*使用lambda表达式重写函数*/\n    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal2 = ThreadLocal\n            .withInitial(() -> new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n}\n```\n### 典型场景2\n◇每个线程内需要保存全局变量（例如在拦截器中获 取用户信息），可以让不同方法直接使用，避免参数传递的麻烦；\n◇实例：当前用户信息需要被线程内所有方法共享；一个比较繁琐的解决方案是把user作为参数层层传递，从service-1传到service-2，再传到service-3，以此类推，但这样做会导致代码冗余且不易维护；\n![image.png](ThreadLocal/1636097267562-7880070c-af75-47e4-bfee-eb13664fbfb3.png)\n◇设想直接给一个全局的用户信息，每一次想要用的时候直接调用就行了；这种想法也是不可取的，因为在这种场景下，每个请求对应着不同的用户；那么又设想使用UserMap，来保存登录用户的信息；如下图，第一个方法生成user对象放到UserMap中，后面的方法需要用时就往里面取；\n![image.png](ThreadLocal/1636097775121-cade40c3-0097-4185-b225-41646225916d.png)\n◇但是，这样一来就会产生新的问题：usermap是很有可能被多个线程同时使用的，必须保证线程安全；\n◇当多个线程同时工作时，我们需要保证线程安全，可以用synchroized,也可以用ConcurrentHashMap,但无论用什么，都会对性能有所影响；\n![image.png](ThreadLocal/1636097961863-031c3d97-0c09-491f-aa64-14c04ae02658.png)\n◇更好的办法是使用ThreadLocal，这样无需synchronized,可以在不影响性能的情况下，也无需层层传递参数，就可以达到保存当前线程对应的用户信息的目的；用ThreadLocal保存一些业务内容(用户权限信息、从用户系统获取到的用户名、user ID等)；这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的；\n◇在线程生命周期内，都通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象(例如user对象)作为参数传递的麻烦；\n◇与场景一不同，这里强调的是同一个请求内(同一个线程内)不同方法间的共享；不需要重写initialValue()方法，但是必须手动调用set()方法；\n◇代码演示\n\n```java\n/**\n * 描述：     演示ThreadLocal用法2：避免传递参数的麻烦\n */\npublic class ThreadLocalNormalUsage06 {\n\n    public static void main(String[] args) {\n        new Service1().process(\"\");\n\n    }\n}\n\n//用来设置用户信息;\nclass Service1 {\n\n    public void process(String name) {\n        User user = new User(\"张珊\");\n        UserContextHolder.holder.set(user);\n        new Service2().process();\n    }\n}\n\nclass Service2 {\n\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(\"Service2拿到用户名：\" + user.name);\n        new Service3().process();\n    }\n}\n\nclass Service3 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(\"Service3拿到用户名：\" + user.name);\n    }\n}\n\n//持有用户信息的类;\nclass UserContextHolder {\n    //这里不需要重写initialValue方法;\n    public static ThreadLocal<User> holder = new ThreadLocal<>();\n}\n\n//用户实体类\nclass User {\n    String name;\n    public User(String name) {\n        this.name = name;\n    }\n}\n```\n◇如下图，第一个线程进来之后执行service-1，会将user信息设置进去；然后service-2,3,4就可以直接获取；\n同样对于第二个请求(对应第二个线程)来讲，也是用1设置信息，2,3,4来读取\n![image.png](ThreadLocal/1636100528679-67455bb1-069d-4c41-b5b3-d3fa9e4d0443.png)\n\n## 总结\n### ThreadLocal的两个作用\n1. 让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象） \n2. 在任何方法中都可以轻松获取到该对象 \n◇根据共享对象的生成时机不同，选择initialValue或set来保存对象；\n◇例如，在场景一中，使用initialValue；在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制；\n◇在场景二中，使用set；因为如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制(在上例中的拦截器生成的用户信息)；因此使用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用；\n### 使用ThreadLocal带来的好处 \n◇达到线程安全 \n◇不需要加锁(线程之间的对象是独立的)，提高执行效率 \n◇更高效地利用内存、节省开销 \n        --相比于每个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销  \n◇免去传参的繁琐 \n        -- 不需要每次都传同样的参数 \n        -- ThreadLocal使得代码耦合度更低，更优雅  \n### 主要方法介绍\n◇T initialValue( )：初始化 ；\n①该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get的时候，才会触发 ； \n②当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本 initialValue方法  \n③ 通常，每个线程最多调用一次此方法，但如果已经调用了remove()来删除后，再调用get()，则可以再次调用此方法  \n④ 如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象。  \n◇void set(T t)：为这个线程设置一个新值 \n◇T get( )：得到这个线程对应的value。如果是首次调用 get()，则会调用initialize来得到这个值 \n◇void remove( )：删除对应这个线程的值；如：UserContextHolder.holder.remove(); \n\n### 图解ThreadLocal原理\n◇搞清楚Thread，ThreadLocal以及 ThreadLocalMap三者之间的关系  \n◇每个Thread对象中都持有且仅有一个ThreadLocalMap成员变量  \n![image.png](ThreadLocal/1636183873959-5116d7b0-f90b-4e47-92b8-8fcd8b85bad1.png)\n◇一个ThreadLocalMap存储很多ThreadLocal，这是因为一个线程可能有多个ThreadLocal对象；\n◇get方法； get方法是先取出当前线程的ThreadLocalMap ；然后调用map.getEntry方法，把ThreadLocal的引用作为key参数传入 ； 取出map中属于本ThreadLocal的value ；\n◇注意：这个map以及map中的key和value都是保存在线程中的，而不是保存在ThreadLocal中；ThreadLocal可以理解为只是对ThreadLocalMap进行了封装，传递了变量值；\n◇ initialValue方法 \n-- 没有默认实现 \n-- 如果要用initialValue方法，需要自己实现 \n-- 通常使用匿名内部类的方式实现  \n◇ remove方法用来删除保存的自定义对象；这里要注意的是，从线程中获取到的ThreadLocalMap对象是包含了很多个ThreadLocal的，但需要删除的只是当前的ThreadLocal对象，所以使用this引用作为参数执行m.remove()方法；\n\n### ThreadLocalMap 类  \n◇ThreadLocalMap类，也就是Thread.threadLocals  \n◇ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[] table，可以认为是一个 map，键值对：\n◇键：这个ThreadLocal \n◇值：实际需要的成员变量，比如User或者 SimpleDateFormat对象  \n◇类似于HashMap的结构，但是遇到冲突的解决方法和HashMap不同；在HashMap中使用拉链法和红黑树来解决冲突；\n![image.png](ThreadLocal/1636189148017-6d7a924f-1470-44d5-a396-ed6396587189.png)\n◇而在ThreadLocalMap中采用线性探测法，也就是如果发生冲突，就继续找下一个空位置而不是用链表拉链；\n\n### 两种使用场景殊途同归 \n◇通过源码分析可以看出，setInitialValue和直接set最后都是利用map.set()方法来设置值\n◇也就是说，最后都会对应到ThreadLocalMap的一个Entry，只不过是起点和入口不一样  \n### 内存泄漏\n◇什么是内存泄漏：某个对象不再有用，但是占用的内存却不能被回收 \n◇泄露有两种情况：ThreadLocal的泄露和key的泄露\n◇key的泄漏：ThreadLocalMap中的Entry(即键值对)继承自 WeakReference，是弱引用  \n```java\n//ThreadLocal部分源码       \nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n◇弱引用的特点：如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收;我们平常的赋值如Object value; value=v都是强引用；\n◇由于Value是强引用，则会导致内存的泄露；\n◇ThreadLocalMap 的每个Entry 都是一个对key的弱引用，同时， 每个 Entry 都包含了一个对value的强引用 \n◇正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了 \n◇但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收，因为有以下的调用链：  Thread→ ThreadLocalMap→ Entry（key为null）→ Value  \n◇因为value和Thread之间还存在这个强引用链路，所以导致value 无法回收，就可能会出现OOM \n◇JDK已经考虑到了这个问题，所以在set, remove, rehash方法中会扫描key为null的Entry，并把对应的value设置为null，这样value对象就可以被回收；如下面ThreadLocal中resize()方法的源码，它会判断如果k==null的话，就将其value也置空； \n\n```java\n private void resize() {\n            Entry[] oldTab = table;\n            int oldLen = oldTab.length;\n            int newLen = oldLen * 2;\n            Entry[] newTab = new Entry[newLen];\n            int count = 0;\n\n            for (int j = 0; j < oldLen; ++j) {\n                Entry e = oldTab[j];\n                if (e != null) {\n                    ThreadLocal<?> k = e.get();\n                    if (k == null) {\n                        e.value = null; // Help the GC\n                    } else {\n                        int h = k.threadLocalHashCode & (newLen - 1);\n                        while (newTab[h] != null)\n                            h = nextIndex(h, newLen);\n                        newTab[h] = e;\n                        count++;\n                    }\n                }\n            }\n```\n◇但是如果一个ThreadLocal不被使用，那么实际上set, remove, rehash方法也不会被调用，如果同时线程又不停止，那么调用链就一直存在，那么就导致了value的内存泄漏  \n◇那么如何避免内存泄漏呢？答案是使用阿里规约；\n◇ 调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal之后，应该调用remove方法；如在场景二中假设最后一个service3使用完ThreadLocal后，调用remove方法；\n```java\nclass Service3 {\n    public void process() {\n        User user = UserContextHolder.holder.get();\n        System.out.println(\"Service3拿到用户名：\" + user.name);\n        UserContextHolder.holder.remove();\n    }\n}\n```\n### 空指针异常\n◇代码示例\n```java\npublic class ThreadLocalNPE {\n    ThreadLocal<Long> longThreadLocal = new ThreadLocal<Long>();\n\n    public void set() {\n        longThreadLocal.set(Thread.currentThread().getId());\n    }\n\n    public long get(){\n        return longThreadLocal.get();\n    }\n    public static void main(String[] args) {\n\n        Thread t1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                ThreadLocalNPE threadLocalNPE = new ThreadLocalNPE();\n                //threadLocalNPE.set();\n                System.out.println(threadLocalNPE.get());\n            }\n        });\n        //执行线程\n        t1.start();\n    }\n}\n```\n以上代码没有set而是直接get，就会抛出空指针异常；\n![image.png](ThreadLocal/1636200155873-2e704ac9-8308-4f6d-9183-43eafa80e208.png)\n但是，如果将get方法的返回值类型有long改为Long，就会打印出null，而不报空指针异常；这是因为我们的泛型指定的是Long包装类型的长整形，而返回类型是基本类型的长整型，它就会做一下装箱拆箱，这样一来在装箱拆箱过程中尝试将get得到到对象转回基本类型long；由于对象是空的，所以在转换的时候抛出空指针异常；即空指针异常的问题通常是由于转换不当造成的；\n\n","tags":["线程"],"categories":["分布式与微服务"]},{"title":"线程池","url":"/p/e2.html","content":"## 线程池-治理线程的最大法宝\n◇线程池的自我介绍\n◇创建和停止线程池\n◇常见线程池的特点和用法\n◇任务太多、怎么拒绝？\n◇钩子方法，给线程池加点料\n◇实现原理、源码分析\n◇使用线程池的注意点\n\n## 线程池的自我介绍\n◇什么是\"池\"\n          --软件中的\"池\"，可以理解为计划经济；资源是有限的，需要合理分配线程；\n◇如果不使用线程池，每个任务都新开一个线程处理；多个任务的话用for循环创建线程；\n◇创建线程的[方式](https://www.cnblogs.com/wxw7blog/p/7727510.html)之一：实现Runnable接口，重写run方法。\n\n```java\npackage threadpool;\n//每个任务创建一个线程\npublic class EveryTaskThread{\n    public static void main(String[] args){\n        Thread thread = new Thread(new Task());\n        thread.start();//启动线程\n    }\n    \n   static class Task implements Runnable{//创建一个任务\n         @Override\n        public void run(){ //重写run方法\n           System.out.pringln(\"执行任务\");\n        }\n    }\n}\n```\n```java\n//循环创建\npublic class ForLoop{\n    public static void main(String[] args){\n        for(int i=0;i<1000;i++){\n            Thread thread = new Thread(new Task());\n            thread.start();//启动线程\n        }\n    }\n    \n   static class Task implements Runnable{//创建一个任务\n         @Override\n        public void run(){ //重写run方法\n           System.out.pringln(\"执行任务\");\n        }\n    }\n}\n```\n◇如果任务数量过于庞大，使用上面的方法显然开销太大了；我们希望有固定数量的线程，来执行这1000个任务，这样就避免了反复创建并销毁线程所带来的开销问题；\n## 为什么要使用线程池 \n◇问题一：反复创建线程开销大 \n◇问题二：过多的线程会占用太多内存 \n◇解决以上两个问题的思路 \n   • 用少量的线程——避免内存占用过多 \n   • 让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗  \n\n## 线程池的好处 \n◇加快响应速度 \n◇合理利用CPU和内存 \n◇统一管理 \n\n## 线程池适合应用的场合 \n◇服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率 \n◇实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理  \n\n## 创建线程池 \n◇线程池构造方法的参数 \n◇线程池应该手动创建还是自动创建 ，手动创建更加灵活；\n◇线程池里的线程数量设定为多少比较合适？ \n◇停止线程池的正确方法  \n\n### 线程池构造方法的参数  \n\n| 参数名        | 类型                     | 含义                                                         |\n| ------------- | ------------------------ | ------------------------------------------------------------ |\n| corePoolSize  | int                      | 核心线程数                                                   |\n| maxPoolSize   | int                      | 最大线程数                                                   |\n| keepAliveTime | long                     | 线程存活时间                                                 |\n| workQueue     | BlockingQueue            | 任务存储队列                                                 |\n| threadFactory | ThreadFactory            | 创建线程工程，当线程池需要新的线程的时候，会使用它来生成新的线程 |\n| Handler       | RejectedExecutionHandler | 线程池无法接受提交的任务时的拒绝策略                         |\n\n### 参数中的corePoolSize和maxPoolSize \n◇corePoolSize指的是核心线程数 \n- 线程池在完成初始化后，默认情况下，线程池中并没有任何线程,线程池会等待有任务到来时,再创建新线程去执行任务 \n\n◇最大量maxPoolSize \n\n- 在核心线程数的基础上，额外增加的线程数的上限  \n\n### corePoolSize和maxPoolSize  \n![image.png](线程池/1635842042382-04e08aec-05d8-41fc-b65c-a2729498e9e4.png)\n◇从左端开始看，当任务进来后就会创建线程一直到达到Current size后；任务会依次使用初始化时的核心线程数来执行任务，一般情况不会突破这个数量；如果任务过多，就会存储到队列中去，等核心线程有剩余后再出队去处理；如果队列满了，并且核心线程数量都在被使用，这样线程池就会在核心线程数的基础上增加新的线程来处理任务，线程数量最多扩展到Max pool size；\n\n### 添加线程规则 \n1. 如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。 \n2. 如果线程数等于（或大于）corePoolSize但少于 maximumPoolSize，则将任务放入队列。 \n3. 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务。\n4. 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。  \n![image-20220526142129371](线程池/image-20220526142129371.png)\n ◇是否需要增加线程的判断顺序是： corePoolSize -> workQueue  -> maxPoolSize  \n### 举例说明\n◇线程池：核心池大小为5，最大池大小为10，队列为100。 \n◇因为线程中的请求最多会创建5个，然后任务将被添加到队列 中，直到达到100。当队列已满时，将创建最新的线程 maxPoolSize，最多到10个线程，如果再来任务，就拒绝。\n\n### 增减线程的特点 \n1.通过设置corePoolSize和maximumPoolSize 相同，就可以创建固定大小的线程池。 \n2.线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。 \n3.通过设置maximumPoolSize为很高的值，例如 Integer.MAX_VALUE， 可以允许线程池容纳任意数量的并发任务。 \n4.只有在队列填满时才创建多于corePoolSize的线程，如果使用的是无 界队列（例如LinkedBlockingQueue），那么线程数就不会超过 corePoolSize。    \n\n### keepAliveTime \n◇如果线程池当前的线程数多于corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止 \n### ThreadFactory 用来创建线程 \n◇新的线程是由ThreadFactory创建的，默认使用 Executors.defaultThreadFactory() \n◇创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。 \n◇如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 \n◇通常使用默认的ThreadFactory就可以了 \n\n### 工作队列 \n◇有3种最常见的队列类型： \n1) 直接交接：SynchronousQueue ；如果任务不是特别多的话，只是把任务通过这个队列进行简单的中转，交到线程去处理的话就可以使用该队列；这个队列本身内部是没有容量的，里面不能存储任务，任务过多的话就不能够缓冲，所以使用时要把初始线程数设置大一点；\n2) 无界队列：LinkedBlockingQueue ；无界队列不会被塞满，使用无界队列可以防止流量突增带来的影响；但也有风险：比如说我们任务处理的速度跟不上任务提交的速度，那么无界队列的任务会越来越多可能会造成内存浪费或者内存溢出(OOM)异常；\n3) 有界的队列：ArrayBlockingQueue ;可以设置队列的大小；\n### 线程池应该手动创建还是自动创建 \n◇手动创建更好，因为这样可以更加明确线程池的运行规则，避免资源耗尽的风险  \n◇自动创建线程池（即直接调用JDK封装好的构造方法，创建常用的几种线程池） 可能带来哪些问题？  \n◇newFixedThreadPool,核心线程线程数和最大线程数相同。因为使用了无界队列，容易造成大量内存占用，造成OOM异常。\n\n◇演示创建FixedThreadPool线程池并处理任务。\n\n```java\npackage threadpool;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n//演示如何创建newFixedThreadPool 线程池\npublic class TestClass {\n    public static void main(String[] args) {\n        //线程数量固定为4，使用无限大的队列\n        ExecutorService executorService = Executors.newFixedThreadPool(4);\n        for (int i = 0; i < 1000; i++) {\n            //执行任务\n            executorService.execute(new Task());\n        }\n    }\n}\n//创建任务\nclass Task implements Runnable{\n\n    public void run() {\n        try {\n            Thread.sleep(500);//休眠500毫秒\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //打印线程名\n        System.out.println(Thread.currentThread());\n    }\n}\n```\n◇演示出现OOM异常的情况，应该将内存设置的小一点: 在编辑运行中设置VM options：-Xmx8m  -Xms8m。即为JVM虚拟机设置堆区内存的参数，-Xms表示java虚拟机堆区内存初始内存分配的大小，-Xmx 表示java虚拟机堆区内存可被分配的最大上限。在开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。\n```java\n/**\n * 描述：     演示newFixedThreadPool出错的情况\n */\npublic class FixedThreadPoolOOM {\n\n    private static ExecutorService executorService = Executors.newFixedThreadPool(1);\n    public static void main(String[] args) {\n        //执行大量的任务\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            executorService.execute(new SubThread());\n        }\n    }\n\n}\nclass SubThread implements Runnable {\n    @Override\n    public void run() {\n      try {\n          Thread.sleep(1000000000);//一直在睡眠中,即任务一个都不能执行;这样能有效的将队列填满\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n◇然后运行程序，隔一段时间就会看到异常出现\n\n![image-20220526151037718](线程池/image-20220526151037718.png)\n\n◇newSingleThreadExecutor，只有一个线程的线程池。核心数量和最大数量都设置为1，采用无界队列，当请求堆积的时候，可能会占用大量的内存。\n\n```java\npublic class SingleThreadExecutor {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        for (int i = 0; i < 1000; i++) {\n            executorService.execute(new Task());\n        }\n    }\n}\n```\n◇newCachedThreadPool  可缓存线程池。特点：具有自动回收多余线程的功能(时间是60s)。使用的是直接交换队列，此队列内部容量为0，不能保存任务，所以任务直接就到线程池中去执行了。线程池设置的线程最大数为整形的最大值，也就是执行任务时线程数量不够的话会一直创建线程。当任务结束之后，就会自动回收多余线程。由于创建过多的线程，也有OOM的风险。创建方法如下\n\n```java\nExecutorService executorService = Executors.newCachedThreadPool();\n```\n◇newScheduledThreadPool；支持定时及周期性任务执行的线程池；最大线程数量为整数的最大值，使用DelayedWorkQueue[优先级队列](https://www.jianshu.com/p/587901245c95)。\n\n```java\nScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);//设置核心数量\n//延迟执行任务，参数为：任务,延迟时间,时间单位\nthreadPool.schedule(new Task(), 5, TimeUnit.SECONDS);\n//周期性执行任务，这里表示为开始时延迟1s执行任务,然后每隔3S执行一次\nthreadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS);\n```\n◇以上4种线程池的构造方法的参数\n\n![image.png](线程池/1635851363010-1f49bdf6-5b10-4aba-82bc-a69c3f184465.png)\n\n◇正确的创建线程池的方法：根据不同的业务场景，设置线程池参数 。\n\n### 线程池里的线程数量设定为多少比较合适？ \n◇{% wavy CPU密集型 %}（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。 \n◇{% wavy 耗时IO型 %}（读写数据库、文件、网络读写等）：最佳线程数一 般会大于CPU核心数很多倍 参考Brain Goetz推荐的计算方法： 线程数=CPU核心数*（1+平均等待时间/平均工作时间）\n\n### 阻塞队列分析 \n◇为什么FixedThreadPool和SingleThreadExecutor的Queue是LinkedBlockingQueue? \n \t\t答：是因为由于线程数量是有限的，所以不得不用一个很大甚至无限大的队列来存储任务；\n◇为什么CachedThreadPool使用的Queue是SynchronousQueue？ \n         答：SynchronousQueue队列内部是不存储的，而刚好CachedThreadPool的线程数量很多，不需要队列来存储任务；\n◇ScheduledThreadPool来说，它使用的是延迟队列 DelayedWorkQueue \n◇workStealingPool是JDK1.8加入的；该线程池和之前的都有很大不同，适用于能够产生子任务的任务；如二叉树的遍历；该线程池拥有窃取能力，即线程之间会进行合作；用它执行的任务最好不要加锁，这样更加高效的进行并行执行；执行的顺序不能保障；实际开发中很少用到；  \n\n## 停止线程池\n### 停止线程池的正确方法 \n\n◇停止线程池一般有以下几种方法:\n\n1、shutdown；实际上运行该方法后线程池不一定停止，这个方法事实上只是初始化关闭的过程；因为在线程池被关闭的时候有线程中正在被执行的任务和在存储队列中的任务；所以不是一个命令想停就停的；shutdown方法执行后即通知要关闭线程池，然后拒绝所有新的任务，但线程池会把正在执行的以及还在队列中等待的任务执行完后才关闭；\n2、isShutdown ；判断线程池是否停止，并不是完全停止，而是指是否执行了shutdown方法；\n\n```java\npublic class ShutDown {\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 1000; i++) {\n            executorService.execute(new ShutDownTask());\n        }\n        Thread.sleep(1500);//休眠1.5s\n        System.out.println(executorService.isShutdown());//判断是否停止\n        executorService.shutdown();//停止线程池\n        System.out.println(executorService.isShutdown());\n        executorService.execute(new ShutDownTask());//添加新任务\n    }\n}\n```\n![image.png](线程池/1635924704169-81d440ab-77b7-4c41-b13e-89e26bc7ca02.png)\n可以看出，在成功执行shutdown方法后，添加新任务会出现异常，但原先正在执行或者在等待中的任务会被执行；\n3、isTerminated ;用来判断线程是否完全终止，即线程池里的任务是否执行完毕；\n4、awaitTermination；用来测试在一段时间内线程池是否会完全关闭；返回只有三种情况，在返回之前该方法是阻塞的：①所有任务都执行完毕；②达到等待的时间；③等待过程中被中断\n\n```java\nexecutorService.awaitTermination(3L, TimeUnit.SECONDS);//(时间,时间单位)\n```\n5、shutdownNow ；立刻关闭线程池，用中断的信号触发正在执行的任务；而在队列里的任务直接加入列表中作为返回对象返回；\n\n```java\nList<Runnable> runnableList = executorService.shutdownNow();\n```\n### 任务太多，怎么拒绝？ \n◇拒绝时机 \n1.当Executor关闭时，提交新任务会被拒绝。 \n2.以及当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时  \n\n### 四种拒绝策略\n◇AbortPolicy；直接抛出异常，终端可以得知任务未提交成功\n◇DiscardPolicy；将任务丢弃，但不通知到终端；\n◇DiscardOldestPolicy ；丢弃最旧的任务，腾出空间存放新提交的任务\n◇CallerRunsPolicy ；让提交任务的线程去执行任务，优点是避免任务损失、可以降低提交任务的速度；\n\n### 钩子方法，给线程池加点料 \n◇每个任务执行前后增加执行钩子函数能够起到暂停、恢复线程池的作用；\n◇日志、统计 \n◇代码演示 \n\n```java\n/**\n * 演示每个任务执行前后放钩子函数\n */\npublic class PauseableThreadPool extends ThreadPoolExecutor {\n    //为了保证布尔值的并发修改是安全的，给其上一把锁；\n    private final ReentrantLock lock = new ReentrantLock();\n    //休眠线程\n    private Condition unpaused = lock.newCondition();\n    private boolean isPaused;//标记位，线程池是否暂停；\n    \n    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {\n        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);\n    }\n\n    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n    }\n\n    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {\n        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);\n    }\n\n    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n    }\n    \n    //重写beforeExecute()钩子方法\n    @Override\n    protected void beforeExecute(Thread t, Runnable r) {\n        super.beforeExecute(t, r);\n        lock.lock();//上锁\n        try {\n        while (isPaused) {//是暂停\n                unpaused.await();//休眠线程\n            }\n        }catch (InterruptedException e) {\n                e.printStackTrace();\n        }finally {\n            lock.unlock();//释放锁\n        }\n    }\n\n    //暂停方法\n    private void pause() {\n        lock.lock();\n        try{\n            isPaused=true;//将标志位设置为true\n        }finally {\n            lock.unlock();\n        }\n    }\n    //恢复方法\n    public void resume() {\n        lock.lock();\n        try {\n            isPaused=false; //设置标志位\n            unpaused.signalAll();//唤醒所有线程\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        //新建线程池\n        PauseableThreadPool pauseableThreadPool =\n                new PauseableThreadPool(10, 20, 10l, TimeUnit.SECONDS,\n                        new LinkedBlockingQueue<>());\n        Runnable runnable = new Runnable(){\n            @Override\n            public void run() {\n                System.out.println(\"线程被执行\");\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        for (int i = 0; i < 1000; i++) {\n            pauseableThreadPool.execute(runnable);\n        }\n        Thread.sleep(1500);//执行一段时间之后\n        pauseableThreadPool.pause();//暂停线程池\n        System.out.println(\"线程池已被暂停\");\n        Thread.sleep(1500);//过一段时间后\n        pauseableThreadPool.resume();//恢复线程池\n        System.out.println(\"线程池已恢复\");\n    }\n}\n```\n![image.png](线程池/1635994280012-49add18a-327b-41bf-9ffa-72cdbafcfd1d.png)\n## 线程池实现原理、源码分析 \n◇线程池重要组成部分：①线程池管理器(如ThreadPoolExecutor)②工作线程③任务队列④任务接口（Task)。\n\n### Executor家族\n◇线程池、ThreadPoolExecutor、ExecutorService、Executor、 Executors等这么多和线程池相关的类，都是什么关系？\n◇继承关系(从父类到子类)：Executor -> ExecutorService -> AbstractExecutorService -> ThreadPoolExecutor\n◇Executor是一个接口，只有一个方法， void execute()用来执行；\n◇ExecutorService也是一个接口，继承了Executor；增加了shutdown等方法；\n◇Executors是一个工具类，有很多方法用来创建各种线程池等；\n\n### 线程池实现任务复用的原理\n◇核心：相同的线程执行不同任务；线程池对线程进行了包装，不需要重复的启动线程；只是启动已有的固定数量的线程即可；在线程池中的线程，不同于普通的线程，它里面的Run方法会不停的检测有没有新的任务进来，有的话就会执行任务的run方法，也就是把这些任务串联起来；线程池让这些固定的线程从任务队列中把任务取出来并且执行；\n◇源码分析：[runWorker()方法](https://blog.csdn.net/ctwctw/article/details/117407152)；\n\n```java\nfinal void runWorker(Worker w) {\n    // 获取当前线程对象的引用\n    Thread wt = Thread.currentThread();\n    // 获取worker的firstTask\n    Runnable task = w.firstTask;\n    // 获取完之后把worker的firstTask置为null 防止下次获取到\n    w.firstTask = null;\n\t//这里不是解锁，而是为了设置state = 0 以及 ExclusiveOwnerThread = null\n    //因为起始状态state = -1,(在前面的源码中,详见链接)。不允许任何线程抢占锁，这里就是初始化操作\n    w.unlock(); \n    // 如果发生异常 当前线程突然退出 该值为true \n    boolean completedAbruptly = true;\n    try {\n        // 如果firstTask获取getTask能获取到任务 则进行内层逻辑, 如果getTask返回null则循环退出了就要\n        while (task != null || (task = getTask()) != null) {\n            /*\n            * worker设置独占锁\n            * shutdown 时会判断当前worker的状态，根据独占锁的状态来判断worker是否在处理任务是否工作\n            */\n            w.lock();\n            /*\n            * 3个判断\n            * 1、runStateAtLeast(ctl.get(), STOP)为真说明当前状态大于等于STOP 此时需要给他一个中断信号\n            * 2、wt.isInterrupted()查看当前是否设置中断状态如果为false则说明为设置中断状态\n            * 3、Thread.interrupted() && runStateAtLeast(ctl.get(), STOP) 获取当前中断状态且清除中断状态 \n            *    这个判断为真的话说明当前被设置了中断状态(有可能是线程池执行的业务代码设置的，然后重置了)且当前状态变成了大于等于STOP的状态了\n            * \n            * 整个判断为真的两种情况\n            * 1、如果当前线程大于等于STOP 且未设置中断状态 整个判断为true 第一个runStateAtLeast(ctl.get(), STOP)为true !wt.isInterrupted()为true\n            * 2、第一次判断的时候不大于STOP 且当前设置了中断状态(Thread.interrupted()把中断状态又刷新了) 且设置完了之后线程池状态大于等于STOP了\n            *    Thread.interrupted() && runStateAtLeast(ctl.get(), STOP) 为true !wt.isInterrupted()为true\n            *\n            * 结合if判断里面的代码来看 \n            * 也就是说如果线程池状态大于等于STOP则设置当前线程的中断状态\n            * 如果线程池状态小于STOP则清除中断状态\n            */\n            if ((runStateAtLeast(ctl.get(), STOP) || \n                        (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) \n                    && !wt.isInterrupted())\n                // 设置中断状态\n                wt.interrupt();\n            try {\n                // 钩子方法留给子类实现\n                beforeExecute(wt, task);\n                try {\n                    // task可能是FutureTask或者普通Runnable/Callable接口实现类\n                    task.run();\n                    // 钩子方法 留给子类实现\n                    afterExecute(task, null);\n                } catch (Throwable ex) {\n                    afterExecute(task, ex);\n                    throw ex;\n                }\n            } finally {\n                // 局部task设置为null\n                task = null;\n                // 完成数量加1\n                w.completedTasks++;\n                // 使用unlock 释放独占锁\n                w.unlock();\n            }\n        }\n        // getTask的返回为null 会走到这行 表示这次不是异常退出\n        completedAbruptly = false;\n    } finally {\n        /*\n        * 执行线程退出逻辑\n        * 如果completedAbruptly是true说明是task.run()方法有异常 先catch后又抛了出来 在执行完了w.unlock();走到了这里\n        * 如果是false则说明是拿不到任务走到了这里\n        */\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n\n```\n### 线程池状态\n\n| 状态       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| RUNNING    | 接受新任务并处理排队任务                                     |\n| SHUTDOWN   | 不接受新任务，但处理排队任务                                 |\n| STOP       | 不接受新任务，也不处理排队任务，并中断正在进行的任务         |\n| TIDYING    | 所有任务都已终止，workerCount为零是，线程会转换到TIDYING状态，并将运行terminate()钩子方法 |\n| TERMINATED | terminate()方法运行完成                                      |\n\n### 使用线程池的注意点\n◇避免任务堆积\n◇避免线程数过度增加\n◇排查线程泄漏，即任务结束后线程却回收不了\n\n### 线程工厂\n◇线程工厂为线程设置了如下内容：\n\n- 默认名字（pool-线程池自增编号-thread-线程的自增编号）\n- 非守护线程\n- 默认优先级\n- 默认线程组\n\n◇可以自定义线程工厂，设置线程名，设置为守护线程，设置优先级，处理未捕获的异常等。自定义工厂实现ThreadFactory接口，重写newThread()方法来进行相关设置。案例如下：\n\n```java\npublic class MyThreadFactory implements ThreadFactory {\n\n    private final ThreadGroup group;//线程组\n    //线程序号,原子操作自增\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String namePrefix;//线程名前缀\n    public MyThreadFactory(String namePrefix) {\n        SecurityManager s = System.getSecurityManager();\n        group = (s != null) ? s.getThreadGroup() :\n                Thread.currentThread().getThreadGroup();\n        this.namePrefix = namePrefix + \"-thread-\";\n    }\n    @Override\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                namePrefix + threadNumber.getAndIncrement(),\n                0);\n        //守护线程\n        if (t.isDaemon())\n            t.setDaemon(true);//设置为守护线程\n        //线程优先级\n        if (t.getPriority() != Thread.NORM_PRIORITY)\n            t.setPriority(Thread.NORM_PRIORITY);\n        /**\n         * 处理未捕捉的异常\n         */\n        t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n            @Override\n            public void uncaughtException(Thread t, Throwable e) {\n                //自定义处理逻辑\n                System.out.println(\"处理未捕捉的异常\");\n            }\n        });\n        return t;\n    }\n\n\n    public static void main(String[] args) {\n        ExecutorService pool = Executors.newFixedThreadPool(5, new MyThreadFactory(\"自定义线程\"));\n        for (int i = 0; i < 10; i++) {\n            pool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName()+\"正在执行\");\n                    //未捕获的异常，走自定义的UncaughtExceptionHandler逻辑\n                    int i = 1 / 0;\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}\n```\n\n◇这样当使用默认的线程工厂时，执行结果如下\n\n![image-20220526180458857](线程池/image-20220526180458857.png)\n\n◇使用自定义的线程工厂，执行结果如下\n\n![image-20220526180616517](线程池/image-20220526180616517.png)\n","tags":["线程"],"categories":["分布式与微服务"]},{"title":"SpringBoot入门","url":"/p/e10.html","content":"## 前期准备\n### 课程简介\n1.Spting Boot概述\n2.Spring Boot版本介绍\n3.新建Spring Boot项目演示(官网和IDEA两种)\n\n### 软件版本\nJava 1.8.0_171（大版本一致） \nMySQL 8.0.12（大版本一致） \nMaven 3.3.9（大版本一致） \nSpring Boot 2.2.1（版本需要严格一致）  \n\n### Spring Boot诞生历史\n◇Spring的缺点：配置过于繁琐\n◇Spring Boot开发团队: Pivotal\n### Spring Boot简介\n◇简化初始搭建以及开发过程\n◇不再需要定义样板化的配置\n◇快速应用开发领域\n### Spring、Spring MVC、Spring Boot\n◇Spring最初利用IOC和AOP解耦\n◇按照这种模式搞了MVC框架\n◇写很多样板代码很麻烦，就有了Spring Boot\n◇Spring Cloud是在Spring Boot基础上诞生的；\n### Spring Boot核心特点\n◇开箱即用：对于spring需要Tomcat等一系列配置，而springboot不需要；\n◇约定优于配置，在开发中遵守某种约定；\n\n### Spring Boot版本介绍\n![image.png](SpringBoot入门/1635758293954-ea2b47bc-0be8-46a2-bc28-cedb50597c0a.png)\n◇CURRENT，代表最新的GA版本\n◇GA，General Availability（正式发布版本),面向大众的，功能完美并且稳定；\n◇SNAPSHOT，版本会被修改\n◇如何选择版本？选择GA版本，不一定要最新的；\n\n## Spring Boot 项目开发\n### 官网构建\n◇[Spring官网 ](https://start.spring.io)来进行开发；选择maven->选择springboot版本->填写工程名->选择jar包->增加springweb依赖->Explore(预览)->Generate(生成)；\n◇打开IDEA，点击import Project(引入项目),将刚才下载好的项目解压并进入文件夹点击open->选择Maven->勾选Import Maven projects automatically->next->finish;可以看到会生成一个启动类xxxApplication,这个启动类最好不要随意更改位置；\n\n### IDEA集成\n◇IDEA集成的Spring Initializr\n◇新建项目->选择Spring Initializr->选择java版本1.8->Default->next->填写项目Group等信息;\n![image.png](SpringBoot入门/1635765769890-3ead8c1a-ed8d-4a93-b864-d6356c202e32.png)\n◇选择springboot版本以及web依赖\n![image.png](SpringBoot入门/1635765865834-485ce888-f4e7-47c3-8adf-ed1b9ff6f74a.png)\n\n### 项目结构解析\n◇Spring Boot的基础结构共三个文件：入口(启动类)、配置文件(放在resources文件夹下)、测试入口(在test文件夹下)\n◇生成的Application和ApplicationTests类都可以直接运行来启动当前创建的项目;\n◇对于pom.xml文件修改springboot的版本为:2.2.1.RELEASE\n\n### 案例演示\n◇新建一个ParaController类\n```java\npackage com.lcg.springboottest;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n *  演示各种传参形式\n */\n@RestController //有Restful能力的Controller\npublic class ParaController {\n    @GetMapping(\"/test01\")\n    public String firstRequest() {\n        return \"第一个Spring Boot接口\";\n    }\n    //@RequestParam注解会在请求参数中找到num这个参数并进行绑定\n    //访问  /test02?num=6\n    @GetMapping(\"/test02\")\n    public String requestParam(@RequestParam Integer num) {\n        return \"test02: num=\"+num;\n    }\n    /*从路径中获取参数num\n    * 访问test03/6*/\n    @GetMapping(\"/test03/{num}\")\n    public String pathParam(@PathVariable(\"num\") Integer num) {\n        return \"test03:num=\"+num;\n    }\n\n    @GetMapping({\"/multi01\",\"/multi02\"})//多url的情况\n    public String multiUrl(@RequestParam Integer num) {\n        return \"multi:num=\"+num;\n    }\n\n    @GetMapping({\"/test04\"}) //required= false表示不是必须传参，并设置默认参数为0；\n    public String test04(@RequestParam(required= false,defaultValue = \"0\") Integer num) {\n        return \"test04: num=\"+num;\n    }\n}\n\n```\n### Web项目的三层结构\n◇Controller 做一些简单的逻辑判断\n◇Service 对业务逻辑进行抽象，封装保持Controller的简洁;\n◇Dao 一般用于和数据库的交互，增删改查之类；\n\n### 配置文件的两种写法\n◇application.properties\n\n```properties\nenvironments.dev.url=[http://gamest.link]()\nenvironments.dev.name=Developer\nserver.port=8081   //配置端口\nserver.servlet.context-path=/first  //配置项目统一路径前缀\n```\n◇yml写法：分层级，冒号后需要空格；好处是前面的前缀相同的话可以直接并列；\n```yaml\nenvironments:\n   dev:\n     url:http://gamest.link\n     name:Developer\nserver:\n\tport:8081\n\tservlet:\n\t\tcontext-path:/first\n\t\t\n```\n◇两种写法的[转换网站](https://www.toyaml.com/index.html)\n### 进行自定义配置\n◇利用value注解配置属性\n```java\n//配置文件中\nschool.grade=3\nschool.classnum=6\n    -----------------------------------------------------------------------\n//控制器中\n    /*\n* 演示读取配置的控制器*/\n@RestController\npublic class PropertiesController {\n    @Value(\"${school.grade}\") //进行与配置文件的绑定,按住ctrl然后鼠标放在上面会有配置提示\n    Integer grade;\n    @Value(\"${school.classnum}\")\n    Integer classnum;\n    @GetMapping(\"/grade\")\n    public String gradeClass() {\n        return \"年级：\"+grade+\"班级：\"+classnum;\n    }\n}\n```\n◇配置类\n```java\npackage com.lcg.springboottest;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\n/**\n * School配置类\n */\n@Component\n@ConfigurationProperties(prefix = \"school\") //设置属性的前缀\npublic class SchoolConfig {\n    Integer grade;\n    Integer classnum;\n        public Integer getGrade() {\n        return grade;\n    }\n    //需要有get和set方法spring才能从配置文件中注入数据进来\n    public void setGrade(Integer grade) {\n        this.grade = grade;\n    }\n\n    public Integer getClassnum() {\n        return classnum;\n    }\n\n    public void setClassnum(Integer classnum) {\n        this.classnum = classnum;\n    }\n}\n\n```\n◇读取配置类的方法\n```java\npackage com.lcg.springboottest;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * 读取配置类\n */\n@RestController\npublic class ConfigController {\n    @Autowired //自动引入\n    SchoolConfig schoolConfig;\n\n    @GetMapping(\"/grade\")\n    public String gradeClass() {\n        return \"年级：\"+schoolConfig.grade+\"班级：\"+schoolConfig.classnum;\n    }\n}\n```\n## Service和DAO的编写\n### 数据库的创建\n◇新建数据库springstu存储学生信息；\n◇建立学生表，包含了id，姓名\n### 项目依赖与配置\n◇引入mybatis依赖\n```xml\n        <!--mybatis依赖-->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>2.1.1</version>\n        </dependency>\n\n        <!--mybatis的mysql连接池依赖-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n```\n◇数据库的配置\n```properties\nspring.datasource.username=root\nspring.datasource.password=password\nspring.datasource.url=jdbc:mysql://localhost:3306/springstu?useUnicode=true&amp;\\\n  characterEncoding=UTF-8\n```\n◇创建实体类\n◇创建controller\n```java\n@RestController\npublic class StudentController {\n    @Autowired\n    StudentService studentService;\n    @GetMapping(\"/student\")\n    public String student(@RequestParam(required = false,defaultValue = \"1\") Integer num) {\n       Student student = studentService.findStudent(num);\n       return \"学生学号:\"+student.getNum()+\"学生姓名：\"+student.getName();\n    }\n}\n```\n◇创建service\n```java\n@Service\npublic class StudentService {\n    @Autowired\n    StudentMapper studentMapper;\n\n    public Student findStudent(Integer id) {\n       return studentMapper.findById(id);\n    }\n}\n```\n◇创建Mapper接口\n```java\n@Mapper \n@Repository //用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理\npublic interface StudentMapper {\n    @Select(\"select * from students where id = #{id}\")\n    Student findById(Integer id);\n}\n```\n◇springboot整合mybatis的项目示例[参考链接](https://www.cnblogs.com/wangzaiplus/p/10899962.html)\n\n","tags":["SpringBoot"],"categories":["Spring","SpringBoot"]},{"title":"SpringMVC拦截器","url":"/p/b7ed.html","content":"## 拦截器-Interceptor\n◇拦截器(Interceptor)用于对URL请求进行前置/后置过滤 \n◇Interceptor与Filter用途相似,但实现方式不同 \n◇Interceptor底层就是基于Spring AOP面向切面编程实现  \n## HandlerInterceptor接口 \n◇preHandle - 前置执行处理 ；即一个请求产生以后，还没有进controller之前先要执行preHandle，对这个请求进行预制处理\n◇postHandle - 目标资源已被Spring MVC框架处理 ；即内部方法return之后，但是并没有产生响应文本之前执行\n◇afterCompletion - 响应文本已经产生；即响应文本产生之后执行，例如如果我们返回的是对象时，当对象进行JSON序列化以后就代表响应文本已经产生；\n## 拦截器开发流程 \n◇完整项目见interceptor\n### Maven依赖servlet-api \n◇在pom.xml中增加依赖\n```xml\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n            <!--作为我们Tomcat的最终运行环境，它是自带servlet-api这个jar包的\n            如果在我们进行打包发布的时候，将当前的依赖也放在war包中，会与Tomcat的\n            jar包造成冲突；因此需要scope设置范围provided,表示只有在开发、编译时\n            才会引用;当进行打包、最终使用的时候这个jar会被排除在外;-->\n            <scope>provided</scope>\n        </dependency>\n```\n### 实现HandlerInterceptor接口 \n◇新增interceptor包，其下开发的都是拦截器类；创建一个java类MyInterceptor\n```java\n/*该类需要实现HandlerInterceptor接口的三个方法\n* 选择接口->Code->Implement Methods->全选方法->OK*/\npublic class MyInterceptor implements HandlerInterceptor {\n    /*如果返回为true，就将请求送达给后面的拦截器或者控制器；返回false，则当前的请求会被阻止直接\n    * 产生响应返回客户端;*/\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(request.getRequestURL()+\"准备执行\");\n        return true;\n    }\n\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        System.out.println(request.getRequestURL()+\"目标处理成功\");\n    }\n\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println(request.getRequestURL()+\"响应内容已产生\");\n    }\n}\n```\n### applicationContext配置过滤地址 \n◇进行配置\n```xml\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/**\"/><!--配置要对哪些路径进行拦截，/**表示所有路径-->\n            <!--指明哪个类对拦截的URL进行处理-->\n            <bean class=\"com.lcg.restful.interceptor.MyInterceptor\"/>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n◇运行结果 浏览器输入http://localhost:8080/restful/persons\n```java\nhttp://localhost:8080/restful/persons准备执行\nRestfulController.findPersons() - return list\nhttp://localhost:8080/restful/persons目标处理成功\nhttp://localhost:8080/restful/persons响应内容已产生\n```\n## 拦截器使用细则\n◇当我们输入[http://localhost:8080/client.html]()地址后，查看后台会发现除了client的信息还有其他地址的信息；\n这是因为作为原始的client.html在这里每一次发送localhost这个url的时候其本质都是通过Tomcat调用springmvc的解析功能来获取对应的资源，因为这些资源都符合\"/\"的规则而被拦截；作为拦截器，不受\\<!--default-servlet-handler将静态资源排除过滤-->\\<mvc:default-servlet-handler/>这个配置的控制；如果希望这些静态资源不受拦截器所拦截，需要额外的设置标签；\\<mvc:exclude-mapping path=\"/.ico\"/\\>  \\<!--这里表示如果遇到了ico为后缀的文件则排除拦截-->；\n\n```java\n            <!--排除一系列静态资源-->\n            <mvc:exclude-mapping path=\"/**.ico\"/>\n            <mvc:exclude-mapping path=\"/**.jpg\"/>\n            <mvc:exclude-mapping path=\"/**.js\"/>\n            <mvc:exclude-mapping path=\"/**.css\"/>\n```\n◇由于静态资源有许多，如果都用exclude-mapping的配置方式会显得过于麻烦；其实在大多数时候我们的静态资源并不是直接存放在我们webapp的根路径上，而是在webapp目录下创建额外的目录如resources(资源)，并且在该资源目录下创建js、css、image等静态资源按目录进行保存；那么这样的话我们可以直接配置\\<mvc:exclude-mapping path=\"/resoutces/\"\\*\\*/\\>就能够将所有静态资源进行排除；\n◇如果一个请求被多个拦截器拦截的话，会按照什么顺序呢？我们再增加一个拦截器，interceptor-1，并且进行配置，配置方法和第一个拦截器一样,顺序在其后；\n当我们运行后，结果如下\n\n```java\nhttp://localhost:8080/restful/persons准备执行\nhttp://localhost:8080/restful/persons准备执行-1\nRestfulController.findPersons() - return list\nhttp://localhost:8080/restful/persons目标处理成功-1\nhttp://localhost:8080/restful/persons目标处理成功\nhttp://localhost:8080/restful/persons响应内容已产生-1\nhttp://localhost:8080/restful/persons响应内容已产生\n```\n◇可以发现，准备执行时顺序按照我们的配置顺序执行，而后面目标处理和响应时却反了过来；通过图示我们来进行说明；\n◇多个Interceptor执行顺序，通过下图可以看出，当浏览器向服务器发送一个请求，那么该请求在SpringMVC中首先被拦截器1所拦截，进行一些前置处理,即preHandle()方法，然后请求传到拦截器2，同样进行一些前置处理后请求到达Controller控制器进行相应业务的处理。处理完毕后产生的响应先到达拦截器2，进行后置处理即postHandle()方法，然后到达拦截器1，同样进行相应后置处理后最终将响应返回给浏览器客户端。\n![image.png](SpringMVC拦截器/1634461611607-3921b40f-9fe2-48b9-b353-ad2d2833d2d8.png)\n\n##  开发\"用户流量\"拦截器\n◇所谓用户流量就是在用户访问我们应用时自动的收集一些底层信息:如访问的时间、网址，用户使用的浏览器、系统、ip等；\n◇我们在前面的项目interceptor中进行开发；在拦截器包中新建一个拦截器类：访问历史拦截器AccessHistoryInterceptor；在所有请求在被处理之前要被该拦截器所记录，所以该拦截器为前置处理，因此实现preHandle方法，又因为不涉及到任何请求阻断，所以直接return true；通常拦截器所记录的数据我们用日志文件进行保存；\n◇第一步先在配置文件pom.xml中引入日志的依赖。记得在引入新的依赖后，在Tomcat中也要将依赖导入到发布的WEB-INF目录下\n\n```java\n        <!--引入日志依赖-->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n```\n◇配置日志文件，新增logback.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration><!--根节点-->\n    <!--定义一个向控制台书写日志的追加器appender-->\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder><!--输出日志的格式-->\n            <!--定义格式:线程名 产生日志时间 日志级别 产生日志的类{包名长度限制}-->\n            <pattern>[%thread] %d %level %logger{10} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    \n    <!--定义日志追加器accessHistoryLog。类属于RollingFileAppender,表示生成按天滚动的日志,该输出器向文件中进行写入，以天为单位；\n    -->\n    <appender name=\"accessHistoryLog\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        \n        <!--rollingPolicy表示滚动策略,TimeBasedRollingPolicy表示按照时间进行滚动-->\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <!--日志文件的保存路径在G盘中的logs目录下 %d表示产生日期-->\n            <fileNamePattern>G:/logs/history.%d.log</fileNamePattern>\n        </rollingPolicy>\n        <encoder>\n            <pattern>[%thread] %d %level %logger{10} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    \n    <root level=\"debug\"><!--定义当前输出级别最低为debug-->\n        <appender-ref ref=\"console\"/><!--引用定义的追加器,向控制台中输出日志-->\n    </root>\n    <!--配置拦截器类的日志,指定使用定义的accessHistoryLog追加器,\n    additivity=\"false\"表示不叠加，即只向文件中输入日志\n    而不打印在控制台中-->\n    <logger name=\"com.lcg.restful.interceptor.AccessHistoryInterceptor\" \n            level=\"INFO\" additivity=\"false\">\n        <appender-ref ref=\"accessHistoryLog\"/><!--引用-->\n    </logger>\n</configuration>\n```\n◇拦截器开发\n```java\npackage com.lcg.restful.interceptor;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class AccessHistoryInterceptor implements HandlerInterceptor {\n    /*利用LoggerFactory的get方法得到logger日志对象*/\n    private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class);\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        StringBuilder log = new StringBuilder();\n        log.append(request.getRemoteAddr());//用户地址\n        log.append(\"|\");//分隔符\n        log.append(request.getRequestURL());//用户访问的URL地址\n        log.append(\"|\");\n        log.append(request.getHeaders(\"user-agent\"));//用户浏览器环境\n        logger.info(log.toString());//输出日志\n        return true;\n    }\n\n}\n```\n◇拦截器配置\n```java\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/**\"/>\n            <mvc:exclude-mapping path=\"/resources/**\"/>\n            <bean class=\"com.lcg.restful.interceptor.AccessHistoryInterceptor\"/>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n◇执行结果，访问页面，点击发送get请求按钮，产生的控制台日志如下\n\n```\n[http-nio-8080-exec-8] 2022-05-26 11:08:46,139 DEBUG o.s.w.s.DispatcherServlet - GET \"/restful/get\", parameters={}\n[http-nio-8080-exec-8] 2022-05-26 11:08:46,140 DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public java.lang.String com.lcg.restful.controller.RestfulController.doGetRequest()\nhttp://localhost:8080/restful/get准备执行\n[http-nio-8080-exec-8] 2022-05-26 11:08:46,140 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using 'application/json;charset=utf-8', given [application/json, text/javascript, */*;q=0.01] and supported [text/html;charset=utf-8, application/json;charset=utf-8, text/plain, */*, application/json, application/*+json]\n[http-nio-8080-exec-8] 2022-05-26 11:08:46,140 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [\"{\"message\":\"返回查询结果\"}\"]\nhttp://localhost:8080/restful/get目标处理成功\nhttp://localhost:8080/restful/get响应内容已产生\n[http-nio-8080-exec-8] 2022-05-26 11:08:46,141 DEBUG o.s.w.s.DispatcherServlet - Completed 200 OK\n```\n\n◇先清空logs中生成的日志文件，在点击发送get请求，查看文件中的日志如下，发现有线程的名字，产生时间，日志级别，产生日志的类名。接下来就是我们拦截用户的信息，有用户ip地址，这里是本机访问的ip地址。然后是请求的url，用户浏览器环境等。\n\n```\n[http-nio-8080-exec-10] 2022-05-26 11:10:01,571 INFO c.l.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost:8080/restful/get|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36 Edg/101.0.1210.53\n```\n\n## Spring MVC处理流程\n\n![image.png](SpringMVC拦截器/1634547937578-4486aad0-b09c-4b1a-b8b1-9d5e1d691805.png)\n◇所有请求首先由DispactherServlet进行拦截，然后把请求交由springmvc处理；\n◇DispactherServlet拦截后的第一步就是查找Handler，Handler也叫处理器，查找Handler的任务由处理器映射器来完成，即通过当前的URL得到执行链；作为HandlerMapper只会获取执行链，而不会对其进行处理；\n执行链的处理由中央处理器向处理器适配器来发起执行请求，然后由HandlerAdapter根据Handler的类型(可能是一个拦截器或者控制器)去执行对应的方法；执行方法后会返回一个对象(例如MAV)，被HandlerAdapter接收，然后返回给中央处理器；中央处理器会去选择与之对应的视图解析器来进行视图对象的创建，视图会随着处理完返回给中央处理器，当中央处理器拿到对象以后就会将模板和从处理器适配器得到的数据进行渲染，得到最终的html返回给浏览器；\n\n","tags":["Spring"],"categories":["Spring","SpringMVC基础"]},{"title":"SpringMVC入门与数据绑定","url":"/p/b016.html","content":"## 周课介绍\n### Spring MVC\n![image.png](SpringMVC入门与数据绑定/1633767307961-da03edbb-a53f-461d-8013-31977b688b90.png)\n### Restful开发风格\n![image.png](SpringMVC入门与数据绑定/1633767365393-c0e20976-0aeb-4cfa-888f-e819e3ad3fe3.png)\n## Spring MVC\n### 课程介绍\n◇Spring MVC入门                ◇Spring MVC数据绑定\n◇Restful开发风格                 ◇Spring MVC拦截器\n### MVC到底是什么\n◇MVC是一种著名的架构模式；View就是我们通常说的界面部分，用于和用户进行交互，比如通过界面显示查询结果，提供表单等；而模型通常指的是数据，如果放在java代码里就是业务逻辑的部分；在MVC的设计理念中，如果前面视图中某个表格的数据来自于后端的Model中，并非视图通过java主动的调用model中的某一个方法来获取数据，而是要通过控制器；控制器相当于中介，作为控制器，是整个MVC架构中最核心的部分，其用途就是接收视图中所传入的数据，然后再根据数据调用后端的业务逻辑得到结果，再将后端得到的结果返回到视图中；\n![image.png](SpringMVC入门与数据绑定/1633767696416-64f8f281-fca5-46ac-8502-59d96086b2cc.png)\n◇Spring MVC是Spring体系的轻量级Web MVC框架\n◇Spring MVC的核心Controller控制器，用于处理请求，产生响应；在MVC中，界面是不允许直接访问后端的Model业务逻辑的，而是通过控制器作为一个中间者传递调用，这样的好处是让我们的界面和后端的java业务逻辑解耦，提高了程序的可维护性；\n◇Spring MVC基于Spring IOC容器运行，所有对象被IOC管理，提高了程序的健壮性与稳定性；\n\n### Spring 5.x 版本变化\n◇Spring 5.x最低要求JDK8与J2EE 7(Servlet 3.1/Tomcat 8.5+)\n◇Spring 5.x支持JDK8/9,可以使用新特性\n◇Spring 5.x最重要的新特性支持响应式编程(即基于事件来的，当触发某一事件后就会在后端自动的执行某一段代码)作为响应式编程，是一种新的开发理念和风格；\n### Spring MVC官方文档学习\n◇进入spring.io官网，project->spring-framework->Features->spring mvc  [链接](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)\n## IDEA环境下创建Maven WebApp\n◇打开idea->new->Maven->SDk:java1.8以上版本->next->GroupId:com.lcg->ArtifactId:first-springmvc->next->设置工程保存路径->finish->Enable Auto-Import（自动导入依赖）\n◇创建好以后，还需要进行如下设置使创建的标准maven工程具备web能力: 选中工程名称->File->Project Structure->Facets->+->web(进行web能力的嵌入)->选中工程名->OK->配置web描述符文件(web.xml)所存储的路径：first-springmvc\\src\\main\\webapp\\WEB-INF\\web.xml->勾选版本为3.1->设置存储页面的目录（就在上一项操作的下方）:src\\main\\webapp->下方设置默认上下文为:/->OK->是否创建目录：yes->Create Artifact（根据前面的设置自动配置运行的方式）->OK;\n◇在webapp目录下创建一个测试页面index.html;然后进行Tomcat的配置；右上角Add Configuration->Templates(配置一个模板): TomcatServer->Local->Application server(应用服务器)->configure->Tomcat Home:Tomcat的安装路径(apache-tomcat-8.5.40)->OK-OK; 模板配置好后，再次点击Add Configuration->+->Tomcat Server ->Local->Deployment->+->Artifact->Application context:/->Server->On 'Update' action(说明在页面发生改变以后如何来生效，默认选项为Restart server即重启服务才会生效):改为Update classes and resources(说明在Tomcat启动过程中，如果idea中的页面代码发生变化不需要重启Tomcat，直接可以更新；这种方式称为热部署)->HTTP port（可以根据自己的需要修改端口，默认为8080）:80->OK; 这样就完成了web的配置；\n\n## Spring MVC环境配置\n### 配置步骤\n1.Maven依赖spring-webmvc\n\n```xml\n<!-- 阿里云的仓库 -->\n<repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n    <dependencies>\n    <!-- 依赖环境 -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n    </dependencies>\n```\n2.web.xml配置DispatcherServlet\n◇DispatchServlet是springmvc最重要的一个类，其作用就是对所有请求进行拦截；类似公司的前台一样，接待不同的客户，然后根据客户的需求向公司对应的部门请求处理；\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n         version=\"3.1\">\n   <!-- DispatchServlet-->\n    <servlet>\n        <servlet-name>springmvc</servlet-name> <!--这里名字是可以自定义的，但一般约定如此-->\n       <!--DispatchServlet是Spring MVC最核心的对象\n           DispatchServlet用于拦截Http请求，\n           并根据请求的URL调用与之对应的Controller方法，\n           来完成Http请求的处理-->\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n      <!--  加载applicationContext.xml\n            告诉DispatcherServlet在IOC容器启动时\n            加载哪一个目录下的哪个xml文件; classpath表示类路径\n            main\\resources下的xml文件会自动加载到类路径中-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:applicationContext.xml</param-value>\n        </init-param>\n        <!--在Web应用启动时自动创建Spring IOC容器，\n           并初始化DispatcherServlet，以提高响应速度;如果没有这个配置，\n           则会在第一次访问url的时候进行容器的创建和初始化工作-->\n        <load-on-startup>0</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <!--\"/\" 代表拦截所有请求-->\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n3.配置applicationContext的mvc标记\n```xml\n<!-- 声明部分 -->\n<!-- schema部分 -->\n\n  <!--\n    context:component-scan 标签作用\n    在Spring IOC初始化过程中,自动创建并管理com.lcg.springmvc及子包中\n    拥有以下注解的对象.\n    @Repository\n    @Service\n    @Controller\n    @Component\n    -->\n    <context:component-scan base-package=\"com.lcg.springmvc\"></context:component-scan>\n    <!--启用Spring MVC的注解开发模式 -->\n    <mvc:annotation-driven/>\n    <!--将图片、js、css等静态资源排除在外(即不被拦截)，可提高执行效率-->\n    <mvc:default-servlet-handler/>\n```\n4.开发Controller控制器\n```java\n/*在配置文件中,context：component-scan所描述的包中包含了这个测试类\n* 因此增加Controller注解，所以在IOC容器初始化时会自动的将TestController\n* 初始化并由IOC容器所管理，且spring也自动该类是一个springmvc的控制器*/\n@Controller\npublic class TestController {\n    @GetMapping(\"/t\")//用于将当前方法绑定某个get方式请求的url，比如localhost/t\n    @ResponseBody //直接向响应提供字符串数据，不跳转页面\n    public String test(){\n        return \"SUCCESS\";\n    }\n}\n```\n5.在运行测试之前，还需要进行Tomcat的配置；因为一些底层依赖还没有加到当前的发布目录(WEB-INF)中，所以需要进行加入；具体做法为：右上角Edit Configuration->Deployment->编辑web exploded->将右侧的依赖全选，put到左边的目录中去->OK\n◇热部署状态下，如果修改了源码，只需要右键Reload Changed Classes（对类进行重新编译）则不要重启Tomcat；\n### SpringMVC处理示意图\n![image.png](SpringMVC入门与数据绑定/1633851296390-cd695bbf-ddc8-4002-a5f5-c4f3151ed46f.png)\n◇打开浏览器输入网址以后，需要向服务器发送请求，假设请求发送的地址是：[http://localhost/t]()  那么这个请求就会发送到本机的Tomcat上，而Tomcat自然启动了springmvc的应用，此时请求会被DispatcherServlet拦截，DispatcherServlet会在Controller中寻找哪个方法映射了t，则DispatcherServlet会知道使用test()方法来处理这个请求，然后请求进入test方法，并返回一个响应体;\n\n## Spring MVC数据绑定\n◇什么是数据绑定：即springmvc中的controller控制器的某一个方法是如何与url进行绑定的，在前面的演示中我们使用了GetMapping这个注解进行绑定，那还有其他的方法吗？答案是肯定的；\n### URL Mapping(URL映射)\n◇URL Mapping指将URL于Controller方法绑定\n◇通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务\n\n### URL Mapping注解\n◇@RequestMapping - 通用绑定 \n◇@GetMapping - 绑定Get请求 \n◇@PostMapping - 绑定Post请求  \n### 注解使用案例\n◇见firstspringmvc项目\n```java\n@Controller\npublic class URLMappingController {\n    @GetMapping(\"/g\")\n    @ResponseBody\n    public String getMapping(){\n        return \"This is get method\";\n    }\n    @PostMapping(\"/p\")\n    @ResponseBody\n    public String postMapping(){\n        return \"This is post method\";\n    }\n}\n```\n◇以上代码运行后，当浏览器中输入/p时会出现405报错，因为直接在浏览器输入地址是get请求，而程序后端里\"/p\"映射的是post请求，出现了请求不一致的情况；那么如何处理post请求呢？可以通过html表单来完成post请求；于是修改index.htm，增加表单，并将提交的地址设置为\"/p\"，指明提交的方法为post；\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n   <form action=\"/p\" method=\"post\">\n       <input type=\"submit\" value=\"提交\">\n   </form>\n</body>\n</html>\n```\n◇通常RequestMapping 注解是放在类上面的，大多数情况下用于URL的全局设置；作为URL可能有多级结构，比如，要求URLMappingController所有的映射地址都是以/um作为前缀来进行访问，那么GetMapping和PostMapping都要在原来的映射地址前增加/um(如/um/p)，如果方法过多的话，都要这样进行一一设置，过于繁琐；而RequestMapping 放在类上就可以进行全局设置了，直接进行注解@RequestMapping (\"/um\"),这样，请求的地址必须在前面加入/um才能够访问成功；\n◇如果将RequestMapping 注解放在方法上，则不再区分get/post请求，但并不推荐这样使用；当然使用RequestMapping 注解也可以指定其请求方法，如@RequestMapping (value=\"/g\", method=RequestMethod.GET)\n\n## 接收请求参数\n◇在大多数情况下一个请求发过来的时候需要包含一些数据，这些数据大多以请求参数来体现的，比如说我们用户登录的时候需要输入用户名和密码，那么这些数据就会以post请求参数的形式发送到controller的方法中；\n### 接收请求参数的常用方法\n◇使用Controller方法参数接收\n```java\n<form action=\"/m1\" method=\"post\">\n<input name=\"username\"/>\n<input name=\"password\"/>\n</form>\n-------------------------------------------------------------- \n@PostMapping(\"/m1\")\n@ResponseBody\n   /*SpringMVC允许进行类型转换，如果在前面进行表单校验的时候\n    Password只允许输入数字，那向服务器提交以后，因为password\n    只是数字，所以可以强制转换为Long类型；因此在接收时，直接可以\n    将形参设置为Long类型，而不需手动转换*/\npublic String post(String username , Long password){\n return username + \":\" + password;\n}\n```\n◇使用Java Bean接收数据\n```java\n<form action=\"/m1\" method=\"post\">\n<input name=\"username\"/>\n<input name=\"password\"/>\n</form>\n----------------------------------------------------------------- \n@PostMapping(\"/m1\")\n@ResponseBody\npublic String post(User user){\n return user.getUsername() + \":\" + user.getPassword();\n}\n\n```\n### Controller方法\n◇html表单\n```java\n   <form action=\"/p\" method=\"post\">\n       <input name=\"username\"><br/>\n       <input name=\"password\"><br/>\n       <input type=\"submit\" value=\"提交\">\n   </form>\n```\n◇controller\n```java\n @PostMapping(\"/p\")\n    @ResponseBody\n    public String postMapping(String username,String password){\n        System.out.println(username+\":\"+password);\n        return \"submit success\";\n    }\n```\n◇ 对于get请求如何接收请求参数呢？如localhost/g?managet_name=lily就是一个带有请求参数的get请求，在java中只有驼峰命名法，所以不能使用managet_name作为参数名来接收请求参数；则需要一个特殊的注解@RequestParam(\"manager_name\"),其放在接收请求的参数前，括号里面填写映射的地址，即请求参数名；作为请求中的manager_name这个参数在运行时会被动态的注入到managerName这个参数中\n```java\n    @GetMapping(\"/g\")\n    @ResponseBody\n    public String getMapping(@RequestParam(\"manager_name\") String managerName){\n        System.out.println(\"mangerName:\"+managerName);\n        return \"This is get method\";\n    }\n```\n### Java Bean方法\n◇假设表单有一百个输入项，那么问题来了，难道我们需要将这一百个参数都在controller的方法中列举出来吗？并且还需要将接收的一百个参数通过set方法进行对象的转化，这样做显然麻烦；为了解决这个问题，springmvc运行我们将前台输入的数据保存为指定的java bean，一步到位，完成了由数据到对象的转换工作；\n◇创建entity实体包，并在实体包下创建实体类User\n```java\npackage com.lcg.springmvc.entity;\n\npublic class User {\n    private String username;\n    private Long password;\n    //getter&seter方法;\n}\n```\n◇controller\n```java\n/*在这里直接将实体类当做参数；springmvc会自动的创建对象\n    * 并且根据前面的请求结合参数名进行一一的赋值,在实体类中属性的\n    * 名字必须和前台的传入参数名保持一致*/\n    @PostMapping(\"/p1\")//也要将表单请求提交的地址改为p1\n    @ResponseBody\n    public String postMapping1(User user){\n        System.out.println(user.getUsername()+\":\"+user.getPassword());\n        return \"This is post method\";\n    }\n```\n◇public String postMapping1(User user，String username)；这样会对user赋值，也会给username这个参数赋值；即不管参数中写了多少个username或者多少个实体对象，只要它们用于username这个属性或者参数，只要符合这个规则那么springmvc都会对其进行赋值；\n## 综合训练：调查问卷\n![image.png](SpringMVC入门与数据绑定/1634001914013-bf055739-65e3-41f3-9c97-d97ee4285e90.png)\n◇像这种一次性选择多个数据的情况，在springmvc中如何进行处理呢？\n\n### 知识点\n◇利用数组或List接收请求中的复合数据\n◇利用@RequestParam为参数设置默认值\n◇使用Map对象接收请求参数及注意事项\n### URI绝对路径与相对路径\n![image.png](SpringMVC入门与数据绑定/1634002605204-1c7322bb-cbe5-479f-afb7-1526d252a47e.png)\n◇所谓URI是统一资源标识符的意思，它包含我们平时使用的URL；\n◇假设{% wavy 左图 %}是开发的某一个应用，我们访问的uri上下文假设叫project，而project包含如图的结构；{% wavy 右图 %}表示在index.html中引用js文件使用的相对路径和绝对路径；右图错误的使用方法，以\"/\"开头，是一个绝对路径，但是并没有加上上下文路径，除非我们设置上下文为\"/\"根路径时才可以；\n◇相对地址的应用案例：如表单提交地址使用相对路径\\<form action=\"./apply\" method=\"post\"\\>。如果访问的表单的页面地址为[http://localhost:8080/]()[上下文路径]/form.html;那么当表单提交以后，其处理请求的地址为[http://localhost:8080/]()[上下文路径]/apply。因为使用了相对路径，则不管前面的上下文路径设置的是什么，只需要保证我们的提交地址apply和当前的html在{% emp 同一个层级 %}上那么请求就会送达而不会产生404错误；通过使用相对路径可以降低我们对于web工程设置的依赖。\n\n### 代码演示\n◇form.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>学员调查问卷</title>\n    <style>\n        .container {\n            position: absolute;\n            border: 1px solid #cccccc;\n            left: 50%;\n            top: 50%;\n            width: 400px;\n            height: 600px;\n            margin-left: -200px;\n            margin-top: -300px;\n            box-sizing: border-box;\n            padding: 10px;\n        }\n\n        h2 {\n            margin: 10px 0px;\n            text-align: center;\n        }\n\n        h3 {\n            margin: 10px 0px;\n        }\n    </style>\n</head>\n<body>\n<div class=\"container\">\n    <h2>学员调查问卷</h2>\n    <form action=\"./apply\" method=\"post\">\n        <h3>您的姓名</h3>\n        <input name=\"name\" class=\"text\" style=\"width: 150px\">\n        <h3>您正在学习的技术方向</h3>\n        <select name=\"course\" style=\"width: 150px\">\n            <option value=\"java\">Java</option>\n            <option value=\"h5\">HTML5</option>\n            <option value=\"python\">Python</option>\n            <option value=\"php\">PHP</option>\n        </select>\n        <div>\n            <h3>您的学习目的：</h3>\n            <input type=\"checkbox\" name=\"purpose\" value=\"1\">就业找工作\n            <input type=\"checkbox\" name=\"purpose\" value=\"2\">工作要求\n            <input type=\"checkbox\" name=\"purpose\" value=\"3\">兴趣爱好\n            <input type=\"checkbox\" name=\"purpose\" value=\"4\">其他\n        </div>\n\n        <h3>收货人</h3>\n        <input name=\"delivery.name\" class=\"text\" style=\"width:150px\">\n        <h3>联系电话</h3>\n        <input name=\"delivery.mobile\" class=\"text\" style=\"width:150px\">\n        <h3>收货地址</h3>\n        <input name=\"delivery.address\" class=\"text\" style=\"width:150px\">\n        <div style=\"text-align: center;padding-top:10px\">\n            <input type=\"submit\" value=\"提交\" style=\"width:100px\">\n        </div>\n    </form>\n\n</div>\n</body>\n</html>\n```\n\n◇对于我们的表单，包含了三种数据，前面两种都是单个数据，最后一种是复合数据(一次性会提交多个数据)，springmvc对复合数据的接收提供了两种方案，一种使用{% emp 数组 %}接收，另一种使用{% emp List %}进行接收；\n◇创建FormController类；使用数组进行接收复合数据\n\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    /*假设value设置一个表单中不存在的n，如果我设置了value这个属性的话，那么以value为准，\n不再以name进行接收，而是value接收后再输入到name中 defaultValue即默认值；如果表单不存在的话，\n    默认值就是设置的ANON；由于表单中并不存在n这个参数，所以当我们提交的时候，即使填了名字\n    也会使用默认的value注入到参数name中；当然，如果我们设置value=\"name\"的话，由于表单中有name\n    这个参数，所以填了名字可以注入到apply的name参数中，而不填的话，就会使用默认值ANON注入*/\n    public String apply(@RequestParam(value = \"n\",defaultValue = \"ANON\")String name, String course, Integer[] purpose){\n        System.out.println(name);\n        System.out.println(course);\n        for (Integer p : purpose) {\n            System.out.println(p);\n        }\n        return \"SUCCESS\";\n    }\n```\n◇前面提到我们的controller类中方法的参数名需要和请求的参数名一致，这样就会完成自动注入；但是，在我们的表单中，有很多都是进行匿名提交的，它并没有包含name参数的值，在这种情况下，name必然是一个空的对象，那么对于空的对象进行操作时，程序很可能报错；解决这一问题的方法是使用@RequestParam给参数设置默认值；\n◇如果使用List进行复合数据的接收，需要在参数前增加@RequestParam注解，这样springmvc才知道请求中的复合数据要被转换为List进行存储；\n\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    public String apply(String name, String course, @RequestParam List<Integer> purpose){\n         //与上类似\n    }\n```\n◇对于一组结构化的数据，我们通常使用对象来进行接收；那么在对象情况下，这个List依然能够进行接收；\n我们额外的创建实体包，并创建表单对象类Form;\n\n```java\npublic class Form {\n    private String name;\n    private String course;\n    private List<Integer> purpose;//复合数据\n    ...\n    }\n```\n在控制器中新建方法使用对象来接收\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    public String apply(Form form){\n        return \"SUCCESS\";\n    }\n```\n◇当然，也可以使用Map来进行参数的接收，Map可以一次性接收表单项的结果，也得在方法参数前加上注解@RequestParam\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    public String apply(@RequestParam Map map){\n        System.out.println(map);\n        return \"SUCCESS\";\n    }\n```\n但是，对于复合数据，Map是无法接收的，Map默认情况下{% emp 只会保留 %}复合数据中的第一个数据，其余都会丢失；\n​\n\n## 关联对象赋值\n◇关联对象赋值即在一个对象中引用了另一个对象，需要在这个被引用对象进行赋值的操作；\n◇复杂内容表单\n\n```java\n用户名:<input name=\"username\">\n密码: <input name=\"password\">\n-------------------------------------- \n姓名:<input name=\"name\">\n身份证号:<input name=\"idno\">\n过期时间:<input name=\"expire\">\n```\n◇对于这张表单来说，包含了两个内容，一个是注册信息，一个是身份信息；对于这个表单来说，可以创建一个对象，然后通过springmvc自动对其进行赋值，但是这样做并不完美；如果按照严格的面向对象的设计方式对表单进行接收的话，需要创建两个类一个User类和一个身份类，并且用户类中包含身份类；\n◇用户类\n\n```java\npublic class User{\n private String username;\n private String password;\n private IDcard idcard = new IDCard();//实例化关联对象，对象名为idcard\n //getter and setter ...\n}\n```\n◇身份类\n```java\npublic class IDcard{\n private String name;\n private String idno;\n private Date expire;\n //getter and setter ...\n}\n```\n◇那么如何对这样的关联对象进行赋值呢？我们需要修改表单的属性名；将关联对象的的对象名(idcard)作为原有属性的前缀，这样通过springmvc接收数据的时候会自动的将三个属性按照名称对应关系依次进行赋值；\n```java\n用户名:<input name=\"username\">\n密码: <input name=\"password\">\n------------------------------------------- \n姓名:<input name=\"idcard.name\">\n身份证:<input name=\"idcard.idno\">\n过期时间:<input name=\"idcard.expire\">\n```\n## 日期类型转换\n◇全世界各地对日期的表达方式是不一样的；欧美一般采用月日年的表达方式，而国内采用年月日的形式；我们如何接收程序中的日期数据并将其转换为日期对象呢？\n◇假设在注册用户的时候，需要提交注册时间(createTime)这个输入项，那么我们只需要在controller的方法中增加一个参数String createTime就可以了，但大多数的情况下，我们需要将字符串转换为日期对象，那么我们直接将参数改为Date createTime，程序运行时会产生日期格式不一致的问题，当我们输入2020-02-02时，会出现400的错误，一般400错误往往就是我们无法将数据转换为目标类型所致；因此我们需要手动转换才可以，但springmvc为我们早有准备，只需要在日期参数前加上@DateTimeFormat这个注解就行了，此注解用于按照指定的格式将前台接收的字符串转换为对应的date对象，在转换前需要指定其格式是什么，需要给此注解增加patten参数；如@DateTimeFormat(pattent=\"yyyy-MM-dd\");注意这里的格式需要与前台输入的对象一致；\n◇在实体对象中，也要给日期属性增加注解，才能够完成Date类型的转换；\n\n```java\nprivate Long password;\n@DateTimeFormat(pattent=\"yyyy-MM-dd\")\nprivate Date createTime;\n```\n◇如果对于大量的需要进行日期类型转换的参数，那么都要一 一 加上注解，则过于麻烦，为了解决这个问题，可以设置全局的默认时间转换机制；\n作为全局的日期转换机制，需要新建一个converter(转换器)包，其中保存的都是转换器，开发一个日期转换类MyDateConverter;\n对于日期转换器springmvc要求必须实现Converter接口，在接口中得实现两个泛型，String和Date因为我们是希望把前台的字符串转换为日期类型；\n\n```java\npublic class MyDateConverter implements Converter<String,Date>{//实现接口\n    public Date convert(String s){\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");//定义格式\n        try{\n             Date d = sdf.parse(s);//开始转换\n            return d;\n        }catch (ParseException e){\n           return null;\n        }\n    }\n}\n```\n◇作为当前的类，需要在applicationContext.xml中进行配置，让springmvc知道该类是一个转换类;配置方法如下：\n```xml\n//下面的配置只是让springmvc知道有这个转换类要想和springmvc进行联动，还需要修改下面\n的driven配置，额外增加conversion-service属性，并将下面定义好的beanid放到这个属性中；\n<mvc:annotation-driven conversion-service=\"conversionService\"/>\n\n//增加bean进行定义，id可自行定义，但通常如下定义，class为转换服务的工厂类，\n其作用就是通知springmvc有哪些自定义的转换类\n<bean id=\"conversionService\" \n    class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n        <property name=\"converters\">//转换类定义的地方\n            <set>//作为converters这个属性，它是一个set集合，使用set标签进行描述\n                <bean class=\"com.lcg.springmvc.converter.MyDateConverter\"/>\n            </set>\n        </property>\n </bean>\n```\n◇如果我们既配置了全局的转换类，又设置了注解，则springmvc会优先使用转换器类来进行转换而注解会被忽略掉，因此我们一般二者选其一使用；\n◇对于转换器类只有一种日期格式，那出现了特殊的日期格式要求怎么办呢？那么这时候我们就要对转换器输入的字符串的日期格式进行判断，来使用不同的日期格式进行解析\n\n## 解决中文乱码\n### Web应用的中文乱码由来\n◇Tomcat默认使用字符集ISO-8859-1,属于西欧字符集，不支持中文；\n◇解决乱码的核心是将ISO-8859-1转换为UTF-8\n◇Controller中请求与响应都需要设置UTF-8字符集\n\n### 中文乱码的配置\n◇Get请求乱码 - server.xml增加URIEncoding属性\n◇Post请求乱码 - web.xml配置CharacterEncodingFilter\n◇Response响应乱码 - Spring配置StringHttpMessageConverter(消息转换器)\n\n### 代码演示\n◇{% u 解决Get请求乱码 %}，需要在文件夹中找到Tomcat的server.xml文件，本机的路径为F:\\JAVA\\Tomcat\\apache-tomcat-8.5.34\\conf\\server.xml；进行修改，在Connector port=\"8080\"处的代码后增加URIEncoding=\"UTF-8\"\n```java\n    <Connector executor=\"tomcatThreadPool\"\n               port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" URIEncoding=\"UTF-8\"/>\n```\n◇在Tomcat8.0以后的版本，URIEncoding默认就是UTF-8，所以在8.0以后的版本不需要进行配置；\n◇{% u 解决Post请求乱码 %}，需要在工程的web.xml中配置一个filter，filter是javabean的标准组件，用于对请求进行过滤；在这里name设置为字符集过滤，过滤类为有springmvc提供的字符编码过滤器\n\n```xml\n    <!--配置过滤器-->\n    <filter>\n        <filter-name>characterFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param><!--配置参数-->\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value><!--特殊需求下会用GBK-->\n        </init-param>\n    </filter>\n    \n    <!--使过滤器生效,配置filter的映射地址-->\n    <filter-mapping>\n        <filter-name>characterFilter</filter-name>\n        <url-pattern>/*</url-pattern><!--代表对所有的url进行拦截-->\n    </filter-mapping>\n```\n◇{% u 解决响应中的中文乱码 %}，需要在applicationContext配置文件中进行设置，在原有的启用注解的标签中增加消息转换器类，首先将原有的标签内容放开，然后在mvc：annotation-driven标签体中增加message-converters(用来设置消息的转换器)，在其下配置的转换器可以对响应中的消息进行调整，这里的converters是个复数，在其下增加一个bean，class为StringHttpMessageConverter(对于http响应中的文本进行转换，如何转换还需要bean下的配置)\n```xml\n <!--启用Spring MVC的注解开发模式 -->\n    <mvc:annotation-driven conversion-service=\"conversionService\">\n        <mvc:message-converters><!--增加消息转换器类-->\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                <property name=\"supportedMediaTypes\">\n                    <list><!--supportedMediaTypes代表支持的媒体类型，是一个集合，所以用list描述-->\n                        <!--在servlet中解决响应乱码如下配置\n                        response.setContentType(\"text/html;charset=utf-8\")-->\n                        <value>text/html;charset=utf-8</value><!--用于说明响应输出对应的字符类型-->\n                    </list>\n                </property>\n            </bean>\n        </mvc:message-converters>\n    </mvc:annotation-driven>\n```\n## 响应输出结果\n◇响应中产生结果主要有两种方式，一种是采用@ResponseBody注解直接产生响应文本显示在客户端浏览器上；\n另一种是ModelAndView对象，利用模板引擎渲染输出，也就是利用我们之前写好的JSP或者freemaker这样的模板引擎再结合数据动态渲染产生页面；\n\n### @ResponseBody\n◇@ResponseBody直接产生响应体的数据，过程不涉及任何视图；\n◇@ResponseBody可产生标准字符串/JSON/XML等格式数据；\n◇@ResponseBody被StringHttpMessageConverter所影响\n\n### ModelAndView\n◇如果要在springmvc响应中进行页面展现的话，就需要使用这个ModelAndView对象；\n◇ModelAndView对象是指\"模型(数据)与视图(界面)\"对象\n◇通过ModelAndView可将包含数据对象与模板引擎进行绑定\n◇springmvc中默认的view是jsp，也可以配置其他的模板引擎\n◇页面展现的方法controller类中的showview方法；\n\n```java\n    @GetMapping(\"/view\")/*映射地址*/\n    public ModelAndView showView(){\n        /*jsp作为模板引擎*/\n        ModelAndView mav = new ModelAndView(\"/view.jsp\");\n        return mav;\n    }\n```\n◇view.jsp\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n     <h1>这是一个视图页面</h1>\n</body>\n</html>\n```\n◇这样，我们能够通过showview方法访问view.jsp的页面，但是，上面的代码我们通过url直接访问view.jsp也是可以的; 因此通过controller访问view.jsp的意义是为了完成数据的动态展现，所以假设我们需要将请求传来的用户编号，我们把数据查询出来得到一个user对象，然后在jsp中把user对象进行展现；\n```java\n    @GetMapping(\"/view\")/*映射地址*/\n    public ModelAndView showView(Integer userId){\n        /*jsp作为模板引擎*/\n        ModelAndView mav = new ModelAndView(\"/view.jsp\");\n        User user = new User();\n        if (userId == 1) {\n            user.setUsername(\"lily\");\n        } else if (userId == 2) {\n            user.setUsername(\"smith\");\n        }\n        /*addObject的含义是在当前的请求中增加一个对象，对象的别名可以设置为u,第二个参数是\n        * 我们要存放的数据，该数据可以是一个java对象*/\n        mav.addObject(\"u\",user);\n        return mav;\n    }\n```\n◇修改jsp部分,通过EL表达式来进行数据的动态传入\n```jsp\n<h1>这是一个视图页面</h1>\n     <hr>\n     <h2>Username:${u.username}</h2>\n```\n然后在浏览器中输入localhost/view?userId=1;会发现页面的展现的username为lily,将userId改为2则name变为Smith；数据是由controller中动态的查询产生，而界面由jsp动态渲染；通过这个例子可以看出springmvc模式设计的核心，mvc一直强调视图和模型解耦，有利于程序的维护；\n## ModelAndView\n◇mav.addObject()方法设置的属性默认存放在当前请求中；\n◇默认ModelAndView使用请求转发(forward)至页面，请求转发就是把当前送给showview方法的请求原封不动的传递给view.jsp，即jsp和controller中的请求是同一个，而mav.addObject方法只是向当前的请求中存放数据；\n◇重定向使用new ModelAndView(\"redirect:/index.jsp\")\n◇如果我们使用页面重定向，即将new ModelAndView(\"redirect:/view.jsp\"),那么我们的jsp页面将接收不到数据；因为重定向是controller通知客户端浏览器重新建立一个新的请求来访问view.jsp的地址；\n◇那么重定向使用的场景也有很多，例如那种需要调转的页面和当前请求中的数据没有关系的时候，比如在用户注册的时候，需要跳转到网站首页，那么网站首页就和用户注册的数据没有太大关系；\n◇ ModelAndView mav = new ModelAndView(\"/view.jsp\")；也可写为 ModelAndView mav = new ModelAndView()；mav.setViewName(\"/view.jsp\");如果/view.jsp去掉\"/\"的话，就代表相对地址，相对于我们当前的访问地址(在控制类上通过@RequestMapping(\"{% emp /um %}\")设置的全局地址)，也就是说，去掉以后我们在浏览器访问到的页面是在程序中的webapp/um/view.jsp；而不是webapp/view.jsp；um文件夹是自己创建的，和RequestMapping设置的一致；\n◇如何利用String与ModelMap实现和ModelAndView一样的作用；如果没有数据需要传递的话，可以没有ModelMap对象参数；\n\n```java\n    /*String与ModelMap\n    * ModelMap对应模型数据，通过ModelMap向里设值可以给我们的页面提供数据\n    * 方法直接返回string字符串\n    * Controller方法返回String的两种情况\n    * 1.方法被@ResponseBody注解描述，SpringMVC直接响应String字符串本身\n    * 2.方法不存在@ResponseBody，则SpringMVC处理String指代的视图(页面)\n    * */\n    //@ResponseBody //直接向响应提供字符串数据，不跳转页面\n    public String showView1(Integer userId, ModelMap modelMap) {\n        String view = \"/view.jsp\";/*设置显示的页面*/\n        User user = new User();\n        /*模拟数据获取*/\n        if (userId == 1) {\n            user.setUsername(\"lily\");\n        } else if (userId == 2) {\n            user.setUsername(\"smith\");\n        }\n        modelMap.addAttribute(\"u\",user);/*与addObject的作用完全相同*/\n        return view;\n    }\n```\n## SpringMVC整合Freemarker\n### 三个步骤\n◇一般分为以下三步：①pom.xml引入依赖、②启用Freemarker模板引擎、 ③配置Freemarker参数  \n◇pom.xml引入freemarker的依赖,还要引入spring上下文的依赖包spring-context-support(该模块提供了spring对freemaker的整合支持类)\n\n```xml\n<dependency>\n <groupId>org.freemarker</groupId>\n <artifactId>freemarker</artifactId>\n <version>2.3.28</version>\n</dependency>\n<dependency>\n <groupId>org.springframework</groupId>\n <artifactId>spring-context-support</artifactId>\n <version>5.1.9.RELEASE</version>\n</dependency>\n```\n◇第二步需要通知springmvc我们要使用用Freemarker模板引擎，在applicationContext.xml中增加如下配置，其作用是通知springmvc我们的默认引擎有jsp改为了FreeMarkerViewResolver；\n```xml\n<bean id=\"ViewResolver\" \nclass=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\">\n <!-- 设置响应输出，并解决中文乱码 -->\n <property name=\"contentType\" value=\"text/html;charset=utf-8\"></property>\n <!-- 指定Freemarker模板文件扩展名 -->\n <property name=\"suffix\" value=\".ftl\"/>\n </bean>\n```\n◇第三步，对Freemarker本身进行参数设置，定义一个bean，类指向Freemarker的配置类；\n注意第三步设置的UTF-8是在模板与数据绑定渲染过程中使用的字符集，而在上一步设置utf-8是指在渲染完成后，向客户端浏览器响应时，响应体中使用的字符集；\n\n```xml\n<bean id=\"freemarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\">\n<!--设置模板保存的目录；WEB-INF目录是无法被直接访问的，Tomcat无法直接解析freemarker\n    模板引擎，因此为了保证模板的安全，就需要把模板文件放在外侧无法访问的WEB-INF目录下\n    一般新增一个ftl文件用于存放freemarker文件-->\n<property name=\"templateLoaderPath\" value=\"/WEB-INF/ftl\"/>\n<!--其他模板引擎设置-->\n<property name=\"freemarkerSettings\">\n<props>\n<!--设置Freemarker脚本与数据渲染时使用的字符集-->\n<prop key=\"defaultEncoding\">UTF-8</prop>\n</props>\n</property>\n</bean>\n```\n### 代码示例\n◇首先按上面步骤进行配置\n◇在controller包中新增FreemarkerController类\n```java\npackage com.lcg.springmvc.controller;\n\nimport com.lcg.springmvc.entity.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\n@RequestMapping(\"/fm\")\npublic class FreemarkerController {\n    public ModelAndView showTest(){\n        /*只写/test,而不写扩展名是因为前面我们已经设置了扩展名为.ftl\n        * '/'代表了根路径，而此时根路径并不是指webapp目录，而是我们定义的\n        * WEB-INF/ftl,在这里我们写的文件名为test，则应该在ftl目录下创建\n        * test.ftl文件*/\n        ModelAndView mav = new ModelAndView(\"/test\");\n        User user = new User();\n        user.setUsername(\"张珊\");\n        mav.addObject(\"u\", user);\n        return mav;\n    }\n}\n```\n◇创建test.ftl模板文件，语法在前面的章节有讲\n```html\n<h1>${u.username}</h1>\n```\n◇因为引入了依赖，但是IDEA并不会将依赖发布，因此需要对发布的信息进行配置，即编辑Web exploded，加入新增的两个依赖，使其运行时能发布到Tomcat中；只要pom.xml配置文件中增加了新的依赖，都要编辑Web exploded\n◇在浏览器中输入:localhost/fm/test，即可出现张珊字样；\n​\n\n","tags":["Spring"],"categories":["Spring","SpringMVC基础"]},{"title":"Spring JDBC与事务管理","url":"/p/d79b.html","content":"## Spring JDBC \n### 简介\n◇Spring JDBC是Spring生态用于处理关系型数据库的模块 \n◇Spring JDBC对JDBC API进行封装，极大简化开发工作量 \n◇JdbcTemplate是Spring JDBC核心类，提供数据CRUD方法 \n◇有Mybatis为什么还需要Spring JDBC？\n\t\t答：这两者面向的对象不一样，Mybatis封装程度较高，适合中小企业做软件的{% emp 敏捷开发 %}，让程序员可以快速的完成数据库的交互工作；但是封装程度高意味着执行效率较低；而Spring JDBC只是对原始的JDBC的API进行简单封装，执行效率较高；\n\n### Spring JDBC的使用步骤 \n①Maven工程引入依赖spring-jdbc -> ②applicationContext.xml配置DataSource数据源 -> ③在Dao注入JdbcTemplate对象,实现数据CRUD  \n\n## jdbcTemplate实现增删改查\n**代码实现(jdbc/s01)**\n◇由于代码过于繁多，因此不再展示。仅将代码中主要方法思路记下。具体代码见文件夹的项目；\n\n### 执行查询\n◇核心配置文件pom.xml ，加载底层依赖：spring-context, spring-jdbc, mysql-connector-java;\n◇新增实体类Employee，实体成员和数据库保持一致。\n◇新增Dao。①jdbcTemplate.queryForObject()方法的含义是进行指定的查询(查询单条语句)，将唯一返回的数据转换为对应的对象，第一个参数是sql语句，第二个参数是与sql语句对应的参数(如sql需要查询的属性)一般用new object数组实现，如new Object[]{\"研发部\"}；最后一个参数是new BeanPropertyRowMapper\\<Employee\\>(Employee.class)，其中BeanPropertyRowMapper的含义是指将bean属性和每一行的列进行一一匹配，即从数据库记录到实体对象的转化；②jdbcTemplate.query()方法用于查询复合数据，默认返回list集合，参数和queryForObject()方法一致；\n◇applicationContext.xml配置文件。①定义数据源，说明要连接哪一个数据库，用户名，密码等；②配置JdbcTemplate以提供数据CRUD(增删改查)的API；③为Dao注入JdbcTemplate对象，只有注入以后，我们的具体的业务方法才可以去掉用jdbcTemplate相应的API来完成数据库的增删改查操作；\n◇如果查询的字段没有与之对应的实体属性，该怎么办？\n\t\t答：使用jdbcTemplate.queryForList()方法，将查询结果作为列表返回，同时将每一条数据按map对象进行包裹；该方法前两个参数和上述一致，但没有第三个参数；List中每一条数据都是一个Map对象，Map的Key是原始的字段名，Value是字段名所对应的数值；通过此方法，不管结果有没有对应的实体属性，都将其放入Map中，按照键值对的规则进行保存，每一个Map就对应着一条记录；如下面的例子：\n\n```java\n //将查询结果作为Map进行封装\nList<Map<String, Object>> maps = jdbcTemplate.queryForList(sql, new Object[]{dname});\n```\n### 执行插入\n◇插入的方法为jdbcTemplate.update()方法；第一个参数为sql语句，第二个为传入的参数(new Object[])；new Object[]的数据来源从实体类的get中将与之对应的属性进行提取；\n```java\npublic void insert(Employee employee){\n        String sql = \"insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)\";\n        //利用update方法实现数据写入操作\n        jdbcTemplate.update(sql,new Object[]{\n           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()\n        });\n    }\n```\n### 执行更新\n◇更新的方法和插入方法一样；只不过SQL语句不同；update方法有一个返回值，代表执行本次sql语句所真实影响的数据条目；\n```java\n    public int update(Employee employee){\n        String sql = \"UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?\";\n        int count = jdbcTemplate.update(sql, new Object[]{employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()});\n        return count;\n    }\n```\n◇测试用例\n```java\n    @Test\n    public void  testUpdate(){\n        Employee employee = employeeDao.findById(8888);\n        employee.setSalary(employee.getSalary() + 1000);\n        int count = employeeDao.update(employee);\n        System.out.println(\"本次更新\" + count + \"条数据\");\n    }\n```\n### 执行删除\n◇执行删除的方法也是update；\n```java\n   public int delete(Integer eno){\n        String sql = \"delete from employee where eno = ?\";\n        return jdbcTemplate.update(sql, new Object[]{eno});\n    }\n```\n## Spring事务管理\n### 什么是事务 \n◇事务是以一种可靠的、一致的方式，访问和操作数据库的 程序单元 \n◇ 通俗地说：要么把事情做完，要么什么都不做，不要做一半 \n◇ 事务依赖于数据库实现,MySQL通过事务区作为数据缓冲地带  \n\n### 编程式事务\n◇编程式事务是指通过代码手动提交回滚事务的事务控制方法\n◇SpringJDBC通过TransactionManager事务管理器实现事务控制\n◇事务管理器提供commit/rollback方法进行事务提交与回滚\n### 代码演示编程式事务(s01)\n◇需求分析：最近公司入职了十名新员工，需要将这十名新员工批量的导入到员工表当中，对于导入的要求，要么一次性全部导入，要么什么都不做；\n◇通过需求分析可知，需要通过事务来进行控制。业务逻辑的代码一般写在service包里，所以新增service。\n◇EmployeeService，底层依赖于EmployeeDao。增加batchImport()方法，用于批量导入；利用for循环模拟十名员工；数据插入调用方法employeeDao.insert()。Service写好后还要在applicationContext中进行配置，beanId为employeeService，class指向service类；属性注入employeeDao。但是，这样写的代码并不正确；因为通过打印的日志可以看出这十个员工数据的插入并{% wavy 不是 %}在同一事务中进行的，如果一旦有一个事务出错，那么插入的数据就不完整，不符合要求。打印日志可以在pom.xml中加载日志组件logback-classic，Spring框架默认集成此组件。\n◇那么要怎么实现事务批量导入呢？\n\t\t作为编程式事务，需要配置bean对象，beanId为transactionManager，意为事务管理器，其用途就是控制事务的提交和回滚；class为org.springframework.jdbc.datasource.DataSourceTransactionManager;  基于数据源的事务管理器，需要绑定数据源；ref=\"dataSource\"；\n\n```xml\n<!-- 事务管理器 -->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <!-- 关联到前面定义的数据源dataSource,即使用的数据库 -->\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n</bean>\n```\n\n在需要进行事务控制的类(EmployeeService)里边进行事务管理器的注入；\n\n```java\npublic class EmployeeService{\n    private EmployeeDao employeeDao;\n    //注入事务管理器\n\tprivate DataSourceTransactionManager transactionManager;\n    //批量操作方法\n    public void batchImport(){\n        ....\n    }\n}\n```\n\n再生成EmployeeService类的getter和setter方法；然后在applicationContext配置文件的employeeService配置中注入事务管理器的bean以及Dao的bean。\n\n```xml\n    <bean id=\"employeeService\" class=\"com.lcg.spring.jdbc.service.EmployeeService\">\n        <property name=\"employeeDao\" ref=\"employeeDao\"/>\n        <property name=\"transactionManager\" ref=\"transactionManager\"/>\n    </bean>\n```\n作为batchImport需要进行事务管理，所以在此方法执行前增加事务默认的标准配置；开始一个事务，说明此段代码后的所有增删改查都进入了事务管理；\n```java\n    public void batchImport(){\n        //定义了事务默认的标准配置\n        TransactionDefinition definition = new DefaultTransactionDefinition();\n        //开始(创建)一个事务,返回的对象为事务状态,事务状态说明当前事务的执行阶段\n        TransactionStatus status = transactionManager.getTransaction(definition);\n        try {\n            for (int i = 1; i <= 10; i++) {\n                /*if (i == 3) {\n                    throw new RuntimeException(\"意料之外的异常\");\n                }*/\n                Employee employee = new Employee();\n                employee.setEno(8000 + i);\n                employee.setEname(\"员工\" + i);\n                employee.setSalary(4000f);\n                employee.setDname(\"市场部\");\n                employee.setHiredate(new Date());\n                employeeDao.insert(employee);\n            }\n            //提交事务,参数为status\n            transactionManager.commit(status);\n        }catch (RuntimeException e){\n            //出现异常，回滚事务\n            transactionManager.rollback(status);\n            throw e;//可以捕获异常，也可以抛出异常，视具体业务而定\n        }\n\n    }\n```\n通过事务，已经执行成功的sql语句并非直接修改在表中，而是在{% emp 事务区 %}内，当所有的事务都执行成功后才写入到数据表中，如果遇到异常则会进行回滚；\n◇编程式事务的优点：代码写在程序中，对程序员友好；缺点：存在{% wavy 人为 %}的风险，产生数据不完整的情况；\n\n### 声明式事务\n◇声明式事务指使用配置或注解，在{% emp 不修改源码 %}的情况下通过配置形式自动实现事务控制，声明式事务的{% emp 本质%}就是AOP环绕通知；\n◇ 当目标方法执行成功时,自动提交事务 \n◇ 当目标方法抛出运行时异常时,自动事务回滚  \n\n### 配置过程\n◇配置TransactionManager事务管理器\n◇配置事务通知与事务属性\n◇为事务通知绑定PointCut切点(PointCut说明在哪个类的哪个方法上应用通知)\n\n### 代码演示声明式事务(s02)\n◇声明式事务直接在配置文件中配置即可\n◇applicationContext的配置\n第一步，和编程式一样需要配置事务管理器，绑定数据源；\n第二步，事务通知配置；需要在配置文件顶部新增命名空间:\n\n```\nxmlns:tx=\"http://www.springframework.org/schema/tx\"\n```\n\n 以及命名空间所对应的url的描述文件(xsd)的实际地址；以及AOP的命名空间\n\n```\nxmlns:aop=\"http://www.springframework.org/schema/aop\"\n```\n\n和实际的xsd文件地址\n\n```xml\nhttp://www.springframework.org/schema/tx\nhttps://www.springframework.org/schema/tx/spring-tx.xsd\n\nhttp://www.springframework.org/schema/aop\nhttps://www.springframework.org/schema/aop/spring-aop.xsd\n```\n事务通知配置，决定哪些方法使用事务，哪些方法不使用事务，配置方法如下：\npropagation表示设置事务的传播行为，propagation=\"REQUIRED\"表示需要使用事务；read-only=\"true\"表示当前方法是只读的，propagation=\"NOT_SUPPORTED\"表示方法不支持事务；\n\n```xml\n    \n  <!-- 1.事务管理器,用于创建事务/提交/回滚 -->\n    <bean id=\"transactionManager\" \t\t  class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n\n    <!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 -->\n\t<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <tx:attributes>\n            <!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 -->\n            <tx:method name=\"batchImport\" propagation=\"REQUIRED\"/>\n            <tx:method name=\"batch*\" propagation=\"REQUIRED\"/>\n            <!-- 设置所有findXXX以及getXXX方法(读操作)不需要使用事务 -->\n            <tx:method name=\"find*\" propagation=\"NOT_SUPPORTED\" read-only=\"true\"/>\n            <tx:method name=\"get*\" propagation=\"NOT_SUPPORTED\" read-only=\"true\"/>\n            //其他选项，一律按如下实现\n            <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n        </tx:attributes>\n    </tx:advice>\n```\n第三步，定义切点作用范围，并关联到通知上\n```xml\n<!--3. 定义声明式事务的作用范围-->\n    <aop:config>\n        <aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*Service.*(..))\"/>\n        //与通知关联\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/>\n    </aop:config>\n```\n### 事务传播行为\n◇事务传播行为是指多个{% wavy 拥有事务的方法 %}在嵌套调用时的事务控制方式\n◇XML配置形式：<tx:method name=\"...\" propagation=\"REQUIRED\"/>\n◇注解形式：@Transactional(propagation=Propagation.REQUIRED)\n◇如果还有大量的类似batchImport的批量任务需要开发，则可以创建一个专用于批量导入的服务类BatchService，类的方法可以有很多批量导入的方法；批量导入的服务执行入口放在EmployeeService服务类里边；需要为批量服务类进行bean配置以及注入；\n\n```xml\n    <bean id=\"batchService\" class=\"com.lcg.spring.jdbc.service.BatchService\">\n        <property name=\"employeeDao\" ref=\"employeeDao\"/>\n    </bean>\n```\n### 事务传播行为七种类型\n\n| 事务传播类型               | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| PROPAGATION_REQUIRED(默认) | 如果当前没有事务，就新建一个事务，如果已经存在一个事务，加入到这个事务中。这是最常见的选择 |\n| PROPAGATION_SUPPORTS       | 支持当前事务，如果当前没有事务，就以非事务方式执行           |\n| PROPAGATION_MANDATORY      | 使用当前的事务，如果当前没有事务，就抛出异常                 |\n| PROPAGATION_REQUIRES_NEW   | 新建事务，如果当前存在事务，把当前事务挂起                   |\n| PROPAGATION_NOT_SUPPORTED  | 不使用事务，如果当前存在事务，就把当前事务挂起               |\n| PROPAGATION_NEVER          | 以非事务方式执行，如果当前存在事务，则抛出异常               |\n| PROPAGATION_NESTED         | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作 |\n\n◇代码分析\n--EmployeeService类中的批量导入方法\n\n```java\n public void startImportJob(){\n        batchService.importJob1();\n        if(1==1){\n            throw new RuntimeException(\"意料之外的异常\");\n        }\n        batchService.importJob2();\n        System.out.println(\"批量导入成功\");\n    }\n```\n--方法的配置情况\n```xml\n <tx:method name=\"importJob1\" propagation=\"REQUIRED\"/>\n <tx:method name=\"importJob2\" propagation=\"REQUIRED\"/>\n <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n```\n◇通过配置信息可以知道对于方法startImportJob()以及其里面嵌套的方法importJob1和\\~2都是具有事务的；\n对于外侧的方法startImportJob在运行时会创建一个事务，而嵌套调用的importJob1和\\~2在执行时发现外侧已经有了现成的事务，所以在运行时内侧的事务就会加入到外侧的事务中，也就意味着在执行start方法的时候，整体是在一个事务中完成的数据的增删改操作；如图所示，红色框为主方法的事务，蓝框为子方法的事务，\n![image.png](SpringJDBC与事务管理/1633677913394-16f82101-b0f1-4094-9393-a165fbd94d0c.png)\n因此当子方法1执行成功了，但子方法2执行前遇到了异常，总的事务也会进行回滚，导致方法1无法写入数据进数据库；\n◇如果我们期望无论是方法1还是方法2，只要方法执行成功，就能够成功写入数据库，彼此互不干扰，该如何实现呢？我们可以更改配置项，将原来的配置改为\n\n```xml\n<tx:method name=\"importJob1\" propagation=\"REQUIRES_NEW\"/>\n<tx:method name=\"importJob2\" propagation=\"REQUIRES_NEW\"/>\n<tx:method name=\"*\" propagation=\"REQUIRED\"/>\n```\nREQUIRES_NEW表示针对于两个子方法，在运行过程中都会产生新的事务；该方法执行过程如下图\n![image.png](SpringJDBC与事务管理/1633678405307-1da3421c-293a-4f2d-8970-a68631305b50.png)\n\n### 注解配置声明式事务\n代码演示(s03)\n◇核心配置文件pom.xml与上面相同\n◇applicationContext.xml没有配置部分，然后利用component-scan来设置扫描的基本包是哪个；然后定义数据源，初始化JdbcTemplate,配置事务管理器，这三项是必须要配置的bean；最后启用注解形式声明式事务；\n\n```xml\n    <!--数据源-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n        <property name=\"url\"\n                  value=\"jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n    </bean>\n    <!--JdbcTemplate-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n    <!--事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n    <!-- 启用注解形式声明式事务 -->\n    <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n```\n◇在Dao类中，利用@Resource完成对象的注入；\n◇在service中，使用@Service完成IOC容器的实例化，在service依赖的每一个dao上进行@Resource完成dao的注入;\n◇利用注解进行事务的配置，则只需将声明式注解@Transactional放在需要的类上,说明事务配置应用于当前类所有方法，默认事务传播为REQUIRED；也可以自行设置@Transactional(propagation = Propagation.REQUIRED);\n当然对于不同的方法，也可以进行不同的设置，只需在方法上进行注解配置即可；例如在查询的方法上选择不使用事务，并且只读；\n\n```java\n@Service\n//声明式事务核心注解\n//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED\n@Transactional\npublic class EmployeeService {\n    @Resource\n    private EmployeeDao employeeDao;\n    @Resource\n    private BatchService batchService;\n\n    @Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true)\n    public Employee findById(Integer eno){\n        return employeeDao.findById(eno);\n    }\n```\n\n","tags":["Spring"],"categories":["Spring","Spring基础"]},{"title":"Spring AOP面向切面编程","url":"/p/7cef.html","content":"## 课程介绍 \n◇ 介绍Spring AOP与相关概念名词 \n◇ Spring AOP开发与配置流程 \n◇ Spring 五种通知类型与应用场景  \n## Spring中的可插拔组件技术  \n◇假设软件模块A是系统的用户管理模块，B是系统的员工管理模块，这两个模块都有自己的各种各样的员工业务逻辑类，执行过程从上到下。要求：两个模块从上到下处理业务的过程中，都要进行权限过滤，只有拥有权限的用户才能进入对应的模块；实现方法：利用面向切面编程技术；所谓面向切面编程就是指在软件运行过程中，在执行前或者执行后都可以额外增加相应的扩展功能(称之为切面，Aspect)，如下图的权限切面和日志切面；\n![image.png](SpringAOP面向切面编程/1633054465138-34c81581-9016-4f4d-9afb-d3be05dc9924.png)\n\n## Spring AOP \n◇Spring AOP - Aspect Oriented Programming 面向切面编程 \n◇AOP的做法是将通用、与业务无关的功能抽象封装为切面类 \n◇切面可配置在目标方法的执行前、后运行，真正做到即插即用  \n◇在不修改源码的情况下对程序行为进行扩展\n\n## 初识AOP编程\n◇业务背景：在工程中有员工和用户两个service及dao；现在需要在service和dao的方法执行之前在控制台打印它们各自执行的时间(不是指时间大小)，通过这些信息我们可以知道在一天什么时间段是应用程序负载最高的时刻；如果采用直接在执行方法前打印输出系统时间，由于程序有很多类，类中也有很多方法，所以这个方法过于繁琐，因此采用Spring AOP技术，在这些方法执行前进行拦截，先打印时间，然后再去执行方法内部的方法；具体项目见AOP/s01\n◇pom.xml核心配置\n\n```java\n<dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n        <!--aspectjweaver是Spring AOP的底层依赖-->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.5</version>\n        </dependency>\n    </dependencies>\n```\n◇创建aspect包，在其下创建MethodAspect类用于扩展功能编写\n```java\npackage com.lcg.spring.aop.aspect;\n\nimport org.aspectj.lang.JoinPoint;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n//切面类\npublic class MethodAspect {\n    //切面方法,用于扩展额外功能\n    //JoinPoint 连接点,通过连接点可以获取目标类/方法的信息\n    public void printExecutionTime(JoinPoint joinPoint){\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n        String now = sdf.format(new Date());\n        String className = joinPoint.getTarget().getClass().getName();//获取目标类的名称\n        String methodName = joinPoint.getSignature().getName();//获取目标方法名称\n        System.out.println(\"---->\" + now + \":\" + className + \".\" + methodName);\n        Object[] args = joinPoint.getArgs();//获取到传入目标方法的参数\n        System.out.println(\"---->参数个数:\" + args.length);\n        for(Object arg:args){\n            System.out.println(\"---->参数:\" + arg);\n        }\n    }\n\n    public void doAfterReturning(JoinPoint joinPoint,Object ret){\n        System.out.println(\"<----返回后通知:\" + ret);\n    }\n    public void doAfterThrowing(JoinPoint joinPoint,Throwable th){\n        System.out.println(\"<----异常通知:\" + th.getMessage());\n    }\n    public void doAfter(JoinPoint joinPoint){\n        System.out.println(\"<----触发后置通知\");\n    }\n}\n\n```\n◇在applicationContext中配置（开头部分schema不同于以前的配置，需要添加一部分）\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <bean id=\"userDao\" class=\"com.lcg.spring.aop.dao.UserDao\"/>\n    <bean id=\"employeeDao\" class=\"com.lcg.spring.aop.dao.EmployeeDao\"/>\n    <bean id=\"userService\" class=\"com.lcg.spring.aop.service.UserService\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n    <bean id=\"employeeService\" class=\"com.lcg.spring.aop.service.EmployeeService\">\n        <property name=\"employeeDao\" ref=\"employeeDao\"/>\n    </bean>\n    <!-- AOP配置 -->\n    <bean id=\"methodAspect\" class=\"com.lcg.spring.aop.aspect.MethodAspect\"></bean>\n    <aop:config>//此标签由AOP命名空间提供\n        <!-- PointCut 切点,使用execution表达式描述切面的作用范围 -->\n        <!-- execution(public * com.lcg..*.*(..)) 说明切面作用在com.lcg包下的所有类的所有方法上 -->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(public * com.lcg..*.*(..))\"></aop:pointcut>-->\n        <!--只对所有Service类生效-->\n        <aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*Service.*(..))\"></aop:pointcut>\n        <!--只对所有返回值为String类型方法生效-->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(String com.lcg..*Service.*(..))\"></aop:pointcut>-->\n        <!--对方法名进行约束 -->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*Service.create*(..))\"></aop:pointcut>-->\n        <!-- 对参数进行约束 -->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*Service.*(String,*))\"></aop:pointcut>-->\n        \n        <!-- 定义切面类 让IOC容器认为这个bean是一个切面类-->\n        <aop:aspect ref=\"methodAspect\">\n            <!-- before前置通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() -->\n            <aop:before method=\"printExecutionTime\" pointcut-ref=\"pointcut\"/>//pointcut-ref指向定义的切点;        \n        </aop:aspect>\n    </aop:config>\n</beans>\n```\n## AOP关键概念 \n### Spring AOP与AspectJ的关系  \n◇Eclipse AspectJ,一种基于Java平台的面向切面编程的语言 \n◇Spring AOP使用了AspectJ切入点匹配功能 \n◇Spring AOP利用代理技术实现对象运行时功能扩展  \n### 几个关键概念\n\n| 名词                | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| Aspect              | 切面，具体的可插拔组件功能类，通常一个切面只实现一个通用功能 |\n| Target Class/Method | 目标类、目标方法，指真正要执行与业务相关的方法               |\n| PointCut            | 切入点,使用execution表达式说明切面要作用在系统的哪些类上     |\n| JoinPoint           | 连接点，切面运行过程中是包含了目标类/方法元数据的对象        |\n| Advice              | 通知,说明具体的切面的执行时机,Spring包含了五种不同类型通知   |\n\n### AOP配置过程\n①依赖Aspect -> ②实现切面类和切面方法 -> ③配置Aspect Bean -> ④定义PointCut -> ⑤配置Advice\n### JoinPoint核心方法\n\n| 方法                     | 说明                  |\n| ------------------------ | --------------------- |\n| Object getTarget()       | 获取IoC容器内目标对象 |\n| Signature getSignature() | 获取目标方法          |\n| Object[] getArgs()       | 获取目标方法参数      |\n\n## PointCut切点表达式\n◇完整方法的描述：         public void com.lcg.service.UserService.createUser(形参1，形参2，...)\n◇切点表达式：execution(public   *    com.lcg      ..             *       .        *         (            ..              ) )\n◇ * 表示通配符    ..表示包通配符      (..) 表示参数通配符\n◇上面的切点表达式的含义为：去匹配com.lcg包下所有类的所有公用方法；\n◇(*,*)  -- 代表两个参数；  *可以替换为string\n\n## 五种通知类型\n### 归纳\n\n| 通知                   | 说明                                                |\n| ---------------------- | --------------------------------------------------- |\n| Before Advice          | 执行前通知，目标方法运行前执行                      |\n| After Returning Advice | 返回后通知，目标方法返回数据后执行                  |\n| After Throwing Advice  | 异常通知,目标方法抛出异常后执行                     |\n| After Advice           | 最后(最终)通知，目标方法运行后执行                  |\n| Around Advice          | 环绕通知,自定义通知执行时机，可决定目标方法是否运行 |\n\n### 特殊的\"通知\" - 引介增强\n◇引介增强(IntroductionInterceptor)是对类的增强，而非方法\n◇引介增强允许在运行时为类目标增加新属性或方法\n◇引介增强允许在运行时改变类的行为，让类随运行环境动态变更\n### 代码示例\n◇目标方法\n```java\npublic void doAfterReturning(JoinPoint joinPoint,Object ret){\n        System.out.println(\"<----返回后通知:\" + ret);\n    }\n    public void doAfterThrowing(JoinPoint joinPoint,Throwable th){\n        System.out.println(\"<----异常通知:\" + th.getMessage());\n    }\n    public void doAfter(JoinPoint joinPoint){\n        System.out.println(\"<----触发后置通知\");\n    }\n```\n◇配置\n```java\n<aop:aspect ref=\"methodAspect\">\n            <!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() -->\n            <aop:before method=\"printExecutionTime\" pointcut-ref=\"pointcut\"/>\n            <!--返回后通知,returning表示哪个参数接收目标方法的返回值-->\n            <aop:after-returning method=\"doAfterReturning\" returning=\"ret\" pointcut-ref=\"pointcut\"/>\n            <!--异常通知-->\n            <aop:after-throwing method=\"doAfterThrowing\" throwing=\"th\" pointcut-ref=\"pointcut\"/>\n            <!--最后通知，目标方法运行后执行-->\n            <aop:after method=\"doAfter\" pointcut-ref=\"pointcut\"></aop:after>\n        </aop:aspect>\n```\n## 详解环绕通知(Around Advice)\n### 利用AOP进行方法性能筛选\n◇案例背景，在实际工作中可能遇到这种情况：由于不断的数据累积，用户量的增大，可能会导致我们生产环境中系统越来越慢，那我们如何定位到是哪一个方法运行慢呢？解决方法：利用AOP技术在方法执行前以及执行后记录时间，两相减即为执行时长，把超过指定时长的方法输出到日志中去；但由于需要记录一前一后两个时间，所以采用环绕通知来实现；\n### 代码示例(AOP/S02)\n◇切面类\n```java\npackage com.lcg.spring.aop.aspect;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class MethodChecker {\n    ////ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行\n    public Object check(ProceedingJoinPoint pjp) throws Throwable {\n        try {\n            long startTime = new Date().getTime();\n            Object ret = pjp.proceed();//执行目标方法,返回的对象ret即为目标方法的返回值\n            long endTime = new Date().getTime();\n            long duration = endTime - startTime; //执行时长\n            if(duration >= 1000){\n                String className = pjp.getTarget().getClass().getName();\n                String methodName = pjp.getSignature().getName();\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n                String now = sdf.format(new Date());\n                System.out.println(\"=======\" + now + \":\" + className + \".\" + methodName + \"(\" + duration + \"ms)======\");\n            }\n            return ret;//返回\n        } catch (Throwable throwable) {\n            System.out.println(\"Exception message:\" + throwable.getMessage());\n            throw throwable;//直接抛出异常\n        }\n    }\n}\n\n```\n◇配置\n```java\n<aop:config>\n    <aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*.*(..))\"></aop:pointcut>\n    <aop:aspect ref=\"methodChecker\">\n        <!--环绕通知-->\n        <aop:around method=\"check\" pointcut-ref=\"pointcut\"/>\n    </aop:aspect>\n</aop:config>\n```\n◇应用程序入口\n```java\npublic class SpringApplication {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        UserService userService = context.getBean(\"userService\", UserService.class);\n        userService.createUser();\n    }\n}\n```\n## 利用注解配置Spring AOP\n**代码示例(AOP/S03)**\n◇pom.xml加载jar包，完成底层依赖；\n◇applicationContext配置文件增加注解相关的配置\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <!--组件扫描,初始化IoC容器-->\n    <context:component-scan base-package=\"com.lcg\"/>\n    <!--启用Spring AOP注解模式-->\n    <aop:aspectj-autoproxy/>\n</beans>\n```\n◇将dao类以及service类进行上节课ioc注解相关的配置，如@Repository和@Service等\n◇切面类注解\n```java\npackage com.lcg.spring.aop.aspect;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n@Component //标记当前类为组件\n@Aspect //说明当前类是切面类\npublic class MethodChecker {\n    //环绕通知,参数为PointCut切点表达式\n    @Around(\"execution(* com.lcg..*Service.*(..))\")\n    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行\n    public Object check(ProceedingJoinPoint pjp) throws Throwable {\n        try {\n            long startTime = new Date().getTime();\n            Object ret = pjp.proceed();//执行目标方法\n            long endTime = new Date().getTime();\n            long duration = endTime - startTime; //执行时长\n            if(duration >= 1000){\n                String className = pjp.getTarget().getClass().getName();\n                String methodName = pjp.getSignature().getName();\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n                String now = sdf.format(new Date());\n                System.out.println(\"=======\" + now + \":\" + className + \".\" + methodName + \"(\" + duration + \"ms)======\");\n            }\n            return ret;\n        } catch (Throwable throwable) {\n            System.out.println(\"Exception message:\" + throwable.getMessage());\n            throw throwable;\n        }\n    }\n}\n\n```\n## 代理模式\n### Spring AOP实现原理\n◇Spring基于代理模式实现功能动态扩展，包含两种形式\n◇目标类拥有接口，通过JDK动态代理实现功能扩展\n◇目标类没有接口，通过CGLib组件实现功能扩展\n### 静态代理\n◇代理模式通过代理对象对原对象的实现功能扩展\n◇所谓代理模式，其核心理念是实现一个代理类，在代理类中持有最原始的委托类；代理类和委托类实现共同的接口；而客户通过代理类来完成所需的功能\n![image.png](SpringAOP面向切面编程/1633227288993-6f02aa5f-5d59-4c02-ad4b-52ad7c10b046.png)\n**代码演示(AOP/S04)**\n◇创建接口UserService\n\n```java\npublic interface UserService {\n    public void createUser();\n}\n```\n◇创建接口的实现类UserServiceImpl（委托类）\n```java\npublic class UserServiceImpl implements UserService{\n    public void createUser() {\n        System.out.println(\"执行创建用户业务逻辑\");\n    }\n}\n```\n◇案例背景：现在需要将方法执行的时间打印出来，在前面已经讲过Spring AOP技术来实现。但是在代理模式中如何实现呢？如果要实现这个功能的扩展就必须基于UserService接口创建对应的代理类，同时在代理类中去持有与之对应的具体实现；\n◇创建UserServiceProxy（代理类）\n\n```java\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n//静态代理是指必须手动创建代理类的代理模式使用方式\npublic class UserServiceProxy implements UserService{\n    //持有委托类的对象\n    private UserService userService ;\n    //创建代理对象的时候，通过外侧传入某一个UserService的实现类为内部的委托类赋值，相当于持有委托类\n    public UserServiceProxy(UserService userService){\n        this.userService = userService;\n    }\n\n    public void createUser() {\n        System.out.println(\"=====\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\").format(new Date()) +\"=========\");\n        userService.createUser();\n    }\n}\n```\n◇主程序（客户）\n```java\npublic class Application {\n    public static void main(String[] args) {\n        UserService userService = new UserServiceProxy(new UserServiceImpl());\n        userService.createUser();\n    }\n}\n```\n◇代理模式是可以嵌套使用的，因此在代理类的构造方法中参数为接口类的某一个实现(在上面的UserServiceProxy代理类的构造方法中，参数是UserService)而非具体的接口实现类UserServiceImpl；嵌套使用案例：再创建一个代理类，实现一些后置功能，然后在这个代理类中传入参数为另一个代理类的实现；new UserServiceProxy1(new UserServiceProxy(new UserServiceImpl())); 因为参数不管是什么对象，只要实现了接口类即可；缺点：随着功能的不断扩大，每一个具体的实现类都至少拥有一个代理类，这种方式称为静态代理。\n### JDK动态代理\n◇静态代理与动态代理最显著的区别是静态代理必须手动创建代理类，而动态代理根据接口的结构运行时在内存中进行生成。\n**代码实现（AOP/S05）**\n◇EmployeeService接口\n\n```java\npublic interface EmployeeService {\n    public void createEmployee();\n}\n```\n◇EmployeeServiceImpl实现类\n```java\npublic class EmployeeServiceImpl implements EmployeeService {\n    public void createEmployee() {\n        System.out.println(\"执行创建员工业务逻辑\");\n    }\n}\n```\n◇创建ProxyInvocationHandler类，实现重要的接口InvocationHandler\n```java\n/**\n * InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强\n * InvocationHandler实现类与切面类的环绕通知类似\n */\npublic class ProxyInvocationHandler implements InvocationHandler {\n    private Object target;//目标对象\n    private ProxyInvocationHandler(Object target){\n        this.target = target;\n    }\n    /**\n     * 必须实现这个invoke()方法\n     * 在invoke()方法对目标方法进行增强\n     * @param proxy 代理类对象\n     * @param method 目标方法对象\n     * @param args 目标方法实参\n     * @return 目标方法运行后返回值\n     * @throws Throwable 目标方法抛出的异常\n     */\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"=====\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\").format(new Date()) +\"=========\");\n        Object ret = method.invoke(target, args);//调用目标方法,相当于ProceedingJoinPoint.proceed()\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        UserService userService = new UserServiceImpl();\n        ProxyInvocationHandler invocationHandler = new ProxyInvocationHandler(userService);\n        //动态创建代理类\n        /*newProxyInstance方法基于接口动态创建代理类,三个参数（类加载器，类要实现的接口，如何对目标方法进行扩展）*/\n        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),\n                userService.getClass().getInterfaces(),\n                invocationHandler);\n        userServiceProxy.createUser();\n\n        //动态代理,必须实现接口才可以运行\n        EmployeeService employeeService = new EmployeeServiceImpl();\n        EmployeeService employeeServiceProxy = (EmployeeService)Proxy.newProxyInstance(employeeService.getClass().getClassLoader(),\n                employeeService.getClass().getInterfaces(),\n                new ProxyInvocationHandler(employeeService));\n        employeeServiceProxy.createEmployee();\n    }\n}\n```\n### JDK动态代理解析\n◇[CSDN参考链接](https://jiankunking.blog.csdn.net/article/details/52143504)\n◇Proxy是JDK反射包提供的类，其作用是根据已有接口来生成对应的代理类。\n\n◇下图代码有简化，省略了参数。首先在执行Proxy.newProxyInstance()方法，然后jdk会在本地文件中生成.class字节码文件，然后依次确定代理类的包名为com.sun.proxy，确定类名为$Proxy0。然后通过ProxyGenerator生成代理类，通过伪代码可以看出是使用确定的类名并实现参数值传递过来的接口创建的，代理类和被代理类{% wavy 实现的是同一个接口 %}。并且代理类中会持有一个接口的对象targetObject,这个对象是由new ProxyInvocationHandler(target)中的参数target提供的。然后在代理类中使用这个对象调用接口中定义的方法，并在方法执行前后者后增加在InvocationHandler类中扩展功能的代码。\n\n◇在创建完代理类以后，因为保存的是字节码文件，所以还要通过方法defineClass0将字节码文件通过被代理类的类加载器载入到JVM的方法区中。当类加载完成后，就会调用userServiceProxy.createUser()方法区加载类对象->new @$Proxy0()最终实例化代理类，将对象存放在JVM的堆区中。由于实例化代理类的同时也会实例化被代理类的实现类，所以代理类对象和被代理类的实现类对象(UserServiceImpl)有关联。\n\n![image-20220327231651543](SpringAOP面向切面编程/image-20220327231651543.png)\n\n### CGLib实现代理类\n◇CGLib是运行时字节码增强技术\n◇Spring AOP扩展无接口类使用CGLib\n◇AOP会运行时生成目标继承类字节码的方式进行行为扩展\n◇如下图，假设有一个最原始的Service类，类中有一个findById()方法;该Service类没有实现任何接口，因此无法实现JDK的动态代理。Spring会自动使用CGLib通过继承的方式来对类进行扩展。这个类是在jvm运行过程中自动生成的，生成规则是：原类名+$$+EnhancerByCGLIB\n![image.png](SpringAOP面向切面编程/1633250112821-72b8f05b-0992-4d48-95a4-208734a4e2dd.png)\n\n","tags":["Spring"],"categories":["Spring","Spring基础"]},{"title":"Spring Ioc容器与Bean管理","url":"/p/ddb.html","content":"## 内容说明\n### Spring loC\n![image.png](SpringIoc容器与Bean管理/1630934849961-68c37275-c326-42dd-8c9f-76cfafd3018f.png)\n### Spring AOP\n![image.png](SpringIoc容器与Bean管理/1630934894951-889d3e71-8aa4-4b9e-9d01-59f2309a0ead.png)\n### Spring JDBC与声明式事务\n![image.png](SpringIoc容器与Bean管理/1630934966182-c5242625-3f9e-4dca-bb7f-b9c938d16a41.png)\n## 课程介绍 \n◇Spring快速入门              ◇Spring XML配置 \n◇对象实例化配置             ◇依赖注入配置 \n◇注解与Java Config         ◇Spring 单元测试  \n\n## Spring 快速入门 \n### 生活中的烦恼   \n◇苹果这个对象的控制权是由客户发起的，客户必须掌握所有对象的特征细节后才能做出选择；\n![image.png](SpringIoc容器与Bean管理/1630896908927-dca53881-2a3f-4257-a25b-b18849a33964.png)\n\n### 现实中的商机 \n◇客户将获取对象的权利交个水果摊老板，有老板替顾客做出选择；\n![image.png](SpringIoc容器与Bean管理/1630896927455-4bbc1576-c9c6-4121-87fa-8faeba7edb6a.png)\n\n### IoC控制反转 \n◇IoC控制反转,全称Inverse of Control,是一种设计理念 \n◇由代理人来创建与管理对象,消费者通过代理人来获取对象 \n◇IoC的目的是降低对象之间直接耦合   \n◇对象直接引用导致对象硬性关联，程序难以扩展维护 \n![image.png](SpringIoc容器与Bean管理/1630896883840-020fd28b-142f-4a04-a184-3ff5e61c3694.png)\n◇ 加入IoC容器将对象统一管理，让对象关联变为弱耦合  \n![image.png](SpringIoc容器与Bean管理/1630897013449-8f132662-7b2a-46a3-9c48-86b23d169e58.png)\n\n### DI依赖注入 \n◇IoC是设计理念,是现代程序设计遵循的标准,是宏观目标 \n◇DI(Dependency Injection)是具体技术实现,是微观实现 \n◇DI在Java中利用反射技术实现对象注入(Injection)  \n\n## Spring  \n[官网](https://spring.io/)\n### Spring的含义 \n◇Spring可从狭义与广义两个角度看待 \n◇狭义的Spring是指Spring框架(Spring Fremework) \n◇广义的Spring是指Spring生态体系 \n\n### 狭义的Spring框架 \n◇Spring框架是企业开发复杂性的一站式解决方案 \n◇Spring框架的核心是IoC容器与AOP面向切面编程 \n◇Spring IoC负责创建与管理系统对象，并在此基础上扩展功能 \n### 广义的Spring生态体系   \n![image.png](SpringIoc容器与Bean管理/1630936934175-c8cf8bd3-8a1a-4b42-b5c9-2aca583eb41b.png)\n\n### Spring框架组成模块  \n\n◇四层，核心为第二层\n![image.png](SpringIoc容器与Bean管理/1630897823185-2161c56c-32a7-4329-9432-24b4449a80e0.png)\n\n### 传统开发方式 \n◇对象直接引用导致对象硬性关联，程序难以扩展维护  \n![image.png](SpringIoc容器与Bean管理/1630897484380-d37f95ca-a896-4b39-8386-450ce02a9638.png)\n\n### Spring IoC容器 \n◇IoC容器是Spring生态的地基,用于统一创建与管理对象依赖  \n![image.png](SpringIoc容器与Bean管理/1630897523216-2350d7a4-dc59-41b0-a257-85960d5a2356.png)\n\n### Spring IoC容器职责 \n◇对象的控制权交由第三方统一管理(IoC控制翻转) \n◇利用Java反射技术实现运行时对象创建与关联(DI依赖注入) \n◇基于配置提高应用程序的可维护性与扩展性 \n\n### Spring IoC初体验 \n◇妈妈在早餐后给三个孩子分发餐后水果 \n◇盘子里装有三个苹果: 红富士/青苹果/金帅 \n◇孩子们口味不同: 莉莉喜欢甜的/安迪喜欢酸的/露娜喜欢软的  \n### 代码示例\n#### 传统代码\n --实体类\n```java\npublic class Apple {\n    private String title;\n    private String color;\n    private String origin;\n               ...\n }\n\npublic class Child {\n    private String name;\n    private Apple apple;\n    ...\n    public void eat(){\n        System.out.println(name+\"吃到了\"+apple.getOrigin()+\"种植的\"+apple.getTitle());\n    }\n}\n```\n --应用入口\n```java\npublic class Application {\n    public static void main(String[] args) {\n        Apple a1 = new Apple(\"红富士\", \"红色\", \"欧洲\");\n        Apple a2 = new Apple(\"青苹果\", \"绿色\", \"中亚\");\n        Apple a3 = new Apple(\"金帅\", \"黄色\", \"中国\");\n        Child lily = new Child(\"莉莉\", a1);\n        Child andy = new Child(\"安迪\", a2);\n        Child luna = new Child(\"露娜\", a3);\n        lily.eat();\n        andy.eat();\n        luna.eat();\n    }\n}\n```\n◇缺点分析：①苹果的描述写死在代码中，若描述改变需要修改源代码；②对象的数量固定的，若要新增对象需要修改源代码，程序的可维护性，可扩展性不足；③对象是硬关联的，每个孩子喜欢的苹果不同则需要修改源码，比较死板；\n#### Spring Ioc\n◇加载配置\n```java\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n    </dependencies>\n```\n◇applicationContext.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--在IoC容器启动时，自动有Spring实例化Apple对象，取名sweetApple放入到容器中-->\n    <bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"红富士\"></property>\n        <property name=\"origin\" value=\"欧洲\"></property>\n        <property name=\"color\" value=\"红色\"></property>\n    </bean>\n    <bean id=\"sourApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"青苹果\"></property>\n        <property name=\"origin\" value=\"中亚\"></property>\n        <property name=\"color\" value=\"绿色\"></property>\n    </bean>\n    <bean id=\"softApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"金帅\"></property>\n        <property name=\"origin\" value=\"中国\"></property>\n        <property name=\"color\" value=\"黄色\"></property>\n    </bean>\n    <!--孩子 -->\n    <bean id=\"lily\" class=\"com.lcg.spring.ioc.entity.Child\">\n        <property name=\"name\" value=\"lily\"/>\n        <property name=\"apple\" ref=\"sweetApple\"/>\n    </bean>\n    <bean id=\"andy\" class=\"com.lcg.spring.ioc.entity.Child\">\n        <property name=\"name\" value=\"andy\"/>\n        <property name=\"apple\" ref=\"sourApple\"/>\n    </bean>\n    <bean id=\"luna\" class=\"com.lcg.spring.ioc.entity.Child\">\n        <property name=\"name\" value=\"luna\"/>\n        <property name=\"apple\" ref=\"softApple\"/>\n    </bean>\n</beans>\n```\n◇应用接口\n```java\npublic class SpringApplication {\n    public static void main(String[] args) {\n        //加载指定的配置文件\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        Apple sweetApple = context.getBean(\"sweetApple\", Apple.class);\n        System.out.println(sweetApple.getTitle());\n        //从IoC容器中提取beanId=lily的对象\n        Child lily = context.getBean(\"lily\", Child.class);\n        Child andy = context.getBean(\"andy\", Child.class);\n        Child luna = context.getBean(\"luna\", Child.class);\n        lily.eat();\n        andy.eat();\n        luna.eat();\n    }\n```\n◇这样，通过Ioc容器，将程序代码转变为配置文本，维护性更好，让对象与对象之间有效的解耦\n\n## XML管理对象(Bean)  \n\n### 三种配置方式 \n◇基于XML配置Bean        \n◇基于注解配置Bean         \n◇基于Java代码配置Bean  \n###  applicationContext.xml  \n```java\n<bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n <property name=\"title\" value=\"红富士\"></property>\n <property name=\"origin\" value=\"欧洲\"></property>\n <property name=\"color\" value=\"红色\"></property>\n</bean>\n```\n### XML方式创建IoC容器  \n```java\n//创建IoC容器并根据配置文件创建对象\nApplicationContext context = new \nClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n```\n### ApplicationContext实现类 \n◇ClassPathXmlApplicationContext \n◇AnnotationConfigApplicationContext \n◇WebApplicationContext \n\n### 实例化Bean的三种方式 \n◇基于构造方法对象实例化 \n◇基于静态工厂实例化 \n◇基于工厂实例方法实例化  \n\n#### 一、构造方法实例化对象 \n\n```java\npublic Apple(String title,Stirng color,String origin){\n    System.out.println(\"通过带参构造方法创建对象,\"+this);\n    this.title=title;\n    this.color=color;\n    this.origin=origin;\n}\n```\n**1.利用构造方法参数名实例化**\n◇如果对象不止一个构造函数，则按照对应的参数(个数，类型)来进行设置;\n\n```java\n<bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\"> \n <!-- 没有constructor-arg则代表调用默认构造方法实例化 -->\n <constructor-arg name=\"title\" value=\"红富士\"/>\n <constructor-arg name=\"origin\" value=\"欧洲\"/> \n <constructor-arg name=\"color\" value=\"红色\"/>\n</bean>\n```\n**2.利用构造方法参数位置实例化**  \n\n```java\n<bean id=\"sweetApple\" class=\"com.imooc.spring.ioc.entity.Apple\"> \n <!-- 利用构造方法参数位置实现对象实例化 -->\n <constructor-arg index=\"0\" value=\"红富士\"/>\n <constructor-arg index=\"1\" value=\"红色\"/>\n <constructor-arg index=\"2\" value=\"欧洲\"/>\n</bean>\n```\n#### 二、工厂模式实例化对象 \n\n◇创建工厂类。创建静态工厂类AppleStaticFactory,使得创建对象的代码被隐藏，主要目的是在ioc容器之外通过程序的形式组织对象；好处：可以在创建对象的过程中赋予额外的行为(如日志输出等),\n\n```java\n/**\n * 静态工厂通过静态方法创建对象，隐藏创建对象的细节\n */\npublic class AppleStaticFactory {\n    public static Apple createSweetApple(){\n        Apple apple = new Apple();\n        apple.setTitle(\"红富士\");\n        apple.setOrigin(\"欧洲\");\n        apple.setColor(\"红色\");\n        return apple;\n    }\n}\n```\n◇在applicationContext.xml中配置\n```java\n    <!--利用静态工厂获取对象，加上工厂方法-->\n    <bean id=\"apple4\" class=\"com.lcg.spring.ioc.factory.AppleStaticFactory\"\n          factory-method=\"createSweetApple\"/>\n```\n#### 三、工厂实例：在ioc容器中对工厂进行实例化\n\n◇在factory中创建AppleFactoryInstance（苹果工厂实例）\n```java\n\n/**\n * 工厂实例方法创建对象是指Ioc容器对工厂类进行实例化并调用相应的实例方法创建对象的过程\n */\npublic class AppleFactoryInstance {\n    public  Apple createSweetApple(){\n        Apple apple = new Apple();\n        apple.setTitle(\"红富士\");\n        apple.setOrigin(\"欧洲\");\n        apple.setColor(\"红色\");\n        return apple;\n    }\n}\n```\n◇在Ioc容器中进行实例化和使用\n```java\n<!-- 利用工厂实例方法获取对象-->\n    <bean id=\"factoryInstance\" class=\"com.lcg.spring.ioc.factory.AppleFactoryInstance\"/>\n    <bean id=\"apple5\" factory-bean=\"factoryInstance\" factory-method=\"createSweetApple\"/>\n```\n## 从IoC容器获取Bean  \n\n◇从IoC容器中获取Bean通过getBean()方法来获取。\n\n```java\n//第一个参数BeanId，第二个Bean的实际类型\nApple sweetApple = context.getBean(\"sweetApple\" , Apple.class);\n//或者单参数方法，进行强制转换\nApple sweetApple = (Apple)context.getBean(\"sweetApple\");\n//打印输出\nSystem.out.println(sweetApple.getTitle());\n```\n### id与name属性相同点 \n◇bean id与bean name都是设置对象在IoC容器中唯一标识 \n◇两者在同一个配置文件中都{% wavy 不允许 %}出现重复 \n◇两者允许在多个配置文件中出现重复,新对象覆盖旧对象 \n\n### id与name属性区别\n◇id要求更为严格,一次只能定义{% emp 一个 %}对象标识(推荐)\n◇name更为宽松,一次允许定义多个对象标识：name=apple1,apple2，...\n◇tips: id与name的命名要求有意义,按驼峰命名书写 \n◇当没有id与name的bean默认使用类名全称作为bean标识\n\n## 路径匹配表达式  \n### 加载单个配置文件  \n◇路径表达式用于加载配置文件\n```java\n//创建IoC容器并根据配置文件创建对象\nApplicationContext context = new \nClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");//参数即路径表达式\n\n```\n### 加载多个配置文件\n```java\nString[] configLocations = new \n String[]{\"classpath:applicationContext.xml\"\n ,\"classpath:applicationContext-1.xml\"};\nApplicationContext context = new \nClassPathXmlApplicationContext(configLocations);\n```\n### 路径表达式  \n![image.png](SpringIoc容器与Bean管理/1630911452907-cd3d11a0-5a18-48c6-acfb-8bd4d8605996.png)\n## 对象依赖注入  \n![image.png](SpringIoc容器与Bean管理/1630911749557-eddc3615-b954-41fc-b63d-41d88b26d3fd.png)\n◇依赖注入是指运行时将容器内对象利用反射赋给其他对象的操作,即将两个对象关联起来\n◇基于setter方法注入对象 \n◇基于构造方法注入对象  \n\n### 利用setter实现静态数值注入  \n```java\n<bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n<!--IoC容器自动利用反射机制运行时调用setXXX方法给属性赋值 -->\n <property name=\"title\" value=\"红富士\"/>\n <property name=\"color\" value=\"红色\"/>\n <property name=\"origin\" value=\"欧洲\"/>\n</bean>\n```\n### 利用setter实现对象注入 \n```java\n<bean id=\"lily\" class=\"com.lcg.spring.ioc.entity.Child\">\n <property name=\"name\" value=\"莉莉\"/>\n <!--利用ref注入依赖对象 -->\n <property name=\"apple\" ref=\"sweetApple\"/>//属性ref代表\"关联\"\n</bean>\n```\n### 基于构造方法注入对象 \n◇使用Child类的构造方法\n```java\npublic Child(String name,Apple apple){\n    this.name=name;\n    this.apple=apple;\n}\n```\n ◇在applicationContext.xml中进行配置\n```java\n<bean id=\"sourApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"青苹果\"></property>\n        <property name=\"origin\" value=\"中亚\"></property>\n        <property name=\"color\" value=\"绿色\"></property>\n</bean>\n<bean id=\"andy\" class=\"com.lcg.spring.ioc.entity.Child\">\n     <constructor-arg name=\"name\" value=\"安迪\"/> //name表示参数，value表示赋值\n     //利用反射技术将sourApple苹果对象做为参数传入带参构造函数中\n     <constructor-arg name=\"apple\" ref=\"sourApple\"/>  //ref用于关联sourApple\n</bean>\n```\n### 注入集合对象 \n ◇注入List  \n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someList\">\n <list>\n <value>具体值</value>\n <ref bean=\"beanId\"></ref>\n </list>\n </property>\n</bean>\n```\n◇ 注入Set  \n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someSet\">\n <set>\n <value>具体值</value>\n <ref bean=\"beanId\"></ref>\n </set>\n </propery>\n</bean>\n```\n ◇注入Map  \n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someMap\">\n <map>//子标签\n <entry key=\"k1\" value=\"v1\"></entry>//每一个entry就相当于一个键值对\n <entry key=\"k2\" value-ref=\"beanId\"></entry>\n </map>\n </property>\n</bean>\n```\n◇ 注入Properties （属性类型）\n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someProperties\">\n <props>\n <prop key=\"k1\">v1</prop>//key和value必须是字符串\n <prop key=\"k2\">v2</prop>\n </props>\n </property>\n</bean>\n```\n### IoC在实际项目中的应用\n\n◇创建两个配置文件applicationContext-dao.xml和applicationContext-service.xml供两名员工开发，前者主要由实习生来实现，因为比较简单，而后者是核心文件，需要有经验的工程师进行开发。\n◇创建BookDao接口\n\n```java\npackage com.lcg.spring.ioc.bookshop.dao;\npublic interface BookDao {\n    public void insert();\n}\n```\n\n◇创建BookImpl实现类\n\n```java\npackage com.lcg.spring.ioc.bookshop.dao;\npublic class BookDaoImpl implements BookDao {\n    public void insert(){\n        System.out.println(\"向MySQL Book表插入一条数据\");\n    }\n}\n```\n\n◇创建BookService\n\n```java\npackage com.lcg.spring.ioc.bookshop.service;\n\nimport com.lcg.spring.ioc.bookshop.dao.BookDao;\n\npublic class BookService {\n    private BookDao bookDao;\n    public void purchase(){\n        System.out.println(\"正在执行图书采购业务方法\");\n        bookDao.insert();\n    }\n\n    public BookDao getBookDao() {\n        return bookDao;\n    }\n\n    public void setBookDao(BookDao bookDao) {\n        this.bookDao = bookDao;\n    }\n}\n```\n\n◇配置applicationContext-dao.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"bookDao\" class=\"com.lcg.spring.ioc.bookshop.dao.BookDaoImpl\">\n\n    </bean>\n</beans>\n```\n\n◇配置applicationContext-service.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"bookService\" class=\"com.lcg.spring.ioc.bookshop.service.BookService\">\n        <!--两个开发人员以这种id=bookDao的约定方式来进行对象的关联\n        这样能够实现两者开发互不干扰，如果要进行换数据库的话，只需要\n        更改dao配置文件就行了\n        -->\n        <property name=\"bookDao\" ref=\"bookDao\"/>\n    </bean>\n</beans>\n```\n\n### 案例-公司资产清单\n\n◇创建Computer类（作为公司资产）\n```java\npackage com.lcg.spring.ioc.entity;\n\npublic class Computer {\n    private String brand;\n    private String type;\n    private String sn;\n    private Float price;\n    public Computer() {\n    }\n\n    public Computer(String brand, String type, String sn, Float price) {\n        this.brand = brand;\n        this.type = type;\n        this.sn = sn;\n        this.price = price;\n    }\n     //...get&set..\n    //重写toString方便程序演示\n    @Override\n    public String toString() {\n        return \"Computer{\" +\n                \"brand='\" + brand + '\\'' +\n                \", type='\" + type + '\\'' +\n                \", sn='\" + sn + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n\n```\n◇创建公司类\n```java\npackage com.lcg.spring.ioc.entity;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class Company {\n    private Set<String> rooms;\n    private Map<String,Computer> computers;\n    private Properties info;\n    //...get&set..\n    @Override\n    public String toString() {\n        return \"Company{\" +\n                \"rooms=\" + rooms +\n                \", computers=\" + computers +\n                \", info=\" + info +\n                '}';\n    }\n}\n```\n◇applicationContext配置\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"c1\" class=\"com.lcg.spring.ioc.entity.Computer\">\n        <constructor-arg name=\"brand\" value=\"联想\"/>\n        <constructor-arg name=\"type\" value=\"台式机\"/>\n        <constructor-arg name=\"sn\" value=\"8389283012\"/>\n        <constructor-arg name=\"price\" value=\"3085\"/>\n    </bean>\n\n    <bean class=\"com.lcg.spring.ioc.entity.Computer\">\n        <constructor-arg name=\"brand\" value=\"微星\"/>\n        <constructor-arg name=\"type\" value=\"台式机\"/>\n        <constructor-arg name=\"sn\" value=\"8389280012\"/>\n        <constructor-arg name=\"price\" value=\"3000\"/>\n    </bean>\n\n    <bean class=\"com.lcg.spring.ioc.entity.Computer\">\n        <constructor-arg name=\"brand\" value=\"华硕\"/>\n        <constructor-arg name=\"type\" value=\"笔记本\"/>\n        <constructor-arg name=\"sn\" value=\"9089380012\"/>\n        <constructor-arg name=\"price\" value=\"6000\"/>\n    </bean>\n\n    <bean id=\"company\" class=\"com.lcg.spring.ioc.entity.Company\">\n        <property name=\"rooms\">\n            <set>//set集合不允许出现重复数据，会自动去重\n                <value>2001-总裁办</value>\n                <value>2003-总经理办公室</value>\n                <value>2010-研发部会议室</value>\n                <value>2010-研发部会议室</value>\n            </set>\n        </property>\n        <property name=\"computers\">\n            <map>\n                <!--方法一、使用value-ref，前提是bean c1已创建-->\n                <entry key=\"dev-88172\" value-ref=\"c1\"/>\n                <!--方法二、使用内置bean，不用额外创建,但这个bean对象只能用于此处-->\n                <entry key=\"dev-88173\">\n                    <bean class=\"com.lcg.spring.ioc.entity.Computer\">\n                        <constructor-arg name=\"brand\" value=\"联想\"/>\n                        <constructor-arg name=\"type\" value=\"笔记本\"/>\n                        <constructor-arg name=\"sn\" value=\"1280258012\"/>\n                        <constructor-arg name=\"price\" value=\"5060\"/>\n                    </bean>\n                </entry>\n            </map>\n        </property>\n\n        <property name=\"info\">\n            <props>//只允许字符串\n                <prop key=\"phone\">010-12345678</prop>\n                <prop key=\"address\">北京市朝阳区XX路XX大厦</prop>\n                <prop key=\"website\">http://www.xxx.com </prop>\n            </props>\n        </property>\n    </bean>\n</beans>\n```\n## 查看容器内对象 \n### 获取对象\n◇如何查看容器内有多少对象，写在内部使用的bean不会产生beanID，即无法用此方法获取内部的bean\n```java\n//获取容器内所有beanId数组\nString[] beanNames = context.getBeanDefinitionNames();\n```\n◇获取bean的类型、内容\n```java\nfor (String beanName:beanNames){\n       System.out.println(beanName);\n       //获取类型，首先传入参数beanName,返回object对象,再通过getClass得到类对象,然后得到类名\n       System.out.println(\"类型:\" + context.getBean(beanName).getClass().getName());\n       System.out.println(\"内容:\" + context.getBean(beanName));\n     }\n```\n◇如果没有设置beanID，则默认为类的全名+#+数字序号，若要查看匿名的bean，只输入类的全名只显示第一个匿名的bean，想要具体输出哪一个匿名的bean需要+#+数字序号\n```java\nComputer c1 = context.getBean(\"com.lcg.spring.ioc.entity.Computer#2\", Computer.class);\n```\n### bean scope属性 \n◇bean scope属性用于决定对象何时被创建与作用范围 \n◇bean scope配置将影响容器内对象的数量 \n◇bean scope默认值singleton(单例),指全局共享同一个对象实例\n◇默认情况下bean会在IoC容器创建后自动实例化,全局唯一  \n### scope用法  \n```java\n<bean id=\"bookDao\"\n class=\"com.lcg.spring.ioc.bookshop.dao.BookDaoOracleImpl\"\n scope=\"prototype\" /> //增加scope\n```\n### bean scope属性清单  \n◇bean scope有六个备选值\n![image.png](SpringIoc容器与Bean管理/1630912828587-c5400c8d-c90f-4ec9-a45c-f97e30bd07c0.png)\n\n### singleton单例示意图  \n![image.png](SpringIoc容器与Bean管理/1630912880476-638a2d81-eea8-40f2-8d2a-5aab6bf98b14.png)\n### singleton的线程安全问题  \n◇用户1设置num=1，然后输出\n![image.png](SpringIoc容器与Bean管理/1630913442004-f3433618-87ea-4bfd-969b-8001de77b38c.png)\n◇用户1设置num=1，过了几毫秒，用户2设置num=2，由于全局只有一个对象，所以num=2，且当用户1的输出时，会输出2\n![image.png](SpringIoc容器与Bean管理/1632401257175-2a43283a-7f8d-47cd-a62c-0d6c58f90bba.png)\n\n### prototype多例示意图  \n◇prototype在容器中多实例,占用更多资源,不存在线程安全问题  \n![image.png](SpringIoc容器与Bean管理/1632401691625-447396bc-7cc1-40f6-b7ec-a8aa795a2bba.png)\n\n### singleton与prototype对比  \n![image.png](SpringIoc容器与Bean管理/1632401797814-885953de-835e-47e8-800e-b8fd70c0dc05.png)\n### bean scope的实际应用\n◇对于某一个属性，如果在运行过程中是恒定不变的，就可以设置单例模式。\n◇创建UserDao\n\n```java\npackage com.lcg.spring.ioc.dao;\npublic class UserDao {\n    public UserDao(){\n        System.out.println(\"UserDao已创建:\" + this);\n    }\n}\n```\n◇创建UserService\n```java\npackage com.lcg.spring.ioc.service;\nimport com.lcg.spring.ioc.dao.UserDao;\npublic class UserService {\n    private UserDao userDao;\n    public UserService(){\n        System.out.println(\"UserService已创建:\" + this);\n    }\n    public UserDao getUserDao() {\n        return userDao;\n    }\n    public void setUserDao(UserDao userDao) {\n        System.out.println(\"调用setUserDao:\" + userDao);\n        this.userDao = userDao;\n    }\n}\n```\n◇applicationContext.xml配置文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n   <bean id=\"userDao\" class=\"com.lcg.spring.ioc.dao.UserDao\" scope=\"prototype\"/>\n   <bean id=\"userService\" class=\"com.lcg.spring.ioc.service.UserService\" scope=\"prototype\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n   </bean>\n</beans>\n```\n◇主程序入口\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.entity.Order;\nimport com.lcg.spring.ioc.service.UserService;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class SpringApplication {\n    public static void main(String[] args) {\n        ApplicationContext context =\n            new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        System.out.println(\"======IoC容器已初始化=======\");\n       /* 创建userDao\n        UserDao userDao1 = context.getBean(\"userDao\", UserDao.class);\n        UserDao userDao2 = context.getBean(\"userDao\", UserDao.class);\n        UserDao userDao3 = context.getBean(\"userDao\", UserDao.class);*/\n        UserService userService1 = context.getBean(\"userService\", UserService.class);\n        UserService userService2 = context.getBean(\"userService\", UserService.class);\n        UserService userService3 = context.getBean(\"userService\", UserService.class);\n        UserService userService4 = context.getBean(\"userService\", UserService.class);\n    }\n}\n```\n## bean的生命周期  \n![bean生命周期.png](SpringIoc容器与Bean管理/1632468115442-463d426e-a10d-4800-8395-8a1be644f3a2.png)\n\n◇左边为容器行为，右边为对象行为。①IoC容器需要解析XML文件，看一下当前的XML文件中需要创建哪些对象，这些对象又改注入什么属性等基础配置信息。②然后IoC容器会根据这些配置信息自动通过反射来实例化相关对象，并且执行其构造方法(当类实例化一个对象时会自动调用构造方法进行对象的初始化工作)。③紧接着，根据前面解析的XML，IoC容器就知道要为当前新创建的对象注入哪些属性，然后为对象注入属性。④当对象注入以后，IoC容器会自动的调用对象配置的init-method初始化方法进行对象的初始化，这里的初始化和前面构造函数初始化有所不同，构造函数初始化时，对象还没有任何属性值，只有当对象创建好以后，IoC容器才对其注入属性值。而init-method方法初始化的作用就是在对象注入属性值以后，基于这些属性值来给对象进行相关的初始化工作。⑤当完成前面的步骤之后，IoC容器的初始化工作就完成了。当然在init-method初始化方法前后会有BeanPostProcessor()方法来进行一些前置处理和后置处理的相关扩展。⑥前面的初始化完成之后，就可以获取Bean对象来执行业务代码了。⑦当IoC容器准备关闭时，也有一个销毁的过程。首先IoC容器准备销毁。⑧然后会去调用在配置文件中所声明的destroy-method()方法释放对应的资源。⑨当所有bean的destroy-method方法执行完后，IoC容器销毁完毕。\n\n### 细节调整 \n◇prototype时对象创建与init-method延迟至执行业务 代码阶段 \n◇prototype时对象不再受IoC容器管理,不会触发 destroy-method \n◇延迟加载lazy-init属性可让对象创建与初始化延迟到 执行代码阶段  \n\n### 生命周期在实战中的运用  \n◇创建订单实体类\n```java\npackage com.lcg.spring.ioc.entity;\npublic class Order {\n    private Float price;\n    private Integer quantity;\n    private Float total;\n\n    public Order(){\n        System.out.println(\"创建Order对象,\" + this);\n    }\n\n    public void init(){\n        System.out.println(\"执行init()方法\");\n        total = price * quantity;//计算总价\n    }\n    public void pay(){\n        System.out.println(\"订单金额为:\" + total);\n    }\n    public Float getPrice() {\n        return price;\n    }\n    public void setPrice(Float price) {\n        System.out.println(\"设置price:\" + price);\n        this.price = price;\n    }\n    public Integer getQuantity() {\n        return quantity;\n    }\n    public void setQuantity(Integer quantity) {\n        System.out.println(\"设置quantity:\" + quantity);\n        this.quantity = quantity;\n    }\n    public Float getTotal() {\n        return total;\n    }\n    public void setTotal(Float total) {\n        this.total = total;\n    }\n    public void destroy(){\n        System.out.println(\"释放与订单对象相关的资源\");\n    }\n}\n```\n◇配置order\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"order1\" class=\"com.lcg.spring.ioc.entity.Order\" \n        init-method=\"init\" destroy-method=\"destroy\">\n        <property name=\"price\" value=\"19.8\"/>\n        <property name=\"quantity\" value=\"1000\"/>\n    </bean>\n</beans>\n```\n◇主程序\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.entity.Order;\nimport com.lcg.spring.ioc.service.UserService;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class SpringApplication {\n    public static void main(String[] args) {\n        ApplicationContext context =\n            new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        System.out.println(\"======IoC容器已初始化=======\");\n        Order order1 = context.getBean(\"order1\", Order.class);\n        order1.pay();\n        //销毁IoC容器方法\n        ((ClassPathXmlApplicationContext) context).registerShutdownHook();\n    }\n}\n```\n◇运行结果\n![image.png](SpringIoc容器与Bean管理/1639625401117-bbde845e-26d7-464d-bbe5-eb3229f9a57d.png)\n\n### 实现极简IoC容器  \n◇创建实体类Apple\n```java\npublic class Apple {\n    private String title;\n    private String color;\n    private String origin;\n    ...\n}\n```\n◇创建配置文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans>\n    <bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"红富士\"/>\n        <property name=\"color\" value=\"红色\"/>\n        <property name=\"origin\" value=\"欧洲\"/>\n    </bean>\n</beans>\n```\n◇创建接口\n```java\npackage com.lcg.spring.ioc.context;\n\npublic interface ApplicationContext {\n    public Object getBean(String beanId);\n}\n```\n◇核心配置文件部分代码\n```java\n    <repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n\n\n    <dependencies>\n        <!-- Dom4j是Java的XML解析组件 -->\n        <dependency>\n            <groupId>org.dom4j</groupId>\n            <artifactId>dom4j</artifactId>\n            <version>2.1.1</version>\n        </dependency>\n        <!-- Jaxen是Xpath表达式解释器 -->\n        <dependency>\n            <groupId>jaxen</groupId>\n            <artifactId>jaxen</artifactId>\n            <version>1.1.6</version>\n        </dependency>\n    </dependencies>\n```\n◇创建类\n◇在Ioc容器初始化的过程中，遇到了对象实例化，就去调用Class.forName、newInstance方法来利用反射技术实现对象的创建;如果遇到了property这个标签，则利用Method对象实现方法的调用\n```java\npackage com.lcg.spring.ioc.context;\n\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.Node;\nimport org.dom4j.io.SAXReader;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\nimport java.net.URLDecoder;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n    private Map iocContainer = new HashMap();\n    public ClassPathXmlApplicationContext(){\n        try{\n            //得到配置文件的地址\n            String filePath = \n                this.getClass().getResource(\"/applicationContext.xml\").getPath();\n            //使用URL解码\n            filePath = new URLDecoder().decode(filePath, \"UTF-8\");\n            SAXReader reader = new SAXReader();\n            //读取指定文件,所有的xml文件都会放在document中\n            Document document = reader.read(new File(filePath));\n            //按照xml格式依次读取,getRootElement()得到根节点,\n            // selectNodes(\"bean\")将所有根节点的bean标签获取\n            List<Node> beans = document.getRootElement().selectNodes(\"bean\");\n            for(Node node : beans){\n                Element  ele = (Element)node;\n                //读取属性\n                String id = ele.attributeValue(\"id\");\n                String className = ele.attributeValue(\"class\");\n                //forName(className)加载指定的类\n                Class c = Class.forName(className);\n                Object obj = c.newInstance();//通过默认构造方法创建Apple类的实例\n                List<Node> properties = ele.selectNodes(\"property\");\n                //遍历属性\n                for(Node p : properties){\n                    Element property = (Element) p;\n                     //读取name及其对应的值\n                    String propName = property.attributeValue(\"name\");\n                    String propValue = property.attributeValue(\"value\");\n                    //组织set方法，substring(1)代表从第二个字符将之后的所有字符串进行截取\n                    String setMethodName = \"set\" + \n                        propName.substring(0,1).toUpperCase()+propName.substring(1);\n                    System.out.println(\"准备执行\" + setMethodName + \"方法注入数据\");\n                    //通过getMethod方法调用\n                    Method setMethod = c.getMethod(setMethodName, String.class);\n                    setMethod.invoke(obj,propValue);//通过setter方法注入数据\n                }\n                //将id和obj放入容器中，即ioc对刚才创建的对象赋予beanId进行管理\n                iocContainer.put(id,obj);\n            }\n            System.out.println(iocContainer);\n            System.out.println(\"IOC容器初始化完毕\");\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    public Object getBean(String beanId){\n        return iocContainer.get(beanId);\n    }\n}\n\n```\n◇入口类\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.context.ApplicationContext;\nimport com.lcg.spring.ioc.context.ClassPathXmlApplicationContext;\nimport com.lcg.spring.ioc.entity.Apple;\npublic class Application {\n    public static void main(String[] args) {\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext();\n        Apple apple = (Apple)context.getBean(\"sweetApple\");\n        System.out.println(apple);\n    }\n}\n```\n## 基于注解配置IoC容器  \n### 基于注解的优势 \n◇摆脱繁琐的XML形式的bean与依赖注入配置 \n◇基于\"声明式\"的原则,更适合轻量级的现代企业应用 \n◇让代码可读性变得更好,研发人员拥有更好的开发体验  \n### 三类注解 \n◇组件类型注解-声明当前类的功能与职责 \n◇自动装配注解-根据属性特征自动注入对象 \n◇元数据注解-更细化的辅助IoC容器管理对象的注解  \n### 四种组件类型注解 \n◇语义注解是组件注解的细化\n```java\n@Component    组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化\n@Controller   语义注解,说明当前类是MVC应用中的控制器类\n@Service      语义注解,说明当前类是Service业务服务类\n@Repository   语义注解,说明当前类用于业务持久层,通常描述对应Dao类\n```\n###  开启组件扫描  \n◇regex表示排除扫描，即类名符合com.imooc.exl.*的正则表达式就不会被ioc容器进行实例化\n![image.png](SpringIoc容器与Bean管理/1632644213443-2887e008-68d5-442b-b82f-eceead2d9772.png)\n\n### 代码示例\n◇创建applicationContext.xml，和传统的配置不一样,额外的增加了context命名空间\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n    <!-- component-scan在IoC容器初始化时自动扫描四种组件类型注解并完成实例化\n        @Repository\n        @Service\n        @Controller\n        @Component\n     -->\n    <context:component-scan base-package=\"com.lcg\"/>\n</beans>\n```\n◇剩余代码见项目s07；\n###  两类自动装配注解  \n◇自动装配注解即在ioc容器运行的过程中自动的为某个属性注入数据，推荐按名称装配\n◇在属性上方进行装配注解和在setXX方法上方进行都可以完成对象的注入，但是在属性上方进行装配Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值，不再执行set方法。_如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入_\n◇如果出现两个类(比方说不同的数据库)实现同一个接口,并且两个类都进行了语义注解(dao的注解为@Repository)，则在运行时会报错，因为出现了两个bean对象。在s07项目中Service类中进行了IUserDao的自动注解，但由于两个dao类都实现了IUserDao接口，则不知道选择哪一个。解决方法：①在userDao中去@Repository注解，这样userDao就不会被Ioc容器管理了；②引入额外的注解@Primary，表示如果出现多个bean对象的话，主要采用有此注解的；\n◇两个不同的Dao\n```java\n//组件类型注解默认beanId为类名首字母小写\n//beadId = userDao\n@Repository\npublic class UserDao implements IUserDao {\n    public UserDao() {\n        System.out.println(\"正在创建UserDao:\" + this);\n    }\n}\n```\n```java\n@Repository\n@Primary\npublic class UserOracleDao implements IUserDao {\n    public UserOracleDao() {\n        System.out.println(\"正在创建UserOracleDao:\" + this);\n    }\n}\n```\n◇因此，为了避免出现这种情况，一般采用按名称进行注入；\n```java\npackage com.lcg.spring.ioc.service;\nimport com.lcg.spring.ioc.dao.IUserDao;\nimport org.springframework.stereotype.Service;\nimport javax.annotation.Resource;\n\n@Service\npublic class DepartmentService {\n    /**\n     * 1. @Resource设置name属性,则按name在IoC容器中将bean注入\n     * 2. @Resource未设置name属性\n     * 2.1 以属性名作为bean name在IoC容器中匹配bean,如有匹配则注入\n     * 2.2 按属性名未匹配,则按类型进行匹配,同@Autowired,需加入@Primary解决类型冲突\n     * 使用建议:在使用@Resource对象时推荐设置name或保证属性名与bean名称一致(规范属性名)\n     */\n//    @Resource(name = \"userOracleDao\") 设置userOracleDao为name属性\n//    private IUserDao uDao;\n    @Resource\n    private IUserDao userDao; //这里属性名为userDao(规范属性名),以其作为name属性\n\n    public void joinDepartment(){\n        System.out.println(userDao);\n    }\n}\n```\n![image.png](SpringIoc容器与Bean管理/1632657405828-7a0f304b-7b46-4865-a138-c2e341b27348.png)\n### 元数据注解  \n◇@Scope(\"prototype\")   //设置单例/多例,XML中 bean scope完全相同 \n◇@PostConstruct      //XML中bean init-method完全相同，即初始化方法\n◇@Value(\"${metaData}\")   //读取config.properties的metaData属性值\n![image.png](SpringIoc容器与Bean管理/1632709510231-6f4d768f-1268-4ce8-aca7-a057100d1bb9.png)\n\n### @Value的读取属性文件  \n◇@value参数书写格式为\"${属性名}\"\n◇config.properties应用程序的配置信息，基于字符串的键值对，需要在applicationContext中进行加载，加载语句为：\n\n```xml\n<!--通知Spring IoC容器初始化时加载属性文件-->\n<context:property-placeholder location=\"classpath:config.properties\"/>\n```\n◇config.properties配置信息\n```java\nmetaData=lcg.com\n//数据库的连接属性，通过增加前缀connection来说明，在引用时也得书写完整字符串\nconnection.driver=xxxxx \nconnection.url=xxx\nconnection.username=xxx\nconnection.password=xxx\n```\n◇xml文件配置维护起来比较方便，但是不便于开发；而注解形式配置开发方便但维护的时候需要修改源代码\n◇示例代码\n```java\n@Service\n@Scope(\"prototype\")//设置单例/多例,XML中 bean scope完全相同\npublic class UserService {\n    @Value(\"${metaData}\")//读取config.properties的metaData属性值\n    private String metaData;\n    @Value(\"${connection.password}\")\n    private String password;\n\n    public UserService() {\n        System.out.println(\"正在创建UserService:\" + this);\n    }\n\n    @PostConstruct //XML中bean init-method完全相同\n    public void init() {\n        System.out.println(\"初始化UserService对象,metaData=\" + metaData);\n    }\n\n    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值\n    //不再执行set方法\n    @Autowired\n    private IUserDao udao;//private->public\n\n    public IUserDao getUdao() {\n        return udao;\n    }\n\n\n    /*@Autowired\n    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入\n    public void setUdao(UserDao udao) {\n        System.out.println(\"setUdao:\" + udao);\n        this.udao = udao;\n    }*/\n}\n```\n## 基于Java Config配置IoC容器  \n### 基于Java Config的优势 \n◇完全摆脱XML的束缚,使用独立Java类管理对象与依赖 \n◇注解配置相对分散,利用Java Config可对配置集中管理 \n◇可以在编译时进行依赖检查,不容易出错  \n◇一般用于敏捷开发\n### Java Config核心注解  \n◇项目演示见s08。\n![image.png](SpringIoc容器与Bean管理/1632712740006-91604ef1-c78a-44ca-b1f0-50eac3ea237c.png)\n◇使用config类代替xml配置\n\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.controller.UserController;\nimport com.lcg.spring.ioc.dao.EmployeeDao;\nimport com.lcg.spring.ioc.dao.UserDao;\nimport com.lcg.spring.ioc.service.UserService;\nimport org.springframework.context.annotation.*;\n\n@Configuration //指明当前类是一个配置类,用于替代applicationContext.xml\n@ComponentScan(basePackages = \"com.lcg\")//进行扫描\npublic class Config {\n    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名\n    public UserDao userDao(){\n        UserDao userDao = new UserDao();\n        System.out.println(\"已创建\" + userDao);\n        return userDao;\n    }\n\n    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名\n    @Primary\n    public UserDao userDao1(){\n        UserDao userDao = new UserDao();\n        System.out.println(\"已创建\" + userDao);\n        return userDao;\n    }\n\n    @Bean\n    //先按name尝试注入,name不存在则按类型注入\n    public UserService userService(UserDao udao , EmployeeDao employeeDao){\n        UserService userService = new UserService();\n        System.out.println(\"已创建\" + userService);\n        userService.setUserDao(udao);\n        System.out.println(\"调用setUserDao:\" + udao);\n        userService.setEmployeeDao(employeeDao);\n        return userService;\n    }\n\n    @Bean //<bean id=\"xxx\" clas=\"xxx\">\n    @Scope(\"prototype\")\n    public UserController userController(UserService userService){\n        UserController userController = new UserController();\n        System.out.println(\"已创建\" + userController);\n        userController.setUserService(userService);\n        System.out.println(\"调用setUserService:\" + userService);\n        return userController;\n    }\n}\n\n```\n◇Java Config初始化方式\n```java\npublic class SpringApplication {\n    public static void main(String[] args) {\n        //基于Java Config配置IoC容器的初始化\n        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        System.out.println(\"=========================\");\n        String[] ids = context.getBeanDefinitionNames();\n        for(String id : ids){\n            System.out.println(id + \":\" + context.getBean(id));\n        }\n    }\n}\n```\n## Spring单元测试\n### Spring Test 测试模块  \n◇Spring Test是Spring中用于测试的模块 \n◇Spring Test对JUnit单元测试框架有良好的整合 \n◇通过Spring Test可在JUnit在单元测试时自动初始化IoC容器  \n### Spring与JUnit4整合过程 \n◇Maven工程依赖spring-test \n◇利用@RunWith与@ContextConfiguration描述测试用例类 \n◇测试用例类从容器获取对象完成测试用例的执行\n### 代码演示\n  ◇核心配置pom.xml\n```java\n<dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n```\n◇applicationContext配置文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"userDao\" class=\"com.lcg.spring.ioc.dao.UserDao\">\n    </bean>\n    <bean id=\"userService\" class=\"com.imooc.spring.ioc.service.UserService\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n</beans>\n```\n◇dao类(模拟功能)\n```java\npublic class UserDao {\n    public void insert(){\n        System.out.println(\"新增用户数据\");\n    }\n}\n```\n◇service类\n```java\npublic class UserService {\n    private UserDao userDao;\n\n    public void createUser(){\n        System.out.println(\"调用创建用户业务代码\");\n        userDao.insert();\n    }\n\n    public UserDao getUserDao() {\n        return userDao;\n    }\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n}\n```\n◇测试用例类\n```java\nimport com.lcg.spring.ioc.service.UserService;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport javax.annotation.Resource;\n\n//将Junit4的执行权交由Spring Test模块,在测试用例执行前自动初始化IoC容器\n@RunWith(SpringJUnit4ClassRunner.class)//RunWith运行器\n//此注解说明要加载哪个配置文件,locations是一个数组,保存配置文件位置\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class SpringTestor {\n    @Resource\n    private UserService userService;//进行属性的注入\n\n    @Test\n    public void testUserService(){\n        userService.createUser();//在测试用例中进行调用\n    }\n}\n```\n\n\n\n","tags":["Spring"],"categories":["Spring","Spring基础"]},{"title":"Redis入门","url":"/p/d40.html","content":"## Redis介绍 \n◇Redis是Key-Value型NoSQL数据库 ,即每一个数据都有键和值；\n◇Redis将数据存储在内存中，同时也能持久化到磁盘 \n◇Redis常用于缓存，利用内存的高效提高程序的处理速度  \n\n## Redis特点 \n①速度快 ②广泛的语言支持 ③持久化 ④多种数据结构 ⑤主从复制 ⑥分布式与高可用 \n\n## Redis的安装与启动 \n### 在Linux系统中安装Redis \n◇进入[redis官网](https://redis.io/)\n◇创建redis目录，安装gcc用于make编译\n◇安装命令\n\n```\n$ wget https://download.redis.io/releases/redis-5.0.2.tar.gz\n$ tar xzf redis-5.0.2.tar.gz\n$ cd redis-5.0.2\n$ make\n```\n◇启动redis: 在src目录中redis-server开启服务器；redis-cli进行客户端连接；\n◇[root@master redis-5.0.2]# ./src/redis-server redis.conf #启动命令\n\n### 在Windows系统中安装Redis  \n◇进入github[下载](https://github.com/MicrosoftArchive/redis)\n◇点击releases，下载zip文件进行解压\n◇在终端(cmd)进入解压目录中，dir查看文件；\n◇安装命令：redis-server  redis.windows.conf\n◇由于Windows的版本过旧，仅做学习使用；\n\n## Redis的常用基本配置  \n![image.png](Redis入门/1630301413623-fa8ca9d5-879a-45c2-9331-146cbba40f2f.png)\n◇编辑redis.conf（配置文件）定位到136行，有一个daemonize（是否后台运行，守护进程)，改为yes即可进行守护；这样启动后，不会出现redis的logo并且启动会只要虚拟机运行，则redis一直提供服务；netstat -tulpn#查看系统占用的端口，进而查看redis是否运行；若要关闭redis，可以杀死进程或者利用客户端关闭；\n◇redis-cli即redis客户端，用来执行redis指令；进入方法：./src/redis-cli 退出命令：exit\n◇在客户端使用命令:ping 若出现PONG 则说明redis正常运行；关闭redis进程：./src/redis-cli shutdown\n◇在redis.conf文件可以使用vim命令修改相关配置；\n◇修改redis端口后需要指定端口进行连接， ./src/redis-cli -p 6380 #指定6380端口进行连接\n◇redis的数据库名字为数字0~15；如果觉得数据库数量不够用，可以在配置文件中设置，在大概186行出的databases进行修改;\n◇在配置文件的507行有个#requirepass foobared,说明默认密码是foobared，将注释取消，修改为12345。这样在使用redis时需要使用密码了。在启动后，输入命令：auth 12345即可\n◇在263行，有dir ./即数据的保存目录；dump.rdb就是redis的全量备份。\n\n## Redis通用命令  \n![image.png](Redis入门/1630301443965-582fbcdb-70a6-42ef-8a1b-d04ef40c75fe.png)\n◇示例\n\n```\n./src/redis-cli -p 6379 #连接客户端\nauth 12345 #输入密码\nselect 0 #选择0号数据库\nset name lily #在当前数据库中增加一个key=name,value=lily的数据\nget name #获取数据\nset name lee #会将前面的数据覆盖掉\nkeys * #查询所有的key\ndbsize #显示当前数据库的数据总量\ndel name #删除name这个key\n```\n## Redis数据类型  \n◇ String - 字符串类型     ◇ Hash - Hash类型 \n◇ List - 列表类型             ◇ Set - 集合类型 \n◇ Zset - 有序集合类型  \n\n## String 字符串类型 \n\n◇是Redis最中最基本的类型，其中String中字符串的操作命令如下\n\n| 命令          | 示例                           | 说明                      |\n| ------------- | ------------------------------ | ------------------------- |\n| get           | get code                       | 获得key=code的结果        |\n| set           | set code 0000                  | 设置key=code,value = 0000 |\n| mset          | mset code 0000 msg error       | 一次性设置多个键值对      |\n| mget          | mget code msg                  | 一次性获取多个键的值      |\n| del           | del code                       | 删除key=code              |\n| incr/decr     | incr count /decr count         | key值自增/自减1           |\n| incrby/decrby | incr count 22/ decrby count 33 | 自增自减指定步长          |\n\n## Hash键值类型   \n◇Hash类型用于存储结构化数据  \n![image.png](Redis入门/1630301642145-939a3186-55d0-47e9-a6fc-7c83e0178a14.png)\n\n## Hash 命令  \n![image.png](Redis入门/1630301692289-f55f142a-ad1a-4e01-bf37-bf1c9d1b3503.png)\n## List列表类型 \n◇List列表就是一系列字符串的“数组”，按插入顺序排序 \n◇List列表最大长度为2的32次方-1，可以包含40亿个元素  \n\n## List 命令  \n◇rpush listkey c b a - 右侧插入 \n◇lpush listkey f e d - 左侧插入 \n◇插入结果：d e f c b a\n◇rpop listkey - 右侧弹出 \n◇lpop listkey - 左侧弹出  \n\n## List 指令  \n◇llen listkey - 获取长度 \n◇lrange listkey 0 2\n◇lrange listkey 1 -1 获取子集  \n## Set与Zset集合类型 \n◇Set集合是字符串的无序集合，集合成员是唯一的 \n◇Zset集合是字符串的有序集合，集合成员是唯一的  \n\n## Java客户端-Jedis \n◇Jedis是Java语言开发的Redis客户端工具包 \n◇Jedis只是对Redis命令的封装,掌握Redis命令便可轻易上手  \n\n### Jedis使用演示  \n◇编辑配置文件redis.conf，在88行处：protected-mode yes #是否开启保护模式，设置为no关闭，允许其他ip主机连接进来\n◇在69行处bind 127.0.0.1改为0.0.0.0表示任意ip主机都可以访问进来；\n◇设置防火墙放行6379端口：firewall-cmd --zone=public --add-port=6379/tcp --permanent; firewall-cmd --reload#重载\n◇查看redis服务器的IP地址\n◇Windows上[下载jedis](https://github.com/redis/jedis)\n◇利用maven进行下载\n\n```xml\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>2.9.0</version>\n</dependency>\n```\n### 在IDEA中创建maven工程\n◇JedisTestor\n```java\npublic class JedisTestor {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"192.168.132.144\" , 6379);//虚拟机IP地址，redis服务器端口号\n        try {\n            jedis.auth(\"12345\");//输入密码\n            jedis.select(2);\n            System.out.println(\"Redis连接成功\");\n            //字符串\n            jedis.set(\"sn\" , \"7781-9938\");\n            String sn = jedis.get(\"sn\");\n            System.out.println(sn);\n            jedis.mset(new String[]{\"title\" , \"婴幼儿奶粉\" , \"num\" , \"20\"});\n            List<String> goods =  jedis.mget(new String[]{\"sn\" , \"title\" , \"num\"});\n            System.out.println(goods);\n            Long num = jedis.incr(\"num\");\n            System.out.println(num);\n            //Hash\n            jedis.hset(\"student:3312\" , \"name\" , \"张晓明\");\n            String name = jedis.hget(\"student:3312\" , \"name\");\n            System.out.println(name);\n            Map<String,String> studentMap = new HashMap();\n            studentMap.put(\"name\", \"李兰\");\n            studentMap.put(\"age\", \"18\");\n            studentMap.put(\"id\", \"3313\");\n            jedis.hmset(\"student:3313\", studentMap);\n            Map<String,String> smap =  jedis.hgetAll(\"student:3313\");\n            System.out.println(smap);\n            //List\n            jedis.del(\"letter\"); //将letter列表删除,否则后面会依次叠加\n            jedis.rpush(\"letter\" , new String[]{\"d\" , \"e\" , \"f\"});\n            jedis.lpush(\"letter\" ,  new String[]{\"c\" , \"b\" , \"a\"});\n            List<String> letter =  jedis.lrange(\"letter\" , 0 , -1);\n            jedis.lpop(\"letter\");\n            jedis.rpop(\"letter\");\n            letter = jedis.lrange(\"letter\", 0, -1);\n            System.out.println(letter);\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally {\n            jedis.close();\n        }\n\n    }\n}\n```\n### 利用Jedis缓存数据  \n◇创建实体类Good\n```java\npublic class Goods {\n    private Integer goodsId;\n    private String goodsName;\n    private String description;\n    private Float price;\n    ...\n}\n\n```\n◇创建缓存示例类\n```java\n\npublic class CacheSample {\n    public CacheSample(){\n        Jedis jedis = new Jedis(\"192.168.132.144\");\n        try {\n            List<Goods> goodsList = new ArrayList<Goods>();\n            //初始化模拟数据\n            goodsList.add(new Goods(8818, \"红富士苹果\", \"\", 3.5f));\n            goodsList.add(new Goods(8819, \"进口脐橙\", \"\", 5f));\n            goodsList.add(new Goods(8820, \"进口香蕉\", \"\", 25f));\n            jedis.auth(\"12345\");\n            jedis.select(3);//选择redis的三号数据库\n            //将每一个二进制存储的java对象序列化为json字符串以便redis存储\n            for (Goods goods : goodsList) {\n                String json = JSON.toJSONString(goods);\n                System.out.println(json);\n                String key = \"goods:\" + goods.getGoodsId();\n                jedis.set(key , json);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            jedis.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new CacheSample();\n        System.out.printf(\"请输入要查询的商品编号：\");\n        String goodsId = new Scanner(System.in).next();\n        Jedis jedis = new Jedis(\"192.168.132.144\");\n        try{\n            jedis.auth(\"12345\");\n            jedis.select(3);\n            String key = \"goods:\" + goodsId;\n            if(jedis.exists(key)){\n                String json = jedis.get(key);\n                System.out.println(json);\n                //json字符串转换为java对象\n                Goods g = JSON.parseObject(json, Goods.class);\n                System.out.println(g.getGoodsName());\n                System.out.println(g.getPrice());\n            }else{\n                System.out.println(\"您输入的商品编号不存在，请重新输入！\");\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally {\n            jedis.close();\n        }\n    }\n}\n\n```\n\n","tags":["Redis"],"categories":["Java数据库","Linux与Redis基础"]},{"title":"Linux基础和Java环境搭建","url":"/p/c40f.html","content":"## 内容简介\n◇Linux基础入门\n![image.png](Linux基础和Java环境搭建/1629881600929-861c5540-c71f-4186-b9f5-ae2f5453bf19.png)\n◇Linux进阶应用\n![image.png](Linux基础和Java环境搭建/1629902441633-e553b490-a782-4a8c-bf13-112f3324acb5.png)\n◇Redis应用入门\n![image.png](Linux基础和Java环境搭建/1629902552805-78f40e53-3374-43dc-8d18-b673821de5ad.png)\n\n## 主要知识点\n◇介绍Linux与CentOS      ◇讲解Linux基础命令 \n◇yum应用安装与卸载     ◇CentOS的权限与系统安全 \n◇Linux文本工具与命令   ◇部署OA项目至Linux服务器  \n## 操作系统\n### 什么是操作系统 \n◇操作系统(Operating System)是应用程序运行的基础支撑环境 \n◇操作系统作用是管理和控制计算机系统的硬件与软件资源 \n◇Intel x86架构上常见的操作系统:Windows、Linux、Unix...  \n\n### Linux操作系统\n◇Linux是开源的基于Intel x86架构的类Unix多用户操作系统 \n◇Linux是目前最主要的服务器端操作系统 \n◇互联网大厂都在使用Linux作为服务器主要操作系统  \n### Linux为什么受欢迎 \n◇免费使用，自由传播    ◇支持多任务、多用户、多CPU \n◇高效而灵活                  ◇兼容任意x86架构计算机 \n◇强大易用的系统命令    ◇完整的应用软件生态  \n\n### Linux发行版本 \n◇Linux系统内核(kernel)提供了Linux操作系统的核心功能 \n◇不同开发商在内核基础上扩展封装,形成了不同发行版本 \n◇常见发行版：Red Hat Linux、CentOS、Ubuntu、SUSE...  \n### Linux发行版选择建议 \n◇桌面系统:Ubuntu\n◇服务器操作系统: CentOS（免费）、Red Hat Linux（收费） \n◇特定需求: Debian(稳定性)、Fedora(新特性)、麒麟Linux(国产)  \n## CentOS - 社区企业操作系统\n### 简介\n◇基于Red Hat Enterprice Linux 的开源企业级Linux发行版本 \n◇各版本CentOS都会获得十年的支持,与RHEL保持同步更新 \n◇CentOS采用社区支持,同时修正了RHEL许多BUG   \n### CentOS版本选择 \n◇CentOS 5/6 : 历史版本,已被淘汰 \n◇CentOS 7 : 主流版本,稳定成熟,大多数服务器的首选版本 \n◇CentOS 8 : 全新版本,基于最新内核,不排除存在漏洞隐患  \n## 安装CentOS 7.7  \n### CentOS 7 运行要求 \n◇CPU : 1核,建议2核以上 \n◇内存 : 1G,建议2G以上 \n◇硬盘 : 预留20G可用空间  \n### 开启CPU虚拟化\n◇Ctrl+Alt+Delete打开任务管理器->性能->查看右下角虚拟化是否已启用\n◇若未启动,则应开启CPU虚拟化，由于电脑型号不同，具体方法可百度\n### 安装VMware Workstation虚拟机\n◇[在VMware中搭建CentOS ](https://blog.csdn.net/weixin_36522099/article/details/106959969) \n## Linux系统目录\nLinux倒挂树形目录结构  \n![image.png](Linux基础和Java环境搭建/1629975406516-bb1ea1f7-fab0-4da8-8303-a12633159db2.png)\n◇\"/\"是所有目录的顶点,称为\"根目录\" \n◇不同目录下的数据可分布在不同磁盘,所有目录按规则组织与命名 \n◇Linux也区分绝对路径与相对路径  \n### 常见系统目录\n![image.png](Linux基础和Java环境搭建/1629975580379-b983d605-acc6-4e15-be66-c7eb638aea3d.png)\n![image.png](Linux基础和Java环境搭建/1629975605738-db5bbc1c-10c7-45fa-a10f-b3dda57685e7.png)\n\n## Linux远程管理\n### SSH客户端\n ◇SSH是专为远程登录和其他网络服务提供的安全性协议 \n◇SSH分为两个不兼容版本1.x与2.x,默认通过SSH2.x连接 \n◇基于SSH远程连接工具有很多,最常见的是Xshell与SecureCRT \n### Xshell与Xftp \n◇Xshell是著名的Linux客户端,常用于在Windows下远程访问 \n◇Xshell同时还支持Telent、RLogin、Serial等其他连接方式 \n◇Xftp是Xshell配套组件，用于向服务器上传/下载文件  \n### Xshell与Xftp安装与配置  \n◇在官方网站安装个人版\n◇在虚拟机终端输入ifconfig查看虚拟机的ip地址\n◇新建xshell会话，连接后输入用户名和密码即可\n<img src=\"Linux基础和Java环境搭建/1629978963671-fd31e45c-c4c0-4fc0-b4eb-a66bd9787a1c.png\" alt=\"image.png\" style=\"zoom: 67%;\" />\n◇在Xshell顶部绿色的新建文件传输打开，可以进行文件的传输\n![image.png](Linux基础和Java环境搭建/1629979354707-b035a667-88ab-4732-b0de-37ad49bfbcb7.png)\n\n## Linux文件操作命令\n### Linux命令格式 \n◇命令 [参数选项] [文件或路径] \n### Linux文件操作核心命令 \n![image.png](Linux基础和Java环境搭建/1629979553331-35a0fe9d-22c7-4753-a083-a1a9916b591d.png)\n◇clear     清屏   ◇rmdir 删除空目录\n◇cd时输入某个路径的前一个字母后可以按Tab进行自动补全\n◇命令 --help可以查看命令的参数等相关信息\n◇mv 重命名格式：mv old.c  new.c ;移动格式：mv old.c /xx/xx 也可以移动整个文件夹\n◇不要轻易使用rm -rf，这样会强制迭代删除而不进行询问，rm -r迭代删除进行询问\n\n### vim文本编辑器 \n◇vi是Linux重要的文字编辑工具,vim是它的增强版 \n◇vim用于在远程环境下用命令形式对文本进行在线编辑 \n◇用法格式: vim [选项] [文件] \n### vim三种模式 \n◇普通模式:默认模式,文本只读,不可编辑 \n◇编辑模式:编辑文本模式,普通模式按i键进入,Esc键退出 \n◇命令模式:执行保存、搜索、退出等操作\n### vim重要快捷键\n![image.png](Linux基础和Java环境搭建/1629980002766-5c22ebbf-1dc8-4840-9a9b-44410e4e2520.png)\n## Linux文本工具\n### 常用文本工具   \n![image.png](Linux基础和Java环境搭建/1630068704114-ec0a4e45-4072-42bc-8618-ee730f5ffd2e.png)\n### 文件输入与输出 \n◇文件输入：< (重写) 或者 << (追加)          ◇文件输出：> (重写) 或者 >> (追加) \n◇echo \"xxxx\" >> log.txt 将xxxx文本追加写入到log.txt文件中\n◇合并文件：cat hello.txt myname.txt >> full.txt\n◇tail full.txt --显示文件尾部内容;   tail -n 2 full.txt --显示文件最后两行\n◇tail -f full.txt --动态监测文件末尾所产生的新行; ctrl+c退出\n◇grep lcg test.txt --查找test.txt文件中包含lcg字符串的文本行,字符串可以是正则表达式\n◇grep -v lcg test.txt --查找test.txt文件中不包含lcg字符串的文本行\n◇ll | grep -E \"log[0-9]{1,5}.txt\" --进行文件的筛选，查看所有日志文件 -E表示使用扩展正则表达式；{1,5}表示数字位数为1~5；\n\n## 文件打包与压缩 \n### Linux压缩程序-gzip \n◇gzip是Linux系统的文件压缩程序 \n◇gzip压缩包文件扩展名.gz \n◇大流量的网站默认都在使用gzip进行数据压缩传输   \n\n### tar打包与压缩 \n◇tar是Linux系统将多个文件打包和压缩的工具 \n◇tar本质是打包软件，扩展名.tar \n◇tar可结合gzip或其他压缩工具实现打包压缩，扩展名.tar.gz \n◇压缩命令: tar zcvf tomcat.tar.gz /usr/local/tomcat \n◇解压缩命令: tar zxvf tomcat.tar.gz -C /usr/local/tomcat   \n\n### tar常用可选项 \n\n###  \n\n| 选项 | 用途               |\n| ---- | ------------------ |\n| z    | 通过gzip压缩或解压 |\n| c    | 创建新的tar.gz文件 |\n| v    | 显示执行过程       |\n| f    | 指定压缩文件名称   |\n| x    | 解压缩tar.gz文件   |\n| -C   | 指定解压缩目录     |\n\n## 安装与卸载应用程序  \n### 为CentOS安装应用程序 \n◇在CentOS中安装第三方应用程序包含两种方式:\n◇rpm:Red Hat软件包管理器,相当于应用程序安装文件的执行者 \n◇编译安装:用户自己从网站下载程序源码进行编译安装 \n### yum与rpm的关系 \n◇rpm安装过程中,需要用户自己解决依赖问题 \n◇yum通过引入软件仓库,联网下载rpm包及依赖,并依次自动安装 \n◇yum是rpm的前端程序,其目的就是简化rpm的安装过程\n\n### yum常用命令 \n◇yum search 应用名 #在仓库中查询是否存在指定应用 \n◇yum install -y 应用名 #全自动下载安装应用及其依赖  \n◇yum info 应用名 #查看软件详细信息 \n◇yum list installed 应用名 #查看已安装的应用程序 \n◇rpm -ql 应用名 #查看安装后输出的文件清单 \n◇yum remove -y 应用名 #全自动卸载指定应用  ，-y表示遇到询问都用y\n\n## 编译方式安装 \n### 编译方式安装应用程序\n◇如yum仓库未提供rpm,往往需要采用编译安装方式 \n◇编译安装是指从应用官网下载源码后,对源码进行编译后使用 \n◇编译命令: make #使用对应编译器对源码编译生成可执行文件  \n### yum与编译安装比较  \n![image.png](Linux基础和Java环境搭建/1630070373099-9af554f6-920f-4c76-9782-70dc5c1dc783.png)\n### 编译安装Redis\n◇利用xftp将下载好的压缩包文件上传到linux；然后解压；进入redis-4.0.14目录；安装gcc编译器：yum install -y gcc;\n◇有时候第一次make编译出错后，可能改变了原来的文件结构，因此纠正错误后下一次编译时需要将解压后的目录删除重新解压；当出现Hint: It's a good idea to run 'make test' ;)时代表编译成功；\n◇编译安装后的应用程序redis-server存放在src中，在启动redis-server前需要加载上一级目录下的redis.conf配置文件;即启动命令为:./src/redis-server redis.conf  启动后ctrl+c退回命令状态\n## Linux进阶应用\n### Linux系统管理命令\n◇使用ifconfig查看网卡ip\n![image.png](Linux基础和Java环境搭建/1630146548264-3229c8fc-d16f-4ace-9c4b-4d140a726bc0.png)\n◇netstat 查看网络端口号：netstat -tulpn 或 netstat -ano\n◇Recv-Q:接收队列；Send-Q:发送队列; LISTEN表示网络状态正在被监听;PID:进程编号；Program name创建网络连接的应用\n![image.png](Linux基础和Java环境搭建/1630146738224-1f08c511-0871-4f93-8fdc-1b45678b64a5.png)\n◇netstat 常用选项\n\n| 选项 | 用途                       |\n| ---- | -------------------------- |\n| t    | 显示tcp传输协议的连接状况  |\n| u    | 显示udp传输协议的连接状况  |\n| l    | 显示处于监听状态的网络连接 |\n| p    | 显示应用PID和程序名称      |\n| n    | 显示ip地址                 |\n| a    | 显示所有连接               |\n| o    | 显示计时器                 |\n\n◇查看进程: ps -ef ，箭头处5412指PID；杀掉进程：kill -9 PID\n◇一般使用应用程序退出来关闭进程，而不是强制杀掉进程，因为可能造成数据丢失\n◇ps -ef | grep vim ; | 表示通道，即ps -ef查询产生的数据像通过通道一样送入到后一个指令\n![image.png](Linux基础和Java环境搭建/1630147070833-32dca895-ace6-45ad-a972-0cb3f0471b45.png)\n\n## 应用服务化  \n### 简介\n◇ 应用服务化是指让应用程序以服务方式在系统后台运行 \n◇ Linux系统对服务化应用进行统一管理 \n◇ 服务管理命令：systemctl    \n\n### systemctl  \n\n| 指令            | 用途             |\n| --------------- | ---------------- |\n| start           | 启动服务         |\n| stop            | 停止服务         |\n| restart         | 重启服务         |\n| enable          | 设置开机启动     |\n| disable         | 禁止开启启动     |\n| status          | 查看服务状态     |\n| daemon-reload   | 重载服务配置文件 |\n| list-unit-files | 列出所有服务     |\n\n◇.pid文件用来保存进程编号\n◇将redis服务化，需要在/usr/lib/systemd/system目录下创建 vim redis.service；在文件中写入配置：\n\n```\n[Unit]\nDescription=Redis\nAfter=syslog.target network.target remote-fs.target nss-lookup.target #表示在这些服务启动以后才能启动redis\n\n[Service]\nType=forking #forking代表后台运行\nPIDFile=/run/redis_6379.pid\n#说明启动时执行server，加载配置文件\nExecStart=/home/lcg/0/redis-4.0.14/src/redis-server /home/lcg/0/redis-4.0.14/redis.conf\n#关闭,-s采用正常流程进行退出；-9表示强制退出\nExecStop=/bin/kill -s QUIT $MAINPID\nPrivateTmp=True #为每一个服务设置私有的Tmp临时文件目录\n\n[Install]\nWantedBy=multi-user.target #将当前的redis服务分配到multi-user服务组上；\n```\n◇systemctl daemon-reload #对所有service进行重载;\n◇systemctl start redis #启动服务； systemctl status redis #查看状态\n## Linux用户与权限 \n### 用户 \n◇ Linux是多用户多任务系统,包含两个概念:用户与用户组 \n◇ 用户与账户是同一概念,用于登录系统与区分资源权限 \n◇ 用户让系统变的更安全,同时也保护了用户的个人数字资产\n### 用户组 \n◇ 用户组就是将用户分组,隶属用户自动拥有组权限 \n◇ 一个用户可隶属于多个组,用户可任意切换当前组 \n◇ 用户组的出现让用户权限管理变更轻松 \n### 用户与用户组常用命令  \n\n| 命令     | 用途                          |\n| -------- | ----------------------------- |\n| useradd  | 创建新用户                    |\n| passwd   | 修改密码                      |\n| usermod  | 修改用户信息/分配组(覆盖原组) |\n| groupadd | 创建新的用户组                |\n| chown    | 更改文件的属主或属组          |\n| chmod    | 更改文件的访问权限            |\n| newgrp   | 切换用户当前组                |\n\n◇分组：usermod -g [组名] [用户名]\n◇让用户拥有多个组： usermod -G [组名1],[组名2] [用户名];通过newgrp进行切换\n◇将用户连接系统: 打开->创建系统副本：然后用新建的用户密码登录\n◇groups #查看用户隶属于哪个组\n◇chown用法：chown [用户名]:[组名] [文件名]\n\n## 项目内部文件权限管理实践 \n### 文件权限代码表  \n![image.png](Linux基础和Java环境搭建/1630153162614-19019fff-aa2c-483e-83e3-46715e47ab51.png)\n◇每个颜色表示一组，共三组；eg:drwxr-xr-x; 其中-代表没有对应属性，此处即没有w(完整的一组是rwx)\n◇在目录上r-x不允许写是指不准修改目录名\n\n### chmod命令 \n◇ chmod 750: 组用户可读写，其他用户不允许访问 \n◇ chmod 777: 所有用户拥有完整权限 \n◇ chmod 700: 只有属主拥有完整权限 \n◇chmod  750 dev-document/(文件名/) #示例操作，\n### sudo超级管理员命令\n◇ sudo可以让普通用户拥有超级管理员的执行权限 \n◇ 普通用户要进行经过超级管理员授权才能使用 \n◇ 授权命令：visudo  \n◇普通模式下输入：100gg 快速定位到100行,无法再屏幕上看到命令；在此处的root ALL-(ALL) ALL下增加一行：\n[用户名] ALL-(ALL) ALL 即可授权用户拥有sudo命令；第一个ALL代表用户可以从任意计算机进行连接；第二个ALL表示切换用户，最后一个ALL代表运行执行所有命令；\n◇:wq保存文件后，使用命令visudo -c进行文件的格式检查;\n## CentOS7防火墙firewall\n### 什么是防火墙 \n◇ 防火墙是借助硬件和软件对内外部网络环境的保护措施 \n◇ CentOS 7基于firewall实现应用层防火墙,CentOS6基于iptables \n◇ firewall-cmd是firewall的核心命令 \n### firwall-cmd \n◇ systemctl start|restart firewalld #启动防火墙 \n◇ firewall-cmd --state | --reload #查看状态,重载防火墙 \n◇ firewall-cmd --zone=public --permanent --add-port=8502/tcp  \n### 对外开放Tomcat  \n◇解压apache-tomcat-9.0.34.tar.gz；进入apache-tomcat-9.0.34/bin目录启动startup.sh文件：./startup.sh \n◇增加放行端口：firewall-cmd --zone=public --permanent --add-port=8080/tcp #zone代表区域；permanent表示永久更改；将add改成remove即可去除端口;8000-9000可以用来进行端口范围的设置\n◇将防火墙进行重载\n## Bash Shell\n### 什么是Shell \n◇ Shell是一个用c语言编写的脚本解释器,是用户通过代码操作 Linux的桥梁 \n◇ Shell脚本描述要执行的任务,完成系列复杂操作,文件通常以.sh后缀 \n◇ Shell脚本通过Shell解释器执行,按解释器分类分为多种类型  \n\n### Linux Shell 分类\n\n| Shell种类          | Shell解释器          |\n| ------------------ | -------------------- |\n| Bourne Shell       | /usr/bin/sh或/bin/sh |\n| Bourne Again Shell | /bin/bash(默认)      |\n| C Shell            | /usr/bin/csh         |\n| K Shell            | /usr/bin/ksh         |\n| Shell for Root     | /sbin/sh             |\n\n### 一键发布Tomcat应用程序\n◇vim deploy_tomcat.sh创建脚本\n```\necho \"准备下载Tomcat9\"\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.52/bin/apache-tomcat-9.0.52.tar.gz\necho \"正在解压Tomcat9\"\ntar zxf apache-tomcat-9.0.52.tar.gz\necho \"防火墙开放8080端口\"\nfirewall-cmd --zone=public --permanent --add-port=8080/tcp\nfirewall-cmd --reload\necho \"启动Tomact\"\ncd ./apache-tomcat-9.0.52/bin\n./startup.sh\n```\n◇启动脚本文件：/bin/bash deploy_tomcat.sh;或./deploy.tomcat.sh\n## 部署OA项目\n### 部署架构\n![image.png](Linux基础和Java环境搭建/1630243029737-67057a7c-0650-4d8c-b630-bd8eab42b589.png)\n◇创建两个虚拟机CentosDB,CentosWEB，均最小化安装(不要图形界面);然后在界面输入: yum install -y net-tools.x86_64 #安装ifconfig等命令;\n◇使用Xshell进行远程连接；\n\n### Centos安装MySQL8\n◇yum search mysql-community #查看是否安装了mysql社区版\n◇mkdir mysql #在/usr/local目录下新建目录存放mysql\n◇wget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm) #获取下载\n◇yum install -y wget #安装wget 命令\n◇yum localinstall -y mysql80-community-release-el7-3.noarch.rpm #从本地安装rpm文件\n◇以上只是安装了mysql的安装源，还没有完成mysql的安装；\n◇yum install -y mysql-community-server #进行安装   ctrl+c可以停止安装\n◇cd /var/cache/yum/x86_64/7/mysql80-community/packages/ #进入yum下载的缓存路径\n◇进入官网找到Mysql Red Hat Enterprise Linux/ Oracle Linux；选择系统版本Linux 7 X86_64； 下载RPM Bundle；然后将这一组rpm文件传到缓存路径中；此时重新执行yum install -y mysql-community-server命令；以此可解决跨国服务器下载缓慢问题；\n◇systemctl start mysqld #启动服务  systemctl status mysqld #查看服务状态\n◇systemctl enable mysqld #设置为开机启动\n\n### 初始化MySQL8\n◇vi  /var/log/mysqld.log #进入mysql日志 在第3~4行可以看到自动生成的密码\n◇mysql -uroot -p #输入密码进行登录\n◇alter user 'root'@'localhost' identified with mysql_native_password by 'newpassword'(需要包含字母大小写以及数字，特殊符号，长度大于8位) 回车加上';' 即可修改，with mysql_native_password做与navicat的兼容考虑；\n◇默认的root用户只能从本机登录；use mysql #使用数据库； select host,user from user;#查询主机和用户\n◇update user set host='%' where user='root';#将root用户的host改为%,即任意设备都可以使用root用户连接mysql服务器; flush privileges #使刚才修改的权限立即生效\n◇exit #退出mysql\n◇放行3306端口并重载，使之能够远程访问mysql；\n◇打开Navicat，新建连接：主机即虚拟机的IP地址；\n\n### 部署配置Web应用服务\n◇yum search jdk #查看仓库中包含哪些版本的jdk;openjdk表示开源jdk\n◇yum install -y java-1.8.0-openjdk #安装jdk\n◇java -version #查看\n◇安装Tomcat;\n◇将oa项目的war包传到虚拟机中，解压；\n◇将解压后的oa目录移动：mv lcg_oa ./apache-tomcat-9.0.34/webapps/\n◇进入webapps目录，vim ./lcg_oa/WEB-INF/classes/mybatis-config.xml  (yum install vim-common#安装vim基础包，yum install vim-enhanced#安装增强包)\n◇/root全文查找，在连接字符串的地方进行调整；将localhost改为mysql服务器的IP地址，密码改为相应的密码\n◇回到上一层目录进行Tomcat的配置: vim ./conf/server.xml ->搜索/8080->将端口改为80->按pagedown跳到最后\n-\\>在Host标签上增加\\<Context path=\"/\" docBase=\"lcg_oa\"/\\>#将oa这个web应用映射的上下文路径指向根路径-\\>:wq保存\n◇启动tomcat：./bin/startup.sh\n◇放行80端口，并重载\n◇在虚拟机DB中，屏蔽掉任意主机都能访问的3306端口；重载；\n◇firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"web服务器的IP地址\" port protocol=\"tcp\" port=\"3306\" accept\" #-rich-rule利用规则放行端口，这样就能放行指定主机指定端口的访问;\n","tags":["Linux"],"categories":["Java数据库","Linux与Redis基础"]},{"title":"MyBaits进阶","url":"/p/fb2c.html","content":"## MyBatis日志管理  \n### 什么是日志 \n◇日志文件是用于记录系统操作事件的记录文件或文件集合 \n◇日志保存历史数据,是诊断问题以及理解系统活动的重要依据  \n### SLF4j与Logback \n![image.png](MyBatis进阶/1628599313923-5abfc2e2-0d7c-4efe-8078-f5601db8fca6.png)\n\n**代码示例**​\n◇配置依赖\n```xml\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n```\n ◇产生的日志(部分)\n```xml\n20:53:41.109 [main] DEBUG goods.selectByTitle - ==>  Preparing: select * from t_goods where title = ? order by title desc \n20:53:41.131 [main] DEBUG goods.selectByTitle - ==> Parameters: '' or 1=1 or title='【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版'(String)\n20:53:41.298 [main] DEBUG goods.selectByTitle - <==      Total: 0\n```\n◇自定义日志格式：在resource目录新建logback.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n  <!--ConsoleAppender是指在控制台输出日志 pattern指定日志输出格式，示例格式即\n  线程，时间，按5个字符右对齐，说明哪个类产生的日志(最多36字符超过压缩)，具体日志内容 换行 \n-->\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>[%thread] %d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <!--\n        日志输出级别(优先级高到低):\n        error: 错误 - 系统的故障日志\n        warn: 警告 - 存在风险或使用不当的日志\n        info: 一般性消息\n        debug: 程序内部用于调试信息\n        trace: 程序运行的跟踪信息\n     -->\n    <root level=\"debug\">\n        <appender-ref ref=\"console\"/>\n    </root>\n</configuration>\n```\n## MyBatis动态SQL\n ◇动态SQL是指根据参数数据动态组织SQL的技术  \n```xml\n<select id=\"dynamicSQL\" parameterType=\"java.util.Map\" resultType=\"com..Goods\">\nselect * from t_goods\n<where>\n<if test=\"categoryId != null\">\nand category_id = #{categoryId}\n</if>\n<if test=\"currentPrice != null\">\nand current_price &lt; #{currentPrice}\n</if>\n</where>\n</select>\n```\n◇示例代码\n```xml\n<select id=\"dynamicSQL\" parameterType=\"java.util.Map\" \n        resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods\n        <where>\n          <if test=\"categoryId != null\">\n              and category_id = #{categoryId}\n          </if>\n          <if test=\"currentPrice != null\">\n              and current_price &lt; #{currentPrice}  //小于号转义符\n          </if>\n        </where>\n    </select>\n\n    @Test\n    public void testDynamicSQL() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Map param = new HashMap();\n            param.put(\"categoryId\", 44);\n            param.put(\"currentPrice\", 500);\n            //查询条件\n            List<Goods> list = session.selectList(\"goods.dynamicSQL\", param);\n            for(Goods g:list){\n                System.out.println(g.getTitle() + \":\" +\n                        g.getCategoryId()  + \":\" + g.getCurrentPrice());\n\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## MyBatis二级缓存\n### 缓存简介\n◇我们从数据库中查询到某一条数据后，因为业务的要求还需要这条数据，那么按照原始的方法就还需要在数据库中查询到该数据；因为MySql是将数据存放在硬盘上的，而硬盘的读取访问速度不是特别快；而且我们这里第一次获取和第二次获取记录的时候，都返回相同的数据；因此我们可以在第一次查询数据时，将该数据暂时保存到内存的某一个区域中，第二次查询时直接从内存的对应区域取出即可，因为内存的访问速度快，这样就能够提高查询的速度；在Mybatis中存在了两级缓存；\n◇ 一级缓存默认开启,缓存的数据范围为SqlSession会话，即在一次SqlSession会话中，对数据库中的某个数据进行重复读取，Mybatis就会利用到这个缓存来提高程序的处理速度；\n◇ 二级缓存手动开启,属于范围Mapper Namespace ，范围比SqlSession大的多；\n### 缓存的范围  \n![image.png](MyBatis进阶/1628648358170-3c4957c8-1a4f-4c0b-9266-d477a41ad6d0.png)\n### 二级缓存运行规则 \n◇二级开启后默认所有查询操作均使用缓存 \n◇写操作使用commit提交时对该namespace缓存强制清空，保证商品一致性；如第一个用户查询到商品，而第二个用户将此商品名称改了，那么这时候就会将namespace缓存强制清空，第一个用户再次查询该商品时就得从数据库中获取了；\n◇配置useCache=false可以不用缓存 \n◇在某一sql语句中配置flushCache=true代表执行完该sql语句后强制清空缓存\n◇代码示例\n```java\n//测试一级缓存\n    @Test\n    public void testLv1Cache() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            //这里执行了两次sql查询，由于使用了缓存，所以在日志中可以看到只打印出一条sql语句\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            Goods goods1 = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode() + \":\" + goods1.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);//关闭了会话\n        }\n\n        try{\n            session = MyBatisUtils.openSession();\n            //由于前面关闭了会话，这里是新的会话，需要对数据库进行查询\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            session.commit();//commit提交时对该namespace缓存强制清空\n            //由于前面对缓存进行了强制清空，所以还需要访问数据库\n            Goods goods1 = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode() + \":\" + goods1.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n\n //测试二级缓存 \n //在mapper标签下添加cache标签\n<!--开启了二级缓存\n        eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除\n            1.LRU – 最近最久未使用:移除最长时间不被使用的对象。\n            O1 O2 O3 O4 .. O512\n            14 99 83 1     893\n            2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。\n            3.SOFT – 软引用:移除基于垃圾收集器状态和软引用规则的对象。\n            4.WEAK – 弱引用:更积极的移除基于垃圾收集器状态和弱引用规则的对象。\n            5.LFU - 最不经常使用：移除最近访问频率最低的对象\n      flushInterval代表间隔多长时间自动清空缓存，单位毫秒，600000毫秒为10分钟\n    -->\n    <cache eviction=\"LRU\" flushInterval=\"600000\" size=\"512\" readOnly=\"true\"/>\n\n    @Test\n    public void testLv2Cache() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n\n        try{\n            //这里虽然是新的会话，但是由于是二级缓存，所以还是可以从内存中提取数据；\n            session = MyBatisUtils.openSession();\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n◇缓存标签的属性：\n①eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除            \n②flushInterval代表间隔多长时间自动清空缓存，单位毫秒\n③size 缓存存储上限，用于保存对象或集合(1个集合算1个对象)的数量上限\n④readOnly 设置为true，代表返回只读缓存，每次从缓存取出的是缓存对象本身，这种执行效率较高\n                设置为false，代表每次取出的是缓存对象的\"副本\"，每一次取出的对象都是不同的，这种安全性较高\n◇一些缓存相关的属性：useCache=\"false\"代表查询结果不被放入缓存，常用于读取全部数据的SQL语句中\n执行完insert语句需要立即清空缓存，flushCache=\"true\"在sql执行后强制清空缓存 \n\n## MyBatis多表级联查询  \n### 实体关系分析  \n![image.png](MyBatis进阶/1628753256241-93038a3b-4c03-4530-ace1-ddb89972beda.png)\n### 商品和详情对象关联查询\n**一对多**\n◇增加实体类GoodsDetail\n```xml\npublic class GoodsDetail {\n    private Integer gdId;\n    private Integer goodsId;\n    private String gdPicUrl;\n    private Integer gdOrder;\n}\n```\n◇配置\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"goodsDetail\">\n    <select id=\"selectByGoodsId\" parameterType=\"Integer\"\n            resultType=\"com.lcg.mybatis.entity.GoodsDetail\">\n        select * from t_goods_detail where goods_id = #{value}\n    </select>\n</mapper>\n```\n◇表达一个Goods对象有多个GoodsDetail对象：在Goods类中增加private List&lt;GoodsDetail&gt;goodsDetails;\n◇Goods.xml中\n\n```xml\n<!--\n    resultMap可用于说明一对多或者多对一以及多表查询(前面学过)的映射逻辑\n    id 是resultMap属性引用的标志,需要和其他resultMap区分开\n    type 在一对多的关系中指向One的实体(Goods)\n-->\n<resultMap id=\"rmGoods1\" type=\"com.lcg.mybatis.entity.Goods\">\n    <!-- 映射goods对象的主键到goods_id字段 -->\n    <id column=\"goods_id\" property=\"goodsId\"></id>\n    <!--\n        collection(集合)专用于描述Goods实体中的goodsDetails这个List数据从哪来的; 其含义是,在\n        select * from t_goods limit 0,10 得到结果后,对所有Goods对象遍历得到goods_id字段值,\n        并代入到goodsDetail命名空间的 selectByGoodsId的SQL中执行查询,\n        将得到的\"商品详情\"集合赋值给goodsDetails 这个List对象.\n    -->\n    <collection property=\"goodsDetails\" select=\"goodsDetail.selectByGoodsId\"\n                column=\"goods_id\"/>\n</resultMap>\n<select id=\"selectOneToMany\" resultMap=\"rmGoods1\">\n    select * from t_goods limit 0,10\n</select>\n```\n◇在核心配置文件(mybatis-config.xml)中进行注册\n```xml\n    <mappers>\n        <mapper resource=\"mappers/goods.xml\"/>\n        <mapper resource=\"mappers/goods_detail.xml\"/>\n    </mappers>\n```\n◇测试\n```xml\n@Test\n    public void testOneToMany() throws Exception {\n        SqlSession session = null;\n        try {\n            session = MyBatisUtils.openSession();\n            List<Goods> list = session.selectList(\"goods.selectOneToMany\");\n            for(Goods goods:list) {\n               System.out.println(goods.getTitle() + \":\" + goods.getGoodsDetails().size());\n            }\n        } catch (Exception e) {\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n**多对一**\n◇在实体类GoodsDetail中增加private Goods goods;\n◇在goods_detail.xml文件中进行对像关联的描述\n\n```xml\n <resultMap id=\"rmGoodsDetail\" type=\"com.lcg.mybatis.entity.GoodsDetail\">\n        <!--主键关联-->\n        <id column=\"gd_id\" property=\"gdId\"/>\n        <!--结果关联-->\n        <result column=\"goods_id\" property=\"goodsId\"/>\n        <!--association关联标签，用于多对一-->\n        <association property=\"goods\" select=\"goods.selectById\" \n                     column=\"goods_id\"></association>\n    </resultMap>\n    <select id=\"selectManyToOne\" resultMap=\"rmGoodsDetail\">\n        select * from t_goods_detail limit 0,20\n    </select>\n```\n◇测试  项目见F:mybatis;\n## 分页插件PageHelper  \n### 分页查询的麻烦事 \n◇当前页数据查询 - select * from tab limit 0,10 \n◇总记录数查询 - select count(*) from tab \n◇程序计算总页数、上一页页码、下一页页码  \n◇MyBatis分页插件PageHelper[官方网站](https://pagehelper.github.io/)\n\n### pageHelper使用流程\n◇maven引入PageHelper与jsqlparser \n```xml\n       //pom.xml中\n       <dependency>\n            <groupId>com.github.pagehelper</groupId>\n            <artifactId>pagehelper</artifactId>\n            <version>5.1.10</version>\n        </dependency>\n        <dependency>\n            <groupId>com.github.jsqlparser</groupId>\n            <artifactId>jsqlparser</artifactId>\n            <version>2.0</version>\n        </dependency>\n```\n◇mybatis-config.xml增加Plugin配置 \n```xml\n    <plugins>\n        <plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\n            <!--设置数据类型 -->\n            <property name=\"helperDialect\" value=\"mysql\"/>\n            <!--分页合理化 -->\n            <property name=\"reasonable\" value=\"true\"/>\n        </plugin>\n    </plugins>\n```\n◇代码中使用PageHelper.startPage()自动分页  \n```xml\n    <select id=\"selectPage\" resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods where current_price &lt; 1000\n    </select>\n@Test\n    public void testSelectPage() throws Exception {\n        SqlSession session = null;\n        try {\n            session = MyBatisUtils.openSession();\n            /*startPage方法会自动将下一次查询进行分页*/\n            PageHelper.startPage(2,10);\n            Page<Goods> page = (Page) session.selectList(\"goods.selectPage\");\n            System.out.println(\"总的页数:\" + page.getPages());\n            System.out.println(\"总记录数:\" + page.getTotal());\n            System.out.println(\"开始行号:\" + page.getStartRow());\n            System.out.println(\"结束行号:\" + page.getEndRow());\n            System.out.println(\"当前页码:\" + page.getPageNum());\n            List<Goods> data = page.getResult();//当前页数据\n            for (Goods g : data) {\n                System.out.println(g.getTitle());\n            }\n            System.out.println(\"\");\n        } catch (Exception e) {\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## 不同数据库的分页实现\n###  MySQL分页  \n```xml\n//第一个参数代表起始行号，第二个是偏移量\nselect * from table limit 10,20;\n```\n###  Oracle  \n```sql\nselect t3.* from (\n select t2.*, rownum as row_num from ( --rownum是伪列：无需声明直接使用的列，将前20条数据筛选\n select * from table order by id asc --用于查询\n ) t2 where rownum<=20\n) t3 \nwhere t2.row_num>11 --第三层嵌套用于起始位置的筛选\n```\n###  SQL Server 2000  \n```sql\nselect top 3 * from table --top语句在sql语句执行完后获取前几条数据\nwhere \n id not in \n (select top 15 id from table)\n```\n###  SQL Server 2012+  \n```sql\nselect * from table order by id \n offset 4 rows fetch next 5 rows only --offset偏移量 fetch next向后取多少行\n --若id为1的话即从第5(1+4)行开始向后取5条数据\n```\n## MyBatis配置C3P0连接池\n◇pom.xml进行配置\n```sql\n        <dependency>\n            <groupId>com.mchange</groupId>\n            <artifactId>c3p0</artifactId>\n            <version>0.9.5.4</version>\n        </dependency>\n```\n◇在mybatis创建datasoutce包，再新建C3P0DataSourceFactory类，继承自UnpooledDataSourceFactory以便于连接\n```sql\n/**\n * C3P0与MyBatis兼容使用的数据源工厂类\n */\npublic class C3P0DataSourceFactory extends UnpooledDataSourceFactory {\n    public C3P0DataSourceFactory(){\n        this.dataSource = new ComboPooledDataSource();\n    }\n}\n```\n◇在mybatis-config.xml配置文件中将<dataSource>的type改为com.lcg.mybatis.datasource.C3P0DataSourceFactory;因为不同的连接池对属性的命名规则不同，所以有以下更改：driver->driverClass , url->jdbcUrl , username->user\n```xml\n            <dataSource type=\"com.lcg.mybatis.datasource.C3P0DataSourceFactory\">\n                <property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"jdbcUrl\" value=\"\"/>\n                <property name=\"user\" value=\"root\"/>\n                <property name=\"password\" value=\"www.LCG.com\"/>\n                <property name=\"initialPoolSize\" value=\"5\"/>\n                <property name=\"maxPoolSize\" value=\"20\"/>\n                <property name=\"minPoolSize\" value=\"5\"/>\n            </dataSource>\n```\n## MyBatis批处理  \n◇goods.xml增加批处理的SQL语句\n```xml\n <!--INSERT INTO table-->\n    <!--VALUES (\"a\" , \"a1\" , \"a2\"),(\"b\" , \"b1\" , \"b2\"),(....)-->\n    <insert id=\"batchInsert\" parameterType=\"java.util.List\">\n        INSERT INTO t_goods(title, sub_title, original_cost, \n      current_price, discount, is_free_delivery, category_id)\n        VALUES\n        <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\">\n          (#{item.title},#{item.subTitle}, #{item.originalCost},\n        #{item.currentPrice}, #{item.discount}, #{item.isFreeDelivery}, #{item.categoryId})\n        </foreach>\n    </insert>\n    @Test\n    public void testBatchInsert() throws Exception {\n        SqlSession session = null;\n        try {\n            long st = new Date().getTime();\n            session = MyBatisUtils.openSession();\n            List list = new ArrayList();\n            for (int i = 0; i < 10000; i++) {\n                Goods goods = new Goods();\n                goods.setTitle(\"测试商品\");\n                goods.setSubTitle(\"测试子标题\");\n                goods.setOriginalCost(200f);\n                goods.setCurrentPrice(100f);\n                goods.setDiscount(0.5f);\n                goods.setIsFreeDelivery(1);\n                goods.setCategoryId(43);\n                //insert()方法返回值代表本次成功插入的记录总数\n                list.add(goods);\n            }\n            session.insert(\"goods.batchInsert\", list);\n            session.commit();//提交事务数据\n            long et = new Date().getTime();\n            System.out.println(\"执行时间:\" + (et - st) + \"毫秒\");\n//            System.out.println(goods.getGoodsId());\n        } catch (Exception e) {\n            if (session != null) {\n                session.rollback();//回滚事务\n            }\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n◇批量插入数据的局限：①无法获得插入数据的id；②批量生成的SQL太长，可能会被服务器拒绝\n◇批量删除\n```xml\n<!--delete from t_goods where goods_id in (1920,1921,...)-->\n   <delete id=\"batchDelete\" parameterType=\"java.util.List\">\n        DELETE FROM t_goods WHERE goods_id in\n     <foreach collection=\"list\" item=\"item\" index=\"index\" open=\"(\" close=\")\" separator=\",\">\n           #{item}\n     </foreach>\n   </delete>\n    @Test\n    public void testBatchDelete() throws Exception {\n        SqlSession session = null;\n        try {\n            long st = new Date().getTime();\n            session = MyBatisUtils.openSession();\n            List list = new ArrayList();\n            list.add(1920);\n            list.add(1921);\n            list.add(1922);\n            session.delete(\"goods.batchDelete\", list);\n            session.commit();//提交事务数据\n            long et = new Date().getTime();\n            System.out.println(\"执行时间:\" + (et - st) + \"毫秒\");\n//          System.out.println(goods.getGoodsId());\n        } catch (Exception e) {\n            if (session != null) {\n                session.rollback();//回滚事务\n            }\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## MyBatis注解开发\n### Mybatis常用注解\n◇把原有放在xml的标签语句放在程序中\n![image.png](MyBatis进阶/1628925337535-f97712fe-fea0-4be2-87bd-c66e102d765b.png)\n◇创建dao包，然后创建GoodsDAO接口\n\n```java\npublic interface GoodsDAO {\n    @Select(\"select * from t_goods where current_price between  \n        #{min} and #{max} order by current_price limit 0,#{limt}\")\n    public List<Goods> selectByPriceRange(@Param(\"min\") Float min ,\n      @Param(\"max\") Float max ,@Param(\"limt\") Integer limt);\n\n    @Insert(\"INSERT INTO t_goods(title, sub_title, original_cost,\n      current_price, discount, is_free_delivery, category_id)\n      VALUES (#{title} , #{subTitle} , #{originalCost}, #{currentPrice}, \n      #{discount}, #{isFreeDelivery}, #{categoryId})\")\n    //<selectKey>\n    @SelectKey(statement = \"select last_insert_id()\" , \n      before = false , keyProperty = \"goodsId\" , resultType = Integer.class)\n    public int insert(Goods goods);\n\n    @Select(\"select * from t_goods\")\n    //<resultMap>\n    @Results({\n            //<id>\n          @Result(column = \"goods_id\" ,property = \"goodsId\" , id = true) ,\n            //<result>\n            @Result(column = \"title\" ,property = \"title\"),\n            @Result(column = \"current_price\" ,property = \"currentPrice\")\n    })\n    public List<GoodsDTO> selectAll();\n}\n```\n◇在核心配置文件mybatis-config.xml中进行相应说明\n```xml\n    <mappers>\n        <!--<mapper class=\"com.lcg.mybatis.dao.GoodsDAO\"/> 指向接口，下为简便方法-->\n        <package name=\"com.lcg.mybatis.dao\"/>\n    </mappers>\n```\n◇测试类\n```java\n@Test\n    public void testSelectByPriceRange() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            //传入类对象\n            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);\n            List<Goods> list = goodsDAO.selectByPriceRange(100f, 500f, 20);\n            System.out.println(list.size());\n        }catch (Exception e){\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n\n        }\n    }\n\t/**\n     * 新增数据\n     * @throws Exception\n     */\n    @Test\n    public void testInsert() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = new Goods();\n            goods.setTitle(\"测试商品\");\n            goods.setSubTitle(\"测试子标题\");\n            goods.setOriginalCost(200f);\n            goods.setCurrentPrice(100f);\n            goods.setDiscount(0.5f);\n            goods.setIsFreeDelivery(1);\n            goods.setCategoryId(43);\n            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);\n            //insert()方法返回值代表本次成功插入的记录总数\n            int num = goodsDAO.insert(goods);\n            session.commit();//提交事务数据\n            System.out.println(goods.getGoodsId());\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n    @Test\n    public void testSelectAll() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);\n            List<GoodsDTO> list = goodsDAO.selectAll();\n            System.out.println(list.size());\n        }catch (Exception e){\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n}\n```\n\n","tags":["MyBaits"],"categories":["Java数据库","MyBaits"]},{"title":"MyBaits入门","url":"/p/f37d.html","content":"## MyBatis课程介绍\n### MyBatis入门使用\n![image.png](MyBatis入门/1628238899331-11e1e3ae-ea4c-48e1-b933-0cece45283b9.png)\n### MyBatis高级特性\n![image.png](MyBatis入门/1628239064225-a53dd20e-0d65-4c5e-acc9-0dc429a8d32e.png)\n##  认识框架-Framework  \n###  生活中的框架  \n![image.png](MyBatis入门/1628239313228-062756fe-2b58-4e3b-902e-c73bf87d0331.png)\n![image.png](MyBatis入门/1628239334642-ca21d0cd-4c30-4653-8811-2537f6edd963.png)\n\n### 软件开发中框架 \n◇框架是可被应用开发者定制的应用骨架 \n◇框架是一种规则,保证开发者遵循相同的方式开发程序 \n◇框架提倡”不要重复造轮子”,对基础功能进行封装  \n### 框架的优点 \n◇极大提高了开发效率 \n◇统一的编码规则,利于团队管理 \n◇灵活配置的应用,拥有更好的维护性  \n### SSM开发框架  \n![image.png](MyBatis入门/1628239469486-ecff36a6-0968-4804-8f26-63c745ed2252.png)\n## 介绍MyBatis  \n### 什么是MyBatis \n◇MyBatis是优秀的持久层框架 \n◇MyBatis使用XML将SQL与程序解耦,便于维护\n◇MyBatis学习简单,执行高效,是JDBC的延伸 \n### MyBatis开发流程 \n①引入MyBatis依赖 -> ②创建核心配置文件 -> ③创建实体(Entity)类 -> ④创建Mapper映射文件 -> ⑤初始化SessionFactory -> ⑥利用SqlSession对象操作数据  \n## 单元测试与JUnit 4\n### 单元测试 \n◇单元测试是指对软件中的最小可测试单元进行检查和验证 \n◇测试用例是指编写一段代码对已有功能(方法)进行校验 \n◇JUnit 4是Java中最著名的单元测试工具,主流IDE内置支持  \n\n### JUnit 4使用方法 \n◇引入JUnit Jar包或增加Maven依赖 \n◇编写测试用例验证目标方法是否正确运行 \n◇在测试用例上增加@Test注解开始单元测试  \n### JUnit 4使用入门  \n◇创建Maven项目\n --pom.xml配置\n\n```java\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n</dependencies>\n```\n --main中创建类\n```java\n//计算器类,支持加减乘除\npublic class Calculator {\n    public int add(int a, int b) {\n        return a+b;\n    }\n\n    public int subtract(int a, int b) {\n        return a - b;\n    }\n\n    public int multiply(int a, int b) {\n        return a * b;\n    }\n\n    public float divide(int a, int b) {\n        return (a*1f)/b;\n    }\n}\n```\n --test中创建测试类,测试类或测试方法前有√则为正确运行,也要看程序运行和预期是否相同\n```java\npublic class CalculatorTest {\n    private Calculator cal = new Calculator();\n    //测试用例命名规则\n    //与原方法保持一致：add或者在原方法前增加test前缀：testAdd\n    @Test\n    public void testAdd(){\n        int result = cal.add(3, 5);\n        System.out.println(result);\n    }\n\n    @Test\n    public void subtract() {\n        int result = cal.subtract(1, 2);\n        System.out.println(result);\n    }\n\n    @Test\n    public void multiply() {\n        int result = cal.multiply(1, 2);\n        System.out.println(result);\n    }\n\n    @Test\n    public void divide() {\n        float result = cal.divide(1, 2);\n        System.out.println(result);\n    }\n}\n\n```\n◇快速生成测试类方法：选中需要测试的类->Code->Generate->Test\n◇可以同时运行多个测试类\n\n## MyBatis环境配置  \n### mybatis-config.xml \n◇ MyBatis采用XML格式配置数据库环境信息 \n◇ MyBaits环境配置标签 \n◇ environment包含数据库驱动、URL、用户名与密码 \n### 项目演示\n◇IDEA支持数据库面板，DataBase->+ ->DataSource->MySql\n◇pom.xml配置\n\n```java\n<repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.1</version>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.47</version>\n        </dependency>\n        <!--增加junit用于测试 -->\n\n    </dependencies>\n```\n◇在main/resources目录下创建mybatis-config.xml文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--设置默认指向的数据库,这里默认指向dev-->\n    <environments default=\"dev\">\n        <!--配置环境，不同的环境不同的id名字-->\n        <environment id=\"dev\">\n            <!-- 采用JDBC方式对数据库事务进行commit/rollback -->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--采用连接池方式管理数据库连接-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\n    \"jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;characterEncoding=UTF-8\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"password\"/>\n            </dataSource>\n        </environment>\n    </environments>\n</configuration>\n```\n## SqlSessionFactory \n◇ SqlSessionFactory是MyBatis的核心对象 \n◇ 用于初始化MyBatis,创建SqlSession对象 \n◇ 保证SqlSessionFactory在应用中全局唯一 \n\n### SqlSession \n◇ SqlSession是MyBatis操作数据库的核心对象 \n◇ SqlSession使用JDBC方式与数据库交互 \n◇ SqlSession对象提供了数据表CRUD对应方法    \n\n### 项目演示\n◇pom.xml中增加junit依赖用于测试\n◇JUNIT单元测试类\n\n```java\npublic class MyBatisTestor {\n    @Test\n    public void testSqlSessionFactory()throws IOException {\n        //按照字符流方式进行.xml文件的读取，返回Reader对象\n        Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");\n        //初始化SqlSessionFactory对象，同时通过reader对象解析xml文件\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n        System.out.println(\"SessionFactory加载成功\");\n        SqlSession sqlSession = null;\n        try {\n            //创建SqlSession对象，SqlSession是JDBC的扩展类，用于与数据库交互\n            sqlSession = sqlSessionFactory.openSession();\n            //进行数据库的交互\n            Connection connection = sqlSession.getConnection();\n            System.out.println(connection);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            /*如果type=\"POOLED\",代表使用连接池，close则是将连接回收到连接池中\n            * 如果type=\"UNPOOLED\",代表直连，close则会调用Connection.close()\n            * 方法关闭连接*/\n            if(sqlSession!=null){\n                sqlSession.close();\n            }\n        }\n    }\n    \n    //测试工具类\n     @Test\n    public void testMyBatisUtils()throws Exception{\n        SqlSession sqlSession = null;\n        try {\n            sqlSession = MyBatisUtils.openSession();\n            Connection connection = sqlSession.getConnection();\n            System.out.println(connection);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            MyBatisUtils.closeSession(sqlSession);\n        }\n    }\n}\n```\n◇初始化工具类\n```java\npublic class MyBatisUtils {\n    //利用static(静态)属于类不属于对象，且全局唯一\n    private static SqlSessionFactory sqlSessionFactory = null;\n\n    //利用静态块在初始化类时实例化sqlSessionFactory\n    static {\n        Reader reader = null;\n        try {\n            reader = Resources.getResourceAsReader(\"mybatis-config.xml\");\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n        } catch (IOException e) {\n            e.printStackTrace();\n            //初始化错误时，通过抛出异常ExceptionInInitializerError通知调用者\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n    \n    /**\n     * openSession 创建一个新的SqlSession对象\n     * 对于工具类的方法大都使用static描述，\n     * 这样通过类名和方法名就可以直接使用了\n     * @return SqlSession对象\n     */\n    public static SqlSession openSession() {\n        return sqlSessionFactory.openSession();\n    }\n\n    /**\n     * 释放一个有效的SqlSession对象\n     *\n     * @param session 准备释放SqlSession对象\n     */\n    public static void closeSession(SqlSession session) {\n        if (session != null) {\n            session.close();\n        }\n    }\n}\n\n```\n## MyBatis数据查询\n### MyBatis数据查询步骤 \n①创建实体类(Entity) -> ②创建Mapper XML -> ③编写SQL标签 -> ④开启驼峰命名映射 -> ⑤新增\\<Mapper\\>   ->             ⑥SqlSession执行select语句 \n###  项目演示\n◇生成实体类，entity\n```java\npublic class Goods {\n    private Integer goodsId;//商品编号\n    private String title;//标题\n    private String subTitle;//子标题\n    private Float originalCost;//原始价格\n    private Float currentPrice;//当前价格\n    private Float discount;//折扣率\n    private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮\n    private Integer categoryId;//分类编号\n    ...\n}\n```\n◇在Resources目录中创建mapper(映射器)文件，在其中创建xml文件;goods.xml文件说明了实体类和哪一张表对应\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><!--与config中的不同 -->\n<!--命名空间用来区分 -->\n<mapper namespace=\"goods\">\n    <!--编写sql标签,resultType说明查询结果返回的实体类 -->\n    <select id=\"selectAll\" resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods order by goods_id desc limit 10\n    </select>\n</mapper>\n```\n◇新建了goods.xml后还需要在mybatis-config.xml中进行声明\n![image.png](MyBatis入门/1628332975684-1cd84570-03e0-4c7a-8f40-a0b5fcd43d7f.png)\n◇驼峰命名转换(在mybatis-config中配置)，数据表字段不区分大小写，但java属性区分大小写；防止读取数据库数据时丢失一些例如goods_id字段的数据\n\n```java\n    <settings>\n        <!-- goods_id ==> goodsId 驼峰命名转换 -->\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n    </settings>\n```\n◇编写测试\n```java\n    @Test\n    public void testSelectAll() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            List<Goods> list = session.selectList(\"goods.selectAll\");\n            for(Goods g : list){\n                System.out.println(g.getTitle());\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## Sql传参\n###  查询 - select\n```java\n<select id=\"selectById\" parameterType=\"Integer\"\nresultType=\"com.lcg.mybatis.entity.Goods\">\nselect * from t_goods where goods_id = #{value}\n</select>\n```\n### 项目示例\n**①单个参数**\n◇在goods.xml中新增一个select查询\n\n```java\n<select id=\"selectById\" parameterType=\"Integer\" resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods where goods_id = #{value}\n    </select>\n```\n◇进行测试\n```java\n/**\n     * 传递单个SQL参数\n     * @throws Exception\n     */\n    @Test\n    public void testSelectById() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.getTitle());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n**②多个参数**\n**◇**session.selectxxx方法无法传递多个参数，所以利用Java.Util.Map键值对来进行多个参数的传递，即参数名为键，值为参数值\n◇新增查询\n```java\n    <select id=\"selectByPriceRange\" parameterType=\"java.util.Map\" \n        resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods\n        where current_price between #{min} and #{max}\n        limit 0,#{limt}\n    </select>\n```\n◇测试\n```java\n /**\n     * 传递多个(3个)SQL参数\n     * @throws Exception\n     */\n    @Test\n    public void testSelectByPriceRange() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Map param = new HashMap();\n            param.put(\"min\",100);\n            param.put(\"max\" , 500);\n            param.put(\"limt\" , 10);\n            List<Goods> list = session.selectList(\"goods.selectByPriceRange\", param);\n            for(Goods g:list){\n                System.out.println(g.getTitle() + \":\" + g.getCurrentPrice());\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n **③多表关联**\n◇Sql语句\n\n```xml\n<!-- 利用LinkedHashMap保存多表关联结果\n        MyBatis会将每一条记录包装为LinkedHashMap对象\n        key是字段名  value是字段对应的值 , 字段类型根据表结构进行自动判断\n        优点: 易于扩展,易于使用\n        缺点: 太过灵活,无法进行编译时检查\n     -->\n<select id=\"selectGoodsMap\" resultType=\"java.util.LinkedHashMap\">\n        select g.*,c.category_name from t_goods g, t_category c\n        where g.category_id = c.category_id\n    </select>\n```\n◇测试\n```xml\n@Test\n    public void testSelectGoodsMap() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            List<Map> list = session.selectList(\"goods.selectGoodsMap\");\n            for(Map map : list){\n                System.out.println(map);\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## ResultMap结果映射 \n◇ResultMap可以将查询结果映射为复杂类型的Java对象 \n◇ResultMap适用于Java对象保存多表关联结果 \n◇ResultMap支持对象关联查询等高级特性  \n**项目示例**\n◇创建类别实体\n```xml\npublic class Category {\n    private Integer categoryId;\n    private String categoryName;\n    private Integer parentId;\n    private Integer categoryLevel;\n    private Integer categoryOrder;\n ...\n}\n```\n◇创建新包dto，用来进行对原始数据的扩展，保存以及传递;如在包中创建GoodsDTO对原始的Goods进行扩展\n```xml\n//Data Transfer Object--数据传输对象\npublic class GoodsDTO {\n    private Goods goods = new Goods();\n    private Category category = new Category();\n    private String test;\n...\n}\n```\n◇结果映射\n```xml\n<!--结果映射-->\n    <resultMap id=\"rmGoods\" type=\"com.lcg.mybatis.dto.GoodsDTO\">\n        <!--设置主键字段与属性映射-->\n        <id property=\"goods.goodsId\" column=\"goods_id\"></id>\n        <!--设置非主键字段与属性映射-->\n        <result property=\"goods.title\" column=\"title\"></result>\n        <result property=\"goods.originalCost\" column=\"original_cost\"></result>\n        <result property=\"goods.currentPrice\" column=\"current_price\"></result>\n        <result property=\"goods.discount\" column=\"discount\"></result>\n        <result property=\"goods.isFreeDelivery\" column=\"is_free_delivery\"></result>\n        <result property=\"goods.categoryId\" column=\"category_id\"></result>\n        <result property=\"category.categoryId\" column=\"category_id\"></result>\n        <result property=\"category.categoryName\" column=\"category_name\"></result>\n        <result property=\"category.parentId\" column=\"parent_id\"></result>\n        <result property=\"category.categoryLevel\" column=\"category_level\"></result>\n        <result property=\"category.categoryOrder\" column=\"category_order\"></result>\n        <result property=\"test\" column=\"test\"/>\n    </resultMap>\n    <select id=\"selectGoodsDTO\" resultMap=\"rmGoods\">\n        select g.* , c.*,'1' as test from t_goods g , t_category c\n        where g.category_id = c.category_id\n    </select>\n```\n◇测试\n```xml\n@Test\n    public void testSelectGoodsDTO()throws Exception{\n        SqlSession session = null;\n        try {\n            session = MyBatisUtils.openSession();\n            List<GoodsDTO> list = session.selectList(\"goods.selectGoodsDTO\");\n            for(GoodsDTO g:list){\n                System.out.println(g.getGoods().getTitle());\n            }\n        } catch (Exception e) {\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## MyBatis数据写入\n### 数据库事务\n◇数据库事务是保证数据操作完整性的基础\n![image.png](MyBatis入门/1628513637346-4dc8cb72-ae9e-46b1-8732-63a7f3f9c3b3.png)\n\n### MyBatis写操作包含三种\n◇插入 -  insert\n```xml\n<insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\nINSERT INTO `babytun`.`t_goods`( `title`, `sub_title`, `original_cost`, current_price`)\nVALUES ( #{title}, #{subTitle}, #{originalCost}, #{currentPrice})\n<selectKey resultType=\"int\" keyProperty=\"goodsId\" order=\"AFTER\">\n<!-- 当前连接中最后产生的id号 -->\nselect last_insert_id()\n</selectKey>\n</insert>\n\n--示例代码\n <insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n        insert into t_goods(title, sub_title, original_cost, current_price, \n                            discount, is_free_delivery,category_id)\n        value (#{title} , #{subTitle} , #{originalCost}, \n               #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId})\n   //用来将新插入的id回填到类中\n        <selectKey resultType=\"Integer\" keyProperty=\"goodsId\" order=\"AFTER\">\n            select last_insert_id()\n        </selectKey>\n    </insert>\n    @Test\n    public void testInsert() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = new Goods();\n            goods.setTitle(\"测试商品\");\n            goods.setSubTitle(\"测试子标题\");\n            goods.setOriginalCost(200f);\n            goods.setCurrentPrice(100f);\n            goods.setDiscount(0.5f);\n            goods.setIsFreeDelivery(1);\n            goods.setCategoryId(43);\n            //insert()方法返回值代表本次成功插入的记录总数\n            int num = session.insert(\"goods.insert\", goods);\n            session.commit();//提交事务数据\n            System.out.println(goods.getGoodsId());\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n◇更新 -  update\n```xml\n<update id=\"update\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n        UPDATE t_goods\n        SET\n          title = #{title} ,\n          sub_title = #{subTitle} ,\n          original_cost = #{originalCost} ,\n          current_price = #{currentPrice} ,\n          discount = #{discount} ,\n          is_free_delivery = #{isFreeDelivery} ,\n          category_id = #{categoryId}\n        WHERE\n          goods_id = #{goodsId}\n    </update>\n @Test\n    public void testUpdate() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            //通过selectOne方法得到指定商品编号的goods对象\n            Goods goods = session.selectOne(\"goods.selectById\", 739);\n            goods.setTitle(\"更新测试商品\");\n            int num = session.update(\"goods.update\" , goods);\n            session.commit();//提交事务数据\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n\n```\n◇删除 -  delete\n```xml\n <!--delete from t_goods where goods_id in (1920,1921)-->\n    <delete id=\"delete\" parameterType=\"Integer\">\n        delete from t_goods where goods_id = #{value}\n    </delete>\n @Test\n    public void testDelete() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            int num = session.delete(\"goods.delete\" , 739);\n            session.commit();//提交事务数据\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n### selectKey与useGeneratedKeys的区别\n◇selectKey标签的用法\n```xml\n <insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n       INSERT INTO SQL语句\n        <selectKey resultType=\"Integer\" keyProperty=\"goodsId\" order=\"AFTER\">\n            select last_insert_id()\n        </selectKey>\n    </insert>\n```\n◇useGeneratedKeys属性用法\n```xml\n<insert>\n   parameterType=\"com.lcg.mybatis.entity.Goods\"\n   useGeneratedKeys=\"true\"\n   keyProperty=\"goodsId\"\n   KeyColumn=\"goods_id\"\n  INSERT INTO SQL 语句\n</insert>\n```\n**二者区别**\n◇selectKey标签需要明确编写获取最新主键的SQL语句\n◇useGeneratedKeys属性会自动根据驱动生成对应SQL语句\n◇selectKey适用于所有的关系型数据库\n◇useGeneratedKeys只适用于能够\"自增主键\"类型的数据库\n◇在Oracle(非自增)中selectKey的用法\n```xml\n <insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n       INSERT INTO SQL语句\n        <selectKey resultType=\"Integer\" keyProperty=\"goodsId\" order=\"BEFORE\">\n            select seq_goods.nextval as id from dual\n        </selectKey>\n    </insert>\n```\n## MyBatis预防SQL注入攻击\n### SQL注入攻击\n ◇SQL注入是指攻击者利用SQL漏洞,绕过系统约束,越权获取数据的攻击方式  \n```xml\nSQL代码:\nselect * from a where name ='\"+ name+\"'\";\n正常情况:\nname:张三 -> select * from a where name='张三';\nSQL注入攻击:\nname:' or 1=1 or 1='\nselect * from a where name='' or 1=1 or 1=''\n```\n### MyBatis两种传值方式 \n◇${}文本替换,未经任何处理对SQL文本替换 \n◇ #{}预编译传值,使用预编译传值可以预防SQL注入  \n## MyBatis工作流程\n![image.png](MyBatis入门/1628585431174-e99c3d94-a034-4cf0-8882-0cee59cca82f.png)\n◇首先在Java应用中创建mybatis-config.xml文件，用于全局配置，这个配置文件包含了全局设置项、环境配置、mapper声明等核心配置信息；然后在程序的运行过程中通过SqlSessionFactoryBuilder构造器对象来build(构造)SqlSessionFactory工厂类对象；该工厂类对象需要保证全局唯一，用于创建SqlSession对象；SqlSession是我们用于对数据库增删改查的核心对象，它要解析与之对应的mapper.xml文件，每一个mapper.xml文件中包含了大量的sql语句；我们通过SqlSession来访问mapper.xml文件，进而执行其中的sql语句；在SqlSession中主要提供了四种方法(insert | update | delete | select)和数据库进行交互；在进行写的操作时，不要忘记对事务进行相应的提交和回滚；在交互完毕后，应当关闭会话任务，这样我们的底层数据库连接要么被连接池回收要么就直接释放掉；SessionClose这个操作一般放在finally块中，保证它一定能够执行；\n","tags":["MyBaits"],"categories":["Java数据库","MyBaits"]},{"title":"Lambda表达式","url":"/p/8609.html","content":"## 初识Lambda表达式  \n### 什么是Lambda表达式 \n◇JDK8开始支持Lambda表达式,用来让程序编写更优雅 \n◇利用Lambda可以更简洁的实现匿名内部类与函数声明与调用 \n◇基于Lambda提供stream流式处理极大简化对集合的操作  \n### 传统代码  \n```java\nList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n//实现集合排序\nCollections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n    \treturn b.compareTo(a);\n    }\n});\n```\n### 使用Lambda表达式\n```java\nList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n//通过lambda表达式简化匿名类的编写\nCollections.sort(names, (a,b) -> b.compareTo(a));\n```\n##  Lambda表达式语法  \n###  Lambda语法格式  \n![image.png](Lambda表达式/1628129093309-0703436d-3189-4b06-a49a-3dd455c97aa9.png)\n### Lambda表达式示例  \n```java\n//四则运算接口\ninterface MathOperation {\n\tint operation(int a, int b);\n}\n```\n```java\npublic class LambdaSample {\n    public static void main(String[] args) {\n        //1.标准使用方式\n        //约束条件：Lambda表达式只能实现有且仅有一个抽象方法的接口，java称为\"函数式接口\"\n        MathOperation addition = (Integer a,Integer b)->{\n            System.out.println(\"加法运算\");\n            return a + b + 0f;//加上0f隐式的将结果转换为浮点型，与接口数据类型对应\n        };\n        System.out.println(addition.operation(3,9));\n        //2.Lambda允许参数类型忽略\n        MathOperation substraction = (a,b)->{\n            System.out.println(\"减法运算\");\n            return a-b+0f;\n        };\n        //3.单行实现代码可以省略大括号和return\n        MathOperation multiplication = (a,b)->a*b+0f;\n    }\n}\n//传统方法：新建一个class类，在类中定义运算方法，然后再实例化进行运算\n```\n## 函数式编程  \n### 什么是函数式编程 \n◇函数式编程是基于函数式接口并使用lambda表达的编程方式 \n◇函数式编程理念是将代码作为可重用数据代入到程序运行中 \n◇函数式编程强调\"你想做什么\",而不是\"你想怎么做\"  \n### 什么是函数式接口 \n◇函数式接口是有且只有一个抽象方法的接口 \n◇Java中拥有大量函数式接口,如java.lang.Runnable \n◇JDK8后提供了一系列新的函数式接口,位于java.util.function \n◇函数式接口的注解@FunctionInterface用来进行抽象方法检查，防止接口中存在多个方法\n### 函数式接口Predicate \n◇Predicate是新增的函数式接口,位于java.util.function \n◇Predicate用于测试传入的数据是否满足判断要求 \n◇Predicate接口需要实现test()方法进行逻辑判断  \n### 函数式编程示例  \n◇示例一\n```java\npublic class PredicateSample {\n    public static void main(String[] args) {\n        Predicate<Integer> predicate = n->n>4;\n        boolean result = predicate.test(5);\n        System.out.println(result);\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    /*   传统方法判断奇数，代码写死，不灵活\n         for(Integer num:list){\n            if(num%2==1){\n                System.out.println(num);\n            }\n        }*/\n        filter(list,n->n%2==1);//判断奇数，直接传参数即可\n        filter(list,n->n%2==0);//判断偶数\n    }\n    public static void filter(List<Integer> list,Predicate<Integer> predicate){\n        for(Integer num:list){\n            if(predicate.test(num)){\n                System.out.print(num + \" \");\n            }\n        }\n    }\n}\n```\n### 函数式编程与面向对象编程比较  \n![image.png](Lambda表达式/1628129379547-304e9c37-fd96-4baf-9943-4bd9c4eb18d7.png)\n## 函数式接口  \n### JDK8常用函数式接口  \n![image.png](Lambda表达式/1628129449949-b8221a19-cc47-4028-8504-49abae762bf2.png)\n### 函数式接口的应用  \n```java\n//Function函数式接口说明闭包要求输入参数并返回数据\nFunction<String, String> fn = (str) -> str.toUpperCase();\nString result = fn.apply(\"admin\"); //apply用于执行方法返回结果\nSystem.out.println(result);\n//Consumer函数式接口说明闭包只要求输入参数,但不会返回数据\nConsumer<String> c = arg -> {\n\tSystem.out.println(arg);\n};\nc.accept(\"hello\"); //accept只接受参数,没有任何结果返回\n```\n◇利用Function函数式接口生成定长随机字符串\n```java\npublic class FunctionSample {\n    public static void main(String[] args) {\n        Function<Integer,String> randomStringFunction = len->{\n            String chars=\"abcdefghijklmnopqrstuvwxyz0123456789\";\n            StringBuffer stringBuffer = new StringBuffer();\n            Random random = new Random();\n            for(int i=0;i<len;i++){\n                //截取某一个字符的位置\n                int position = random.nextInt(chars.length());\n                //charAt方法按照指定位置将字符提取出来\n                stringBuffer.append(chars.charAt(position));\n            }\n            return stringBuffer.toString();\n        };\n        String randomString = randomStringFunction.apply(5);\n        System.out.println(randomString);\n    }\n}\n```\n## Stream流式处理\n◇Stream流式处理是建立在Lambda基础上的多数据处理技术 \n◇Stream对集合数据处理进行高度抽象,极大简化代码量 \n◇Stream可对集合进行迭代,去重,筛选,排序,聚合等一系列处理  \n### Stream示例  \n```java\n//获取List集合中最大的偶数\nOptional<Integer> op = Arrays.asList(1,2,3,4,5,6).stream()\n.filter(x -> x%2 == 0)//先进行筛选,得到偶数\n.sorted((a,b) -> b-a)//b-a表示降序,a-b表示升序\n.findFirst();//取第一个,这里即最大的\nSystem.out.println(op.get());\n```\n### Stream常用方法  \n![image.png](Lambda表达式/1628129577239-b2769d4b-57df-4c3d-9ddf-edc3c57fabb9.png)\n### Stream操作实例\n◇Stream流的五种创建方式；最常用的为1,2两种  \n```java\npublic class StreamGenerator {\n    //1.基于数组创建\n    @Test\n    public void generator1(){\n        String[] arr = {\"莉莉\", \"安迪\", \"明明\", \"牛牛\"};\n        Stream<String> stream = Stream.of(arr);\n        stream.forEach(s->System.out.println(s));\n    }\n    //2.基于集合创建\n    @Test\n    public void generator2(){\n        List<String> list = new ArrayList<>();\n        list.add(\"莉莉\");\n        list.add(\"安迪\");\n        list.add(\"马马\");\n        list.add(\"牛牛\");\n        Stream<String> stream = list.stream();\n        stream.forEach(s-> System.out.println(s));\n    }\n    //3.利用generate方法创建无限长度流\n    @Test\n    public void generator3(){\n        //bound限制产生的随机数小于其参数\n        Stream<Integer> stream = Stream.generate(() -> new Random().nextInt(1000));\n        //limit用来限制流的最大长度，不设置则为无限\n        stream.limit(10).forEach(i-> System.out.println(i));\n    }\n    //4.基于迭代器创建\n    @Test\n    public void generator4(){\n        //seed：起始的数据；n+1表示每一次循环步长为1\n        Stream<Integer> stream = Stream.iterate(1, n -> n + 1);\n        stream.limit(100).forEach(i-> System.out.println(i));\n    }\n    //5.基于字符序列创建\n    @Test\n    public void generator5(){\n        String str = \"hello你好\";\n        IntStream stream = str.chars();\n        //输出为字母的ASCII码或者汉字的Unicode编码;将c强制转换成char类型即可输出原字符\n        stream.forEach(c -> System.out.println((char)c));\n    }\n}\n```\n◇Stream流的常用方法\n```java\npublic class StreamMethod {\n    //1.提取集合中所有偶数并求和\n    @Test\n    public void case1(){\n        //List的泛型设为String类型,否则编译器默认s为object,而parseInt不支持object类型\n        List<String> list = Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\");\n        int sum = list.stream() //获取stream对象\n            .mapToInt(s->Integer.parseInt(s)) //mapToInt将流中的每一个数据转换为整数\n            .filter(n->n%2==0)//对流中数据进行过滤\n            .sum();//将所有数据进行求和，数据只能为整数\n        System.out.println(sum);\n    }\n    //2.所有名字首字母大写\n    @Test\n    public void case2(){\n        List<String> list = Arrays.asList(\"lily\",\"smith\",\"jackson\",\"bob\");\n        List newList = list.stream()\n                /*substring()截取位置为a到b的字符串，\n                若只有一个参数，则此参数表示从该位置截取\n                到最后*/\n                .map(s -> s.substring(0, 1).toUpperCase()+s.substring(1))\n                //.forEach(s -> System.out.println(s));只能进行打印，没有保存\n                //collect对流数据进行收集，生成新的List/Set(Set可以将重复数据自动清除)\n                .collect(Collectors.toList());//可以将转换后的结果保存到新的List中\n        System.out.println(newList);\n    }\n    //3.将所有奇数从大到小进行排序，且不许出现重复\n    //Set方法可以清楚重复数据，但没有顺序，排序功能会失效\n    @Test\n    public void case3(){\n        List<Integer> list = Arrays.asList(1,60,38,21,51,60,51,73);\n        List newList = list.stream().distinct()//去除重复的流数据\n                .filter(n->n%2==1)\n                .sorted((a,b)->b-a)\n                .collect(Collectors.toList());\n        System.out.println(newList);\n    }\n}\n```\n### 如何通过oracle官网学习Stream流的方法\n◇[官网地址](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html):百度java.util.stream\n◇查看每一个方法的作用\n​\n\n\n\n","tags":["Lambda"],"categories":["Java数据库","框架前置知识"]},{"title":"Java反射","url":"/p/7c7c.html","content":"## 课程介绍\n◇介绍反射及作用 \n◇讲解反射四个核心类 \n◇反射在项目中的应用 \n## 主要知识点 \n◇反射的作用 \n◇Class类 \n◇Constructor构造方法类 \n◇Method方法类 \n◇Field成员变量类  \n## 什么是反射Reflect \n◇反射(Reflect)是在运行时动态访问类与对象的技术 \n◇反射是JDK1.2版本后的高级特性,隶属于java.lang.reflect \n◇大多数Java框架都基于反射实现参数配置、动态注入等特性  \n◇反射方法与传统方法对比,传统方法要增加乘法类时需要再写一个if else而反射方法支持动态增加方法的功能\n```java\n /**\n     * 传统的创建对象方式\n     */\n    public static void case1(){\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"请输入计算类名:\");\n        String op = scanner.next();\n        System.out.print(\"请输入a:\");\n        int a = scanner.nextInt();\n        System.out.print(\"请输入b:\");\n        int b = scanner.nextInt();\n        MathOperation mathOperation = null;\n        if(op.equals(\"Addition\")){\n            mathOperation = new Addition();\n        }else if(op.equals(\"Subtraction\")) {\n            mathOperation = new Subtraction();\n        }else if(op.equals(\"Multiplication\")){\n            mathOperation = new Multiplication();\n        }else{\n            System.out.println(\"无效的计算类\");\n            return;\n        }\n        float result = mathOperation.operate(a, b);\n        System.out.println(result);\n    }\n\n    /**\n     * 利用反射创建对象更加灵活\n     */\n    public static void case2(){\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"请输入计算类名:\");\n        String op = scanner.next();\n        System.out.print(\"请输入a:\");\n        int a = scanner.nextInt();\n        System.out.print(\"请输入b:\");\n        int b = scanner.nextInt();\n        MathOperation mathOperation = null;\n        try {\n            //根据类路径获取类名并实例化\n            mathOperation = \n                (MathOperation) Class.forName(\"com.lcg.reflect.\" + op).newInstance();\n        }catch(Exception e){\n            System.out.println(\"无效的计算类\");\n            return;\n        }\n        float result = mathOperation.operate(a, b);\n        System.out.println(result);\n    }\n```\n## 反射的核心类 \n◇Class类 \n◇Constructor构造方法类 \n◇Method方法类 \n◇Field成员变量类 \n## Class类  \n◇Class是JVM中代表\"类和接口\"的类 \n◇Class对象具体包含了某个特定类的结构信息 \n◇通过Class对象可获取对应类的构造方法/方法/成员变量  \n###  Class核心方法  \n![image.png](Java反射/1627994260419-a7f327ff-16ef-4c68-82b0-f4bf86f15749.png)\n###  利用Class创建对象  \n```java\npublic class ClassSample {\n    public static void main(String[] args) {\n        try {\n            //Class.forName()方法将指定的类加载到jvm,并返回对应Class对象(得到员工类对象)\n            Class employeeClass = Class.forName(\"com.imooc.reflect.entity.Employee\");\n            System.out.println(\"Employee已被加载到jvm\");\n            //newInstance通过默认构造方法创建新的对象(实例化),返回Object对象，需要强制转换\n            Employee emp = (Employee)employeeClass.newInstance();\n            System.out.println(emp);\n        } catch (ClassNotFoundException e) {\n            //类名与类路径书写错误是抛出\"类无法找到\"异常\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            //非法访问异常,当在作用域外访问对象方法或成员变量时抛出\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            //对象无法被实例化,抛出\"实例化异常\"\n            e.printStackTrace();//抽象类(abstract)无法被实例化\n        }\n    }\n}\n```\n## Constructor构造方法类 \n◇Constructor类是对Java类中的构造方法的抽象 \n◇Contructor对象包含了具体类的某个具体构造方法的声明 \n◇通过Constructor对象调用带参构造方法创建对象  \n###  Constructor类核心方法  \n![image.png](Java反射/1627996525920-b349474c-5ebe-4cda-a6fa-dcf70573d893.png)\n###  利用Constructor创建对象  \n```java\npublic class ConstructorSample {\n    public static void main(String[] args) {\n        try {\n            //得到员工类的类对象\n            Class employeeClass = Class.forName(\"com.lcg.reflect.entity.Employee\");\n            //得到Employee类中包含有四个参数的构造方法对象,Class[]类型数组\n            Constructor constructor = employeeClass.getConstructor(new Class[]{\n                    Integer.class,String.class,Float.class,String.class\n            });\n            //通过指定构造方法传入数据,创建对象\n            Employee employee = (Employee) constructor.newInstance(new Object[]{\n                    100,\"李磊\",3000f,\"研发部\"\n            });\n            System.out.println(employee);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            //没有找到与之对应格式的方法\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            //当被调用的方法的内部抛出了异常而没有被捕获时\n            e.printStackTrace();\n        }\n    }\n}\n```\n## Method方法类 \n◇Method对象指代某个类中的方法的描述 \n◇Method对象使用classObj.getMethod()方法获取 \n◇通过Method对象调用指定对象的对应方法  \n### Method类核心方法  \n![image.png](Java反射/1627996618023-85940d99-f781-4daf-8279-76c4a76ff3c6.png)\n### 利用Method执行方法  \n```java\n/**\n * 利用Method方法类调用\n */\npublic class MethodSample {\n    public static void main(String[] args) {\n        try {\n            Class employeeClass = Class.forName(\"com.lcg.reflect.entity.Employee\");\n            Constructor constructor = employeeClass.getConstructor(new Class[]{\n                    Integer.class, String.class, Float.class, String.class\n            });\n            //传入参数时用Object[]对象数组\n            Employee employee = (Employee) constructor.newInstance(new Object[]{\n                    100, \"李磊\", 3000f, \"研发部\"\n            });\n            Method updateSalaryMethod = employeeClass.getMethod(\"updateSalary\", new Class[]{\n                    Float.class\n            });\n            Employee employee1 = (Employee) updateSalaryMethod.invoke(employee, new Object[]{1000f});\n            System.out.println(employee1);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n##  Field成员变量类 \n◇Field对应某个具体类中的成员变量的声明 \n◇Field对象使用classObj.getField()方法获取 \n◇通过Field对象可为某对象成员变量赋值/取值  \n###  Field类核心方法  \n![image.png](Java反射/1627996714885-1ad3a503-3276-4d82-aa14-3ed8abf131de.png)\n###  利用Field赋值与取值  \n```java\n...\n//获取员工姓名Field成员变量对象\nField enameField = employeeClass.getField(\"ename\");\n//成员变量赋值\nenameField.set(employee,\"李雷\");\n//成员变量取值，参数为对象名\nString ename = (String)enameField.get(employee);\n```\n##  getDeclared系列方法 \n◇getDeclaredConstructor(s)|Method(s)|Field(s)获取对应对象(构造方法，方法，成员变量) ,+s表示获取所有(多个)\n◇getConstructor(s)|Method(s)|Field(s)只能获取public对象  \n◇访问非作用域内构造方法、方法、成员变量,会抛出异常  \n◇public变量.get()直接获取，非public变量先通过类对象获取到get方法再来调用get方法获取\n```java\nClass employeeClass = Class.forName(\"com.lcg.reflect.entity.Employee\");\nConstructor constructor = employeeClass.getConstructor(new Class[]{\n    Integer.class, String.class, Float.class, String.class\n        });\nEmployee employee = (Employee) constructor.newInstance(new Object[]{\n    100, \"李磊\", 3000f, \"研发部\"\n    });\n//获取当前类所有成员变量\nField[] fields = employeeClass.getDeclaredFields();\nfor(Field field : fields){\n    //System.out.println(field.getName());\n    //对成员变量区分对待\n    if(field.getModifiers() == 1){ //pubilc修饰\n        Object val = field.get(employee);\n        System.out.println(field.getName() + \":\" + val);\n    }else if(field.getModifiers() == 2){ //private修饰\n        //构造出get方法名,eg: getSalary();\n        String methodName = \"get\" + field.getName().substring(0,1).toUpperCase()\n            + field.getName().substring(1);\n        Method getMethod = employeeClass.getMethod(methodName);//获取类的get方法;\n        Object ret = getMethod.invoke(employee);//执行get方法\n        System.out.println(field.getName() + \":\" + ret);\n    }\n}\n```\n##  反射在项目中的应用   \n◇网站的国际化\n```java\npublic class Application {\n    public static void say(){\n        Properties properties = new Properties();//加载指定配置文件\n        //获取配置文件路径\n        String configPath = Application.class.getResource(\"/config.properties\").getPath();\n        try {\n            configPath = new URLDecoder().decode(configPath,\"UTF-8\");\n            properties.load(new FileInputStream(configPath));\n            //用 Properties.getProperty来读取配置文件里面的(language属性)的属性值\n            String language = properties.getProperty(\"language\");\n            //利用language告知Class获取哪一个指定类并实例化\n            I18N i18n = (I18N)Class.forName(language).newInstance();\n            System.out.println(i18n.say());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        Application.say();\n    }\n}\n```\n\n","tags":["反射"],"categories":["Java数据库","框架前置知识"]},{"title":"Maven项目管理","url":"/p/316f.html","content":"###  课程介绍  \n ◇ 介绍Maven的核心特性  \n ◇ 掌握Maven的依赖管理  \n ◇ 掌握Maven的打包方式  \n\n###  Maven介绍  \n ◇ Maven 是项目管理工具,对软件项目提供构建与依赖管理  \n ◇ Maven是Apache下的Java开源项目  \n ◇ Maven为Java项目提供了统一的管理方式，已成为业界标准  \n###  Maven核心特性  \n◇ 项目设置遵循统一的规则，保证不同开发环境的兼容性 Maven核心特性 \n◇ 强大的依赖管理，项目依赖组件自动下载、自动更新 \n◇ 可扩展的插件机制，使用简单，功能丰富  \n\n### Maven的安装与配置  \n\n◇Maven是由Java语言编写的程序，所以安装Maven之前需要安装JDK或JRE；然后配置JDK的环境变量（可以配置用户变量，也可以配置系统变量）\n\n![image-20220524152244936](Maven项目管理/image-20220524152244936.png)\n\n◇继续添加Path路径，可以如图所示使用%通配符，也可以直接指定  F:\\\\JAVA\\\\JDK\\\\install\\\\bin\n\n![image-20220524153151724](Maven项目管理/image-20220524153151724.png)\n\n◇配置好相关环境变量后，进入[Maven官网](https://maven.apache.org/)点击下载链接进行压缩包的下载即可。\n\n![image-20220524153811232](Maven项目管理/image-20220524153811232.png)\n\n◇解压后的目录如下，bin可执行文件夹，boot引导文件夹，conf配置文件夹，lib依赖文件夹。\n\n![image-20220524154211391](Maven项目管理/image-20220524154211391.png)\n\n◇使用Maven也需要配置环境变量，将maven的bin文件夹目录配置即可。接下来进入cmd，输入mvn -v命令,能查看到版本表示配置成功。\n\n![image-20220524155814867](Maven项目管理/image-20220524155814867.png)\n\n###  Maven的坐标  \n ◇ GroupId：机构或者团体的英文，采用\"逆向域名\"形式书写  \n ◇ ArtifactId：项目名称,说明其用途，例如：cms、oa...  \n ◇ Version：版本号，一般采用\"版本+单词\"形式，例如：1.0.0.RELEASE  \n\n###  Maven项目标准结构  \n![image.png](Maven项目管理/1627634963647-8798bed9-4a2c-4e9b-8873-7bb418fdba6d.png)\n###  Maven依赖管理 \n◇Maven利用dependency(依赖)自动下载、管理第三发jar\n◇在pom.xml文件中配置项目依赖的第三方组件\n◇maven自动将依赖从远程仓库下载至本地仓库，并在工程中引用 \n◇[maven中央仓库检索网站](https://search.maven.org/)\n◇pinyin4j将汉字转换为拼音\n 配置\n```xml\n <dependency>\n\t  <groupId>com.belerweb</groupId>\n\t  <artifactId>pinyin4j</artifactId>\n\t  <version>2.5.1</version>\n\t</dependency>\n```\n 代码\n```java\npublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString str = scan.nextLine();\n\t\tString[] pinyin = PinyinHelper.toHanyuPinyinStringArray('李'); \n\t\tfor(String py : pinyin) {\n\t\t\tSystem.out.println(py);\n\t\t}\n\t}\n```\n◇配置多个jar包:依赖本身也依赖于底层jar包，因此有多个jar包\n###  本地仓库与中央仓库  \n![image.png](Maven项目管理/1627635052884-beae7764-b69b-40ff-8215-a112d76dbd79.png)\n\n 本地仓库目录\n\n![image.png](Maven项目管理/1627733946275-eab3e214-a8aa-4a33-aa28-3b7371428144.png)\n◇创建备份服务器，提高下载速度\n\n```java\n  <repositories>\n    <repository>\n      <!-- 创建私服的地址 -->\n      <id>aliyun</id>\n      <name>aliyun</name>\n      <url>https://maven.aliyun.com/repository/public</url>\n    </repository>\n  </repositories>\n```\n###  项目打包  \n ◇ Maven可将Java项目打包为jar、war包  \n ◇ Maven项目打包是通过Plugins（插件）技术实现  \n ◇ Maven输出Jar包插件：maven-assembly-plugin  \n ◇ 配置文件\n```java\n<build>\n  <!-- 配置插件 -->\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-assembly-plugin</artifactId>\n        <version>2.5.5</version>\n        <configuration>\n          <archive>\n            <mainfest>\n              <mainClass>com.lcg.maven.PinyinTestor</mainClass>\n            </mainfest>\n          </archive>\n          <descriptorRefs>\n          <!--  all in one 在打包时会将所有引用的jar合并到输出的jar文件中 -->\n            <descriptorRef>jar-with-dependencies</descriptorRef>\n          </descriptorRefs>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n```\n ◇ 配置运行\n![image.png](Maven项目管理/1627738334274-d9101c2e-e3dd-43be-b703-6cc97ac65fc9.png)\n◇ 打包成功后的运行命令\n\n```java\njava -jar maven-1-1.0.0-RELEASE-jar-with-dependencies.jar\n```\n###  Maven构建Web工程  \n◇创建maven项目->配置JRE：JRE System Library->properties->Workspace default JRE->Apply and Close\n◇修改JDK编译级别：工程名->properties->Java Compiler->Compiler compliance level(编译级别):1.8-OK\n◇在src/main目录下创建webapp文件夹\n◇工程名->properties->Project Facets->Convert to faceted form->勾选Dynamic Web Module 3.1->Runtimes:指定Apache Tomcat->Further configuration available->Content directory:src/main/webapp->勾选web.xml-OK->Apply and Close\n###  Web工程打包  \n◇[遇见错误](https://blog.csdn.net/cx1110162/article/details/78110277?spm=1001.2014.3001.5506)：将jar文件复制到工程的WEB-INF/lib目录即可\n◇配置：RunConfigurations->MavenBuild->NewConfiguration->Name:build-war->Base directory:指向工程->Goals:package->Apply->Run\n◇pom.xml\n```java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" \n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n        xsi:schemaLocation=\n          \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.lcg</groupId>\n  <artifactId>maven</artifactId>\n  <version>1.0.0-RELEASE</version>\n    <!-- packaging代表输出的格式 -->\n  <packaging>war</packaging>\n  <dependencies>\n    <dependency>\n\t  <groupId>javax.servlet</groupId>\n\t  <artifactId>jstl</artifactId>\n\t  <version>1.2</version>\n    </dependency>\n  </dependencies>\n  <!-- 自定义解压文件名 -->\n  <build>\n  \t<finalName>maven-web</finalName>\n  \t<plugins>\n  \t\t<plugin>\n  \t\t\t<groupId>org.apache.maven.plugins</groupId>\n  \t\t\t<artifactId>maven-war-plugin</artifactId>\n  \t\t\t<version>3.2.2</version>\n  \t\t</plugin>\n  \t</plugins>\n  </build>\n</project>\n```\n###  Maven常用命令  \n◇需要配置环境变量\n◇在cmd中使用\n![image.png](Maven项目管理/1627635155092-1aa7242a-e588-4d42-81df-c93b29c0ceb3.png)\n\n###  修改本地仓库地址  \n◇打开F:\\JAVA\\tool\\apache-maven-3.6.0\\conf中的settings.xml文件\n◇修改49-52处的代码\n```java\n修改前 \n<!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}/.m2/repository\n  <localRepository>/path/to/local/repo</localRepository>\n  -->\n  修改后\n    <!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}/.m2/repository  -->\n  <localRepository>G:/maven-repo</localRepository>\n```\n◇Eclipse中配置：Window->Preferences->Maven->User Settings:选择apache-maven-3.6.0\\conf中的settings.xml文件->Reindex-Apply and Close\n###  在IDEA中配置Maven\n◇Settings->Build,Execution->Build Tools->Maven->Maven home directory: ;User settings file: ;Local repository: \n![image.png](Maven项目管理/1627914341482-b8b8d144-9206-48d8-82e5-94b3fa017a28.png)\n◇创建Maven项目：New Project->Maven->Next->GroupID;ArtifactID;Version->Next->Finish\n◇IDEA关于Maven的快捷键:点击右边的Maven弹出界面,即Maven的常用命令\n![image.png](Maven项目管理/1627915088171-0ea5f377-320d-4db9-90c8-30e2f2f06f5b.png)\n\n","tags":["Maven"],"categories":["Java数据库","框架前置知识"]},{"title":"JDBC入门","url":"/p/8791.html","content":"##  主要知识点  \n◇JDBC使用步骤 \n◇数据库查询方法 \n◇数据库写入方法\n◇SQL注入攻击的应对 \n◇连接池的使用 \n◇Apache Commons DBUtils  \n##  什么是JDBC  \n◇Java数据库连接-Java DataBase Connectivity \n◇JDBC可让Java通过程序操作关系型数据库\n◇JDBC基于驱动程序实现与数据库的连接与操作  \n##  什么是驱动程序  \n![image.png](JDBC入门/1627277427089-85c466be-a249-4635-97bc-01d3aadddf7e.png)\n ◇JDBC驱动程序  \n![image.png](JDBC入门/1627277734522-eff71526-c749-4218-918b-9c681fa21208.png)\n\n##  JDBC的优点  \n◇统一的API,提供一致的开发过程 \n◇易于学习,容易上手,代码结构稳定 \n◇功能强大,执行效率高,可处理海量数据  \n##  JDBC开发简要流程  \n### 0.Navicat创建数据库\n\n◇字符集采用utf8mb4\n\n### 1. 加载并注册JDBC驱动 \n◇将MySQL驱动的jar包复制到工程的lib目录->File->Project Structure->Modules(模块)->Dependencies(依赖)->'+'->1->选择lib目录下的jar包，OK->勾选Export->OK\n```sql\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n```\n### 2. 创建数据库连接 \n```sql\n \"jdbc:mysql://localhost:3306/gamest?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\",\n                \"root\",\"password\"\n```\n### 3. 创建Statement对象 \n```sql\nStatement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(\"select * from employee\");\n```\n### 4. 遍历查询结果  \n```sql\nwhile (rs.next()) {\n         Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置\n         String ename = rs.getString(\"ename\");//获取ename列的数据（数据为String型），按名称\n         Float salary = rs.getFloat(\"salary\");\n         String dname = rs.getString(\"dname\");\n         System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n```\n### 5. 关闭连接,释放资源  \n```sql\nif (conn!=null&&conn.isClosed()==false){//防止空指针异常\n         //5. 关闭连接,释放资源\n         conn.close();//如果conn为空，则会出现空指针异常，如执行1.就报错后，conn为空}\n```\n## JDBC开发详细流程\n###  如何获取JDBC驱动Jar  \n◇[Mysql官网下载](https://www.mysql.com/cn/products/connector/)MySQL Connectors ->JDBC Driver for MySQL->由于是跨平台的，选择任意版本即可Ubuntu Linux->直接下载。\n###  创建数据库连接代码  \n```sql\nString dbDriver = \"com.mysql.cj.jdbc.Driver\"; //JDBC驱动类\nString dbURL = \"jdbc:mysql://localhost:3306/gamest\" ; //连接字\n符串\nString dbUsername = \"root\"; //数据库用户名\nString dbPassword = \"123456\"; //数据库密码\n//1.加载并初始化JDBC驱动\nClass.forName(dbDriver);\n//2.创建数据库连接\nConnection connection = DriverManager.getConnection(dbURL, dbUsername, dbPassword);\n```\n###  Class.forName的作用  \n◇Class.forName用于加载指定的JDBC驱动类 \n◇Class.forName本质是通知JDBC注册这个驱动类 \n◇驱动由数据库厂商自行开发,连接字符串也不同  \n###  数据库与连接字符串  \n![image.png](JDBC入门/1627288444741-e2147775-ca39-4693-88c7-0f545847efb5.png)\n###  DriverManager  \n◇DriverManager用于注册/管理JDBC驱动程序 \n◇DriverManager.getConnection(连接字符串,用户名,密码) \n◇返回值Connection对象,对应数据库的物理网络连接  \n###  Connection对象  \n◇Connection对象用于JDBC与数据库的网络通信对象 \n◇java.sql.Connection是一个接口，具体由驱动厂商实现 \n◇所有数据库的操作都建立在Connection基础上  \n![image.png](JDBC入门/1627311314818-03c42582-5f5a-4798-8a3a-8062442ab49f.png)\n\n###  MySQL连接字符串  \n◇格式: jdbc:mysql://\\[主机ip\\]\\[:端口\\]/数据库名?参数列表 \n◇主机ip与端口是可选设置,默认值为127.0.0.1与3306 \n◇参数列表采用url编码,格式:参数1=值1&参数2=值2&...  \n\n###  MySQL连接字符串常用参数  \n![image.png](JDBC入门/1627311449343-e094739a-3298-4553-8e3e-ad1ee903c721.png)\n###  连接数据库的常见问题  \n◇ClassNotFoundException - 类未找到异常 \n◇Connection refuse - 数据库连接被拒绝异常 \n◇Access denied for user - 用户名与密码错误异常  \n##  数据库查询操作  \n◇部分代码\n```sql\n//4. 遍历查询结果\n            /*rs.next()返回布尔值，代表是否存在下一条记录，若有，返回true\n            同时提取下一条记录；如果没有，返回false，循环就会停止*/\n         while (rs.next()){\n           Integer eno = rs.getInt(1);//JDBC中字段索引从1开始\n           String ename = rs.getString(\"ename\");//获取ename列的数据（数据为String型），按名称\n           Float salary = rs.getFloat(\"salary\");\n           String dname = rs.getString(\"dname\");\n           System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n           }\n         //5.关闭连接，释放资源\n            try {\n                if(rs!=null){\n                    rs.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if(stmt!=null){\n                    stmt.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if(conn!=null&&!conn.isClosed()){//不为空并且没有关闭\n                    conn.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n```\n### Statement对象 \n◇Statement是用于执行SQL的工具 \n◇查询方法: ResultSet executeQuery(String sql) \n◇注意: sql参数必须是SELECT 查询SQL语句 \n### ResultSet对象 \n◇ResultSet结果集对象,保存查询结果 \n◇ResultSet采用迭代方式逐行获取每一行表数据 \n◇每一次迭代,使用ResultSet对象的getXXX()方法获取列数据  \n##  SQL注入攻击  \n◇SQL注入攻击是指利用SQL漏洞越权获取数据的黑客行为 \n◇SQL注入攻击根源是未对原始SQL中的敏感字符做特殊处理 \n◇解决方法:放弃Statement改用PreparedStatement处理SQL  \n###  PreparedStatement  \n◇PreparedStatement 预编译Statement是Statement接口的子接口 \n◇PreparedStatement对SQL进行参数化,预防SQL注入攻击 \n◇PreparedStatement比Statement执行效率更高  \n◇原始代码  \n```sql\n// 存在SQL注入风险\n// pdname值为' or 1=1 or 1='时,所有筛选条件均失效\n// SQL: select * from employee where pdname='' or 1=1 or 1='' ;单引号没有处理\nString sql = \"select * from employee where dname='\" + pdname + \"'\" ;\nStatement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery(sql);\nwhile(rs.next()){\n....\n}\n```\n ◇PreparedStatement  \n```sql\n// 利用PreparedStatement预防SQL注入风险\n// 当dname值为' or 1=1 or 1='时 , 查询不到任何结果\n// SQL: select * from employee where dname='\\' or 1=1 or 1=\\'' ;单引号被处理\nString sql = \"select * from employee where dname=?\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setString(1,dname); //设置SQL参数,参数从1开始\nResultSet rs = pstmt.executeQuery();\nwhile(rs.next()){\n....\n}\n```\n◇示例代码\n```java\npackage com.lcg.jdbc.hrapp.command;\n\nimport java.sql.*;\nimport java.util.Scanner;\n\n/**\n * PreparedStatement对象使用方法\n */\npublic class PstmtQueryCommand implements Command {\n    @Override\n    public void execute() {\n        System.out.print(\"请输入部门名称：\");\n        Scanner in = new Scanner(System.in);\n        String pdname = in.nextLine();\n        Connection conn = null;\n        //Statement stmt = null;\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        try {\n            //1. 加载并注册JDBC驱动\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            //2. 创建数据库连接\n            conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/imooc?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true\", \"root\", \"root\");\n            //3. 创建PreparedStatement对象\n            String sql = \"select * from employee where dname=? and eno > ?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setString(1, pdname); //注意:参数索引从1开始\n            pstmt.setInt(2, 3500);//2,即第二个参数\n            //结果集\n            rs = pstmt.executeQuery();\n            //4. 遍历查询结果\n            //rs.next()返回布尔值，代表是否存在下一条记录\n            //如果有，返回true,同时结果集提取下一条记录\n            //如果没有，返回false，循环就会停止\n            while (rs.next()) {\n                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0\n                String ename = rs.getString(\"ename\");\n                Float salary = rs.getFloat(\"salary\");\n                String dname = rs.getString(\"dname\");\n                System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n\n            }\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //5. 关闭连接,释放资源\n            try {\n                if (rs != null) {\n                    rs.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n\n            try {\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n\n            try {\n                if (conn != null && !conn.isClosed()) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n### SQL传参的错误使用方式\n\n◇下面是在JDBC中几种常见的错误传参方式:\n\n```sql\n#传入参数的占位符?只能在=的右边，即传入的参数只能作为值。=的左边是字段名，参数不能作为字段使用\nselect * from employee where ?='abc' \n#SQL参数不允许进行二次计算\nselect * from employee where salary = ?+100 \n#SQL参数不能作为字段使用\nselect ? from employee where ename = ?  \n```\n\n##  JDBC实现写数据  \n###  封装DbUtils工具类  \n◇工具类代码\n```sql\npublic class DbUtils {\n    /**\n     * 在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板\n     * 创建新的数据库连接\n     * @return 新的Connection对象\n     * @throws SQLException\n     * @throws ClassNotFoundException\n     */\n    public static Connection getConnection() throws SQLException, ClassNotFoundException {\n        //1. 加载并注册JDBC驱动\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");\n        //2. 创建数据库连接\n        Connection conn = DriverManager.getConnection(\n                \"jdbc:mysql://localhost:3306/gamest?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\",\n                \"root\", \"password\"\n        );\n        return conn;\n    }\n    /**\n     * 关闭连接，释放资源\n     * @param rs 结果集对象\n     * @param pstmt Statement对象\n     * @param conn Connection对象\n     */\n    public static void closeConnection(ResultSet rs, PreparedStatement pstmt,Connection conn){\n        try {\n            if(rs!=null){\n                rs.close();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        try {\n            if(pstmt!=null){\n                pstmt.close();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        try {\n            if(conn!=null&&!conn.isClosed()){\n                conn.close();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n###  JDBC执行INSERT语句  \n```sql\nString sql= \"insert into employee(eno,ename) values(?,?)\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setInt(1,10);\npstmt.setString(2,\"张三\");\n//executeUpdate方法返回记录数\nint cnt = pstmt.executeUpdate(); //cnt=1,表示sql语句所影响的数据库的行数\nSystem.out.println(\"数据新增成功\");\n```\n◇新增员工数据\n```sql\npublic class InsertCommand implements Command{\n    @Override\n    public void execute(){\n        Scanner in = new Scanner(System.in);\n        System.out.println(\"请输入员工编号\");\n        int eno = in.nextInt();\n        System.out.println(\"请输入员姓名\");\n        String ename = in.next();\n        System.out.println(\"请输入员工薪资\");\n        float salary = in.nextFloat();\n        System.out.println(\"请输入隶属部门\");\n        String dname = in.next();\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        try {\n            conn = DbUtils.getConnection();\n            String sql = \"insert into employee(eno,ename,salary,dname) values(?,?,?,?)\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, eno);\n            pstmt.setString(2, ename);\n            pstmt.setFloat(3, salary);\n            pstmt.setString(4, dname);\n            int cnt = pstmt.executeUpdate();//所有写操作都使用executeUpdate\n            System.out.println(\"cnt:\"+cnt);\n            System.out.println(ename+\"员工入职手续办理成功\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }finally {\n            DbUtils.closeConnection(null,pstmt,conn);\n        }\n    }\n}\n```\n###  JDBC执行UPDATE语句  \n```sql\nString sql= \"update employee set salary=salary + 1000 where dname=?\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setString(1,\"研发部\");\n//executeUpdate方法返回记录数\nint cnt = pstmt.executeUpdate();\nSystem.out.println(\"研发部\" + cnt + \"名员工提薪1000元\");\n```\n###  JDBC执行DELETE语句  \n```sql\nString sql= \"delete from employee where eno = ?\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setInt(1, 3395);\n//executeUpdate方法返回记录数\nint cnt = pstmt.executeUpdate();\nSystem.out.println(cnt+\"名员工数据已被删除\");\n```\n##  JDBC中的事务管理  \n### 什么是事务 \n◇事务是以一种可靠的、一致的方式，访问和操作数据库的程序单元 \n◇说人话：要么把事情做完，要么什么都不做，不要做一半 \n◇事务依赖于数据库实现,MySQL通过事务区作为数据缓冲地带  \n###  事务的提交操作  \n![image.png](JDBC入门/1627462586528-28cc5fc3-1e3f-465e-9968-8e89b86516eb.png)\n### 事务的回滚操作\n![image.png](JDBC入门/1627462637835-0f24ab7b-4905-4827-9f32-f494780da680.png)\n\n###  JDBC两种事务模式    \n◇JDBC允许两种事务模式 \n◇自动提交事务模式 \n◇手动提交事务模式  \n####  自动提交事务模式  \n◇自动提交模式是指每执行一次写操作SQL,自动提交事务 \n◇自动提交开启方法: conn.setAutoCommit(true) \n◇自动事务是JDBC默认行为,此模式无法保证多数据一致性  \n####  手动提交事务模式  \n◇手动提交模式是指显式调用commit()与rollback()方法管理事务 \n◇手动提交开启方法: conn.setAutoCommit(false) \n◇手动提交事务可保证多数据一致性,但必须手动调用提交/回滚方法  \n###  实现批量增加员工  \n```sql\n/**\n * JDBC中的事务机制\n */\npublic class TransactionSample {\n    public static void main(String[] args) {\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        try {\n            conn = DbUtils.getConnection();\n            //JDBC默认使用自动提交模式\n            conn.setAutoCommit(false);//设置手动提交\n            String sql = \"insert into employee(eno,ename,salary,dname) values(?,?,?,?)\";\n            for(int i=100;i<200;i++){\n/*                if(i==105){\n                    throw new RuntimeException(\"插入失败\");//模拟抛出异常\n                }*/\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1,i);\n                pstmt.setString(2, \"员工\" + i);\n                pstmt.setFloat(3, 5000);\n                pstmt.setString(4, \"市场部\");\n                pstmt.executeUpdate();\n            }\n            conn.commit();//当for循环全部完成后，才开始进行提交\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                if (conn!=null&&!conn.isClosed()) {\n                    conn.rollback();//发生异常回滚\n                }\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            DbUtils.closeConnection(null,pstmt,conn);\n        }\n    }\n}\n```\n##  基于实体类实现分页数据封装  \n◇实体类代码\n```sql\n/**\n * 员工实体类\n */\npublic class Employee {\n    /**\n     * 需符合javabean的要求\n     * 1.具备默认构造函数\n     * 2.属性私有\n     * 3.存在getter与setter\n     */\n    public Employee(){}\n    private Integer eno;\n    private String ename;\n    private Float salary;\n    private String dname;\n\n    public Integer getEno() {\n        return eno;\n    }\n\n    public void setEno(Integer eno) {\n        this.eno = eno;\n    }\n\n    public String getEname() {\n        return ename;\n    }\n\n    public void setEname(String ename) {\n        this.ename = ename;\n    }\n\n    public Float getSalary() {\n        return salary;\n    }\n\n    public void setSalary(Float salary) {\n        this.salary = salary;\n    }\n\n    public String getDname() {\n        return dname;\n    }\n\n    public void setDname(String dname) {\n        this.dname = dname;\n    }\n\n}\n```\n◇分页命令代码\n```sql\n/**\n * 分页查询员工数据\n */\npublic class PaginationCommand implements Command {\n    @Override\n    public void execute(){\n        Scanner in = new Scanner(System.in);\n        System.out.println(\"请输入页号：\");\n        int page = in.nextInt();\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        List<Employee> list = new ArrayList();//存储查询结果\n        try {\n            conn = DbUtils.getConnection();\n            String sql = \"select * from employee limit ?,10\";//10代表从？开始往后取10条记录\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1,(page-1)*10);//分页公式\n            rs = pstmt.executeQuery();\n            while (rs.next()){\n                Integer eno = rs.getInt(\"eno\");\n                String ename = rs.getString(\"ename\");\n                Float salary = rs.getFloat(\"salary\");\n                String dname = rs.getString(\"dname\");\n                Employee emp = new Employee();\n                emp.setEno(eno);\n                emp.setEname(ename);\n                emp.setSalary(salary);\n                emp.setDname(dname);\n                list.add(emp);//将emp实体加到list集合中\n            }\n            System.out.println(list.size());\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }finally {\n            DbUtils.closeConnection(rs, pstmt, conn);\n        }\n    }\n}\n```\n##  JDBC中Date日期对象的处理  \n◇实体类中添加日期\n```sql\nprivate Date hiredate;\npublic Date getHiredate() {\n        return hiredate;\n    }\npublic void setHiredata(Date hiredate) {\n        this.hiredate = hiredate;\n    }\n```\n◇分页命令添加日期\n```sql\n//JDBC获取日期使用java.sql.Date,其继承自java.util.Date\n//所以两者互相兼容\nDate hiredata = rs.getDate(\"hiredate\");\n emp.setHiredate(hiredate);\n```\n◇向数据库中写入日期时需要使用java.sql.Date\n```sql\nSystem.out.println(\"请输入入职日期\");\n        String strHiredate = in.next();\n        //String 到java.sql.Date分为两步\n        //1.将String转为java.util.Date\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        java.util.Date udHiredate = null;\n        try {\n             udHiredate = sdf.parse(strHiredate);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        //2.将util转为sql\n        long time = udHiredate.getTime();//获取1970年到现在的毫秒数\n        java.sql.Date sdHiredate = new java.sql.Date(time);\n        \npstmt.setDate(5,sdHiredate);//java.sql.Date\n```\n## JDBC数据批处理\n◇批处理部分代码\n```sql\npstmt = conn.prepareStatement(sql);\n            for(int i=100000;i<200000;i++){\n                pstmt.setInt(1,i);\n                pstmt.setString(2, \"员工\" + i);\n                pstmt.setFloat(3, 5000f);\n                pstmt.setString(4, \"市场部\");\n                pstmt.addBatch();//将参数加入批处理任务\n                //pstmt.executeUpdate();\n            }\n            pstmt.executeBatch();//执行批处理任务\n            conn.commit();//当for循环全部完成后，才开始进行提交\n```\n◇批处理效率高的原因：在标准方法中，创建了十万个prepareStatement对象，每一个对象都是新增一条数据；而在批处理方法中，是用一个对象新增十万条数据；\n## 连接池与JDBC进阶使用\n◇连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用\n### 阿里巴巴Druid连接池  \n◇Druid是阿里巴巴开源连接池组件,是最好的连接池之一 \n◇Druid对数据库连接进行有效管理与重用,最大化程序执行效率 \n◇连接池负责创建管理连接,程序只负责取用与归还  \n![image.png](JDBC入门/1627542621734-d1f41e8f-ec79-4286-910d-86feb455549d.png)\n\n###  Druid连接池配置与使用  \n◇配置.properties文件\n```java\n//不需要引号和分号,将初始尺寸和最大尺寸设为一致可便于维护\ndriverClassName=\nurl=\nusername=\npassword=\ninitialSize=10  //初始尺寸:连接池默认创建10个数据库连接\nmaxActive=20 //最大尺寸:数据库不够用时，创建的最大连接数，还不够用则需等待\n```\n◇使用连接池\n```java\n/**\n * Druid连接池配置与使用\n */\npublic class DruidSample {\n    public static void main(String[] args) {\n        //1.加载属性文件\n        Properties properties = new Properties();\n        //作用：获取当前类(DruidSample)路径下对应文件的路径，因为配置文件会随着代码运行而发布到运行文件夹中\n        String propertyFile = DruidSample.class.getResource(\"/druid-cofig.properties\").getPath();\n        //在上面获取的路径中getPath方法会进行URL编码:空格->%20\n        // 如：原始路径：c:\\java code 转换后的路径：c:\\java%20code;\n        // 使用URLDecoder().decode()方法进行容错，将%20还原为空格\n        try {\n            propertyFile = new URLDecoder().decode(propertyFile, \"UTF-8\");\n            properties.load(new FileInputStream(propertyFile));//加载,load参数为文件流\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        ResultSet rs = null;\n\n        try {\n            //2.获取DataSource数据源对象\n            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//DataSource选择sql\n            //3.创建数据库连接\n            conn = dataSource.getConnection();\n            psmt = conn.prepareStatement(\"select * from employee limit 0,10\");\n            rs = psmt.executeQuery();\n            while (rs.next()) {\n                Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置\n                String ename = rs.getString(\"ename\");//获取ename列的数据（数据为String型），按名称\n                Float salary = rs.getFloat(\"salary\");\n                String dname = rs.getString(\"dname\");\n                System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            /**\n             * 不使用连接池：conn.close()关闭连接\n             * 使用连接池：conn.close()将连接回收至连接池\n             */\n            DbUtils.closeConnection(rs,psmt,conn);\n        }\n    }\n}\n```\n###  扩展知识:C3P0连接池  \n◇配置文件，使用xml且文件名必须为：c3p0-config.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<c3p0-config>\n    <default-config>\n        <property name=\"driveClass\">com.mysql.cj.jdbc.Driver</property>\n        <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</property>\n        <property name=\"user\">root</property>\n        <property name=\"password\">password</property>\n        <property name=\"initialPoolSize\">10</property>\n        <property name=\"maxPoolSize\">20</property>\n    </default-config>\n</c3p0-config>\n```\n◇使用\n```java\npublic class C3P0Sample {\n    public static void main(String[] args) {\n        //1.加载配置文件\n        //2.创建DataSource\n        DataSource dataSource = new ComboPooledDataSource();\n        //3.得到数据库连接\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        ResultSet rs = null;\n        .....\n    }\n}\n```\n###  Apache Commons DBUtils  \n◇commons-dbutils是Apache提供的开源JDBC工具类库 \n◇它是对JDBC的简单封装,学习成本较低 \n◇使用commons-dbutils可以极大简化JDBC编码工作量  \n\n```java\n/**\n * Apache DBUtils + Druid联合使用\n */\npublic class DbUtilsSample {\n    private static void query(){\n        Properties properties = new Properties();\n        String propertyFile = \n            DruidSample.class.getResource(\"/druid-config.properties\").getPath();\n        try {\n            propertyFile = new URLDecoder().decode(propertyFile, \"UTF-8\");\n            properties.load(new FileInputStream(propertyFile));\n            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n            //利用Apache DbUtils大幅简化了数据的提取过程\n            /**\n             * BeanListHandler将结果集包装成list对象\n             * Object[]{1}用来传递参数，这里表示？=1\n             */\n            QueryRunner qr = new QueryRunner(dataSource);\n            List<Employee> list =  qr.query(\"select * from employee limit ?,10\",\n                    new BeanListHandler<>(Employee.class),\n                    new Object[]{1});\n            for (Employee emp : list) {\n                System.out.println(emp.getEname()+\"--\"+emp.getSalary());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }//自动关闭数据库连接\n    }\n\n    public static void update(){\n        Properties properties = new Properties();\n        String propertyFile = \n            DruidSample.class.getResource(\"/druid-config.properties\").getPath();\n        Connection conn = null;\n        try {\n            propertyFile = new URLDecoder().decode(propertyFile, \"UTF-8\");\n            properties.load(new FileInputStream(propertyFile));\n            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n            conn = dataSource.getConnection();//创建连接\n            conn.setAutoCommit(false);//关闭自动提交\n            String sql1 = \"update employee set salary=salary+10000 where eno=?\";\n            String sql2 = \"update employee set salary=salary-1000 where eno=?\";\n            QueryRunner qr = new QueryRunner();\n            qr.update(conn,sql1,new Object[]{1});\n            qr.update(conn, sql2, new Object[]{100});\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                if (conn!=null&&!conn.isClosed()){\n                    conn.rollback();\n                }\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        }finally {\n            try {\n                if(conn!=null&&!conn.isClosed()){\n                    conn.close();//对数据库连接进行回收，前面手动创建了连接\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) {\n        query();\n        //update();\n    }\n}\n```\n\n","tags":["数据库"],"categories":["Java数据库","Java数据库开发基础"]},{"title":"IDEA开发工具入门","url":"/p/5708.html","content":"## IDEA开发工具入门\n### IntelliJ IDEA\n◇IDEA全称IntelliJ IDEA ,是Java编程公认的最好的IDE\n◇IDEA提供了大量的智能工具，例如语法提示，代码分析，格式化等\n◇IDEA最核心的特色是它的快捷键，利用快捷键可以极大提高开发效率\n\n### IDEA的特点\n◇沉浸式开发体验\n◇超强的快捷键体系\n◇智能的代码助手\n◇全栈开发环境\n◇丰富的模板支持\n## IDEA快捷键\n### IDEA窗口快捷键\n◇Find Action即模糊查询所有的功能\n\n| 快捷键         | 描述          |\n| -------------- | ------------- |\n| Ctrl+Alt+S     | Settings面板  |\n| Ctrl+Shift+F/R | 全局查找/替换 |\n| Ctrl+Shift+N   | 文件查找面板  |\n| Alt+Insert     | 快速生成面板  |\n| Ctrl+Shift+A   | Find Action   |\n\n### 代码快捷键\n\n| 快捷键           | 描述              |\n| ---------------- | ----------------- |\n| Ctrl+C/X/V       | 复制/剪贴/粘贴    |\n| Ctrl+←→          | 上一个/下一个单词 |\n| Ctrl+Shift+Enter | 自动完成          |\n| Alt+Enter        | 智能提示          |\n| Ctrl+Alt+L       | 格式化代码        |\n| Ctrl+(Shift)+/   | 行注释/块注释     |\n| Shift+F6         | 重命名            |\n| Ctrl+W           | 选中单词          |\n| Ctrl+Alt+Shift+J | 列操作            |\n\n### 代码快速定位\n\n| 快捷键          | 描述                     |\n| --------------- | ------------------------ |\n| Ctrl+(Shift)+E  | 最近访问(编辑)的文件列表 |\n| Ctrl+Shift+ 1~9 | 创建书签                 |\n| Shift+F11       | 查看书签                 |\n| Ctrl+1~9        | 快速切换书签             |\n| Alt + ←→        | 切换标签                 |\n\n### Live Template\n◇也可以自定义，自定义方法为：settings->Editor->Live Template->'+' 2->'+'1;\n\n| 快捷键 | 描述                       |\n| ------ | -------------------------- |\n| psvm   | public static void main()  |\n| sout   | System.out.println()       |\n| psfs   | public static final String |\n| fori   | for循环                    |\n| itli   | List迭代                   |\n\n### 运行与打包\n◇打包方法：File->Project Structure->Artifacts->'+' ->JAR->empty->Create Manifest(定义入口类)->默认选中->OK->选择入口类->将右侧的compile output双击添加到左侧(即将编译后的类打入JAR包)->OK->.MF文件创建成功->Build->Build Artifacts ->Action:Bulid->生成jar包\n在生成的jar包上右键选中Open in File path( Show in explore在文件管理器中打开)->在地址栏中删掉地址然后直接输入cmd进入命令行(会自动定位到目录地址)->键入java -jar 文件名.jar\n\n| 快捷键        | 描述                 |\n| ------------- | -------------------- |\n| Shift+F9      | 调试                 |\n| Shift+F10     | 运行                 |\n| F8            | 单步运行             |\n| F9            | 恢复运行至下一个断点 |\n| Shift+Ctrl+F8 | 查看所有断点         |\n\n### 其他快捷键\n◇查看方法返回类型：Ctrl+q\n◇查看方法的具体实现：Ctrl+Alt\n◇方法或类注释：在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板\n\n## IDEA开发Web应用\n◇NewProjece-> Java Enterprise ->服务器选择Tomcat ->勾选WebApplication 3.1->勾选create web.xml->Next->输入工程名称->finish;\n◇如何更改URL的上下文路径: 点击Tomcat下拉框->Edit Configurations ->Deployment->Application context->修改->OK\n◇热部署(即修改项目后在浏览器能直接查看，只支持在DeBug模式下)：点击Tomcat下拉框->Edit Configurations ->Server->On frame deactivation->Update classes and resources->OK \n◇打包Web项目：File->Project Structure->Artifacts->'+'Web Application:Archive->Empty->双击compile output添加到左侧war包中->双击Web facet resource将静态资源放入左侧->OK->Build->Build Artifact ->选择打包文件->Build ->复制.war文件将其放到Tomcat实际运行环境的webapps目录下->在Tomcat/bin目录中双击startup.bat文件启动Tomcat->浏览器输入路径即可。\n![image.png](IntelliJ IDEA开发工具入门/1627096260390-f697c0eb-8644-4516-bc22-fa9ba432d2e0.png)\n","tags":["开发"],"categories":["Java数据库","Java数据库开发基础"]},{"title":"MySQL综合应用","url":"/p/c9e2.html","content":"##  数据库的事务机制  \n###  避免写入直接操作数据文件  \n ◇ 如果数据的写入直接操作数据文件是非常危险的事情  \n![image.png](MySQL综合应用/1626917790269-93acb2ad-63b6-4dd4-be0c-2e9fc2a0efb0.png)\n\n###  利用日志来实现间接写入  \n◇ MySQL总共有5种日志，其中redo(重做)日志和undo(回滚)日志与事务有关 。redo日志保证事务一致性，undo日志保证原子性。\n\n![image.png](MySQL综合应用/1626917898437-0ccbca8d-0d06-4df1-a5bc-55e18b880fe0.png)\n\n###  事务机制（Transaction）  \n◇ RDBMS = SQL语句 + 事务（ACID）  \n\n◇ 事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要 么全都执行失败  \n\n###  事务案例  \n◇ 把10部门中MANGER员工调往20部门，其他岗位的员工调往30部门，然后删除10部门  \n![image.png](MySQL综合应用/1626917996276-921161a2-38af-41f5-ae65-e38647751e68.png)\n\n###  管理事务  \n◇ 默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务  \n\n◇ 为了让多条SQL语句纳入到一个事务之下，可以手动管理事务  \n\n```sql\nSTART TRANSACTION ;//开启事务\nSQL语句\n[ COMMIT | ROLLBACK ] ;//提交|回滚\n```\n###  事务的ACID属性  \n![image.png](MySQL综合应用/1626918119445-1a0602c1-e9b0-4847-bfce-dcefc14db76d.png)\n####  事务的原子性  \n◇ 一个事务中的所有操作要么全部完成，要么全部失败。事务执行后 ，不允许停留在中间某个状态  \n####  事务的一致性  \n◇ 不管在任何给定的时间、并发事务有多少，事务必须保证运行结果的一致性  \n\n◇ 事务可以并发执行，但是最终MySQL却串行执行  \n![image.png](MySQL综合应用/1626918183199-9912d76a-7d0f-43f0-b79e-3a527aa25551.png)\n\n####  事务的隔离性\n◇ 隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务是数据库唯一运行的事务\n\n◇ 默认情况下A事务，只能看到日志中该事务的相关数据  \n![image.png](MySQL综合应用/1626918249811-8534a704-899e-49cb-9c39-01d8f26737fc.png)\n\n####  事务的持久性  \n ◇事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化  \n###  事务的四个隔离级别  \n![image.png](MySQL综合应用/1626918389326-5eab4721-6bd8-43a0-bf2e-6a779663c28e.png)\n\n◇隔离级别造成的影响：①**脏读**表示 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。②**不可重复读**：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。③**幻读**：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n|     隔离级别     | 脏读 | 不可重复读 | 幻读 |\n| :--------------: | :--: | :--------: | :--: |\n| READ-UNCOMMITTED |  √   |     √      |  √   |\n|  READ-COMMITTED  |  ×   |     √      |  √   |\n| REPEATABLE-READ  |  ×   |     ×      |  √   |\n|   SERIALIZABLE   |  ×   |     ×      |  ×   |\n\n###  修改事务隔离级别  \n\n◇在Navicat中开启两个sql面板可以模拟两个不同的事务；Mysql默认的隔离级别是REPEATABLE READ\n◇ READ UNCOMMITTED 代表可以读取其他事务未提交的数据  \n\n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL \nREAD UNCOMMITTED;\n```\n◇ READ COMMITTED 代表只能读取其他事务提交的数据  \n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL \nREAD COMMITTED;\n```\n◇ REPEATABLE READ 代表事务在执行中反复读取数据，得到的结果是一致的，不会受其他事务影响  \n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL \nREPEATABLE READ;\n```\n###  业务案例  \n①比如说购票场景里面，由于事务之间是隔离的，所以A、B两事务分别对第一条记录进行操作；A事务修改将其改为已售出，但是A事务未进行提交，因此真实的数据还是未售出状态；B事务将其改为已售出，并且很快进行提交；那么当A进行提交时，发现记录变成了已售出，就会发生回滚，即修改失败；虽然说没有产生有歧义的数据，但是动不动就购票失败，十分影响用户体验；因此在这个场景下我们应当允许事务去读取其他事务的临时状态；B事务可以看到A事务里的临时信息，即修改了第一条记录，但未提交；那么B就无法修改此记录；就不会引发数据冲突了；所以这里使用的隔离级别为:READ UNCOMMITTED\n![image.png](MySQL综合应用/1626918423470-5ed66a73-33cf-4fd7-8082-cdefb265ee8a.png)\n②对于银行转账之类的业务场景；就只能让当前事务去读取其他事务已经提交的数据，而不能够去读取其他事务的临时数据;比如说下面的Scott账户，假设B事务执行，需要支出100元，但是还没有提交；而这时A事务进行转账操作，由于可以看到B事务的临时数据，所以A事务看到Scott账户为4900元，提交后，账户变为5900元；但如果B事务由于某些原因回滚的话，原来的操作无效；而此时账户余额却是4900元，凭空少了100元；因此这种场景必须使用READ COMMITTED隔离级别；\n![image.png](MySQL综合应用/1626918537468-9c083613-aa6e-4b96-9e6a-3cb7625db4f6.png)\n③又如，A事务进行某商品的下单购票后未提交事务，但是B事务确将商品价格提高了；那么此时A事务应该根据原价购买；所以隔离级别使用REPEATABLE READ；即不受其他任何事务的影响，无论其他事务提交与否；\n![image.png](MySQL综合应用/1626918633199-35ba965c-25a8-41b6-b280-3a59d1b6d4ee.png)\n\n###  事务的序列化  \n◇ 由于事务并发执行所带来的各种问题，前三种隔离级别只适用在某些业务场景中，但是序列化的隔离性，只有前面的会话结束后(事务提交后)才能执行下一个事务，即让事务逐一执行，不能够并发地执行事务；但是这样会大大降低数据库的并发能力，所以不太常用；  \n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL\nSERIALIZABLE;\n```\n##  数据导入与导出  \n### 数据导出与备份的区别 \n◇ 数据导出，导出的纯粹是业务数据  \n\n◇ 数据备份，备份的是数据文件、日志文件、索引文件等等  \n![image.png](MySQL综合应用/1626918828306-0b54f018-06c6-4391-8539-16724d411448.png)\n\n###  数据导出的分类  \n![image.png](MySQL综合应用/1626918863615-44b06718-5e90-4bbd-99c0-489bbc76cba0.png)\n###  导出SQL文件  \n◇ mysqldump用来把业务数据导出成SQL文件，其中也包括了表结构  \n```sql\nmysqldump -uroot -p [ no-data ] 逻辑库 > 路径\n```\n◇ 如果业务数据非常多，建议只导出表结构，然后用SELECT INTO OUTFILE把数据导出成文本文档  \n###  导入SQL文件  \n◇ source命令用于导入SQL文件，包括创建数据表，写入记录等  \n```sql\nsql > USE demo ;\nsql > SOURCE backup.sql ;\n```\n\n","tags":["MySQL"],"categories":["Java数据库","MySQL基础"]},{"title":"MySQL基本函数","url":"/p/8500.html","content":"##  MySQL的函数  \n ◇像编程语言利用函数封装业务功能一样，数据库也把一些复杂的功能封装到函数里，供使用者调用  \n ◇也可以自定义函数\n![image.png](MySQL基本函数/1626744661345-6111ef9d-04c3-4761-b727-9ae5c97863f8.png)\n\n## 数字函数  \n###  数字函数（一）  \n![image.png](MySQL基本函数/1626744703126-a396cd11-c086-4a87-b1b4-6312391ae480.png)\n###  数字函数（二）  \n◇三角函数的参数为弧度\n![image.png](MySQL基本函数/1626744716967-68f7ed15-b497-4b9e-9f62-1c2445dbe9ec.png)\n\n## 日期函数\n###  获取系统时间函数  \n◇NOW()函数能获得系统日期和时间，格式yyyy-MM-dd hh:mm:ss \n◇CURDATE()函数能获得当前系统日期，格式yyyy-MM-dd \n◇CURTIME()函数能获得当前系统时间，格式hh:mm:ss  \n###  日期格式化函数  \n![image.png](MySQL基本函数/1626752210323-8c7cf93e-cd79-462d-8331-0f275fd02f86.png)\n◇ DATE_FORMAT()函数用于格式化日期，返回用户想要的日期格式  \n\n```sql\nDATE_FORMAT( 日期, 表达式)\nSELECT ename,DATE_FORMAT(hiredate,\"%Y\")-- 获取年份的格式\nDATE_FORMAT(hiredate,\"%Y/%m%d\") -- 返回2021/07/20这种格式\nFROM t_emp;\n```\n###  日期计算的注意事项  \n◇ MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减  \n###  日期偏移计算 \n ◇ DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活  \n```sql\nDATE_ADD( 日期 , INTERVAL 偏移量 时间单位 )\n\nSELECT DATE_ADD(NOW(),INTERVAL 15 DAY);\nSELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE);\n```\n###  计算日期之间相隔的天数  \n◇ DATEDIFF()函数用来计算两个日期之间相差的天数  \n```sql\nDATEDIFF ( 日期 , 日期 )\n```\n###  课堂练习  \n◇ 利用日期函数，查询明年你的生日是星期几？  \n```sql\nSELECT DATE_FORMAT(\"2020-02-19\",\"%w\")\n```\n◇ 利用日期函数，查询1981年上半年入职的员工有多少人？  \n```sql\nSELECT COUNT(*) FROM t_emp\nWHERE DATE_FORMAT(hiredate,\"%Y\")=1981\nAND DATE_FORMAT(hiredate,\"%m\")<=6;\n```\n## 字符函数\n###  字符函数（一）  \n◇INSERT(\"ABC\",1,0,\"DE\")数字1表示从前面的字符串ABC的第一个位置插入后面的字符串DE，0表示替换从插入位置起的0个字符；\n◇REPLACE() 的第二个参数表示被替换的内容，最后一个参数表示替换的内容\n![image.png](MySQL基本函数/1626744868617-349e75c7-1c16-4cd4-bf54-b7ed9fab0132.png)\n\n###  字符函数（二）  \n◇截取字符串起始位置从1开始\n◇填充字符函数第二个参数表示填充到多少字符，而不是填充多少字符；\n![image.png](MySQL基本函数/1626744883419-428def08-c61f-4a7c-b422-7e6c5ecd35fa.png)\n\n### 课堂练习\n◇将某人的姓名的名用\\*替代  eg: 欧\\*\\*\n```sql\nSELECT RPAD(SUBSTRING(\"欧宝玉\",1,1),LENGTH(\"欧宝玉\")/3,\"*\");\n```\n## 条件函数\n◇ SQL语句中可以利用条件函数来实现编程语言里的条件判断  \n```sql\nIFNULL( 表达式 , 值 )\nIF( 表达式 , 值1 , 值2 ) -- 如果满足表达式则是值1，否则是值2\n```\n###  条件语句  \n ◇ 复杂的条件判断可以用条件语句来实现，比IF语句功能更强大  \n```sql\nCASE\nWHEN 表达式 THEN 值1 ,\nWHEN 表达式 THEN 值2 , …… , ELSE 值N\nEND\n```\n### 课堂练习  \n◇ 中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B， 打印每名员工获得的礼品。  \n```sql\nSELECT FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno,\nIF(d.dname=\"SALES\",\"礼品A\",\"礼品B\")\nFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno;\n```\n◇ 公司年庆决定组织员工集体旅游，每个部门旅游目的地是不同的。SALES部门去P1地点，ACCOUNTING部门去P2地点 ，RESEARCH部门去P3地点，查询每名员工的旅行地点。  \n```sql\nSELECT \n e.empno,e.ename,\n CASE \n WHEN d.dname=\"SALES\" THEN \"P1\"\n WHEN d.dname=\"ACCOUNTING\" THEN \"P2\"\n WHEN d.dname=\"RESEARCH\" THEN \"P3\"\n END \n AS place\nFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno\n```\n◇ 公司决定为员工调整基本工资，具体调整方案如下：  \n![image.png](MySQL基本函数/1626790167145-a52425b0-80f5-499c-9547-8e4307a1d314.png)\n\n```sql\nUPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno\nLEFT JOIN (SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) t\nON e.deptno=t.deptno\nSET sal=(\nCASE \n  WHEN d.dname=\"SALES\" AND DATEDIFF(NOW(),e.hiredate)/365>=20\n  THEN e.sal*1.1\n  WHEN d.dname=\"SALES\" AND DATEDIFF(NOW(),e.hiredate)/365<20\n  THEN e.sal*1.05\n  WHEN d.dname=\"ACCOUNTING\"  THEN e.sal+300\n  WHEN d.dname=\"RESEARCH\" AND e.sal<t.avg THEN e.sal+200\n  WHEN e.deptno IS NULL THEN e.sal+100\n  END\n);\n```\n\n","tags":["MySQL"],"categories":["Java数据库","MySQL基础"]},{"title":"MySQL基本操作","url":"/p/a881.html","content":"##  数据操作语言：INSERT语句  \n###  INSERT语句  \n ◇ INSERT语句可以向数据表写入记录，可以是一条记录，也可以是多条记录  \n```sql\nINSERT INTO 表名 ( 字段1, 字段2, …… ) \nVALUES ( 值1, 值2, …… ) ;\nINSERT INTO 表名 ( 字段1, 字段2, …… ) \nVALUES ( 值1, 值2, …… ) , ( 值1, 值2, …… ) ;-- 插入多条记录\n```\n###  INSERT语句方言  \n ◇ MYSQL的INSERT语句还有一种方言语法  \n```sql\nINSERT INTO 表名 SET 字段1=值1, 字段2=值2, …… ;\n```\n###  IGNORE关键字  \n ◇ IGNORE关键字会让INSERT只插入数据库不存在的记录  \n```sql\nINSERT [ IGNORE ] INTO 表名 …… ;\n```\n###  INSERT中的子查询  \n◇ INSERT语句中可以包含子查询语句，代表把子查询的内容写入到数据表 \n◇ 把人数超过5人的部门记录拷贝到新的部门表  \n```sql\nCREATE TABLE t_dept_new LIKE t_dept;\nINSERT INTO t_dept_new(deptno,dname,loc)\n(SELECT d.deptno,d.dname,d.loc FROM t_dept d JOIN\n(SELECT deptno FROM t_emp GROUP BY deptno\nHAVING COUNT(*)>=5) temp\nON d.deptno = temp.deptno\n);\n```\n##  数据操作语言：UPDATE语句  \n###  UPDATE语句  \n◇ UPDATE语句用于修改表的记录  \n\n```sql\n-- \"IGNORE\"关键字在UPDATE语句中表示忽略修改数据时遇到冲突的记录，把不冲突的记录写到数据表里\nUPDATE [ IGNORE ] 表名\nSET 字段1=值1, 字段2=值2, ……\n[ WHERE 条件1, 条件2, …… ] \n[ ORDER BY …… ] -- 排序，如果需要将员工编号+1的话，可以先进行降序否则可能引发主键冲突\n[ LIMIT …… ] -- 取分页数据\n```\n###  UPDATE语句的表连接  \n ◇ 因为WHERE子句中的子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句  \n```sql\nUPDATE 表1 JOIN 表2 ON 条件\nSET 字段1 = 值1 , 字段2 = 值2 , …… ;\n```\n ◇ 表连接的UPDATE语句可以修改多张表的记录  \n\n ◇ UPDATE语句的表连接可以演变成下面的样子  \n\n```sql\nUPDATE 表1 , 表2\nSET 字段1 = 值1 , 字段2 = 值2 , ……\nWHERE 连接条件 ;\n```\n ◇ UPDATE语句的表连接既可以是内连接，又可以是外连接 \n```sql\nUPDATE 表1 [ LEFT | RIGHT ] JOIN 表2 ON 条件\nSET 字段1 = 值1 , 字段2 = 值2 , …… ;\n```\n ◇ 把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门  \n```sql\nUPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno\nSET e.deptno=20\nWHERE e.deptno IS NULL OR (d.dname=\"SALES\" AND e.sal<2000);\n```\n###  课堂练习  \n ◇ 把每个员工的编号和上司的编号+1，用ORDER BY子句完成 \n```sql\nUPDATE t_emp SET empno=empno+1,mgr=mgr+1\nORDER BY empno DESC\n```\n ◇ 把月收入前三名的员工底薪减100元，用LIMIT子句完成  \n```sql\nUPDATE t_emp SET sal=sal-100\nORDER BY sal+IFNULL(comm,0) DESC\nLIMIT 3;\n```\n ◇ 把ALLEN调往RESEARCH部门，职务调整为ANALYST  //牵扯到两张表\n```sql\n-- 这里不能写连接条件(ON e.deptno=d.deptno)，因为会将A锁定到R部门\nUPDATE t_emp e JOIN t_dept d \nSET e.deptno=d.deptno,e.job=\"ANALYST\"\nWHERE e.ename=\"ALLEN\" AND d.dname=\"RESEARCH\"\n```\n ◇ 把底薪低于公司平均底薪的员工，底薪增加150元  \n```sql\nUPDATE t_emp e JOIN\n(SELECT AVG(sal) AS avg FROM t_emp) t -- 子查询结果集\nON e.sal<t.avg\nSET e.sal=e.sal+150;\n```\n##  数据操作语言：DELETE语句  \n###  DELETE语句  \n ◇ DELETE语句用于删除记录，语法如下：  \n```sql\nDELETE [ IGNORE ] FROM 表名 -- IGNORE:能删则删，不能删则忽略，不会报错\n[ WHERE 条件1, 条件2, …… ]\n[ ORDER BY …… ] \n[ LIMIT …… ] ;\n```\n###  DELETE语句的表连接  \n ◇ 因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造DELETE语句  \n```sql\nDELETE 表1 , …… FROM 表1 JOIN 表2 ON 条件\n[ WHERE 条件1 , 条件2 , …… ] \n[ ORDER BY …… ] \n[ LIMIT …… ] ;\n```\n ◇ DELETE语句的表连接既可以是内连接，又可以是外连接  \n```sql\nDELETE 表1 , …… FROM 表1 [ LEFT | RIGHT ] JOIN 表2 \nON 条件 …… ;\n```\n ◇ 删除SALES部门的员工，以及没有部门的员工。  \n```sql\nDELETE e\nFROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno\nWHERE d.dneme=\"SALES\" OR e.deptno IS NULL\n```\n###  快速删除数据表全部记录  \n ◇ DELETE语句是在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里，然后再删除记录。 \n◇ TRUNCATE语句在事务机制之外删除记录，速度远超过DELETE语句  \n```sql\nTRUNCATE TABLE 表名 ;\n```\n###  课堂练习  \n ◇ 删除10部门中，工龄超过20年的员工记录 \n```sql\nDELETE FROM t_emp\nWHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365 >=20\n```\n◇ 删除20部门中工资最高的员工记录  \n```sql\nDELETE FROM t_emp\nWHERE deptno=20\nORDER BY sal+IFNULL(comm,0) DESC\nLIMIT 1;\n```\n◇ 删除SALES部门和该部门的全部员工记录 \n```sql\nDELETE e,d\nFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno\nWHERE d.dname=\"SALES\";\n```\n◇ 删除每个低于部门平均底薪的员工记录  \n```sql\nDELETE e\nFROM t_emp e JOIN \n(SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) t\nON e.deptno = t.deptno AND e.sal<t.avg\n```\n ◇ 删除员工KING和他的直接下属的员工记录，用表连接实现。  \n```sql\nDELETE e\nFROM t_emp e JOIN \n(SELECT empno FROM t_emp WHERE ename=\"KING\") t -- 结果集里的数据不能删\nON e.mgr=t.empno OR e.empno=t.empno;\n```\n\n","tags":["MySQL"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库的高级查询","url":"/p/1648.html","content":"##  数据操作语言：聚合函数  \n###  什么是聚合函数 \n◇ 聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对数据求和、求最大值和最小值、求平均值等等。 \n◇ 求公司员工的平均月收入是多少？  \n\n```sql\n--IFNULL(comm,0)判断如果comm字段为空则返回0,否则返回comm值\nSELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;\n```\n### SUM函数  \n ◇ SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0 ，日期类型统计结果是毫秒数相加  \n ◇ SUM函数求和会排除NULL值  \n\n### MAX函数\n ◇ MAX函数用于获得非空值的最大值。  \n ◇ 问题1：查询10和20部门中，月收入最高的员工？  \n```sql\nSELECT MAX(sal+IFNULL(comm,0)) FROM t_emp\nWHERE deptno IN(10,20);\n```\n ◇ 问题2：查询员工名字最长的是几个字符？  \n```sql\nSELECT MAX(LENGTH(ename)) FROM t_emp;\n```\n### MIN函数  \n ◇ MIN函数用于获得非空值的最小值。  \n### AVG函数  \n ◇ AVG函数用于获得非空值的平均值，非数字数据统计结果为0  \n### COUNT函数  \n ◇ COUNT(*)用于获得包含空值的记录数，COUNT(列名)用于获得包 含非空值的记录数。  \n ◇ 查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数？  \n```sql\nSELECT COUNT(*) FROM t_emp\nWHERE deptno IN(10,20) AND sal>=2000\nAND DATEDIFF(NOW(),hiredate)/365>=15; --DATEDIFF指相差的天数\n```\n ◇ 查询1985年以后入职的员工，底薪超过公司平均底薪的员工数量？  \n```sql\nSELECT COUNT(*) FROM t_emp\nWHERE hiredate>=\"1985-01-01\"\nAND sal>ROUND(AVG(sal));--ROUND()四舍五入 \n#WHERE 子句不能有聚合函数，所以这里是错误的,\n#因为聚合函数需要根据WHERE子句确定的数据范围进行计算\n#正确的做法是将平均成绩作为一个子查询获取\nsal>(SELECT ROUND(AVG(sal)) FROM t_emp)\n```\n##  数据操作语言：分组查询  \n### 为什么要分组？  \n ◇ 默认情况下汇总函数是对全表范围内的数据做统计 \n ◇ GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干 个小的区域，然后针对每个小区域分别进行数据汇总处理  \n### 逐级分组  \n ◇ 数据库支持多列分组条件，执行的时候逐级分组。 \n ◇ 查询每个部门里，每种职位的人员数量和平均底薪  \n### 对SELECT子句的要求  \n ◇ 查询语句中如果含有GROUP BY子句，那么SELECT子句中的内容就 必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在SELECT子句中  \n如下sql语句就是错误的：\n```sql\n-- sal字段并不是GROUP BY子句的分组列,如果按照部门分组的话,一个部门中的sal不是唯一的(员工不止一个)\nSELECT deptno,COUNT(*),AVG(sal),sal \nFROM t_emp GROUP BY deptno;\n```\n### 对分组结果集再次做汇总计算  \n```sql\n-- ROLLUP关键字会在底部增加一行记录对分组查询后的结果进行的汇总\nSELECT deptno,COUNT(*),AVG(sal),MAX(sal),MIN(sal)\nFROM t_emp GROUP BY deptno WITH ROLLUP;\n```\n### GROUP_CONCAT函数  \n\n ◇ GROUP_CONCAT函数可以把分组查询中的某个字段拼接成一个字符串\n ◇ 查询每个部门内底薪超过2000元的人数和员工姓名    \n\n```sql\nSELECT deptno,GROUP_CONCAT(ename),COUNT(*)\nFROM t_emp WHERE sal>=2000\nGROUP BY deptno;\n```\n### 各种子句的执行顺序  \n ◇ 查询语句中，GROUP BY子句应该第几个执行？ 先由FROM选择查询的表，然后WHERE子句进行筛选，符合条件的记录交由GROUP BY子句进行分组，分完组后由SELECT里的聚合函数进行计算，然后由ORDER BY子句排序，最后由LIMIT子句返回分页的数据\nFROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY -> LIMIT  \n\n## 数据操作语言：HAVING子句  \n###  分组查询遇到的困难？  \n ◇ 查询部门平均底薪超过2000元的部门编号  \n ◇ 因为WHERE子句先于GROUP BY执行，一旦WHERE子句中出现了 汇总函数，数据库根本不知道按照什么范围计算汇总值  \n\n###  HAVING子句的用途  \n ◇ 可以将聚集函数写在HAVING子句中,HAVING子句中的字段只能是GROUP BY分组表中的字段，例如果经过GROUP BY分组后得到的表中没有sal(员工工资)字段，则在HAVING中不能使用sal字段\n ◇ 查询每个部门中，1982年以后入职的员工超过2个人的部门编号  \n\n```sql\nSELECT deptno FROM t_emp\nWHERE hiredate>=\"1982-01-01\"\nGROUP BY deptno HAVING COUNT(*)>=2;\nORDER BY deptno ASC\n```\n###  HAVING子句的特殊用法  \n ◇ 按照数字1分组，MySQL会依据SELECT子句中的列进行分组， HAVING子句也可以正常使用  \n```sql\nSELECT deptno,COUNT(*), FROM t_emp\nGROUP BY 1;\n\nSELECT deptno,COUNT(*), FROM t_emp\nGROUP BY 1 HAVING deptno IN (10,20);\n```\n##  数据操作语言：表连接查询  \n###  从多张表中提取数据  \n ◇ 从多张表中提取数据，必须指定关联的条件。如果不定义关联条件 就会出现无条件连接，两张表的数据会交叉连接，产生笛卡尔积。\n![image.png](数据库的高级查询/1626527536343-fe29719d-f14e-4f1f-b2dd-0b875407529f.png) \n ◇ 规定了连接条件的表连接语句，就不会出现笛卡尔积  \n![image.png](数据库的高级查询/1626527554966-ef6bd0c6-0869-473a-807a-aaf8bb2b0479.png)\n\n###  表连接的分类  \n ◇ 表连接分为两种：内连接和外连接 \n ◇ 内连接是结果集中只保留符合连接条件的记录 \n ◇ 外连接是不管符不符合连接条件，记录都要保留在结果集中  \n###  内连接的简介  \n ◇ 内连接是最常见的一种表连接，用于查询多张关系表符合连接条件的记录。INNER关键字可省略\n![image.png](数据库的高级查询/1626527706776-ea571078-3649-4f98-8763-458cf7d9bea1.png)\n\n###  内连接的多种语法形式  \n```sql\nSELECT …… FROM 表1 JOIN 表2 ON 连接条件 ;\nSELECT …… FROM 表1 JOIN 表2 WHERE 连接条件 ;\nSELECT …… FROM 表1 , 表2 WHERE 连接条件 ;//常用\n```\n###  内连接练习  \n ◇ 查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级？ \n```sql\nSELECT e.empno,e.ename,d.deptno,e.sal,e.job,s.grade\nFROM t_emp e,t_dept d,t_salgrade s \nWHERE e.deptno=d.deptno AND e.sal BETWEEN s.losal AND s.hisal;\n```\n ◇ 内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以  \n ◇ 相同的数据表也可以做表连接  \n ◇ 结果集也可以作为一张“表”来跟其他表连接  \n\n###  为什么要使用外连接  \n ◇ 如果说陈浩是一名临时人员，没有固定的部门编制，那么我们想查询每名员工和他的部门名称，用内连接就会漏掉陈浩，所以要引入外连接的语法才能解决这个问题  \n![image.png](数据库的高级查询/1626529078875-5839b367-ab6b-4302-adab-a26f1cb433cf.png)\n\n###  外连接简介  \n ◇ 外连接与内连接的区别在于，除了符合条件的记录之外，结果集中 还会保留不符合条件的记录。  \n![image.png](数据库的高级查询/1626579588053-e5d55de3-cb32-46d2-a9b3-aac5f56aee42.png)\n\n###  左连接和右连接  \n ◇ 左外连接就是保留左表所有的记录，与右表做连接。如果右表有符合条件的记录就与左表连接。如果右表没有符合条件的记录，就用 NULL与左表连接。右外连接也是如此。  \n###  外连接练习  \n ◇ 查询每个部门的名称和部门的人数？  \n```sql\nSELECT  d.dname,COUNT(e.deptno-- 忽略右表(t_emp)的NULL记录\nFROM  t_dept d LEFT JOIN t_emp e -- 保留左表(t_dept)的所有记录\nON d.deptno=e.deptno\nGROUP BY d.deptno;\n```\n◇结果：\n![image.png](数据库的高级查询/1626621372904-af26d4c8-739c-4c3f-9e1c-cae69f7cc554.png)\n ◇ 查询每个部门的名称和部门的人数？如果没有部门的员工，部门名称用NULL代替。  \n\n```sql\n(SELECT  d.dname,COUNT(e.deptno)\nFROM  t_dept d LEFT JOIN t_emp e \nON d.deptno=e.deptno\nGROUP BY d.deptno )  \n    UNION //使用UNION关键字进行左外连接和右外连接的合并\n(SELECT  d.dname,COUNT(*) //保留所有有效记录\nFROM  t_dept d RIGHT JOIN t_emp e \nON d.deptno=e.deptno\nGROUP BY d.deptno )\n```\n◇结果：\n![image.png](数据库的高级查询/1626621411537-c2ca9e43-f9fc-43e4-8616-a7eff4e887a1.png)\n ◇ 查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司 编号、上司姓名、上司部门？  \n\n```sql\nSELECT e1.empno AS '编号',e1.ename AS '姓名',d1.dname AS '部门',\ne1.sal+IFNULL(e1.comm,0) AS '薪水',t.grade AS '薪资等级',\nFLOOR(DATEDIFF(NOW(),e1.hiredate)/365) AS '工龄',\ne1.mgr AS '上司编号',e2.ename AS '上司姓名',d2.dname AS '上司部门' \nFROM t_emp e1 LEFT JOIN t_dept d1 ON e1.deptno=d1.deptno\nLEFT JOIN t_emp e2 ON e1.mgr=e2.empno\nLEFT JOIN t_salgrade t ON e1.sal BETWEEN t.losal AND t.hisal\nLEFT JOIN t_dept d2 ON e2.deptno=d2.deptno;\n```\n◇结果：\n![image.png](数据库的高级查询/1626664826083-f96e349d-cc41-40fc-8a9f-0b996022332a.png)\n\n ◇ UNION关键字可以将多个查询语句的结果集进行合并 ,结果集字段名称、个数需要相同\n```sql\n( 查询语句 ) UNION ( 查询语句 ) UNION ( 查询语句 ) ……\n```\n###  外连接的注意事项  \n ◇ 内连接只保留符合条件的记录，所以查询条件写在ON子句和 WHERE子句中的效果是相同的。但是外连接里，条件写在WHERE 子句里，不合符条件的记录是会被过滤掉的,而不是保留下来。\n①\n使用ON子句\n```sql\nSELECT e.ename,d,dname,d.deptno\nFROM t_emp e\nLEFT JOIN t_dept d ON e.deptno = d.deptno\nAND e.deptno=10;\n```\n结果：\n![image.png](数据库的高级查询/1626665352162-b0b6a378-88e3-4711-9b18-ee194cf32151.png)\n\n发现所有记录都被保留，但不符合条件的记录为空\n②使用WHERE子句\n\n```sql\nSELECT e.ename,d,dname,d.deptno\nFROM t_emp e\nLEFT JOIN t_dept d ON e.deptno = d.deptno\nWHERE e.deptno=10;\n```\n结果：\n![image.png](数据库的高级查询/1626665474286-a40128b4-d895-4759-86f7-d68289ac14ba.png)\n\n##  数据操作语言：子查询  \n###  子查询简介  \n ◇ 子查询是一种查询中嵌套查询的语句 \n ◇ 查询底薪超过公司平均底薪的员工的信息  \n```sql\n SELECT empno,ename,sal\n FROM t_emp\n WHERE sal>=(SELECT AVG(sal) FROM t_emp);\n```\n###  子查询的分类 \n ◇ 子查询可以写在三个地方：WHERE子句、FROM子句、SELECT子 句，但是只有FROM子句子查询是最可取的   \n###  WHERE子查询  \n ◇ 这种子查询最简单，最容易理解，但是却是效率很低的子查询  \n ◇ 查询底薪超过公司平均底薪的员工的信息  \n![image.png](数据库的高级查询/1626670116652-f8ce1b67-2d79-462d-902f-12c22d33e139.png)\n\n###  用表连接替代WHERE子查询  \n ◇ 表连接的优点是子查询只执行一次，查询效率特别高  \n```sql\nSELECT e2.empno,e2.ename\nFROM t_emp e1 JOIN t_emp e2\nON e1.deptno = e2.deptno\nAND e2.ename!=\"FORD\"\nAND e1.ename=\"FORD\";\n```\n###  FROM子查询  \n ◇ 这种子查询只会执行一次，所以查询效率很高，把子查询写在FROM子句中\n ◇ 查询底薪超过公司平均底薪的员工的信息 \n```sql\nSELECT e.empno,e.ename,e.sal,t.avg\nFROM t_emp e JOIN \n(SELECT deptno,AVG(sal) as avg\nFROM t_emp GROUP BY deptno) t\nON e.deptno=t.deptno AND e.sal>=t.avg;\n\n```\n###  SELECT子查询  \n ◇ 这种子查询每输出一条记录的时候都要执行一次，查询效率很低  \n```sql\nSELECT e.empno,e.ename,(SELECT dname FROM t_dept WHERE deptno=e.deptno)\nFROM t_emp e;\n```\n###  相关子查询  \n◇ 查询语句执行的时候要多次的依赖于子查询的结果，这类子查询被称作相关子查询 \n◇ WHERE子查询和SELECT子查询都属于相关子查询 \n◇ 因为相关子查询要反复多次执行，所以应该避免使用  \n\n###  单行子查询和多行子查询  \n◇ 单行子查询的结果集只有一条记录，多行子查询结果集有多行记录 \n◇ 多行子查询只能出现在WHERE子句和FROM子句中 \n◇ 子查询一般先写出子查询语句\n◇ 如何用子查询查找FORD和MARTIN两个人的同事？  \n\n```sql\nSELECT \nFROM t_emp\nWHERE \ndeptno IN //这里子查询结果集为多行记录，所以不能用\"=\",而用\"IN\"表示等于其中一条记录即可\n(SELECT deptno FROM t_emp WHERE ename IN(\"FORD\",\"MARTIN\"))\nAND ename NOT IN(\"FORD\",\"MARTIN\");\n```\n###  WHERE子句中的多行子查询  \n◇ WHERE子句中，可以使用IN、ALL、ANY、EXISTS关键字来处理多行表达式结果集的条件判断 \n◇ 查询比FORD和MARTIN底薪都高的员工信息？  \n\n```sql\nSELECT ename\nFROM t_emp\nWHERE sal>=ALL\n(SELECT sal FROM t_emp WHERE ename IN(\"FORD\",\"MARTIN\"))\nAND ename NOT IN(\"FORD\",\"MARTIN\");\n```\n###  EXISTS关键字  \n ◇ EXISTS关键字是把原来在子查询之外的条件判断，写到了子查询的里面。  \n```sql\nSELECT …… FROM 表名 WHERE [NOT] EXISTS ( 子查询 ) ;\n```\n ◇ 查询工资等级3和4级的员工信息？  \n```sql\nSELECT empno,ename,sal\nFROM t_emp\nWHERE EXISTS(\nSELECT grade FROM t_salgrade\nWHERE sal BETWEEN losal AND hisal\nAND grade IN(3,4)\n);\n```\n\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库的基本查询","url":"/p/f427.html","content":"##  数据操作语言：普通查询  \n###  记录查询  \n◇ 最基本的查询语句是由 SELECT 和 FROM 关键字组成的  \n◇ SELECT语句屏蔽了物理层的操作，用户不必关心数据的真实存储，交由数据库高效的查找数据  \n\n```sql\nSELECT * FROM t_student;\nSELECT id,name,sex FROM t_student;\n```\n###  使用列别名  \n◇ 通常情况下，SELECT子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列名重命名的机制  \n```sql\nSELECT\n ename,\n sal * 12 AS \"annual_salary\"\n FROM\n emp;\n```\n◇ 重命名只在显示输出的时候使用，数据表列名不会真的改变  \n◇ 查询语句的子句执行顺序  \n![image.png](数据库的基本查询/1625994166757-969465a0-9e0f-4a0b-ad16-e6d3ae59731c.png)\n\n##  数据操作语言：数据分页  \n###  数据分页  \n◇ 比如我们查看朋友圈，只会加载少量部分信息，不用一次性加载全 部朋友圈，那样只会浪费CPU时间、内存和网络带宽\n◇ 如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量。  \n```sql\nSELECT …… FROM …… LIMIT 起始位置 , 偏移量 ;\nSELECT empno,ename FROM t_emp LIMIT 0,20;//20是偏移量而不是终止的\n```\n###  数据分页的简写用法  \n◇如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0  \n◇执行顺序： FROM -> SELECT -> LIMIT  \n##  数据操作语言：结果集排序  \n###  结果集排序  \n◇ 如果没有设置，查询语句不会对结果集进行排序。也就是说，如果想让结果集按照某种顺序排列，就必须使用ORDER BY子句。  \n```sql\nSELECT …… FROM …… ORDER BY 列名 [ ASC | DESC ] ;\n```\n###  排序关键字  \n ◇ASC代表升序（默认），DESC代表降序 如果排序列是数字类型，数据库就按照数字大小排序，如果是日期 类型就按照日期大小排序，如果是字符串就按照字符集序号排序。  \n###  排序字段内容相同的情况  \n◇ 默认情况下，如果两条数据排序字段内容相同，那么排序会是什么 样子？  \n◇ 如果排序字段内容相同，MySQL会按照主键大小来排序两条数据  \n###  多个排序字段  \n ◇我们可以使用ORDER BY规定首要排序条件和次要排序条件。数据库会先按照首要排序条件排序，如果遇到首要排序内容相同的记录 ，那么就会启用次要排序条件接着排序  \n```sql\nSELECT empno,ename,sal,hiredate\nFROM t_emp\nORDER BY sal DESC,hiredate ASC;\n```\n###  排序+分页  \n◇ ORDER BY子句书写的时候放在LIMIT子句的前面  \n FROM -> SELECT -> ORDER BY -> LIMIT  \n##  数据操作语言：去除重复记录  \n◇ 假如我们要查询员工表有多少种职业， 如果我们需要去除重复的数据，可以使用DISTINCT关键字来实现  ；\n```sql\nSELECT DISTINCT 字段 FROM …… ;\n```\n◇ 注意事项  ： ①使用DISTINCT的SELECT子句中只能查询一列数据，如果查询多列， 去除重复记录就会失效。  \n② DISTINCT关键字只能在SELECT子句中使用一次  ；\n##  数据操作语言：条件查询\n###  条件查询   \n◇ 很多时候，用户感兴趣的并不是逻辑表里的全部记录，而只是它们 当中能够满足某一种或某几种条件的记录。这类条件要用WHERE子 句来实现数据的筛选。  \n```sql\nSELECT …… FROM …… WHERE 条件 [ AND | OR ] 条件 …… ;\n```\n###  四类运算符  \n WHERE语句中的条件运算会用到以下四种运算符：  \n![image.png](数据库的基本查询/1625997158623-77abf14a-54c7-475f-b681-9b41a645994f.png)\n\n###  算数运算符  \n![image.png](数据库的基本查询/1626506515565-3a9d08ca-5c97-4fbd-84e7-3fcdfa11bca4.png)\n###  比较运算符  \n![image.png](数据库的基本查询/1626506532025-a81b1d45-0bcb-4b12-99af-3bf2f1ac8c56.png)\n![image.png](数据库的基本查询/1626506751691-a643c08a-1c57-46a6-8a9e-0f7478ade47b.png)\n\n###  逻辑运算符  \n![image.png](数据库的基本查询/1626506615665-ab58a3e7-4c84-4cb3-b3ce-b8d089816b3e.png)\n###  二进制按位运算  \n◇ 二进制位运算的实质是将参与运算的两个操作数，按对应的二进制数逐位进行逻辑运算。  \n![image.png](数据库的基本查询/1626506691986-8cb9c71e-23fe-4243-a98f-61ecaeb2037e.png)\n\n###  按位运算符  \n![image.png](数据库的基本查询/1626506705766-5f082cda-69bc-4213-8776-6b307ec394b4.png)\n###  WHERE子句的注意事项  \n◇ WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把索引条件，或者筛选掉记录最多的条件写在最左侧。\n```sql\nSELECT empno,ename FROM t_emp\nWHERE ename = \"FORD\" AND sal >= 2000;\n\nSELECT empno,ename FROM t_emp\nWHERE deptno = 10 AND sal >= 2000;\n```\n\n\n###  各种子句的执行顺序  \n 条件查询中，WHERE子句应该是第几个执行？ FROM -> WHERE -> SELECT -> ORDER BY -> LIMIT 。 \n\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库范式与索引","url":"/p/77e3.html","content":"## 范式概念\n◇ 构造数据库必须遵循一定的规则，这种规则就是范式  \n◇ 目前关系数据库有6种范式，一般情况下，只满足第三范式即可  \n\n##  第一范式：原子性  \n◇ 第一范式是数据库的基本要求，不满足这一点就不是关系数据库  \n◇ 数据表的每一列都是不可分割的基本数据项，同一列中不能有多个值，也不能存在重复的属性。\n![image.png](数据库的范式/1625840047827-6aee66b4-51fa-4462-9315-661dcc5bbc8c.png)\n\n##  第二范式：唯一性  \n◇ 数据表中的每条记录必须是唯一的。为了实现区分，通常要为表加上一个列用来存储唯一标识，这个唯一属性列被称作主键列  \n![image.png](数据库的范式/1625840463558-faa7b806-aebf-4fa1-83d6-1fa49132c68f.png)\n\n##  第三范式：关联性  \n◇ 每列都与主键有直接关系，不存在传递依赖  \n![image.png](数据库的范式/1625840515859-2c1f2750-a72c-4ca8-9693-0097054d1a89.png)\n ◇依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联  \n![image.png](数据库的范式/1625840617006-d3552f4a-77d7-4734-8d1b-f4347315568f.png)\n\n## 字段约束\n◇ MySQL中的字段约束共有四种：  \n![image.png](数据库的范式/1625990627379-e5fb0810-df5e-4398-bd38-3841fc1be58b.png)\n\n### 主键约束\n◇ 主键约束要求字段的值在全表必须唯一，而且不能为NULL值  \n◇ 建议主键一定要使用数字类型，因为数字的检索速度会非常快  \n◇ 如果主键是数字类型，还可以设置自动增长  \n```sql\nCREATE TABLE t_teacher(\nid INT PRIMARY KEY AUTO_INCREMENT,\n.......\n)\n```\n### 非空约束\n◇ 非空约束要求字段的值不能为NULL值  \n◇ NULL值以为没有值，而不是\" \"空字符串  \n```sql\nCREATE TABLE t_teacher(\nid INT PRIMARY KEY AUTO_INCREMENT,\nname VARCHAR(200) NOT NULL,\nmarried BOOLEAN NOT NULL DEFAULT FALSE //设置默认值为false\n);\n```\n### 唯一约束\n◇ 唯一约束要求字段值如果不为NULL，那么在全表必须唯一  \n```sql\nCREATE TABLE t_teacher(\n...\ntel CHAR(11) NOT NULL UNIQUE\n);\n```\n### 外键约束\n◇ 外键约束用来保证关联数据的逻辑关系  \n![image.png](数据库的范式/1625991461738-358528fb-416f-4cef-b409-575041655201.png)\n◇ 外键约束的定义是写在子表上的  \n\n```sql\nCREATE TABLE t_emp(\nempno INT UNSIGNED PRIMARY KEY,\nename VARCHAR(20) NOT NULL,\nsex ENUM(\"MAN\",\"WOMAN\") NOT NULL,\ndeptno INT UNSIGNED NOT NULL,\nhiredate DATE NOT NULL,\nFOREIGN KEY (deptno) REFERENCES t_dept(deptno)\n);\n```\n**外键约束的闭环问题** \n◇ 如果形成外键闭环，我们将无法删除任何一张表的记录  \n![image.png](数据库的范式/1625992112385-0da833a2-88ca-4eed-8643-262a3b35b40d.png)\n\n##  数据库索引  \n###  索引优点\n\n◇使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。\n\n◇ 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n### 索引缺点\n\n◇创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n\n◇索引需要使用物理文件存储，也会耗费一定空间。\n\n###  索引底层结构 \n◇ 索引本身是一种数据结构，MySQL的InnoDB存储引擎利用B+树的结构，对数据表的记录排序，从而加速数据的检索速度。\n\n### 索引类型\n\n◇主键索引：数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 null，不能重复。在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。\n\n◇唯一索引：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。\n\n◇普通索引：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。\n\n◇复合索引：将数据库中的多个字段组合起来形成的一个索引就是复合索引。复合索引的第一个字段必须出现查询语句中，这样索引才能够被使用。\n\n◇前缀索引：前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。\n\n◇全文索引：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。\n\n###  如何创建索引  \n\n◇创建表时创建\n\n```sql\n#普通索引\nCREATE TABLE 表名称 ( \n'字段名' 字段类型 约束,\n    ...\nINDEX [ 索引名称 ] ( 字段 )\n) ;\n#唯一索引\nCREATE TABLE 表名称 ( \n'字段名' 字段类型 约束,\n    ...\nUNIQUE INDEX [ 索引名称 ] ( 字段 ) ……\n) ;\n#全文索引\nCREATE TABLE 表名称 ( \n'字段名' 字段类型 约束,\n    ...\nFULLTEXT INDEX [ 索引名称 ] ( 字段 ) ……\n) ;\n#复合索引\nCREATE TABLE 表名称 ( \n'字段名' 字段类型 约束,\n    ...\nKEY [ 索引名称 ] ( 字段1,字段2,... )\n) ;\n```\n◇创建表后索引的增加和删除\n\n```sql\nCREATE INDEX 索引名称 ON 表名( 字段 ) ；#创建普通索引\nCREATE UNIQUE INDEX 索引名称 ON 表名( 字段 ) ；#创建唯一索引\nCREATE FULLTEXT INDEX 索引名称 ON 表名( 字段 ) ；#创建全文索引\nCREATE INDEX 索引名称 ON 表名(字段1,字段2... ) ；#创建复合索引\n#以修改表的方式添加索引\nALTER TABLE 表名称 ADD [UNIQUE | FULLTEXT]INDEX [ 索引名 ]( 字段 ) ;\n#查看索引情况\nSHOW INDEX FROM 表名 ; \n#删除索引\nDROP INDEX 索引名称 ON 表名 ;\n```\n###  索引的使用原则  \n◇ 数据量很大，而且经常被查询的数据表可以设置索引 \n◇ 索引只添加在经常被用作检索条件的字段上面 \n◇ 不要在大字段上创建索引\n\n◇[索引相关文章](https://blog.csdn.net/qq_35190492/article/details/109257302)\n\n  \n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"SQL简介","url":"/p/a804.html","content":"## 学习目标\n◇ 管理逻辑库和数据表\n\n◇创建、删除、修改逻辑库和数据表  \n◇ 了解常用的数据类型和约束  \n\n◇字符串、整数、浮点数、精确数字、日期、枚举。主键约束、非空 约束、唯一约束、外键约束等  \n◇ 掌握索引运行机制和使用原则  \n\n◇排序为什么可以提高数据检索速度？怎么创建和删除索引？什么条 件下使用索引？  \n\n##  什么是SQL语言 ？\n◇ SQL 是用于访问和处理数据的标准的计算机语言  \n![image.png](SQL简介/1625838154950-b6a31bc1-f93a-4483-a4bc-a7499a1c4669.png)\n\n###  SQL语言分类  \n![image.png](SQL简介/1625838195563-598330f3-eee6-49ab-b74d-d55f33493ae0.png)\n###  SQL语句注意事项  \n◇ SQL语句不区分大小写，但是字符串区分大小写  \n◇ SQL语句必须以分号结尾  \n◇ SQL语句中的空白和换行没有限制，但是不能破坏语法 \n###  SQL语句的注释   \n◇ SQL语句的注释有两种，分别如下：  \n #这是一段注释\n/*\\* 这是另一段注释  \\**/\n\n##  创建逻辑库  \n![image.png](SQL简介/1625838421553-d4761883-6cd5-47ea-bed3-1e2d07e73537.png)\n##  创建数据表  \n```sql\nCREATE TABLE 数据表 (\n列名1 数据类型 [ 约束 ] [COMMENT 注释] ,\n列名2 数据类型 [ 约束 ] [COMMENT 注释] , ……\n) [ COMMENT = 注释 ] ;\nDROP TABLE 数据表 ;\n```\n```sql\nCREATE TABLE student (\nid INT UNSIGNED PRIMARY KEY ,\nname VARCHAR(20) NOT NULL , sex CHAR(1) NOT NULL ,\nbirthday DATE NOT NULL ,\ntel CHAR(11) NOT NULL ,\nremark VARCHAR(200)\n);\n```\n##  数据表的其他操作  \n```sql\nSHOW tables ;    #查看当前数据库中的表\nDESC student ;   #查看表的结构\nSHOW CREATE TABLE student ; #查看建表语句\nTRUNCATE TABLE student; #清空表数据，保留表结构，不能恢复数据\nDROP TABLE student ;  #删除表\n```\n##  数据定义语言：数据类型  \n###  数据类型：数字  \n◇DECIMAL相当于用字符来保存数字，所以不存在精度的丢失；参数10表示整数+小数为十位\n参数2表示精确到小数点后两位\n![image.png](SQL简介/1625838928851-acc12aba-1b8a-47cd-a43b-7bb022a49641.png)\n\n###  不精确的浮点数  \n◇ 十进制的浮点数无法在计算机中用二进制精确表达  \n![image.png](SQL简介/1625838986936-842b2ae4-572c-4618-949b-d0874d60b79f.png)\n\n###  数据类型：字符串  \n![image.png](SQL简介/1625839086946-6c97c58c-0b4d-4c4a-9314-535803a59c73.png)\n###  数据类型：日期类型  \n![image.png](SQL简介/1625839693685-beccf98c-d86a-49ae-ba12-ad38022c6eb1.png)\n##  数据定义语言：修改表结构  \n###  添加字段  \n```sql\nALTER TABLE 表名称\nADD 列1 数据类型 [ 约束 ] [COMMENT 注释] , ADD 列2 数据类型 [ 约束 ] [COMMENT 注释] ,\n…… ;\n```\n###  修改字段类型和约束  \n```sql\nALTER TABLE 表名称\nMODIFY 列1 数据类型 [ 约束 ] [COMMENT 注释] , MODIFY 列2 数据类型 [ 约束 ] [COMMENT 注释] ,\n…… ;\n```\n###  修改字段名称  \n```sql\nALTER TABLE 表名称\nCHANGE 列1 新列名1 数据类型 [ 约束 ] [COMMENT 注释] ,\nCHANGE 列2 新列名2 数据类型 [ 约束 ] [COMMENT 注释] ,\n…… ;\n```\n###  删除字段  \n```sql\nALTER TABLE 表名称\nDROP 列1 ,\nDROP 列2 ，\n…… ;\n```\n###  修改表名  \n```sql\nALTER TABLE 表名 RENAME 新表名 \n```\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库简介","url":"/p/f849.html","content":"## 学习目标\n**了解关系型数据库的重要性**\n  -为什么会出现关系型数据库？有哪些常见的关系型数据库？  \n**掌握MySQL的安装和配置**\n  -怎么安装MySQL数据库？怎么配置MySQL的字符集、端口号、IP 地址绑定、数据目录等等？  \n**实践用户创建、分配权限和密码找回**\n\n  -如何创建root之外的帐户并分配权限？忘记数据库密码，应该如何找回？  \n\n## 操作系统中数据存放的载体\n◇ Windows、Linux和MacOS都是基于文件的操作系统  \n◇ 文件能保存数据，为什么不用文件来管理数据？\n## 什么是(关系型)数据库系统？\n◇ 数据库系统（DBMS）是指一个能为用户提供信息服务 的系统。它实现了有组织地、动态地储存大量相关数据 的功能，提供了数据处理和信息资源共享的便利手段。\n◇ 关系型数据库系统（RDBMS）是指使用了关系模型的数 据库系统  \n◇ 关系模型中，数据是分类存放的，数据之间可以有联系\n![image.png](数据库简介/1625747084668-a2ccf897-723b-4ed3-b2ff-7306028578de.png)\n\n##  关系型数据库的应用      \n◇ 关系型数据库被应用在非常多的领域  \n![image.png](数据库简介/1625746899055-c7f7b681-d7e6-404e-adf4-955b8c3fbb72.png)\n 关系型数据库可以有效组织和管理大量复杂的数据，所 以关系型数据库才是最重要的数据库产品  \n◇数据库的大规模应用\n![image.png](数据库简介/1625746981059-77d2bbc5-76f7-433c-b1f3-1579d1cb15a1.png)\n◇主流关系型数据库\n![image.png](数据库简介/1625747003200-98e2e0e6-1830-4277-8891-7d4db47274b3.png)\n\n##  什么是NoSQL数据库系统？\n◇ NoSQL数据库指的是数据分类存放，但是数据之间没有关联关系的数据库系统  \n![image.png](数据库简介/1625747164092-f6498682-6d07-4ab0-9c56-c7977aa8d09c.png)\n◇ 主流NoSQL数据库  \n![image.png](数据库简介/1625747213311-ffaffb43-e795-4115-95a5-89ee1ef45a6f.png)\n\n## 用户管理\n◇MySQL客户端  Navicat\n### 重设root密码\n◇ 密码忘记后\n◇ 创建一个TXT文件，定义修改密码的SQL语句  \n\n```csharp\nALTER USER 'root'@'localhost' IDENTIFIED BY\n'123456' ;\n```\n◇以管理员身份打开PowerShell窗口\n![image.png](数据库简介/1625755485452-38a0d75a-c473-4e30-ba8b-2a4ab32121e1.png)\n◇ 修改my.ini文件，删除之前添加的参数 C:\\ProgramData\\MySQL\\MySQL Server 8.0，先打开隐藏文件； \n◇ 重启MySQL服务，用新密码登陆root帐户\n\n## MySQL配置文件  \n◇ 在my.ini文件中，我们可以设置各种MySQL的配置(包含客户端配置和MySQL配置)，例如字符集、端口号、目录地址等等 。\n\n```csharp\n[client]\nport=3306   \n[mysql]\nno-beep    #关闭蜂鸣器\n[mysqld]\nport=3306  #端口号\ndatadir=C:/ProgramData/MySQL/MySQL Server 8.0\\Data  #数据目录\ndefault_authentication_plugin=mysql_native_password #密码认证插件\ndefault-storage-engine=INNODB  #默认存储引擎\nsql-mode=\"STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION\"  #开启严格模式\nlog-output=FILE  #用文件记录日志\ngeneral-log=0  #关闭日志输出\ngeneral_log_file=\"LAPTOP-3NL7HPNI.log\"  #日志文件名称\nslow-query-log=1  #开启慢查询日志\nslow_query_log_file=\"LAPTOP-3NL7HPNI-slow.log\" #慢查询日志文件名称\nlong_query_time=10  #大于多少秒的执行SQL被记录在慢查询\nlog-error=\"LAPTOP-3NL7HPNI.err\" #错误日志名称\nlog-bin=\"LAPTOP-3NL7HPNI-bin\"\nserver-id=1 #数据库ID，集群时用到\nreport_port=3306\nlower_case_table_names=1 #把表名转换成小写\nsecure-file-priv=\"C:/ProgramData/MySQL/MySQL Server 8.0/Uploads\" #导入导出数据的目录地址\nmax_connections=151 #最大连接数\ntable_open_cache=2000\ntmp_table_size=21M\nthread_cache_size=10 #线程数量\n.......\n\n```\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"删除功能出现的BUG","url":"/p/de80.html","content":"\n### 功能简介\n\n​\t\t开发一个删除油画功能模块，要求能够在前台中点击某一油画进行删除后，弹出对话框进行确认删除，若确认则发送ajax请求到后台，然后后台根据发送过来的id进行相应的删除，并且使用json对象返回处理的结果；\n\n### 实现思路\n\n​\t\t对于底层的数据删除，使用dom4j进行对xml的删除操作；首先根据id筛选出指定的节点p；然后根据此节点获取到其父节点，使用父节点的remove方法来删除此节点；代码如下：\n\n```java\n//得到P的根节点然后用根节点删去P;\np.getParent().remove(p);\n```\n\n​\t\t然后就是根据MVC的调用要求，依次创建Dao、Service、Controller中的方法；在Controller方法中进行与前台的交互即可；\n\n### 出现的BUG\n\n​\t\t当在前台页面点击删除油画后，发现删除成功，然后不刷新页面。再次删除此油画，这幅油画实际上已经被删除了，所以根据后台的逻辑，应该会删除失败，并提示该油画已经被删除或者不存在；但是前台确提示删除成功，按F12查看浏览器控制台打印的json对象如下:\n\n![console.png](https://s2.loli.net/2021/12/09/oAaKdbu2tNm4iYP.png)\n\n这说明在控制器中根本没有执行catch块里的代码，而是执行了try里的代码，{% wavy 没有捕捉到 %}XmlDataSource中抛出的异常；后端控制台打印的信息如下：\n\n```tex\n获取ajax请求发送过来的id为:16\n/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xml\njava.lang.RuntimeException: 编号为16的油画不存在或已删除\n\tat com.lcg.mgallery.utils.XmlDataSource.delete(XmlDataSource.java:186)\n\tat com.lcg.mgallery.dao.PaintingDao.delete(PaintingDao.java:68)\n\tat com.lcg.mgallery.service.PaintingService.delete(PaintingService.java:69)\n\tat com.lcg.mgallery.controller.ManagementController.delete(ManagementController.java:247)\n\tat com.lcg.mgallery.controller.ManagementController.doGet(ManagementController.java:64)\n\tat com.lcg.mgallery.controller.ManagementController.doPost(ManagementController.java:73)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:661)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:742)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\n\tat org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800)\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498)\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.lang.Thread.run(Unknown Source)\n/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xml\n成功执行了删除的操作\n```\n\n​\t\t可以发现确实出现了异常，但出现异常后却仍然打印出\"成功执行了删除的操作\"；这是什么原因呢？**为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常？**我们来分析一下后台的代码；\n\n对Xml文件进行直接操作的XmlDataSource类中的删除方法代码如下：\n\n```java\npublic static void delete(Integer id) {\n\t\ttry {\n\t\t\tdocument = reader.read(dataFile);\n\t\t\tList<Node> nodes = document.selectNodes(\"/root/painting[@id=\" + id + \"]\");\n\t\t\tif(nodes.size() == 0) {\n\t\t\t\tthrow new RuntimeException(\"编号为\" + id + \"的油画不存在或已删除\");\n\t\t\t}\n             //省略执行删除操作代码..\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(\"编号为\" + id + \"的油画不存在或已删除\");\n\t\t}finally {\n            //...部分代码\n\t\t\treload();\n\t\t}\n\t}\n```\n\n​\t\t控制器中的删除方法代码如下(控制器中调用的是Service中的delete方法，按照MVC的架构模式会{% u 逐级调用 %}到XmlDataSource中的方法)\n\n```java\n//删除油画\nprivate void delete(HttpServletRequest request,HttpServletResponse response) throws IOException {\n    String id = request.getParameter(\"id\");//获取ajax请求发送过来的参数\n    System.out.println(\"获取ajax请求发送过来的id为:\"+id);\n    Map result = new HashMap();\n    try {\n        //调用方法进行油画的删除\n        paintingService.delete(Integer.parseInt(id));\n        result.put(\"code\", \"0\");\n        result.put(\"msg\", \"success\");\n        System.out.println(\"成功执行了删除的操作\");\n    }catch(Exception e) {\n        e.printStackTrace();\n        result.put(\"code\", \"1\");\n        result.put(\"msg\", e.getMessage());\n        System.out.println(\"遇到了异常\");\n    }\n    String json = JSON.toJSONString(result);\n    response.setContentType(\"text/html;charset=UTF-8\");\n    response.getWriter().println(json);\n}\n```\n\n​\t\t通过对控制台中的打印结果分析想到，既然在Controller中并没有捕捉到，那么为什么会打印出异常的信息呢？很快就想到可能在XmlDataSource中就把异常给捕捉了，于是在XmlDataSource中将catch块中的e.printStackTrace();注释掉，在前台执行重复删除的操作，发现后台{% emp 果然没有打印出 %}异常信息!\n\n### BUG解决方法\n\n​\t\t在知道了为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常后，就能想到出错的原因在哪里了；因为在XmlDataSource的删除方法中，前面的一些代码也会抛出异常，为了寻求方便我索性使用Exception来捕捉这些异常，这就导致将我们自定义的异常给捕获并处理了（因为RuntimeException继承自Exception），进而在Controller中无法捕捉到异常，给前台的反馈消息总是删除成功的；\n\n​\t\t所以解决方法是分别捕捉可能出现的每一种异常(除RuntimeException以外)；修改后的方法如下：\n\n```\npublic static void delete(Integer id) {\n\t\tSAXReader reader = new SAXReader();\n\t\tWriter writer = null;\n\t\tDocument document;\n\t\ttry {\n\t\t\tdocument = reader.read(dataFile);\n\t\t\tList<Node> nodes = document.selectNodes(\"/root/painting[@id=\" + id + \"]\");\n\t\t\tif(nodes.size() == 0) {\n\t\t\t\tthrow new RuntimeException(\"编号为\" + id + \"的油画不存在或已删除\");\n\t\t\t}\n\t\t\tElement p = (Element)nodes.get(0);\n\t\t\t//得到P的根节点然后用根节点删去P;\n\t\t\tp.getParent().remove(p);\n\t\t\t//修改后的数据回写到原来的xml文件中;\n\t\t\twriter = new OutputStreamWriter(new FileOutputStream(dataFile),\"UTF-8\");\n\t\t\tdocument.write(writer);\n\t\t} catch (DocumentException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tif(writer != null) {\n\t\t\t\ttry {\n\t\t\t\t\twriter.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treload();\n\t\t}\t\t\n\t}\n```\n\n​\t\t这样以后，成功解决了前面出现的问题；这里附上前台页面的代码，弹出窗口使用了[SweetAlert](https://sweetalert2.github.io/)\n\n```jsp\n<script>\n//提示删除\n\tfunction del(previewObj){\n\t\tvar preview = $(previewObj).attr(\"data-preview\");//获取自定义属性\n\t\tvar pname = $(previewObj).attr(\"data-pname\");\n\t\tvar id = $(previewObj).attr(\"data-id\");\t\t\n\t\tSwal.fire({\n\t\t\t  title: '删除'+pname+'?',\n\t\t\t  html: \"<img src='\" + preview + \"' style='width:361px;height:240px'>\",\n\t\t\t  icon: 'warning',\n\t\t\t  showCancelButton: true,\n\t\t\t  confirmButtonColor: '#3085d6',\n\t\t\t  cancelButtonColor: '#d33',\n\t\t\t  confirmButtonText: '是的',\n\t\t\t  cancelButtonText: '取消'\n\t\t\t}).then(function(isConfirm){\n\t\t\t  if (isConfirm.value) {\n\t\t\t\t//发送ajax请求\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\"url\" : \"/management?method=delete\",\n\t\t\t\t\t\t\"type\" : \"post\",\n\t\t\t\t\t\t\"data\" : {\"id\":id},\n\t\t\t\t\t\t\"dataType\" : \"json\",\n\t\t\t\t\t\t\"success\" : function(json){\n\t\t\t\t\t\t\tconsole.log(json);\n\t\t\t\t\t\t\tif(json.code==\"0\"){\n\t\t\t\t\t\t\t\tSwal.fire('删除成功!','油画已经成功删除','success').then(function(isConfirm){\n\t\t\t\t\t\t\t\t\tif (isConfirm.value){\n\t\t\t\t\t\t\t\t\t\t//点击确认后刷新页面\n\t\t\t\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tSwal.fire('删除失败!',json.msg,'error').then(function(isConfirm){\n\t\t\t\t\t\t\t\t\tif (isConfirm.value){\n\t\t\t\t\t\t\t\t\t\t//点击确认后刷新页面\n\t\t\t\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t  }\n\t\t})\n\t}\n</script>\n  <!-- 省略部分代码 -->\n<a class=\"oplink\" data-id=\"${painting.id}\" data-preview=\"${painting.preview}\" data-pname=\"${painting.pname}\" href=\"javascript:void(0)\" onclick=\"del(this)\">删除</a>\n```\n\n### 总结\n\n​\t\ttry-catch-finally执行的基本步骤是：如果try块中出现了{% emp 异常 %},不管是自定义抛出的还是系统抛出的，在catch块中只要符合捕捉的范围，都会对该异常进行处理，最后执行finally块中的代码； 如果没有出现异常，则直接执行try块中的代码，然后执行finally中的代码；因此在开发过程中不要一时图方便，将捕捉异常的范围扩大，还应当业务逻辑进行仔细分析，采用最佳的处理方法；\n","tags":["BUG"],"categories":["Java开发"]},{"title":"递归逆置链表","url":"/p/bac2.html","content":"\n#### 实验内容\n\n  对于一个不带头结点的单链表，设计递归算法逆置所有结点。\n\n#### 实验原理\n\n  **1.递归介绍**\n\n​\t\t程序调用自身的编程技巧称为递归；一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。递归必须具备两个条件，一个是{% wavy 调用自己 %}，一个是有{% wavy 终止条件 %}。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方如下面的代码一样:\n\n```C\nvoid recursion(参数0) {\n    if (终止条件) {\n        return;\n    }\n    recursion(参数1);\n}\n```\n\n**2.逆置方法**\n\n​\t\t对于单链表的递归逆置虽然只有几行代码，但刚开始接触可能会有点绕，所以我尽可能详细的把思路理出来；\n\n​\t\t对于有n个结点的链表的逆置，利用递归的思想可以先将前n-1个结点逆置；当链表为空或者链表只有一个结点的时候终止递归；每一次调用逆置函数R()完成后返回链表已经逆置完成的部分的第一个结点(设为newNode)；因为在当前结点(设为p)前面的结点都已经完成了逆置，所以当前结点指向的下一个结点(p->next)，成为了已经逆置完成的部分的最后一个结点；如果要进行逆置的话，当前结点应该要变成最后一个结点；所以将p->next的下一个结点设置为当前结点，即指向p：**p->next**->next=**p**;  p变为最后一个结点后，其下一个结点为空，即p->next=NULL;这样就完成了以当前结点为第一个结点的链表部分的逆置，返回当前的第一个结点，继续进行逆置，直到所有递归函数调用完毕；\n\n​\t\t我们来看一个例子，比如要对链表a->b->c->d进行逆置；调用逆置函数R(a),R(a)中会递归调用R(a->next)即R(b),而R(b)中又会调用R(b->next)即R(c);这样依次下来：（递归完成部分加粗显示，按照调用完成的顺序）\n\n①R(d),对d进行逆置，由于d->next为空，所以直接返回d;此时有newNode=d, a->b->c->**d->NULL**;\n\n②R(c),对c->d进行逆置,当前结点为c，要进行逆置，c应该为最后一个结点，则有：c->next(d)->next=c;c->next=NULL; 此时有newNode=d,**d->c->NULL**; a->b->c->NULL;注意这里没有任何结点指向d了，因为已经将c->next设置为空；\n\n③R(b),对b->c->d进行逆置，由于c->d部分已经逆置成**d->c->NULL**了，所以只需要将b设置为最后一个结点即可；b->next(c)->next=b; b->next=NULL;返回d；此时有newNode=d,**d->c->b->NULL**; a->b->NULL;\n\n④R(a),对a->b->c->d进行逆置,由于b->c->d部分已经逆置成**d->c->b->NULL**，所以像③一样，a->next(b)->next=a, a->next=NULL;至此，所有的递归函数都已经调用完毕；得到了newNode=d，**d->c->b->a->NULL**完成了所有节点的逆置；\n\n#### 代码演示\n\n{% tabs tab-id %}\n\n<!-- tab 完整代码 -->\n\n```c++\n#include<iostream>\nusing namespace std;\n\ntypedef struct Node {\n\tint data;\n\tstruct Node* next;\n} LinkNode;\n\nLinkNode* CreateList(int a[],int n) {\n\tif (n < 0)\n\t\treturn NULL;\n\tLinkNode* head = new LinkNode();\n\tLinkNode* p = new LinkNode();\n\tp = head;\n\thead->data = a[0];\n\tint i = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tLinkNode* node = new LinkNode();\n\t\tnode->data = a[i];\n\t\tp->next = node;\n\t\tp = node;\n\t}\n\tp->next = NULL;  // 尾结点next域置为空\n\treturn head;\n}\n\nvoid DispList(LinkNode* ln) {\n\tcout << \" \";\n\tif (ln != NULL) {\n\t\tcout << ln->data;\n\t\tDispList(ln->next);\n\t}\n}\n\nLinkNode* Release(LinkNode* ln) {\n\tif (ln == NULL || ln->next == NULL)\n\t\treturn ln;\n\telse {\n\t\tLinkNode* newNode = Release(ln->next);\n\t\tln->next->next = ln;//将当前结点接在逆置完成部分的最后结点后面,使其成为最后结点\n\t\tln->next = NULL;//逆置后，最后一个结点的下一个结点为空\n\t\treturn newNode;//返回逆置完成部分的第一个结点      \n\t}\n}\n\nint main() {\n\tint a[] = {0,1,2,3,4,5,6,7,8,9};\n    int n = sizeof(a) / sizeof(a[0]);\n\tLinkNode* L, *N;\n\tL = CreateList(a,n);\n\tcout << \"初始链表:\" << endl;\n\tDispList(L);\n\tcout << endl;\n\tcout << \"逆置链表:\" << endl;\n\tN = Release(L);\n\tDispList(N);\n\tcout << endl;\n\tdelete L;\n\tdelete N;\n\treturn 0;\n}\n```\n\n<!-- endtab -->\n\n<!-- tab 运行结果 -->\n\n![](https://s2.loli.net/2021/12/09/bSlnhdWxo7vPZ6G.png)\n\n<!-- endtab -->\n\n{% endtabs %}\n\n","tags":["递归"],"categories":["数据结构"]},{"title":"【转载】如何成为优秀的程序员","url":"/p/6380.html","content":"\n​        本文转自:http://www.akaedu.org/pages/news_detail.php?id=294 \n\n​        我们的老师每天都要应对报名者和学员提出的很多同样的问题，以下是这类典型问题的汇总：嵌入式行业（或者IT业）有没有前途？我听说编程编到三十五 岁就没人要了，一定要转行找出路是吗？做驱动开发和做应用开发哪个更有前途？我一开始看什么书都看不懂，怎么才能理出一个学习顺序？诸如此类。这使我迫切 地感觉到，应该总结这样一份非具体技术问题的FAQ了。本文仅代表我个人观点，有问题欢迎Email: [songjinshan@akaedu.org](mailto:songjinshan@akaedu.org)。\n\n​        在看这份FAQ之前，你必须先读完ESR的《如何成为一名黑客》（本文末尾附有中译版），该文所讲过的道理我不再重复。该文用很大的篇幅讲什么是黑客文 化，虽然态度和信仰的确是成功的最关键因素，但是你肯定会想，做不做黑客跟我没关系，我只是想学个一技之长，找个好工作而已，对吧？那么肯定更希望获得一 些具体的可操作的指导。\n\n####   1、各种软件技术之间是怎样的关系？ \n\n  我把软件技术分为三个层次：\n        **问题域**：计算机图形学、音视频编码、信息安全、模式识别、信息检索、自然语言分析、人工智能、科学计算等；\n        **系统集成**：C++和Java等面向对象语言、Python等解释型语言、LISP等函数式编程语言、GUI、中间件、编译器与解释器、虚拟机、数据库、网络服务、并行计算、集群、Peer2Peer、系统管理等；\n\n**系统功能**：硬件描述语言、计算机体系结构与编程模型、指令集与汇编语言、C语言、内核、文件系统、设备驱动、网络协议、POSIX等。\n\n​        计算机最终是做什么用的呢？最终是通过问题域的各种技术为用户解决问题的，这些技术都包含很高深的算法，然而它们必须在一个平台上运行，它们需要利用平台 提供的各种基础设施，比如计算能力、I/O能力和网络互联能力。系统功能和系统集成层就是用来实现这个平台的。系统功能层实现计算、I/O和网络的基本功 能，系统集成层对这些基本功能做一些抽象和包装，提供更方便灵活的接口。\n\n####   2、为什么要学习嵌入式技术？ \n\n​        在亚嵌的学习期间，你将详细了解系统功能层的各部分是如何工作的，也会在面向对象编程、GUI、数据库、网络服务等系统集成层的技术方向进行探索。嵌入式 系统可说是麻雀虽小五脏俱全，虽然没有PC和服务器那么复杂，但计算机系统的各种组成一样也不缺。因此，以嵌入式系统作为切入点开始学习软件技术是非常好 的选择，避开不必要的复杂性，把握计算机系统最根本的概念和技术要点。打下扎实的基础之后，你的职业发展则完全不必局限于嵌入式领域，即使你日后做PC或 服务器开发，在亚嵌所学的知识和技能同样使你终生受益。正如庖丁解牛，心中有全牛，自然就能游刃有余。\n\n​        另一方面，你一定见到各大网站都有大量的宣传，说现在嵌入式行业前景空前的好，嵌入式人才紧缺，有几百万职位空缺等等。这些说法也是对的，但我们需要更深 入地理解这说明了什么问题。刚才我们说，嵌入式系统也是一个完整的计算机系统，和PC或服务器没有本质的区别，事实上，嵌入式、PC和服务器的界限已经越 来越模糊了。以前的嵌入式就是单片机，只能做简单的运算处理，现在的ARM处理器性能比从前的奔腾还强，打游戏、看电影都没问题，谁能说它不是PC呢？另 外有些专用的嵌入式系统已经在充当服务器的功能了，而集群技术更是可以使许多廉价的处理器组合在一起发挥大型服务器的作用。由于嵌入式越来越多地应用到电 器、汽车和各种设施上，无处不在，并且与PC、服务器呈融合的趋势，所以嵌入式行业前景空前的好。\n\n​        那么，为什么说嵌入式人才紧缺呢？其实，学嵌入式系统就是学计算机系统，本质上并没有什么特殊的只有嵌入式系统才有的技术。说嵌入式人才紧缺，其实质上是 说真正懂计算机的人才紧缺。现在很多学校的所谓“软件学院”培养的软件人才都是一叶障目不见泰山的：只懂J2EE和.NET，没学过C和汇编；只会调库函 数sort()，而对各种排序算法一无所知；设计模式、软件工程讲得头头是道，却不知道好的软件还是要靠牛人靠智商来做的。培养人像蒸包子一样一屉一屉地 出，靠软件工程搭一条生产线，然后让熟练工人站在生产线上拧螺丝，幻想着这样就能生产出好的软件，那是把软件工程和程序员的作用本末倒置了。现在嵌入式开 发对程序员的素质要求更高了，以上这类“软件人才”不能胜任了，因此说嵌入式人才紧缺。亚嵌的就业班虽然只有几个月，但培养目标是有完整的计算机系统概念 的软件人才，而不是只会拧螺丝的软件工人，这正得益于我们始终坚持做嵌入式培训而不是Java或.NET培训。\n\n####   3、有人说软件技术变化太快，现在学的东西过两年就要完全淘汰，是吗？ \n\n​        你知道这话是什么人说的吗？必然是已经被淘汰的人说的。比如Delphi、BCB、PB这些开发工具和语言，都曾经很是风光了一阵，但现在已经完全被 Java和.NET取代了。那么Java和.NET会不会被取代呢，也许在相当长的时间内还不会，但是我看好Python。\n\n​        这些被淘汰的程序员有一些共同的特点：只会用鼠标拖拽控件，离开IDE就不知道如何工作，学点儿花拳绣腿的功夫就想吃一辈子，对学习新技术不感兴趣，做一 天和尚撞一天钟。现在请回头看看FAQ1，在整个软件技术领域，这些变化快的技术其实只占了很小的一块，却成了这些人的全部看家本领，这样的人能不被淘汰 吗？\n\n​        与这些流行的开发工具和语言相反，很多技术和思想是很少变化的。比如，POSIX和SUS标准规定了一套系统函数接口和基本命令的语义，只有实现了这些才 可以称作UNIX，因此今天的Linux、Solaris跟20多年前的UNIX在系统功能层上是基本一致的。而指导计算机科学发展的数学理论，甚至是老 祖宗们在计算机还没诞生的年代就替我们想好的：布尔代数发表于19世纪，直到一个世纪后发明了计算机和数字电路才有了用武之地；数论在17世纪就出现了， 一直都被数学家们当成一套好玩的理论，但只是好玩而已，直到计算机密码学诞生后才发现它的实际用处。\n\n​        各种流行的开发工具和高级语言虽然变化很快，但是底层的编程语言却非常稳定，各种操作系统的内核都是用C语言写的，以前是这样，以后也不会改变。另一方 面，各种编程语言的设计思想也是非常稳定的。其实世界上只有两种编程语言，一种是C，一种是LISP，前者是imperative的，是对计算机模型的抽 象，后者是functional的，是对数学函数模型的抽象。面向对象是一种重要的软件工程思想，却算不上一种新的语言模型，应该归在C的一类。属于同一 类的各种语言其实都大同小异，一个精通C++的人学习Java需要多长时间？熟悉语法一个星期，熟悉类库三个星期，一个月足矣，以往的经验都可以套到新的 编程语言上。然而要想习得深厚的算法功底、逻辑思维和抽象思维修养，能够真正说清楚“系统”是什么，如何分析和设计“系统”，需要多长时间？恐怕要数十 年。\n\n####  4、C和Java哪种语言更好？ \n\n​        计算机科学与编程语言无关，甚至与计算机本身也没太大关系，它研究的对象并不是计算机，而是人分析问题解决问题的方法论。程序写出来最主要不是为了给计算 机执行的，而是为了给人看的，使用编程语言和使用自然语言一样是为了表达和交流，只不过程序还可以顺便给计算机执行而已。\n\n​        以上这些话并不是我说的，而是一位著名的计算机科学家说的。所以，在编程语言的层面上争论是没有意义的。很多初学者错误地认为掌握了编程语言就等于学会了 计算机，一种编程语言都还没有掌握好，更没有上升到方法论的层面，只有这种无知的人才会去争论哪种语言好的问题。掌握了编程语言远远不等于学会了计算机， 而只是最开始的一步，最简单的一步，到了工作中，用到什么语言就去学什么语言，什么语言过时了就丢掉，编程语言不需要积累因为它太简单了，真正需要积累的 是方法论。\n\n​        很多人喜欢参与到这类争论之中，毫无例外，每个人都在为自己熟练掌握的编程语言辩护，就是“我会的语言最好，我不会的语言都不好”，其实这些人真正想说的 是“我会的语言最好是千秋万代，我就不必学新的语言，不必适应新的变化了”，概括起来说就是一个字，懒。真正的高手都是会很多编程语言的，国外有些做技术 咨询的，每年都要学好几门新的编程语言，这样才能应对市场的变化。不断丢掉旧的编程语言学习新的，看起来好像完全是白费力气，没有积累，其实，每种编程语 言的设计都有独到之处，体现了每种语言的精髓，在融汇百家之后积累下来的正是方法论。\n\n​       争论哪种语言能做的事情更多、功能更强是没有意义的。从理论上说，任何一种符合图灵机模型的编程语言，加上适当的I/O扩展都可以做任何事情，用 shell脚本也可以写出很像样的游戏来。只不过各种语言的设计目标不同，表达能力不同，做不同的事情所需的代码量不同而已。\n\n​        另外一种错误认识是：哪种语言的市场最大，开发人员最多，哪种语言就最好。单从这种意义上说，Java的确比C更好，所以往届有学员问我们为什么只教C语 言。请你注意，操作系统内核是用C写的，各种底层的应用程序包括Java虚拟机也是用C写的。如果你想学Java，在亚嵌的学习完成后你将有能力分析 Java虚拟机的实现，站在计算机系统的高度来学Java才会使你成为真正的Java高手。如果你只想速成，想早点学成一门技术去做拧螺丝的工作，那么亚嵌不适合你。\n\n​       在FAQ3里说过，世界上有C和LISP两种编程语言，你现在学了C，以后学了C++、Java、.NET等等，也仍然只认识了半个世界。LISP和 Haskell构成了另外半个世界，现在很常见的Python和JavaScript等解释型语言也借用了functional programming的思想。如果你只管闷着头写代码，而不去广泛涉猎，那么你将错过很多精彩。\n\n####   5、我听说编程编到三十五岁就没人要了一定要转行找出路是吗？ \n\n​      这个观点虽然很流行，但根本不值一驳。现在三十五岁转行的那些人，都具有前面所说的那些特征，对学习新技术不感兴趣，对探索计算机的本质不感兴趣，得过且 过，下了班就是打游戏、看电视，总之就是懒。如果是开出租、摆摊，勤快人懒人都有饭吃，而IT这一行对懒人是非常无情的，懒人就不该入IT这一行，不从自 身找原因，却到处散布这种言论，怪社会不好，打击新人的信心，着实可恨。\n\n​       另外一种情况，编程编到三十五岁，进入公司的管理层，或者自己创业，这都是很勤快的人，如果他们把这种勤快用在技术上肯定也可以做得更好，所以也无法证明编程编到三十五岁会因为没有出路而转行。\n\n​       编程不是个体力活，需要高强度的思考和智力投入，分析能力、思考能力都需要时间积累起来，所以并不是越年轻干得越好。相反，我认为三十岁以前写的代码都是 垃圾，三十岁以后才能写出像样的程序来。如果希望一辈子走技术的道路而不会被迫转行，就要不断地把自己的工作性质从“体力活”变成“脑力活”。什么叫“不 断地”变呢？这里的“体力活”并不是指种地、盖房子这种劳动，而是指简单重复地编写代码，这时你会感觉，派给你的工作都能凭以往的经验轻松应付了，但是千 万不要满足于现状，就像温水煮青蛙一样，这是危险的处境！要摆脱这种处境就需要学习、思考、提高，让公司派给你更有挑战性的工作，在工作中应用新学到的知 识和技术就是“脑力活”了，但是用得久了又会变成简单重复的“体力活”，这时就需要再学习、再提高，所以叫做“不断地”把自己的工作性质从“体力活”变成 “脑力活”。如果有一天你发现，自己长期陷于简单重复的劳动之中，并且业余时间非常少，无法学习提高，这说明公司不会用人，你就该考虑跳糟了。\n\n​       从另外一个角度来说，如果希望一辈子走技术的道路，就要有自己的核心竞争力，这个核心竞争力决不是凭以往的经验能够做某些工作的能力，而是学习能力、思考 能力和解决有挑战性的新问题的潜力。在IT这一行，凭借以往的经验干重复的活是干不长久的，原因很简单，一个问题不会被解决两次，当你发现你的经验能够解 决一类问题时，别人早把解决这一类问题的套路编写成framework，新上手的人即使不具备你的这些经验也可以调用framework中的类和函数来解 决问题，然后在这个framework的基础上积累新的经验解决新的问题。正因为如此，全世界开发人员的经验才会积累起来，促使软件技术发展得如此迅速。 这并不是说经验完全没有用，最关键的，学习和思考也是建立在以往经验的基础之上的。另一方面，现有的framework并不一定是某方面开发经验的完美整 合，也需要不断发展，用新的办法重新解决老问题，以Web开发为例，从早期的ASP、PHP到后来的.NET、J2EE，到现在的Ruby on Rails、Django等等，这些framework解决的是同一问题，就是如何快速有效地开发Web应用，这方面的经验被不断重新整合，推陈出新。总 结一下，什么才是核心竞争力呢？应该是在经验的基础上学习新技术、解决新问题的能力。\n\n####   6、做驱动开发还是做应用开发更有前途？ \n\n​       意思就是说，“你告诉我哪个更有前途，我就好好学哪个，另外一个就不用学了”。问这种问题的学员往往会同时问另外一些问题：我以后就想做驱动开发，你教我这些应用开发的技术有什么用？C++用得多吗？学了有什么用？我以后不想做GUI，你教我Qt有什么用？\n\n​        学习最忌讳的就是“有用的就学，没有用的就不学”这种功利的态度。两个问题：第一，在你还没学进去、还不了解这种技术时，要如何判断这种技术学了有没有 用？只能是根据道听途说，看各种论坛上都怎么说的，岂不知论坛上参与这种讨论的100%都是菜鸟，有的水平还不如你。第二，就算你学的技术没有用上，有什 么损失吗？从亚嵌毕业的学员从事各种各样的开发工作，有做驱动的，有做系统编程的，有做GUI的，有做Web开发的，只要确定了做一类工作，就不可能把在 亚嵌四个月学的知识都用上，但至少也用得上3/4的知识，假设剩下的1/4你一辈子也没机会用上了，那也就损失你一个月的学习时间而已，相比于你的收获， 这算是很大的损失吗？请注意，上面的假设是不成立的，没用上的那1/4也只是暂时没用上而已，程序员要换工作或者换项目是很常见的，任何人都不可能只涉及 一类开发工作，只要有扎实的基础、完备的知识体系，任何工作都能轻松上手。\n\n​        扎实的基础，完备的知识体系，我们在安排就业班课程体系的时候，正是以这两点为依据的。有的课程内容很少有学员在以后工作中会用到，但是缺了这一环就不成 为一个完备的知识体系，例如MMU和Cache，那这种课该不该上呢？毫无疑问该上。有的课程培养一种基本的编程思想，例如通过C++来讲面向对象编程， 通过Qt来讲面向对象、事件驱动和状态机编程，这些编程思想是程序员必备的基本素质，而C++和Qt可能有些学员以后工作用不到，那这种课该不该上呢？毫 无疑问该上。至于还有些人争论说C++不如Java用得多，Qt不如GTK用得多，请翻回去看FAQ4，这种争论是无意义的，有工夫争论谁优谁劣，不如把 两种都学了，会更有收获。\n\n​        回到做驱动开发还是做应用开发更有前途的问题。我只能说，做好了都有前途，做不好都没有前途，只会做一样而完全不懂另一样是最没前途的。不要以为内核开发 者就不写应用程序，Linus写了一个源代码管理系统git来维护内核，因为觉得现有的源代码管理系统都不好用。牛人都是这样，需要什么就写什么，才不管 是kernel space还是user space。同样，做应用开发如果不懂内核，也没有办法很好地利用内核提供的服务写出性能最优的程序。做内核难，因为调试难，要跟踪大量的并发线程，因为 入门难，要写一个hello world都需要学很多知识。做应用也难，回头去看FAQ1，计算机科学从理论到实践大部分都在上面两层做文章。所以不存在哪个更难哪个更有前途的问题， 任何关于哪个更难的讨论都是too naive的。\n\n####   7、我一开始看什么书都看不懂，怎么才能理出一个学习顺序？ \n\n​       以前有个学员在学C语言时说，“C语言很多地方都很奇怪，都得用内核的知识去解释，可是你又不先教我内核，我没法学C语言。我只好自己看操作系统的书，看 内核代码，可是看不懂。”当然看不懂了，内核代码都是用C写的，如果不学内核就没法学C语言，那不学C语言又怎么可能看懂内核？看来这是一个鸡生蛋还是蛋 生鸡的问题。\n\n​        懒真的是人的本性，就连学习的过程都希望是一条路顺利地走下去，不用动脑就能学会的：身后走过的路都是“已知”，每走一步就把眼前新的“未知”变成“已 知”，如此一路走来，把所有的“未知”都变成“已知”就算学成了。可惜，知识不是一条路，而是一个圈，你从任何一个地方跳进这个圈开始走，身后都是“未 知”，眼前也都是“未知”。有的人就是不能容忍自己的身后是“未知”：看一本书，一个新的概念A是用我不了解的概念B、C来解释的，我连B、C都不懂怎么 学A？没法学了！\n\n  不是人家书写得不好，而是没有任何办法能把一个圈扯成一条直线的。学习的过程本质上就是一个循环往复的过程，唯一的办法就是“存疑”：在本子上记着，有 B、C这样两个概念是我暂时不理解的，然后就不再去想这回事，而是相信自己已经理解了B、C，基于自己的理解和假设去学习A，由A再去理解X、Y，这样学 下去，走完一圈之后再回来，自然就明白当初对B、C的假设正确不正确了，理解了这两个概念，就从本子上划掉，这时需要再走一圈，把原来的一些错误认识纠正 过来。所以，任何书都要至少看两遍，第二遍看的时候你会对很多概念有新的认识，因为你看过这个概念后面的章节，在此基础上产生了新的认识。古人早就明白这 个道理，所以提出了“温故而知新”。\n\n​        亚嵌的课程体系经过多年教学实践的锤炼，已经很好地理顺了知识之间的关系，使你从最佳的位置跳进这个圈开始学习，所谓“最佳位置”是指，在你初学的时候需 要容忍的“未知”尽可能少，需要做的假设尽可能少，但要想消除所有的“未知”是不可能的，例如没有学内核就要学C语言。根据你以往的经验和一些运气因素， 你对内核的一些假设可能正确也可能错误，但这并不影响你学C语言，对内核的一些错误假设可能会导致在学C语言的过程中有些误解，但没关系，只要跟着我们的 课程体系一步一步走下来，这些误解和错误的假设最终都会纠正过来。\n\n####   8、有哪些好书可以推荐一下吗？ \n\n​        能问出这个问题的都是聪明的学员。看书学习是入门过程中非常重要的一环，如果用一本烂书入门，浪费时间还是小事，如果被误导了就麻烦了，如果形成的错误认 识不能及时纠正，变得根深蒂固了就更麻烦了。所以，看书一定要有“品牌意识”，在决定看书学习一门技术时先问问这一领域最权威的书是哪本，这里列举一些 Bible级别的书：\n  *T*he C Programming Language, 2nd Edition；* \n  *C++ Primer, 4th Edition；* \n  *Structure and Interpretation of Computer Programs, 2nd Edition；* \n  *Introduction to Algorithms, 2nd Edition；* \n  *Compilers: Principles, Techniques, and Tools；* \n  *Advanced Programming in the UNIX Environment, 2nd Edition；* \n  *TCP/IP Illustrated, Volume 1: The Protocols；* \n  *UNIX Network Programming Volume 1, 3rd Edition: The Sockets Networking API；* \n  *Understanding the Linux Kernel, 3rd Edition；* \n  Linux Device Drivers, 3rd Edition。*\n\n  在学习过程中，眼界一定要开阔，不要学到一点东西就沾沾自喜，坐井观天，以为这就是技术的全部。要多和别人交流，多了解别人在看什么书、别人对技术的认识是怎样的。书是看不完的，活到老学到老，对于程序员来说尤其如此。\n\n####   9、如何处理打游戏和学习的关系？ \n\n​        ESR的文章中也说过，黑客们都有一些特别的业余爱好，并且往往是非理性思维的爱好，大概是需要换换脑子吧。典型的例子是因滑翔机事故去世的 Stevens，他写了FAQ8所推荐的Bible当中的三本。爱打游戏的优秀程序员肯定大有人在，有一些还成了优秀的游戏开发人员。但是我认为，要想成 为优秀的程序员，必须有两点基本素质，一是对编程非常感兴趣，二是对所有别的事情都不感兴趣，或者都不如对编程感兴趣。有人说，人的一天有24小时，8小时休息，8小时上班，另外的8小时在干什么就决定了你以后有多大发展。一有时间就看书学习，这就是一个程序员应该做的。今天打游戏，明天看电影，后天炒股，那么你就等着三十五岁下岗。如果你不能够认同编程和思考是比其它事情更有吸引力的，那么你不必学编程，集中精力去做最喜欢的事情或许会有更大的成就。\n","tags":["程序员"],"categories":["杂谈"]},{"title":"测试文章","url":"/p/1023.html","content":"\n## 测试标题\n这是一个测试页面,以下内容为余华的《活着》![art](https://img1.baidu.com/it/u=4151257971,460772575&fm=26&fmt=auto)\n***\n &emsp;&emsp; 我比现在年轻十岁的时候，获得了一个游手好闲的职业，去乡间收集民间歌谣。那一年的整个夏天，我如同一只乱飞的麻雀，游荡在知了和阳光充斥的村舍田野。\n &emsp;&emsp; 我喜欢喝农民那种带有苦味的茶水，他们的茶桶就放在田埂的树下，我毫无顾忌地拿起漆满茶垢的茶碗舀水喝，还把自己的水壶灌满，与田里干活的男人说上几句废话，在姑娘因我而起的窃窃私笑里扬长而去。我曾经和一位守着瓜田的老人聊了整整一个下午，这是我有生以来瓜吃得最多的一次，当我站起来告辞时，突然发现自己像个孕妇一样步履艰难了。然后我与一位当上了祖母的女人坐在门槛上，她编着草鞋为我唱了一支《十月怀胎》。我最喜欢的是傍晚来到时，坐在农民的屋前，看着他们将提上的井水泼.在地上，压住蒸腾的尘土，夕阳的光芒在树梢上照射下来，拿一把他们递过来的扇子，尝尝他们和盐一样咸的咸菜，看看几个年轻女人，和男人们说着话。      \n &emsp;&emsp; 我头戴宽边草帽，脚上穿着拖鞋，一条毛巾挂在身后的皮带上，让它像尾巴似的拍打着我的屁股。我整日张大嘴巴打着呵欠，散漫地走在田间小道上，我的拖鞋吧哒吧哒，把那些小道弄得尘土飞扬，仿佛是车轮滚滚而过时的情景。    \n &emsp;&emsp; 我到处游荡，已经弄不清楚哪些村庄我曾经去过，哪些我没有去过。我走近一个村子时，常会听到孩子的喊叫：     \n\n &emsp;&emsp; “那个老打呵欠的人又来啦。”\n\n`print \"hello world\"`\n\n```多行代码块\nfor(int i=0;i=100;i++){\n     cout<<\"这是第\"<<i+1<<\"次\"<<循环<<endl;\n}\n```\n\n","tags":["测试标签"],"categories":["分类测试"]}]