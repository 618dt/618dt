[{"title":"SpringBoot入门","url":"/p/e10.html","content":"## 前期准备\n### 课程简介\n1.Spting Boot概述\n2.Spring Boot版本介绍\n3.新建Spring Boot项目演示(官网和IDEA两种)\n\n### 软件版本\nJava 1.8.0_171（大版本一致） \nMySQL 8.0.12（大版本一致） \nMaven 3.3.9（大版本一致） \nSpring Boot 2.2.1（版本需要严格一致）  \n\n### Spring Boot诞生历史\n◇Spring的缺点：配置过于繁琐\n◇Spring Boot开发团队: Pivotal\n### Spring Boot简介\n◇简化初始搭建以及开发过程\n◇不再需要定义样板化的配置\n◇快速应用开发领域\n### Spring、Spring MVC、Spring Boot\n◇Spring最初利用IOC和AOP解耦\n◇按照这种模式搞了MVC框架\n◇写很多样板代码很麻烦，就有了Spring Boot\n◇Spring Cloud是在Spring Boot基础上诞生的；\n### Spring Boot核心特点\n◇开箱即用：对于spring需要Tomcat等一系列配置，而springboot不需要；\n◇约定优于配置，在开发中遵守某种约定；\n### Spring Boot版本介绍\n![image.png](SpringBoot入门/1635758293954-ea2b47bc-0be8-46a2-bc28-cedb50597c0a.png)\n◇CURRENT，代表最新的GA版本\n◇GA，General Availability（正式发布版本),面向大众的，功能完美并且稳定；\n◇SNAPSHOT，版本会被修改\n◇如何选择版本？选择GA版本，不一定要最新的；\n\n## Spring Boot 项目开发\n### 官网构建\n◇[Spring官网 ](https://start.spring.io)来进行开发；选择maven->选择springboot版本->填写工程名->选择jar包->增加springweb依赖->\nExplore(预览)->Generate(生成)；\n◇打开IDEA，点击import Project(引入项目),将刚才下载好的项目解压并进入文件夹点击open->选择Maven->勾选Import Maven projects automatically->next->finish;可以看到会生成一个启动类xxxApplication,这个启动类最好不要随意更改位置；\n### IDEA集成\n◇IDEA集成的Spring Initializr\n◇新建项目->选择Spring Initializr->选择java版本1.8->Default->next->填写项目Group等信息;\n![image.png](SpringBoot入门/1635765769890-3ead8c1a-ed8d-4a93-b864-d6356c202e32.png)\n◇选择springboot版本以及web依赖\n![image.png](SpringBoot入门/1635765865834-485ce888-f4e7-47c3-8adf-ed1b9ff6f74a.png)\n\n### 项目结构解析\n◇Spring Boot的基础结构共三个文件：入口(启动类)、配置文件(放在resources文件夹下)、测试入口(在test文件夹下)\n◇生成的Application和ApplicationTests类都可以直接运行来启动当前创建的项目;\n◇对于pom.xml文件修改springboot的版本为:2.2.1.RELEASE\n\n### 案例演示\n◇新建一个ParaController类\n```java\npackage com.lcg.springboottest;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n *  演示各种传参形式\n */\n@RestController //有Restful能力的Controller\npublic class ParaController {\n    @GetMapping(\"/test01\")\n    public String firstRequest() {\n        return \"第一个Spring Boot接口\";\n    }\n    //@RequestParam注解会在请求参数中找到num这个参数并进行绑定\n    //访问  /test02?num=6\n    @GetMapping(\"/test02\")\n    public String requestParam(@RequestParam Integer num) {\n        return \"test02: num=\"+num;\n    }\n    /*从路径中获取参数num\n    * 访问test03/6*/\n    @GetMapping(\"/test03/{num}\")\n    public String pathParam(@PathVariable(\"num\") Integer num) {\n        return \"test03:num=\"+num;\n    }\n\n    @GetMapping({\"/multi01\",\"/multi02\"})//多url的情况\n    public String multiUrl(@RequestParam Integer num) {\n        return \"multi:num=\"+num;\n    }\n\n    @GetMapping({\"/test04\"}) //required= false表示不是必须传参，并设置默认参数为0；\n    public String test04(@RequestParam(required= false,defaultValue = \"0\") Integer num) {\n        return \"test04: num=\"+num;\n    }\n}\n\n```\n### Web项目的三层结构\n◇Controller 做一些简单的逻辑判断\n◇Service 对业务逻辑进行抽象，封装保持Controller的简洁;\n◇Dao 一般用于和数据库的交互，增删改查之类；\n### 配置文件的两种写法\n◇application.properties\nenvironments.dev.url=http://gamest.link\nenvironments.dev.name=Developer\n```java\nserver.port=8081   //配置端口\nserver.servlet.context-path=/first  //配置项目统一路径前缀\n```\n◇yml写法：分层级，冒号后需要空格；好处是前面的前缀相同的话可以直接并列；\n```java\nenvironments:\n   dev:\n     url:http://gamest.link\n     name:Developer\n```\n◇两种写法的[转换网站](https://www.toyaml.com/index.html)\n### 进行自定义配置\n◇利用value注解配置属性\n```java\n//配置文件中\nschool.grade=3\nschool.classnum=6\n    -----------------------------------------------------------------------\n//控制器中\n    /*\n* 演示读取配置的控制器*/\n@RestController\npublic class PropertiesController {\n    @Value(\"${school.grade}\") //进行与配置文件的绑定,按住ctrl然后鼠标放在上面会有配置提示\n    Integer grade;\n    @Value(\"${school.classnum}\")\n    Integer classnum;\n    @GetMapping(\"/grade\")\n    public String gradeClass() {\n        return \"年级：\"+grade+\"班级：\"+classnum;\n    }\n}\n```\n◇配置类\n```java\npackage com.lcg.springboottest;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\n/**\n * School配置类\n */\n@Component\n@ConfigurationProperties(prefix = \"school\") //设置属性的前缀\npublic class SchoolConfig {\n    Integer grade;\n    Integer classnum;\n        public Integer getGrade() {\n        return grade;\n    }\n    //需要有get和set方法spring才能从配置文件中注入数据进来\n    public void setGrade(Integer grade) {\n        this.grade = grade;\n    }\n\n    public Integer getClassnum() {\n        return classnum;\n    }\n\n    public void setClassnum(Integer classnum) {\n        this.classnum = classnum;\n    }\n}\n\n```\n◇读取配置类的方法\n```java\npackage com.lcg.springboottest;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * 读取配置类\n */\n@RestController\npublic class ConfigController {\n    @Autowired //自动引入\n    SchoolConfig schoolConfig;\n\n    @GetMapping(\"/grade\")\n    public String gradeClass() {\n        return \"年级：\"+schoolConfig.grade+\"班级：\"+schoolConfig.classnum;\n    }\n}\n```\n## Service和DAO的编写\n### 数据库的创建\n◇新建数据库springstu存储学生信息；\n◇建立学生表，包含了id，姓名\n### 项目依赖与配置\n◇引入mybatis依赖\n```java\n        <!--mybatis依赖-->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>2.1.1</version>\n        </dependency>\n\n        <!--mybatis的mysql连接池依赖-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n```\n◇数据库的配置\n```java\nspring.datasource.username=root\nspring.datasource.password=www.LCG.com\nspring.datasource.url=jdbc:mysql://localhost:3306/springstu?useUnicode=true&amp;\\\n  characterEncoding=UTF-8\n```\n◇创建实体类\n◇创建controller\n```java\n@RestController\npublic class StudentController {\n    @Autowired\n    StudentService studentService;\n    @GetMapping(\"/student\")\n    public String student(@RequestParam(required = false,defaultValue = \"1\") Integer num) {\n       Student student = studentService.findStudent(num);\n       return \"学生学号:\"+student.getNum()+\"学生姓名：\"+student.getName();\n    }\n}\n```\n◇创建service\n```java\n@Service\npublic class StudentService {\n    @Autowired\n    StudentMapper studentMapper;\n\n    public Student findStudent(Integer id) {\n       return studentMapper.findById(id);\n    }\n}\n```\n◇创建Mapper接口\n```java\n@Mapper \n@Repository //用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理\npublic interface StudentMapper {\n    @Select(\"select * from students where id = #{id}\")\n    Student findById(Integer id);\n}\n```\n◇springboot整合mybatis的项目示例[参考链接](https://www.cnblogs.com/wangzaiplus/p/10899962.html)\n\n","tags":["SpringBoot"],"categories":["Spring","SpringBoot"]},{"title":"项目实现-后台","url":"/p/28f1.html","content":"## 富文本编辑器[wangEditor](https://www.wangeditor.com/)\n### 简介\n◇基于javascript与css开发的Web富文本编辑器，类似于word可以进行图文混排的工具；\n![image.png](书评网-后台/1635512115522-da065370-16e0-47da-848e-b050a6b70137.png)\n\n### 使用方法\n◇下载wangEditor的js文件，在test.ftl页面中进行引用；\n◇基本使用方法写入和读取\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <#--引用wangEditor-->\n    <script src=\"/resources/wangEditor.min.js\"></script>\n</head>\n<body>\n<div>\n    <button id=\"btnRead\">读取内容</button>\n    <button id=\"btnWrite\">写入内容</button>\n</div>\n<#--使用div容器来显示富文本编辑器-->\n<div id=\"divEditor\" style=\"width: 800px;height:600px\"></div>\n<script>\n    var E = window.wangEditor;//获取对象\n    var editor = new E(\"#divEditor\");//完成富文本编辑器初始化\n    editor.create();//创建富文本编辑器，显示在页面上\n    //为按钮绑定单击事件，因为没有引入jquery，所以使用原生的document；\n    document.getElementById(\"btnRead\").onclick = function () {\n        var content = editor.txt.html();//获取编辑器现有的html内容\n        alert(content);\n    };\n    //写入,可以看出和jQuery的语法很像,html无参则为读取，有参则为写入\n    document.getElementById(\"btnWrite\").onclick = function () {\n        var content = \"<li style='color:red'>李凭中国弹箜篌</li>\";\n        editor.txt.html(content);\n    };\n</script>\n</body>\n</html>\n```\n## 实现图书管理功能\n### 图片上传功能\n◇在训练素材中将后台页面图书管理页复制到项目中，放在ftl/management目录下(与前台进行区别),并重命名为book.ftl;\n◇book.ftl部分代码\n```java\n//显示新增图书对话框\n    function showCreate(){\n\t\t//弹出\"新增图书\"对话框\n        layui.layer.open({\n            id: \"dlgBook\",\n            title: \"新增图书\",\n            type: 1,\n            content: $('#dialog').html(),\n            area: ['820px', '730px'], //宽，高\n            resize: false\n        })\n\t\t//初始化wangEditor\n        editor = new wangEditor('#dlgBook #editor');\n        editor.customConfig.uploadImgServer = '/management/book/upload';//设置图片上传地址\n        editor.customConfig.uploadFileName = 'img';//设置图片上传参数，在springmvc接收时会用到\n        editor.create();//创建wangEditor\n\n        layui.form.render(); //LayUI表单重新渲染\n        $(\"#dlgBook #optype\").val(\"create\");//设置当前表单提交时提交至\"create\"新增地址\n\n    };\n```\n◇新建子包management并重建controller类以显示后台管理页面以及后面的交互；\n◇wangEditor[官方文档](https://www.wangeditor.com/doc/pages/07-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/)对上传图片功能的介绍；\n◇在pom.xml中增加底层的文件上传依赖;对于springmvc底层上传依赖于Apache的commons-fileupload组件\n```java\n        <!-- Spring MVC文件上传底层依赖 -->\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.4</version>\n        </dependency>\n```\n◇然后在applicationContext.xml中配置激活springmvc的文件上传功能\n```java\n    <!-- 激活Spring MVC 文件上传 -->\n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        <property name=\"defaultEncoding\" value=\"UTF-8\"/>\n    </bean>\n```\n◇在controller中开发文件上传功能\n```java\n    //这里的地址要和book.ftl中设置的文件上传地址/management/book/upload一致\n    /*MultipartFile用于接收文件,前面注解里的参数要和前面设置的上传参数一致\n    * 原生的request用来获取发布路径*/\n    @PostMapping(\"/upload\")\n    @ResponseBody\n    public Map upload(@RequestParam(\"img\") MultipartFile file, HttpServletRequest request) throws IOException {\n        /*这行代码在运行时执行，即在web应用发布以后才执行，所以实际得到的路径是在\n        * 工程发布的目录下(即out/artifacts/xxx_Web_expload)的路径,而不是webapp下的*/\n        String uploadPath = request.getServletContext().getResource(\"/\").getPath() + \"/upload\";\n        //生成文件名,利用SimpleDateFormat生成毫秒级文件名，以防止命名冲突\n        String fileName = new SimpleDateFormat(\"yyyyMMddHHmmssSSS\").format(new Date());\n        //文件扩展名，来自原始文件,所以将原始文件进行字符串的截取,从最后一次出现\".\"开始截取剩余的字符串\n        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\".\"));\n        //利用transferTo()(另存为方法)将上传的文件报存到我们指定的目录中;new File（）新建文件\n        file.transferTo(new File(uploadPath+fileName+suffix));\n        \n        //按照wangEditor的要求组织返回结果\n        Map result = new HashMap();\n        result.put(\"errno\", 0);//0,代表服务器处理正常\n        //data要求是数组，所以新建一个数组,而上传的文件可以直接访问，所以返回的data填上其访问地址\n        result.put(\"data\",new String[]{\"/upload/\"+fileName+suffix});\n        \n        return result;\n    }\n```\n◇图片上传成功返回的json字符串\n![image.png](书评网-后台/1635518539958-ee415fc0-f347-448c-b0bd-71f2679dc2ea.png)\n◇指定的目录下\n![image.png](书评网-后台/1635518575411-6ee8bb12-4d04-44ad-857c-f1bcb5f1ef15.png)\n\n### 图书新增功能\n◇图书封面的第一张作为封面在前台展示；如果没有增加图片就提交的话弹出提示增加图片作为封面；\n◇提交后发送至后台的数据\n![image.png](书评网-后台/1635560197806-f4fd6c73-48cf-4816-a8ad-920f04bc0b03.png)\n◇在BookService中书写相关接口及接口实现类，然后在MBookController中用前台传来的参数进行调用；\n◇我们看到发送后台的数据没有评分，图书封面，评论的信息，所以还需要我们在controller中进行补全；那么如何从description描述的html文本中将第一幅图作为图书封面呢？\n◇[jsoup](https://jsoup.org)是一款java html解析器，利用jsoup可以将第一张图片截取出来；\n\n```java\npackage com.lcg.reader.controller.management;\n\n@PostMapping(\"/create\")\n    @ResponseBody\n    public Map createBook(Book book){\n        Map result = new HashMap();\n        try {\n            book.setEvaluationQuantity(0);//补全评论数量\n            book.setEvaluationScore(0f);//补全评分\n            /*利用jsoup进行html的解析*/\n            Document doc = Jsoup.parse(book.getDescription());\n            //选中图书详情中所有的img标签,然后获取第一个\n            Element img = doc.select(\"img\").first();\n            //获取当前元素指定的属性值,作为图片是在img标签中存在于src这个属性中的;\n            String cover = img.attr(\"src\");\n            book.setCover(cover);//补全图书封面\n            bookService.createBook(book);\n            result.put(\"code\",\"0\");\n            result.put(\"msg\", \"success\");\n        } catch (BussinessException e) {\n            e.printStackTrace();\n            result.put(\"code\",e.getCode());\n            result.put(\"msg\", e.getMsg());\n        }\n        return result;\n    }\n```\n### 后台图书分页\n ◇layui的数据列表在初始化以后会利用ajax向服务器发送请求来自动获取分页数据；即发起一个请求，该请求附带了page和limit两个参数，如图(表示查询第一页数据，每页显示10条)；这两个参数只有在layui数据表格开启分页后才会显示;\n![image.png](书评网-后台/1635562567548-4228df18-7a6c-44ab-82d7-47e0de7a33a5.png)\n◇下面针对这个请求网址来实现图书分页查询；\n◇在开发前台的时候我们已经在BookService中创建了分页功能方法paging,参数为图书分类，排序方法，页数，每页几行4个参数；对于前面两个参数，如果想要进行忽略的话设置为null即可；基于paging方法进行后台查询功能的开发；\n\n```java\n    package com.lcg.reader.controller.management;\n\n    @GetMapping(\"/list\")\n    @ResponseBody\n    public Map list(Integer page, Integer limit) {\n        if (page == null) {//容错处理，设置为空时的默认值\n            page = 1;\n        }\n        if (limit == null) {\n            limit = 10;\n        }\n        //调用前面创建的分页方法获取图书分页对象\n        IPage<Book> iPage = bookService.paging(null, null, page, limit);\n        //按Layui的数据规范书写返回数据\n        Map result = new HashMap();\n        result.put(\"code\", \"0\");\n        result.put(\"msg\", \"success\");\n        result.put(\"data\", iPage.getRecords());//当前页面数据\n        result.put(\"count\", iPage.getTotal());//未分页时记录总数\n        return result;\n    }\n```\n### 图书修改功能\n◇作为图书修改功能需要和服务器建立两次通信：第一次是点击修改按钮的时候需要把要修改的图书信息进行返回，回填到修改框中；第二次是点击提交时将修改后的数据发送到后台；\n◇book.ftl修改部分的代码\n```java\n\t//obj对应点击的\"修改\"按钮对象\n    function showUpdate(obj){\n\t\t//弹出\"编辑图书\"对话框\n        layui.layer.open({\n            id: \"dlgBook\", //指定div\n            title: \"编辑图书\", //标题\n            type: 1, \n            content: $('#dialog').html(), //设置对话框内容,复制自dialog DIV\n            area: ['820px', '730px'], //设置对话框宽度高度\n            resize: false //是否允许调整尺寸\n        })\n\n        var bookId = $(obj).data(\"id\"); //获取\"修改\"按钮附带的图书编号\n        $(\"#dlgBook #bookId\").val(bookId); //为表单隐藏域赋值,提交表单时用到\n\n        editor = new wangEditor('#dlgBook #editor'); //初始化富文本编辑器\n        editor.customConfig.uploadImgServer = '/management/book/upload' //设置图片上传路径\n        editor.customConfig.uploadFileName = 'img'; //图片上传时的参数名\n        editor.create(); //创建wangEditor\n        $(\"#dlgBook #optype\").val(\"update\"); //设置当前表单提交时提交至\"update\"更新地址\n\n\t\t//发送ajax请求,获取对应图书信息\n        $.get(\"/management/book/id/\" + bookId , {} , function(json){\n\t\t\t//文本框回填已有数据\n            $(\"#dlgBook #bookName\").val(json.data.bookName);//书名\n            $(\"#dlgBook #subTitle\").val(json.data.subTitle); //子标题\n            $(\"#dlgBook #author\").val(json.data.author);//作者\n            $(\"#dlgBook #categoryId\").val(json.data.categoryId); //分类选项\n            editor.txt.html(json.data.description); //设置图文内容\n            layui.form.render();//重新渲染LayUI表单\n        } , \"json\")\n\n    }\n```\n◇MBookController中增加两个方法：数据查询和数据修改;\n◇在进行数据修改操作时，正确的方法为：先查询出原始数据，然后在原始数据上进行相应的更改；\n```java\n//获取数据进行回填\n    @GetMapping(\"/id/{id}\") //与前台保持一致的路径变量\n    @ResponseBody\n    public Map selectById(@PathVariable(\"id\") Long bookId) {\n        Book book = bookService.selectById(bookId);\n        Map result = new HashMap();\n        result.put(\"code\", \"0\");\n        result.put(\"msg\", \"success\");\n        result.put(\"data\", book);//data在前端对应的是book数据，这里要和前面保持一致\n        return result;\n    }\n    @PostMapping(\"/update\")\n    @ResponseBody\n    public Map updateBook(Book book) {\n        Map result = new HashMap();\n        try {\n            /*这里注意不能直接对book进行更新，因为从前台传入过来的book对象中没有评分以及评论数量的信息\n            * 需要根据前台传入的book通过id进行查询获取到原始的Book记录后才能进行更新操作*/\n            Book rawBook = bookService.selectById(book.getBookId());//原始(未编辑前)的记录\n            rawBook.setAuthor(book.getAuthor());\n            rawBook.setBookName(book.getBookName());\n            rawBook.setSubTitle(book.getSubTitle());\n            rawBook.setCategoryId(book.getCategoryId());\n            rawBook.setDescription(book.getDescription());\n            //获取封面\n            Document doc = Jsoup.parse(book.getDescription());\n            Element img = doc.select(\"img\").first();\n            String cover = img.attr(\"src\");\n            rawBook.setCover(cover);//设置封面\n            //并且修改要基于原始的rawBook，这样不容易出错\n            bookService.updateBook(rawBook);\n            result.put(\"code\", \"0\");\n            result.put(\"msg\", \"success\");\n            //result.put(\"data\", book); 更新不需要返回数据，数据通过其他方法在前端显示\n        } catch (BussinessException e) {\n            e.printStackTrace();\n            result.put(\"code\", e.getCode());\n            result.put(\"msg\", e.getMsg());\n        }\n       return result;\n    }\n```\n### 图书删除功能\n◇删除的请求\n![image.png](书评网-后台/1635578378966-7d348a9f-dd0f-4b21-931c-a0f2db6cb7af.png)\n◇注意，在删除图书的同时，也应该将用户对该图书的阅读状态以及评论进行级联删除；\n\n```java\n@Service(\"bookService\")\n@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)\npublic class BookServiceImpl implements BookService { \n    @Resource\n    private BookMapper bookMapper;\n    @Resource\n    private MemberReadStateMapper memberReadStateMapper;\n    @Resource\n    private EvaluationMapper evaluationMapper;\n    @Transactional\n    public void deleteBook(Long bookId) {\n        bookMapper.deleteById(bookId);\n        /*构造条件删除某一本图书的所有阅读状态*/\n        QueryWrapper<MemberReadState> mrsQueryWrapper = new QueryWrapper<MemberReadState>();\n        mrsQueryWrapper.eq(\"book_id\", bookId);//即删除的where book_id = bookId\n        memberReadStateMapper.delete(mrsQueryWrapper);\n        QueryWrapper<Evaluation> evaluationQueryWrapper = new QueryWrapper<Evaluation>();\n        evaluationQueryWrapper.eq(\"book_id\", bookId);\n        evaluationMapper.delete(evaluationQueryWrapper);\n    }\n}\n```\n## 后台首页\n◇在训练素材中把后台首页复制到项目中\n◇在management包下新增ManagementController类，即后台系统的管理控制器;提供了后台系统的通用功能：默认首页的显示等等；\n## 总结\n### 开发整体思路\n◇基于MVC开发理念：逐级调用方法;\n### 开发注意避坑\n◇注意注解不要写在接口里面；\n◇显示首页logo的时候，我直接把图片命名为logo.png结果前台无法显示，报404错误，然后改为gamest_logo.png后可以显示，猜想可能和一些框架的命名有冲突导致的；\n### 待完善的地方\n◇项目开发的很简陋，还有很多带完善的地方；\n◇用户评论回复功能、用户个人信息查看功能、图书的搜索功能、用户密码修改功能等等；\n\n","tags":["SSM"],"categories":["Spring","SSM开发项目"]},{"title":"项目实现-前台","url":"/p/aeec.html","content":"## 本周学习内容简介\n◇讲解Spring/Spring MVC/Mybatis(SSM)整合配置过程 \n◇讲解MyBatis-Plus敏捷开发插件的用法 \n◇开发javaweb应用\"书评网\"  \n◇由于篇幅有限，项目的全部代码见[gamest-reader](https://github.com/618dt/JavaPractice/tree/main/gamest-reader)\n\n## 主要知识点\n◇SSM整合配置 \n◇Mybatis-Plus配置与应用 \n◇Boostrap UI框架入门 \n◇Kaptcha验证码组件使用 \n◇富文本编辑器wangEditor\n◇Spring Task任务调度  \n## SSM整合的意义\n### 什么是整合 \n◇整合通过Spring IoC容器管理第三方框架对象,让多框架形成整体 \n◇Spring/Spring MVC/MyBatis是业内最主流的框架搭配 \n◇SSM配置与使用是所有Java工程师必须掌握的技能  \n### SSM整合三阶段 \n◇Spring与Spring MVC环境配置 \n◇Spring与MyBatis的整合配置 \n◇整合其他组件:声明式事务/日志/任务调度/...  \n### Spring与Spring MVC环境配置 \n◇依赖spring-webmvc   \n```java\n--pom.xml文件\n<!--Freemarker-->\n<!-- Jackson -->\n```\n◇配置DispatcherServlet              --web.xml文件\n◇启用Spring MVC注解模式        --applicationContext.xml文件\n◇配置请求与响应字符集            --applicationContext.xml文件\n◇配置FreeMarker模板引擎        --applicationContext.xml文件\n◇配置Json序列化组件                --applicationContext.xml文件\n### Spring与MyBatis整合配置 \n◇Spring的整合其核心目的是通过spring去管理其他组件或框架的核心对象，让这些对象之间形成一个整体；\n◇创建数据库gamest_reader\n◇依赖mybatis-spring及驱动     --pom.xml文件         \n◇配置数据源与连接池              --applicationContext.xml文件\n◇配置SqlSessionFactory           --applicationContext.xml文件\n◇配置Mapper扫描器                --applicationContext.xml文件\n◇创建mybatis-config.xml \n### 整合其他组件 \n◇配置logback日志输出 ，新建logback.xml文件，日志组件会自动识别；\n◇声明式事务配置 ;引入依赖spring-jdbc后，事务的依赖spring-tx也会自动被引入，在applicationContext中配置声明式事务\n◇整合junit单元测试  \n## MyBatis-Plus\n### MyBatis-Plus简介\n◇ MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具 \n◇ 自动实现Mapper CRUD操作,极致提高数据库开发效率 \n◇ MP在MyBatis 的基础上只做增强不做改变  \n◇[MyBatis-Plus官网](https://mp.baomidou.com/)\n### MyBatis-Plus整合三部曲 \n◇pom引入mybatis-plus依赖 \n```java\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus</artifactId>\n            <version>3.3.2</version>\n        </dependency>\n```\n◇Spring XML更改配置SqlSessionFactory实现类    \n◇mybatis-config.xml增加MP分页插件(plugin) \n```java\n    <plugins>\n        <!-- 配置MyBatis-Plus分页插件 -->\n        <plugin interceptor=\"com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor\"></plugin>\n    </plugins>\n```\n### MyBatis-Plus开发三部曲 \n◇创建实体类，实体类中的属性需要与数据库中表的字段保持一致,基于@Table/@TableId/@TableField进行与表的自动映射 \n◇创建Mapper接口继承BaseMapper,创建Mapper XML \n◇开发时注入Mapper对象,通过内置API实现CRUD(增删改查)操作 \n### MyBatis-Plus核心注解 \n◇@TableName - 将实体类与表名映射 \n◇@TableId - 说明对应属性是表的主键 ,Tabled(type=IdType.AUTO)，type即设置主键的生成方式，IdType.AUTO表示使用数据库底层的自增主键来完成数据的插入；\n◇@TableField - 设置属性与列名(字段)的对应关系  ，如果字段名与属性名相同或者符合驼峰命名转换规则，则TableField可省略\n### BaseMapper接口核心API  \n◇在所有的Mapper文件中都要实现BaseMapper接口，BaseMapper是由Mybatis-plus提供的核心父接口，在实现的时候需要加入泛型说明定义的实体是哪一个例如BaseMapper&lt;test&gt;；当我们继承自接口以后，实现增删改查直接使用继承的方法就行了，如果需要自定义增删改查方法的话，方法名不应与父接口的方法产生混淆；\n![image.png](书评网-前台/1634779418318-3d3df12d-ee20-4c2f-9f42-ab25df66569f.png)\n\n##  案例分析与数据库建表\n### 案例分析\n![image.png](书评网-前台/1634888234791-174ffddc-68f1-4bd7-9baa-450f8b55e69c.png)\n◇最核心的数据是图书信息，包含了书名、作者、描述等等；\n◇作为网站，也会内置会员部分，也就是用户；而围绕着会员与图书会衍生出两个状态信息：阅读状态和评论；\n\n### 数据库建表\n◇围绕着上面分析的五个数据，可以建立五张表\n◇图书表\n![image.png](书评网-前台/1634889164832-405d915b-9837-4e38-881e-ecacbf54238b.png)\n◇会员表\n![image.png](书评网-前台/1634889215160-169dab43-7425-4f8e-9a6b-7315a9c784a9.png)\n\n◇评价表\n![image.png](书评网-前台/1634889032203-d15faf1f-d68c-4c26-b808-5d873b080bef.png)\n◇阅读状态表\n![image.png](书评网-前台/1634889085837-5794340d-25cd-49fb-90d2-8c20fa67d668.png)\n◇分类表\n![image.png](书评网-前台/1634889137631-3ac9ff3d-2d3a-4d74-a5b2-1a4a3838172c.png)\n◇额外建立一张user表用于后台管理\n![image.png](书评网-前台/1634889260690-4e7ad4df-dd46-47d3-8433-d9f1833f2aa0.png)\n\n## 实现图书列表页面\n◇将训练素材里的三个基础文件目录粘贴到项目的webapp目录下\n◇images包含了前端页面的图片信息\n◇resources包含了一系列js、css组件\n◇upload是文件上传的目录，在程序运行时所有远程上传的图片都会保存于此；\n![image.png](书评网-前台/1634889626531-f9d30ee9-fe34-460f-8233-5f3840e4b782.png)\n◇将素材里的首页.html文件复制到项目的WEB-INF\\ftl路径下，并将文件名改为index.ftl；\n◇前端的UI框架由Bootstrap来实现\n\n### Bootstrap\n◇Bootstrap是全球最受欢迎的前端组件库,由推特(TWitter)开源 \n◇Bootstrap用于开发响应式布局、移动设备优先的WEB项目 \n◇Bootstrap提供完整的HTML、CSS 和 JS 开发工具集  \n◇Boostrap[中文网](https://www.bootcss.com/)\n### 显示图书类别\n◇queryWrapper即条件构造器，按条件对数据库进行查询;\n◇具体步骤为创建类别实体->创建Mapper接口->创建与接口对应的xml->创建service接口->为接口创建实现类（这里要在service包下创建一个子包impl，专门用来存放接口的实现类）impl.CategoryServiceImpl->在该实现类中实现查询方法，并进行事务管理\n◇实现类实现了接口的方法，因此在使用查询数据时，直接给接口注入数据，然后用接口的方法进行查询；\n◇完成上面的实现后就要进入Controller开发环节,创建一个BookController，在这个控制器中完成一系列url与方法的绑定；在该类的showXXX方法是将数据展示到页面，通常返回一个mav来进行数据的传递；因此创建showIndex（）方法来显示图书分类信息；\n◇完成showXXX方法后进入ftl文件中\n\n### 实现图书分页\n◇首先创建图书实体类Book->创建接口->接口对应的xml文件->service接口（图书的分页查询属于业务逻辑类，在service中实现）->生成service的实现类(快捷键：选中类然后Alt+Enter)\n◇基于Mybatis-plus的分页查询：\n核心方法为selectPage()；\n\n```java\npackage com.lcg.reader.service.impl;\nimport *\n@Service(\"bookService\")\n@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)\npublic class BookServiceImpl implements BookService {\n    @Resource\n    private BookMapper bookMapper;\n    public IPage<Book> paging(Integer page, Integer rows) {\n        //分页信息：哪一页，每页的记录数\n        Page<Book> p = new Page<Book>(page, rows);\n        //条件构造器，为空表示没有条件\n        QueryWrapper<Book> queryWrapper = new QueryWrapper<Book>();\n        //参数为分页信息，条件构造器\n        IPage<Book> pageObject =  bookMapper.selectPage(p, queryWrapper);\n        return pageObject;\n    }\n}\n```\n◇其原理为SELECT COUNT(1) FROM book查询出未分页前的所有图书总数，然后根据总数除以每页记录数求出一共有多少页；然后再\nSELECT book_id,book_name,sub_title,author,cover,description,category_id,evaluation_score,evaluation_quantity FROM book LIMIT ?,?  //两个问号分别代表本次查询的其实位置和终止位置\n### Ajax动态加载图书信息\n◇在BookController类中新增图书查询方法selectBook;\n◇修改index.ftl文件进行动态渲染，在其&lt;head&gt;内部增加javascript块&lt;script&gt;用来发送ajax和BookController中的/books进行交互，需要引入jquery；\n◇如何将book中的信息填充到页面中？因为所有的操作都是通过JavaScript来完成的，所以不能够像freemarker一样直接在页面中加入freemarker标签来完成服务器端的渲染；而是需要利用JavaScript动态的将这些分页信息组织成html插入到当前页面中；而html的实现使用拼接字符串来完成；\n◇但是如果页面信息很多的话，通过拼接字符串的方法显然不现实；需要使用js的模板引擎来完成复杂页面的构建工作；\n\n### Art-Template 腾讯JS模板引擎\n◇上述说到，利用字符串拼接来实现html对于复杂页面不太好；那么可以利用JS模板引擎来对复杂的html进行模板化；\n◇官网[http://aui.github.io/art-template/](http://aui.github.io/art-template/)\n◇应用数据的时候{% raw %} {{}} {% endraw %}里的名字要和ajax返回数据的属性名一致\n![image.png](书评网-前台/1635062178732-187705b8-6471-48e5-a44e-7756002d2c69.png)\n◇创建的模板\n```javascript\n<#--定义js模板,type说明script中内容的类型,id设置为tpl-->\n{% raw %}\n    <script type=\"text/html\" id=\"tpl\">\n        <#--看ajax返回数据的时候的属性名和 {{}} 里的一致-->\n        <a href=\"/book/{{bookId}}\" style=\"color: inherit\"><#--每一块超链接都对应了图书的详细信息-->\n            <div class=\"row mt-2 book\">\n                <div class=\"col-4 mb-2 pr-2\">\n                    <#--图书封面-->\n                    <img class=\"img-fluid\" src=\"{{cover}}\">\n                </div>\n                <div class=\"col-8  mb-2 pl-0\">\n                    <h5 class=\"text-truncate\">{{bookName}}</h5><#--图书名称-->\n                    <#--作者-->\n                    <div class=\"mb-2 bg-light small  p-2 w-100 text-truncate\">{{author}}</div>\n\n                    <#--图书子标题-->\n                    <div class=\"mb-2 w-100\">{{subTitle}}</div>\n\n                    <p><#--评分信息-->\n                        <span class=\"stars\" data-score=\"{{evaluationScore}}\" \ttitle=\"gorgeous\"><img alt=\"1\" src=\"./resources/raty/lib/images/star-on.png\" title=\"gorgeous\">&nbsp;<img alt=\"2\" src=\"./resources/raty/lib/images/star-on.png\" title=\"gorgeous\">&nbsp;<img alt=\"3\" src=\"./resources/raty/lib/images/star-on.png\" title=\"gorgeous\">&nbsp;<img alt=\"4\" src=\"./resources/raty/lib/images/star-on.png\" title=\"gorgeous\">&nbsp;<img alt=\"5\" src=\"./resources/raty/lib/images/star-on.png\" title=\"gorgeous\"><input name=\"score\" type=\"hidden\" value=\"{{evaluationScore}}\" readonly=\"\"></span>\n                        <span class=\"mt-2 ml-2\">{{evaluationScore}}</span>\n                        <span class=\"mt-2 ml-2\">{{evaluationQuantity}}人已评</span>\n                    </p>\n                </div>\n            </div>\n        </a>\n    </script>\n{% endraw %}\n```\n### 实现发评分插件\n◇Jquery评分插件[raty](https://www.jq22.com/jquery-info6430)\n◇引用raty的css和js\n```java\n<link rel=\"stylesheet\" href=\"./resources/raty/lib/jquery.raty.css\">\n<script src=\"./resources/raty/lib/jquery.raty.js\"></script>\n```\n◇将评价部分的静态部分星星图片删除，即删除&lt;img&gt;标签\n### 实现加载更多\n◇点击加载更多时显示下一页的数据；则要设置一个数据域：nextpage用于保存下一页的页号是多少；\n◇在javascript块中新增点击事件；\n```java\n/*定义一个加载更多函数 标志位isReset表示重置*/\n{% raw %}\n        function loadMore(isReset) {\n            if (isReset == true) {\n                $(\"#nextPage\").val = 1;\n            }\n            var nextPage = $(\"#nextPage\").val();\n            $.ajax({\n                url : \"/books\",\n                data : {p:nextPage},\n                type : \"get\",\n                dataType : \"json\",\n                success: function (json) {\n                    console.info(json);\n                    var list = json.records;\n                    for (var i = 0; i < list.length; i++) {\n                        var book = json.records[i];\n                        var html = template(\"tpl\", book);\n                        $(\"#bookList\").append(html);\n                    }\n                    $(\".stars\").raty({readOnly:true});\n                    /*如果当前页小于总页数,则显示点击更多按钮*/\n                    if(json.current < json.pages){\n                        $(\"#nextPage\").val(parseInt(json.current) + 1);\n                        $(\"#btnMore\").show();//显示组件\n                        $(\"#divNoMore\").hide();//隐藏组件\n                    }else{\n                        $(\"#btnMore\").hide();//显示组件\n                        $(\"#divNoMore\").show();//隐藏组件\n                    }\n                }\n            })\n        }\n\n//绑定加载更多按钮单击事件\n        $(function () {\n            $(\"#btnMore\").click(function () {\n                loadMore();\n            });\n        });\n{% endraw %}\n```\n### 多条件分页查询\n◇实现的第一个步骤：当我吗点击查询条件的连接后需要将其高亮显示；第二，在点击之后根据所选的条件在后台进行动态查询；\n◇在按钮单击事件中对category进行捕获然后设置单击事件；\n```java\n/*.category是进行类选择*/\n            $(\".category\").click(function () {\n                $(\".category\").removeClass(\"highlight\");//移除原先所拥有的高亮css\n                $(\".category\").addClass(\"text-black-50\");//设置为灰色\n                $(this).addClass(\"highlight\");//设置当前点击的为高亮\n            });\n```\n◇修改service进行数据联动，在paging方法中增加两个参数categoryId, order;然后在其实现类中进行条件的判断；\n```java\npublic IPage<Book> paging(Long categoryId,String order,Integer page, Integer rows) {\n        //分页信息：哪一页，每页的记录数\n        Page<Book> p = new Page<Book>(page, rows);\n        //条件构造器，为空表示没有条件\n        QueryWrapper<Book> queryWrapper = new QueryWrapper<Book>();\n        if (categoryId != null && categoryId != -1) {\n            //设置条件为分类的id ,查询等于指定字段的数据\n            queryWrapper.eq(\"category_id\", categoryId);\n        }\n        if (order != null) {\n            if (order.equals(\"quantity\")) {\n                //设置条件按照指定的字段进行降序排序\n                queryWrapper.orderByDesc(\"evaluation_quantity\");\n            } else if (order.equals(\"score\")) {\n                queryWrapper.orderByDesc(\"evaluation_score\");\n            }\n        }\n        //参数为分页信息，条件构造器\n        IPage<Book> pageObject =  bookMapper.selectPage(p, queryWrapper);\n        return pageObject;\n    }\n```\n◇然后在controller调用paging方法处进行修改，增加两个参数\n```java\n@GetMapping(\"/books\")\n    @ResponseBody\n    public IPage<Book> selectBook(Long categoryId,String order,Integer p) {\n        if (p == null) {\n            p=1;\n        }\n        IPage<Book> iPage = bookService.paging(categoryId,order,p,5);//默认每页显示5条数据\n        return iPage;\n    }\n```\n◇以上方法设置完后，需要把前台的分类和排序数据传到控制器中；即在index.ftl中进行设置，点击不同的超链接或者span后，给对应的[隐藏域](https://www.w3school.com.cn/jsref/dom_obj_hidden.asp)进行赋值；其中使用到了[自定义属性，data-*](https://www.w3school.com.cn/tags/att_global_data.asp) ；\n◇最后进行数据的查询，需要修改发送请求的方法（在loadMore中），在发送请求的数据data中附加分类和排序信息，在点击选择类别、排序规则的点击事件中增加loadMore方法，并将是否重置设置为true，因为每一次点击选择类别或排序方法的时候就相当于重新进行查询，那自然是重第一页进行的；\n## 图书详情页\n### 实现主页面\n◇在训练素材中将详情页复制到项目中，并改为detail.ftl；\n◇在BookService接口中开发新的查询方法，根据图书编号查询图书对象；并完成其实现类；在本项目中使用面向接口编程的思想，所以每一个service都有接口及其实现类；\n◇接下来实现controller，在controller中根据index.ftl提供的url(book/id)进行相应的绑定；\n```java\n{% raw %}\n@GetMapping(\"/book/{id}\")//路径变量用{}包裹\n    public ModelAndView showDetail(@PathVariable(\"id\")Long id) {\n        Book book = bookService.selectById(id);\n        ModelAndView mav = new ModelAndView(\"/detail\");\n        mav.addObject(\"book\", book);\n        return mav;\n    }\n{% endraw %}\n```\n◇当我们运行后，会发现js、css等未加载；F12查看NetWork选择all，会发现有css、js的请求为404；点击查看发现路径是localhost/book/resources/bootstrap/bootstrap.css，这是因为我们使用了相对路径，而相对路径是基于目前我们url所在的路径(localhost/book)之后进行附加；所以我们访问的资源错误，则应该改为绝对路径来开发(在这里去掉 . 即可)\n### 实现评论列表\n◇首先创建评论的实体类Evaluation；\n◇创建EvaluationMapper；\n◇创建evaluation.xml\n◇创建EvaluationService，并完成其实现类；\n◇进入BookController中修改showDetail方法，使其得到evaluationList对象，并添加到mav中\n◇在detail.ftl中对evaluationList进行遍历显示；\n◇由于评论列表需要显示用户名，所以需要增加用户的实现类以及Mapper等等；然后在Evaluation实体类中增加关联对象\n```java\n//设置关联对象\n    @TableField(exist = false)//说明book属性在数据库表中没有对应的字段,不会参与到sql自动生成\n    private Book book;\n    @TableField(exist = false)\n    private Member member;\n```\n◇在EvaluationService接口的实现类中进行获取每一条评论的用户信息的实现；\n```java\npublic List<Evaluation> selectByBookId(Long bookId) {\n        //获取图书对象\n        Book book = bookMapper.selectById(bookId);\n        QueryWrapper<Evaluation> queryWrapper = new QueryWrapper<Evaluation>();\n        queryWrapper.eq(\"book_id\", bookId);\n        queryWrapper.eq(\"state\", \"enable\");\n        queryWrapper.orderByDesc(\"create_time\");\n        List<Evaluation> evaluationList = evaluationMapper.selectList(queryWrapper);\n        for (Evaluation eva : evaluationList) {\n            /*遍历每一个评论列表，然后根据评论列表的memberId在数据库中查询member对象\n            * 再把查到的对象赋值给Evaluation类里面关联的对象Member*/\n            Member member = (Member) memberMapper.selectById(eva.getMemberId());\n            eva.setMember(member);\n            eva.setBook(book);\n        }\n        return evaluationList;\n    }\n```\n◇获取每一条评论的图书信息和获取用户信息类似，只不过每一个图书下面有许多评论，而每一条评论和其评论者是一 一对应的；因此图书对象的获取放在循环外面；\n## 开发验证码功能\n### Kaptcha验证码组件\n◇Kaptcha是谷歌开源的可高度配置的实用验证码生成工具\n◇通过Kaptcha可阻拦大多数机器人脚本操作\n◇Kaptcha典型应用于注册、登录、重要信息提交等用户交互\n### Kaptcha使用步骤 \n◇Kaptcha配置验证码生成参数 \n◇开发KapatchaController生成验证码图片 \n◇将前台输入验证码与session保存的验证码进行比对  \n### Kaptcha的配置及使用\n◇pom.xml加载依赖\n```xml\n        <!-- Kaptcha验证码组件 -->\n        <dependency>\n            <groupId>com.github.penggle</groupId>\n            <artifactId>kaptcha</artifactId>\n            <version>2.3.2</version>\n        </dependency>\n```\n◇applicationContext.xml进行配置\n```xml\n    <!-- 配置Kaptcha -->\n    <bean id=\"kaptchaProducer\" class=\"com.google.code.kaptcha.impl.DefaultKaptcha\">\n        <property name=\"config\">\n            <bean class=\"com.google.code.kaptcha.util.Config\"><!--该bean不需要id，只需要指明类-->\n                <constructor-arg><!--构造参数-->\n                    <props>\n                        <!--验证码图片不生成边框-->\n                        <prop key=\"kaptcha.border\">no</prop>\n                        <!-- 验证码图片宽度为120像素 -->\n                        <prop key=\"kaptcha.image.width\">120</prop>\n                        <!-- 验证码图片字体颜色为蓝色 -->\n                        <prop key=\"kaptcha.textproducer.font.color\">blue</prop>\n                        <!-- 每个字符最大占用40像素 -->\n                        <prop key=\"kaptcha.textproducer.font.size\">40</prop>\n                        <!-- 验证码包含4个字符 -->\n                        <prop key=\"kaptcha.textproducer.char.length\">4</prop>\n                    </props>\n                </constructor-arg>\n            </bean>\n        </property>\n    </bean>\n```\n◇创建新的控制器KaptchaController\n```java\npublic class KaptchaController {\n    /*引用Producer接口*/\n    @Resource\n    private Producer kaptchaProducer;//这里的属性名需要和配置的beanId一致;\n    /*参数为原生的http请求和响应对象\n    * 这样书写，把原生的对象放在参数列表中，则会在运行时由springIOC容器将当前的请求与\n    * 响应对象动态的注入到对应的参数中*/\n    @GetMapping(\"/verify_code\")\n    public void createVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        //设置响应过期时间,0为立即过期\n        response.setDateHeader(\"Expires\",0);\n        /*设置缓存控制;因为每一次要求生成的验证码都是全新的；所以需要把浏览器的缓存都进行清空\n        *no-store不存储  no-cache不缓存 must-revalidate必须重新校验*/\n        response.setHeader(\"Cache-Control\", \"no-store,no-cache,must-revalidate\");\n        //处于兼容性考虑，平时一般用不到\n        response.setHeader(\"Cache-Control\",\"post-check=0,pre-check=0\");\n        response.setHeader(\"Pragma\",\"no-cache\");//以上三行都是设置浏览器不缓存任何图片数据\n        response.setContentType(\"image/png\");//返回类型为图片\n        //生成验证码字符文本\n        String verifyCode = kaptchaProducer.createText();\n        //将验证码放到会话(Session)中\n        request.getSession().setAttribute(\"kaptchaVerifyCode\",verifyCode);\n        System.out.println(\"验证码为：\" + request.getSession().getAttribute(\"kaptchaVerifyCode\"));\n        //创建验证码图片,返回为二进制的图片\n        BufferedImage image = kaptchaProducer.createImage(verifyCode);\n        /*用getOutputStream方法向浏览器输出二进制文件(如图片等)*/\n        ServletOutputStream out = response.getOutputStream();\n        //将图片以png形式写入out输出流中\n        ImageIO.write(image, \"png\", out);\n        out.flush();//立即输出\n        out.close();//关闭输出流\n    }\n}\n```\n## 实现用户注册功能\n◇将训练素材的注册页复制到项目中并改名为register.ftl；\n◇创建用户控制器类\n```java\n@Controller\npublic class MemberController {\n    @GetMapping(\"/register.html\")/*这里的后缀可写可不写*/\n    public ModelAndView showRegister() {\n        //没有数据传到前台，因此直接return\n        return new ModelAndView(\"/register\");\n    }\n}\n```\n◇实现点击验证码图片刷新功能\n```java\n\t//重新发送请求,刷新验证码\n    function reloadVerifyCode(){\n        //attr设置组件属性（属性名，属性值）\n        /*ts代表timestamp(时间戳),get请求容易被浏览器缓存起来,所以有可能\n        * 点击图片后尽管执行了代码但图片还是原来的，则增加时间戳使每次get请求的url不一样*/\n        $(\"#imgVerifyCode\").attr(\"src\", \"/verify_code?ts=\" + new Date().getTime());\n    }\n\t\n\t//点击事件，点击验证码图片刷新验证码\n    $(\"#imgVerifyCode\").click(function () {\n        reloadVerifyCode();\n    });\n```\n### 验证码校验\n◇在register页面中发送ajax请求\n◇在Member控制器中进行接收\n```java\n/*因为无论哪一个web应用框架都是基于底层的Servlet进行实现，所以这里我们\n    * 可以直接将原生的HttpServletRequest对象写入参数中进行使用*/\n    @PostMapping(\"/register\")//ajax采用post方式提交的\n    @ResponseBody //直接进行序列化的响应返回\n    public Map register(String vc, String username, String password, String nickname, HttpServletRequest request) {\n       //获取当前会话中的kaptchaVerifyCode属性的值(即验证码)\n        String verifyCode = (String) request.getSession().getAttribute(\"kaptchaVerifyCode\");\n        /*验证码校验,返回result Map对象*/\n        Map result = new HashMap();\n        //没有写入验证码||后台没有产生验证码||忽略大小写比对验证码\n        if (vc == null||verifyCode == null||vc.equalsIgnoreCase(verifyCode)) {\n            result.put(\"code\",\"VC01\");\n            result.put(\"msg\", \"验证码错误\");\n        }else{\n            result.put(\"code\",\"0\");\n            result.put(\"msg\", \"success\");\n        }\n        return result;\n    }\n```\n### 实现业务逻辑\n◇新增MemberService接口，定义createMember()方法用于创建新的用户；完成其实现类，在实现类中注入mapper用于查询；\n◇在service下创建子包exception然后新增一个异常类BussinessException，用来处理我们注册登录等相关异常;\n◇在pom.xml中增加加密/解密组件，用来对密码进行加密;创建utils工具包，在其下创建MD5Utils类；\n```java\npublic class MD5Utils {\n    public static String md5Digest(String source, Integer salt) {\n        char[] ca = source.toCharArray();//获取到字符数组\n        for (int i = 0; i < ca.length; i++) {\n            ca[i] = (char) (ca[i] + salt);//对原始字符串的每一位字符加盐混淆\n        }\n        String target = new String(ca);//再将字符数组转换为原始字符串\n        String md5 = DigestUtils.md5Hex(target);//MD5摘要\n        return md5;\n    }\n}\n```\n◇用户注册底层逻辑\n```java\n/**\n     * 会员注册,创建新的会员\n     *\n     * @param username 用户名\n     * @param password 密码\n     * @param nickname 昵称\n     * @return 新的会员对象\n     */\n    public Member createMember(String username, String password, String nickname) {\n        QueryWrapper<Member> queryWrapper = new QueryWrapper<Member>();\n        queryWrapper.eq(\"username\", username);\n        List<Member> memberList = memberMapper.selectList(queryWrapper);\n        //判断用户名是否已存在\n        if (memberList.size()>0) {\n            //抛出我们自定义的异常\n            throw new BussinessException(\"M01\", \"用户名已存在\");\n        }\n        Member member = new Member();\n        member.setUsername(username);\n        member.setNickname(nickname);\n        //生成小于1000的随机数加上1000相当于随机的4位数用来当作盐值；\n        int salt = new Random().nextInt(1000) + 1000;\n        String md5 = MD5Utils.md5Digest(password, salt);\n        member.setSalt(salt);\n        member.setPassword(md5);\n        member.setCreateTime(new Date());\n        memberMapper.insert(member);\n        return member;\n    }\n```\n◇在MemberController中注入memberService进行用户注册功能的完善；\n```java\n@Controller\npublic class MemberController {\n    @Resource\n    private MemberService memberService;\n\n    @GetMapping(\"/register.html\")/*这里的后缀可写可不写*/\n    public ModelAndView showRegister() {\n        return new ModelAndView(\"/register\");\n    }\n\n    /*因为无论哪一个web应用框架都是基于底层的Servlet进行实现，所以这里我们\n    * 可以直接将原生的HttpServletRequest对象写入参数中进行使用\n    在register方法中的参数必须和前台的一致，这样才能将前台的数据传递到方法的参数中；\n    */\n    @PostMapping(\"/register\")//ajax采用post方式提交的\n    @ResponseBody //直接进行序列化的响应返回\n    public Map register(String vc, String username, String password, String nickname, HttpServletRequest request) {\n       //获取当前会话中的kaptchaVerifyCode属性的值(即验证码)\n        String verifyCode = (String) request.getSession().getAttribute(\"kaptchaVerifyCode\");\n        /*验证码校验,返回result Map对象*/\n        Map result = new HashMap();\n        //没有写入验证码||后台没有产生验证码||忽略大小写比对验证码\n        if (vc == null||verifyCode == null||vc.equalsIgnoreCase(verifyCode)) {\n            result.put(\"code\",\"VC01\");\n            result.put(\"msg\", \"验证码错误\");\n        }else{\n            try {\n                //创建用户\n                memberService.createMember(username, password, nickname);\n                result.put(\"code\", \"0\");\n                result.put(\"msg\", \"success\");\n            } catch (BussinessException e) {\n                e.printStackTrace();\n                result.put(\"code\", e.getCode());\n                result.put(\"msg\", e.getMsg());\n            }\n        }\n        return result;\n    }\n}\n```\n## 实现用户登录\n◇加载登录页.html改为login.ftl\n◇在MemberService中增加检查登录的方法checkLogin(返回对象为Member):根据前台传来的用户名拿到整个用户对象，然后根据对象里的salt值和前台传来的密码进行MD5摘要，比对生成的md5字符串是否和对象里的密码一致；\n◇service里的业务逻辑代码写好后需要在控制器中进行调用;在控制器中创建方法checkLogin,返回对象为Map，因为需要与前台交互；\n```java\n/*这里采用session,session比request的范围更广,用来保存页面的用户信息*/\n    @ResponseBody\n    @PostMapping(\"/login\")\n    public Map checkLogin(String username, String password, String vc, HttpSession session) {\n        String verifyCode = (String) session.getAttribute(\"kaptchaVerifyCode\");\n        Map result = new HashMap();\n        if (vc == null||verifyCode == null||vc.equalsIgnoreCase(verifyCode)) {\n            result.put(\"code\",\"VC01\");\n            result.put(\"msg\", \"验证码错误\");\n        }else{\n            try {\n                //先进行验证码的比对，然后校验登录的用户信息，信息不正确的话会自动抛出异常\n                Member member = memberService.checkLogin(username, password);\n                //保存登录用户的信息，在首页中进行展现\n                session.setAttribute(\"loginMember\", member);\n                result.put(\"code\", \"0\");\n                result.put(\"msg\", \"success\");\n            } catch (BussinessException e) {\n                e.printStackTrace();\n                result.put(\"code\", e.getCode());\n                result.put(\"msg\", e.getMsg());\n            } finally {\n            }\n        }\n        return result;\n    }\n```\n◇如果发现if语句没有执行,一定要仔细检查条件是否正确；\n## 用户交互功能\n### 阅读状态变更\n◇阅读状态的变更只能选择想看和看过其一；\n◇为阅读状态创建实体类MemberReadState;然后创建相关的Mapper接口及xml；\n◇在MemberService接口中实现用户的交互功能，新增方法selectMemberReadState()，用来查询传入的两个参数用户与图书是否有阅读状态；\n◇查询阅读状态方法执行的时机: 当我们跳转到图书详情页面时；因此修改BookController.showDetail（）方法，增加session参数用来获取当前用户的信息；\n```java\n@GetMapping(\"/book/{bid}\")//路径变量用{}包裹,即将index中book/后的bookId定义为id;\n    public ModelAndView showDetail(@PathVariable(\"bid\")Long id, HttpSession session) {\n        Member member = (Member) session.getAttribute(\"loginMember\");\n        ModelAndView mav = new ModelAndView(\"/detail\");\n        if (member != null) {\n            //获取会员阅读状态\n            MemberReadState memberReadState = memberService.selectMemberReadState(member.getMemberId(), id);\n            mav.addObject(\"memberReadState\", memberReadState);\n        }\n        Book book = bookService.selectById(id);\n        List<Evaluation> evaluationList = evaluationService.selectByBookId(id);\n        mav.addObject(\"book\", book);\n        mav.addObject(\"evaluationList\", evaluationList);\n        return mav;\n    }\n```\n◇由于用户的阅读状态很有可能为空，所以我们要在detail详情页面的script块中增加javascript语句进行相应的判断;\n```java\n/*页面就绪函数，书写freemarker的脚本*/\n        $(function () {\n            <#if memberReadState ??>//存在阅读状态\n            /*利用JavaScript的属性选择器，‘*’表示所有名为data-read-state且值为''的属性\n            * 并将该属性设置为高亮，那么就可以将对应的想看或者看过的按钮设置为高亮显示了\n            * 这里的值是后台通过mav传过来的*/\n            $(\"*[data-read-state='${memberReadState.readState}']\").addClass(\"highlight\");\n            </#if>\n        });\n```\n◇更新会员阅读状态，即点击相应的按钮实现交互功能；\n◇首先需要在detail页面中进行用户是否登录的判断,只有用户登录了才能进行相应的交互；在刚才的页面就绪函数中添加判断语句；\n```java\n            <#if !loginMember ??>/*如果用户没有登录*/\n            /*选择拥有data-read-state这个自定义属性的标签，而不管自定义属性的值是多少*/\n            $(\"*[data-read-state]\").click(function () {\n                /*通过id选择bootstrap的对话框,然后根据其对话框函数执行show(显示)动作*/\n                $(\"#exampleModalCenter\").modal(\"show\");\n            })\n            //将写短评以及点赞等功能进行相应的登录控制,这里利用组合选择减少代码\n            $(\"#btnEvaluation,*[data-evaluation-id]\").click(function () {\n                $(\"#exampleModalCenter\").modal(\"show\");\n            })\n            </#if>\n```\n◇在MemberService中新增方法写入阅读状态;\n◇在控制器中进行调用并与前台交互；\n```java\n    @PostMapping(\"/update_read_state\")\n    @ResponseBody\n    public Map updateReadState(Long memberId, Long bookId, Integer readState) {\n        Map result = new HashMap();\n        try {\n            memberService.updateMemberReadState(memberId, bookId, readState);\n            result.put(\"code\", \"0\");\n            result.put(\"msg\", \"success\");\n        } catch (BussinessException e) {\n            e.printStackTrace();\n            result.put(\"code\", e.getCode());\n            result.put(\"msg\", e.getMsg());\n        }\n        return result;\n    }\n```\n◇在页面中发送ajax进行处理；\n```java\n            <#if loginMember ??>\n            $(\"*[data-read-state]\").click(function () {\n                var readState = $(this).data(\"read-state\");//获取当前点击按钮的自定义属性的值；\n                /*ajax方法的简化形式四个参数为\n                (发送的地址，发送的参数列表,处理函数（用来处理服务器返回的数据）,服务器返回的数据类型)*/\n                $.post(\"/update_read_state\",{\n                    memberId:${loginMember.memberId},\n                    bookId:${book.bookId},\n                    readState:readState\n                },function (json){\n                    if (json.code == \"0\") {\n                        //将原有高亮的css全部清除，让两个按钮回到默认的状态\n                        $(\"*[data-read-state]\").removeClass(\"highlight\");\n                        /*通过拼接字符串的方式选择刚才点击的那个按钮*/\n                        $(\"*[data-read-state='\" + readState + \"']\").addClass(\"highlight\");\n                    }\n                },\"json\")\n                \n                \n                //ajax一般写法\n                $.ajax({\n                    url:\"/update_read_state\",\n                    data:{memberId:${loginMember.memberId},bookId:${book.bookId},readState:readState},\n                    type:\"post\",\n                    dataType:\"json\",\n                    success: function (json) {\n                        if (json.code == \"0\") {\n                            //将原有高亮的css全部清除，让两个按钮回到默认的状态\n                            $(\"*[data-read-state]\").removeClass(\"highlight\");\n                            /*通过拼接字符串的方式选择刚才点击的那个按钮*/\n                            $(\"*[data-read-state='\" + readState + \"']\").addClass(\"highlight\");\n                        }\n                    }\n                })\n            });\n            </#if>\n```\n◇一点小坑\n这里的一个小坑，由于忘记设置了主键注解，导致后面在更新阅读状态的时候发现只有没有任何阅读状态的时候\n* 点击阅读状态会生效；但当切换阅读状态的时候发现请求报500错误，一开始以为是前台的问题，但想着增加阅读状态没问题\n* 只有修改阅读状态才有问题，以为是后台修改语句的问题，所以检查了后台的业务逻辑，却发现修改语句没有问题，然后慢慢的\n* 查看日志发现updateById的sql语句是where null = ?才发现可能是忘记了实体类中主键的设置\n![image.png](书评网-前台/1635326132436-25eb54ae-f219-4c7f-b305-e200ea9931b9.png)\n### 图书写短评\n◇点击事件弹出写短评的对话框，并加载评分组件；点击提交按钮后边向后台发送数据；\n◇memberService中新增写短评的方法，并完成其实现类，在controller中进行调用与前台交互\n◇图书短评的回复功能暂时不开发；\n\n### 短评点赞\n◇短评功能只显示短评获得的点赞数量;\n◇在MemberService中进行短评点赞功能，新增方法enjoy();\n◇这里发现的一个新bug：就是自己新写的短评然后进行点赞会报错，查看DEBUG:value of type 'java.lang.String' to required type 'java.lang.Long';说明我们写评论的时候，id值太大了导致系统认为应该是一个字符串而不是Long，这里的原因是使用mybatis-plus增加评论时，ID直接从2000多开始；解决方法是把数据库表删除，然后将主键的自动增长取消，保存；然后设置主键自动增长，保存；最后在前台写入评论，在数据库表中发现id从1开始了（非常玄学）;\n\n## Spring-Task定时任务\n## 介绍\n◇Spring Task是Spring 3.0后推出的定时任务模块\n◇Spring Task的职责是按周期后台自动执行任务\n◇Spring Task可利用Cron表达式实现灵活的定时处理\n### Cron表达式实例\n![image.png](书评网-前台/1635496332290-5fb87671-f60c-418e-ad8e-5fc64d31a1c1.png)\n◇本质是七位的字符串，分别对应秒分...年；\n◇在大多数情况下只需要前六位就可以了\n◇ 0代表具体的数字，放在秒这个位置上即表示时间是0秒的时候对应的任务自动执行，*代表任意的时间点；关于具体的日期和星期是互斥的，二者选其一，忽略的用?，则第一行的六位表达式(省略了年)具体含义为任一年，任一月、日、时、分的0秒；\n◇0-5表示每小时的前5分钟， 0,30表示第0秒和第30秒；\n\n### 子查询\n◇ifnull表示为空时设置默认值(此处设置为0)\n```sql\nupdate book b SET evaluation_score = (\n   select ifnull(avg(score),0) from evaluation where book_id = b.book_id and state=\"enable\"\n),evaluation_quantity=(\n   select ifnull(count(*),0) from evaluation where book_id = b.book_id and state=\"enable\"\n)\n```\n◇现在我们来完成自动执行上面的sql语句；\n◇mybatis-plus对于简单的sql语句可以直接继承父类，但是对于上面这种复杂的sql语句还是的在mapper中的xml文件里定义；如：\n```sql\n<!--如果命名空间里的接口中没有方法定义，则mapper标签下也无子标签-->\n<mapper namespace=\"com.lcg.reader.mapper.BookMapper\">\n    <update id=\"updateEvaluation\">\n        update book b SET evaluation_score = (\n   select ifnull(avg(score),0) from evaluation where book_id = b.book_id and state=\"enable\"\n),evaluation_quantity=(\n   select ifnull(count(*),0) from evaluation where book_id = b.book_id and state=\"enable\"\n)\n    </update>\n</mapper>\n```\n◇然后在接口中进行定义\n```java\npublic interface BookMapper extends BaseMapper<Book> {\n    /**\n     * 更新图书评分、评价数量\n     */\n    public void updateEvaluation();\n\n}\n```\n◇然后在service接口中增加方法\n```java\n public void updateEvaluation();\n```\n◇在接口实现类中具体实现\n```java\n    /*既然只是调用bookMapper提供的方法，为什么不直接在前台调用呢？\n    * 这是因为我们基于MVC的按层逐级调用，禁止从controller直接调用mapper的方法来\n    * 进行与数据库的操作,中间必须经过service；遵循这样的开发规范，会使程序维护更加轻松*/\n@Transactional\npublic void updateEvaluation() {\n        bookMapper.updateEvaluation();\n    }\n```\n◇那么下面如何让updateEvaluation()方法每分钟调用一次呢？那就需要使用spring-Task模块了，该模块包含在spring-context中 在前面我们已经加载了，所以不需要额外引入jar包；\n◇在applicationContext.xml文件中开启定时任务的注解模式;\n```java\n    <!-- 开启Spring Task定时任务的注解模式-->\n    <task:annotation-driven/>\n```\n◇在reader下创建一个子包：task(任务)，创建一个类ComputeTask(计算任务)\n```java\npackage com.lcg.reader.task;\n\nimport com.lcg.reader.service.BookService;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\n\n/**\n * 完成自动计算任务\n */\n@Component //组件注解，当一个类不好确定是service还是controller时增加该注解让spring进行管理\npublic class ComputeTask {\n    @Resource\n    private BookService bookService;\n    //任务调度,每分钟0秒的时候执行一次\n    @Scheduled(cron=\"0 * * * * ?\")\n    public void updateEvaluation() {\n        bookService.updateEvaluation();\n        System.out.println(\"已更新所有图书评分\");\n    }\n}\n```\n\n\n\n","tags":["SSM"],"categories":["Spring","SSM开发项目"]},{"title":"SpringMVC拦截器","url":"/p/b7ed.html","content":"## 拦截器-Interceptor\n◇拦截器(Interceptor)用于对URL请求进行前置/后置过滤 \n◇Interceptor与Filter用途相似,但实现方式不同 \n◇Interceptor底层就是基于Spring AOP面向切面编程实现  \n## HandlerInterceptor接口 \n◇preHandle - 前置执行处理 ；即一个请求产生以后，还没有进controller之前先要执行preHandle，对这个请求进行预制处理\n◇postHandle - 目标资源已被Spring MVC框架处理 ；即内部方法return之后，但是并没有产生响应文本之前执行\n◇afterCompletion - 响应文本已经产生；即响应文本产生之后执行，例如如果我们返回的是对象时，当对象进行JSON序列化以后就代表响应文本已经产生；\n## 拦截器开发流程 \n◇项目见interceptor\n### Maven依赖servlet-api \n◇在pom.xml中增加依赖\n```xml\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n            <!--作为我们Tomcat的最终运行环境，它是自带servlet-api这个jar包的\n            如果在我们进行打包发布的时候，将当前的依赖也放在war包中，会与Tomcat的\n            jar包造成冲突；因此需要scope设置范围provided,表示只有在开发、编译时\n            才会引用;当进行打包、最终使用的时候这个jar会被排除在外;-->\n            <scope>provided</scope>\n        </dependency>\n```\n### 实现HandlerInterceptor接口 \n◇新增interceptor包，其下开发的都是拦截器类；创建一个java类MyInterceptor\n```java\n/*该类需要实现HandlerInterceptor接口的三个方法\n* 选择接口->Code->Implement Methods->全选方法->OK*/\npublic class MyInterceptor implements HandlerInterceptor {\n    /*如果返回为true，就将请求送达给后面的拦截器或者控制器；返回false，则当前的请求会被阻止直接\n    * 产生响应返回客户端;*/\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(request.getRequestURL()+\"准备执行\");\n        return true;\n    }\n\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        System.out.println(request.getRequestURL()+\"目标处理成功\");\n    }\n\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println(request.getRequestURL()+\"响应内容已产生\");\n    }\n}\n```\n### applicationContext配置过滤地址 \n◇进行配置\n```xml\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/**\"/><!--配置要对哪些路径进行拦截，/**表示所有路径-->\n            <!--指明哪个类对拦截的URL进行处理-->\n            <bean class=\"com.lcg.restful.interceptor.MyInterceptor\"/>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n◇运行结果 浏览器输入http://localhost:8080/restful/persons\n```java\nhttp://localhost:8080/restful/persons准备执行\nRestfulController.findPersons() - return list\nhttp://localhost:8080/restful/persons目标处理成功\nhttp://localhost:8080/restful/persons响应内容已产生\n```\n## 拦截器使用细则\n◇当我们输入http://localhost:8080/client.html地址后，查看后台会发现除了client的信息还有其他地址的信息；\n这是因为作为原始的client.html在这里每一次发送localhost这个url的时候其本质都是通过Tomcat调用springmvc的解析功能来获取对应的资源，因为这些资源都符合\"/**\"的规则而被拦截；作为拦截器，不受_<!--default-servlet-handler将静态资源排除过滤-->_<**mvc:default-servlet-handler**/>这个配置的控制；如果希望这些静态资源不受拦截器所拦截，需要额外的设置标签；<**mvc:exclude-mapping path=\"/**.ico\"**/>_<!--如果遇到了ico为后缀的则排除拦截-->_；\n```java\n            <!--排除一系列静态资源-->\n            <mvc:exclude-mapping path=\"/**.ico\"/>\n            <mvc:exclude-mapping path=\"/**.jpg\"/>\n            <mvc:exclude-mapping path=\"/**.js\"/>\n            <mvc:exclude-mapping path=\"/**.css\"/>\n```\n◇由于今天资源有许多，如果都用exclude-mapping的配置方式会显得过于麻烦；其实在大多数时候我们的静态资源并不是直接存放在我们webapp的根路径上，而是在webapp目录下创建额外的目录如resources(资源)，并且在该资源目录下创建js、css、image等静态资源按目录进行保存；那么这样的话我们可以直接配置<**mvc:exclude-mapping path=\"/resoutces/**\"**/>就能够将所有静态资源进行排除；\n◇如果一个请求被多个拦截器拦截的话，会按照什么顺序呢？我们再增加一个拦截器，interceptor-1，并且进行配置，配置方法和第一个拦截器一样；\n当我们运行后，结果如下\n```java\nhttp://localhost:8080/restful/persons准备执行\nhttp://localhost:8080/restful/persons准备执行-1\nRestfulController.findPersons() - return list\nhttp://localhost:8080/restful/persons目标处理成功-1\nhttp://localhost:8080/restful/persons目标处理成功\nhttp://localhost:8080/restful/persons响应内容已产生-1\nhttp://localhost:8080/restful/persons响应内容已产生\n```\n◇可以发现，准备执行时顺序按照我们的配置顺序执行，而后面却反了过来；通过图示我们来进行说明；\n◇多Interceptor执行顺序  ，其中前置请求就是preHandle\n![image.png](SpringMVC拦截器/1634461611607-3921b40f-9fe2-48b9-b353-ad2d2833d2d8.png)\n\n##  开发\"用户流量\"拦截器\n◇所谓用户流量就是在用户访问我们应用时自动的收集一些底层信息:如访问的时间、网址，用户使用的浏览器、系统、ip等；\n◇我们在前面的项目interceptor中进行开发；在拦截器包中新建一个拦截器类 访问历史拦截器AccessHistoryInterceptor；在所有请求在被处理之前要被该拦截器所记录，所以该拦截器为前置处理；所以实现preHandle方法，又因为不涉及到任何请求阻断，所以直接return true；通常拦截器所记录的数据我们用日志文件进行保存；\n◇引入依赖\n\n```java\n        <!--引入日志依赖-->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n```\n◇配置日志文件，新增logback.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration><!--根节点-->\n    <!--定义一个向控制台书写日志的追加器appender-->\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder><!--输出日志的格式-->\n            <!--定义格式:线程名 产生日志时间 日志级别 产生日志的类{包名长度限制}-->\n            <pattern>[%thread] %d %level %logger{10} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    \n    <!--RollingFileAppender表示生成按天滚动的日志,该输出器向文件中进行写入，以天为单位；\n    -->\n    <appender name=\"accessHistoryLog\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <!--rollingPolicy表示滚动策略,TimeBasedRollingPolicy表示按照时间进行滚动-->\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <!--日志文件的保存路径 %d表示产生日期-->\n            <fileNamePattern>G:/logs/history.%d.log</fileNamePattern>\n        </rollingPolicy>\n        <encoder>\n            <pattern>[%thread] %d %level %logger{10} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    \n    <root level=\"debug\"><!--定义当前输出级别最低为debug-->\n        <appender-ref ref=\"console\"/><!--引用定义的追加器-->\n    </root>\n    <!--配置拦截器类的日志,指定使用定义的accessHistoryLog追加器,\n    additivity=\"false\"表示不叠加，即只向文件中输入日志\n    而不打印在控制台中-->\n    <logger name=\"com.lcg.restful.interceptor.AccessHistoryInterceptor\" \n            level=\"INFO\" additivity=\"false\">\n        <appender-ref ref=\"accessHistoryLog\"/><!--引用-->\n    </logger>\n</configuration>\n```\n◇拦截器开发\n```java\npackage com.lcg.restful.interceptor;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class AccessHistoryInterceptor implements HandlerInterceptor {\n    /*利用LoggerFactory的get方法得到logger日志对象*/\n    private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class);\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        StringBuilder log = new StringBuilder();\n        log.append(request.getRemoteAddr());//用户地址\n        log.append(\"|\");//分隔符\n        log.append(request.getRequestURL());//用户访问的URL地址\n        log.append(\"|\");\n        log.append(request.getHeaders(\"user-agent\"));//用户浏览器环境\n        logger.info(log.toString());\n        return true;\n    }\n\n}\n```\n◇拦截器配置\n```java\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/**\"/>\n            <mvc:exclude-mapping path=\"/resources/**\"/>\n            <bean class=\"com.lcg.restful.interceptor.AccessHistoryInterceptor\"/>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n## Spring MVC处理流程\n![image.png](SpringMVC拦截器/1634547937578-4486aad0-b09c-4b1a-b8b1-9d5e1d691805.png)\n◇所有请求首先由DispactherServlet进行拦截，然后把请求交由springmvc处理；\n◇DispactherServlet拦截后的第一步就是查找Handler，Handler也叫处理器，查找Handler的任务由处理器映射器来完成，即通过当前的URL得到执行链；作为HandlerMapper只会获取执行链，而不会对其进行处理；\n执行链的处理由中央处理器向处理器适配器来发起执行请求，然后由HandlerAdapter根据Handler的类型(可能是一个拦截器或者控制器)去执行对应的方法；执行方法后会返回一个对象(例如MAV)，被HandlerAdapter接收，然后返回给中央处理器；中央处理器会去选择与之对应的视图解析器来进行视图对象的创建，视图会随着处理完返回给中央处理器，当中央处理器拿到对象以后就会将模板和从处理器适配器得到的数据进行渲染，得到最终的html返回给浏览器；\n\n##  执行链  \n![image.png](SpringMVC拦截器/1634548426067-a5e5abc6-193c-4efd-b36e-b9042a45ee5e.png)\n◇如果Handler类型为拦截器，HandlerAdapter首先会执行前置处理方法，之后请求向后送；\n\n","tags":["Spring"],"categories":["Spring","SpringMVC基础"]},{"title":"RESTFUL风格的应用","url":"/p/cc19.html","content":"##  传统Web应用的问题  \n![image.png](RESTful风格的应用/1634216854423-40c6124e-0a6c-4a90-8fc0-094c591599f2.png)\n◇上图描述了传统开发模式的流程，可知在这种模式下，我们客户端需要支持html的浏览器；但目前互联网的发展呈多元化，有微信小程序，APP等各种客户端；那么像这种客户端是不支持html的，那么我们希望这种客户端都能和后端通过html进行通信，该如何实现呢？这时一种全新的开发理念就出现了，即RESTful；\n\n## REST与RESTful \n◇REST-表现层状态转换,资源在网络中以某种表现形式进行状态转移 \n◇RESTful是基于REST理念的一套开发风格,是具体的开发规则  \n◇RESTful传输数据如下图，客户端不再是标准的浏览器，并不拘泥于客户端必须是浏览器；当手机中有一个小程序向http://xxx.com/list这个url发送了一个请求，而这个请求发送到了web端的服务器，经过服务器处理以后，作为服务器返回的不再是html的文本，而是像JSON或XML这样的数组；即在RESTful开发风格中，服务器只返回数据，而这种数据以JSON或XML的方式体现，要求返回的数据不包含任何与展现的内容；具体的展现方式交由客户端处理；这样做的好处是后端工程师可以专注于后台开发，而数据的展现交给前端完成；即前后端分离；\n![image.png](RESTful风格的应用/1634217425921-bc98db74-c09b-4e16-b950-091b8b553382.png)\n\n## RESTful开发规范 \n◇使用URL作为用户交互入口 \n◇ 明确的语义规范(GET|POST|PUT|DELETE)；这里的语义规范是指在http发送请求的时候，例如get请求和post请求它们实现的含义是不同的；在我们日常开发中，常用的http发送的方式有四种，GET|POST|PUT|DELETE，在web环境下不支持后两种，这四种其实分别对应了查询|新增|更新|删除 的操作，也就是说同一个url在向服务器发送请求的时候，使用了不同的请求方式，则服务器的处理操作也是不同的；\n◇ 只返回数据(JSON|XML),不包含任何展现 ；默认使用JSON数据；\n\n## RESTful命名要求  \n◇uri在RESTful中是有明确用法的，需要书写正确；\n第一行说明我们要查询作者是Lily的文章；\n◇第二行错误是因为我不具有语义，即无法通过uri明白要干什么；而修改后的uri让我们知道是要查询id号为1的学生；RESTful可以把id号附加到uri中；\n◇第三行，在RESTful中强制要求所有的uri中出现的单词必须是名词，不能是动词；\n◇第四行，实际使用中如果uri的层级过多，会造成uri的管理混乱，同时造成维护不便；如果超过两级，通常将id进行参数化，书写为?id=1的形式；作为RESTful它里边所代表的资源是由最后一个名词决定的；所以这里查询id=1的名词是指作者而不是文章；\n◇第五行，RESTful建议最好在名词上区分单复数；一般复数形式用于查询；其他操作往往针对一个对象，通常采用单数形式；\n![image.png](RESTful风格的应用/1634218937948-c2fd7f02-a288-4f85-84c0-cfb73d99a99f.png)\n\n## 开发RESTful Web应用\n### 服务器端\n◇创建maven项目restful，然后配置工程结构，配置Tomcat；\n◇配置各种xml文件；\n◇创建RestController控制器类\n```java\n@Controller\n@RequestMapping(\"/restful\")\npublic class RestfulController {\n    @GetMapping(\"/request\")\n    @ResponseBody\n    public String doGetRequest(){\n        /*一个JSON格式的字符串，在其中增加key和value\n        * 注意：双引号中如果包括双引号，要使用转义字符\\,将双引号写成\\\"*/\n        return \"{\\\"message\\\":\\\"返回查询结果\\\"}\";\n    }\n}\n```\n◇这样，就完成了restful风格的开发，可以看出，restful并不是新技术，而是一种开发风格；那么如何将JSON字符串进行页面的展现呢？这就是前端的工作了；\n◇如果我们在页面运行过程中，想得到url返回的数据，可以使用ajax技术，ajax可以在页面中异步的与url发送请求，得到相应结果；\n### 客户端\n◇现在我们开发一个客户端，与服务器端的restful进行交互\n◇将jQuery包复制到webapp目录下，因为待会需要使用jQuery的ajax函数，在http页面中向controller发起http请求；\n◇在webapp目录下创建客户端html页面；client.html；\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>RESTful实验室</title>\n<!--引入jquery-->\n    <script src=\"jquery-3.3.1.min.js\"></script>\n    <!--书写页面就绪函数,在页面加载完以后\n    直接用我们定义的按钮绑定单击事件,并书写事件函数-->\n    <script>\n        $(function(){//页面就绪函数\n            $(\"#btnGet\").click(function () {//单击事件函数\n                $.ajax({/*利用ajax函数向服务器端发送一个异步请求*/\n                    url:\"/restful/request\", //请求的url地址\n                    type:\"get\", //请求方式为get\n                    dataType:\"json\",//说明服务器返回的数据类型为json\n                    /*success回调函数，能将字符串转换为json对象*/\n                    success:function (json) {\n                        /*绑定一个<h1>标签的id,然服务器返回的数据\n                        * 填充到这个<h1>里边；text方法用于设置内部的文本\n                        * json.message得到JSON中message的value(值)*/\n                        $(\"#message\").text(json.message);\n                    }\n                })\n            })\n        })\n    </script>\n</head>\n<body>\n<!--通过这个按钮利用ajax向服务器发送http请求-->\n    <input type=\"button\" id=\"btnGet\" value=\"发送Get请求\">\n    <h1 id=\"message\"></h1>\n</body>\n</html>\n```\n◇当我们运行Tomcat并在浏览器输入client.html的页面，点击按钮就会将服务器返回的数据展示在页面的&lt;h1&gt;标签上，如果出现了中文乱码，并且是在程序里创建了消息转换器解决中文时；我们可以按F12然后查看Network网络部分，再次点击按钮，查看request请求，查看Headers中Response Headers响应头部分，如下图，可以看看蓝标处的Context-Type；jequery通过ajax发送请求以后，返回的响应的类型不是我们设置的text/html,而且如果字符集不是utf-8的话，就会出现乱码问题；\n![image.png](RESTful风格的应用/1634262466249-64e6e6dd-dac1-4ffa-8a6a-34af3e96fb01.png)\n那么如果如果charset不是utf-8的话，该怎么做呢？\n我们可以在服务器端修改这个字符集，打开applicationContext配置文件将消息转换器增加配置；\n\n```xml\n<list>\n<!--原本设置的字符集只能针对text/html格式的-->\n<value>text/html;charset=utf-8</value>\n<!--现在我们增加application/json格式的，通知客户端\n将数据用utf-8的字符集进行展示-->\n<value>application/json;charset=utf-8</value>\n</list>\n```\n### RESTful不同操作\n◇作为restful还有一个重要特性，就是针对不同的请求来做不同的操作；如查询用get，新增用post，修改put，删除delete；那么在程序中是如何体现的呢？\n◇服务端方法,注意请求地址需要不同，否则会报500错误：There is already 'restfulController' bean method\n```java\n    @RequestMapping(\"/request\")\n    @ResponseBody\n    public String doPostRequest(){\n        return \"{\\\"message\\\":\\\"数据新增成功\\\"}\";\n    }\n    @RequestMapping(\"/put\")\n    @ResponseBody\n    public String doPutRequest(){\n        return \"{\\\"message\\\":\\\"数据更新成功\\\"}\";\n    }\n    @RequestMapping(\"/delete\")\n    @ResponseBody\n    public String doDeleteRequest(){\n        return \"{\\\"message\\\":\\\"数据删除成功\\\"}\";\n    }\n```\n◇客户端调用,只写了delete请求的，其他的请求是一样的实现方式，只是请求类型不一样\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>RESTful实验室</title>\n<!--引入jquery-->\n    <script src=\"jquery-3.3.1.min.js\"></script>\n    <script>\n        $(function(){\n            $(\"#btnDelete\").click(function () {\n                $.ajax({\n                    url:\"/restful/delete\",\n                    type:\"delete\", //可以是GET|POST|PUT|DELETE\n                    dataType:\"json\",\n                    success:function (json) {\n                        $(\"#message\").text(json.message);\n                    }\n                })\n            })\n        })\n    </script>\n</head>\n<body>\n    <input type=\"button\" id=\"btnDelete\" value=\"发送Delete请求\">\n    <h1 id=\"message\"></h1>\n</body>\n</html>\n```\n## RestController注解与路径变量\n◇上面的案例还有一些小问题，其一返回值我们使用的是字符串拼接完成的，如果是一个复杂对象或者大的集合就会显得很麻烦；那么如何优化JSON产生的过程呢？其二，在当前的应用中，我们每一个方法都固定写了 @ResponseBody这个注解来直接返回一个JSON字符串，那么有没有简单的方式，不用每一个方法上都进行这个注解呢；其三，在restful中允许uri出现id这样的数据，那么如何获取uri中像id这样的数据呢；\n◇解决第二个问题，我们只需要将原来类上的@Controller注解改为@RestController，这样就不需要在每个方法上面都添加@ResponseBody了；\n◇路劲变量即放在uri中的变量；如 POST /article/1 意思为提交id为1的文章，其中1就是一个变量称为路径变量；\n现在我们要创建一个全新的请求request，假设请求的id值为100的话，那么uri书写的样式为：POST /restful/request/100，那在服务器端怎么接收到这个100呢？因为100并不是我们请求得参数，而是uri中的一部分，好在springmvc给我们提供了路径变量的支持，我们只需要给@GetMapping注解中的uri增加对应的路劲变量名字即可，需要用大括号括起来；如@GetMapping(**\"/request/{rid}\"**)；前面我们定义了路径前缀/restful；在程序中的接收方法为：在方法中根据rid的属性设置一个Integer数字类型的参数,并且在参数前增加路劲变量的注解，并将上面增加的路径变量名字rid放在注解中，\n即方法写为：**public **String doPostRequest(@PathVariable(**\"rid\"**) Integer requestId)；\n◇controller方法部分\n```java\n    //Post /restful/request/100\n    @RequestMapping(\"/request/{rid}\")\n    public String doPostRequest(@PathVariable(\"rid\") Integer requestId){\n        return \"{\\\"message\\\":\\\"数据新增成功\\\",\\\"id\\\":\"+requestId+\"}\";\n    }\n```\n◇客户端请求部分\n```java\n        $(function(){\n            $(\"#btnPost\").click(function () {\n                $.ajax({\n                    url:\"/restful/request/100\",\n                    type:\"post\",\n                    dataType:\"json\",\n                    success:function (json) {\n                        $(\"#message\").text(json.message+\":\"+json.id);\n                    }\n                })\n            })\n        })\n```\n## 简单请求与非简单请求\n### 概念\n◇简单请求是指标准结构的HTTP请求,对应GET/POST请求 \n◇ 非简单请求是复杂要求的HTTP请求,指PUT/DELETE、扩展标准请求 \n◇ 两者最大区别是非简单请求发送前需要发送预检请求  \n◇非简单请求图示\n![image.png](RESTful风格的应用/1634353555066-a7e51ee4-b7a0-42f8-a3a0-cc0973f71136.png)\n◇预检请求可以让服务器预先处理，对于不符合要求的请求就会挡在外头实际的数据并不会发送，这样就可以减轻网络传输和服务器的压力了；\n\n### 代码演示\n◇我们在简单请求post和非简单请求put上各加一个数据data，在发送的请求中我们附加查询字符串：\"name=lily&age=23\",\n```java\n data:\"name=lily&age=23\",\n```\n◇如果要接收一系列数据，最好新建一个实体对象；那么我们在实体包总成绩Person实体对象\n```java\npackage com.lcg.restful.entity;\n\npublic class Person {\n    private String name;\n    private Integer age;\n    ...\n}\n```\n◇然后在控制器类中的post请求方法里增加实体对象的参数；\n```java\n //Post /restful/request/100\n    @RequestMapping(\"/request/{rid}\")\n    public String doPostRequest(@PathVariable(\"rid\") Integer requestId, Person person) {\n        System.out.println(person.getName()+\":\"+person.getAge());\n        return \"{\\\"message\\\":\\\"数据新增成功\\\",\\\"id\\\":\" + requestId + \"}\";\n    }\n\n\n    @RequestMapping(\"/put\")\n    public String doPutRequest(Person person) {\n        System.out.println(person.getName()+\":\"+person.getAge());\n        return \"{\\\"message\\\":\\\"数据更新成功\\\"}\";\n    }\n```\n◇但是，作为非简单请求的put，不能像post一样直接进行参数的增加；这是因为springmvc最早是为网页提供服务的，而网页中只支持post和get两个简单请求，对于put和delete这种特殊请求是不支持的；但随着技术的发展，springmvc需要考虑到这种特殊请求，作为springmvc不能把这种特殊请求方式和简单请求进行相同的处理，因此springmvc为这种特殊请求提供了额外的表单内容过滤器；具体实现为，打开web.xml配置表单内容过滤器\n```java\n<filter>\n        <filter-name>formContentFilter</filter-name>\n        <filter-class>org.springframework.web.filter.FormContentFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>formContentFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n```\n只有增加了这个filter，springmvc才能对put等特殊请求进行良好的支持；\n## JSON序列化\n◇Apache提供的maven[中央仓库地址](https://search.maven.org)下载jackson-core，jackson的核心组件；jackson是世界上使用频率高，效率号的JSON序列化组件，其核心组件2.9以前的版本与mysql使用时会有漏洞，所以我们使用2.9版本以后的组件；\n◇在pom.xml中增加jackson的依赖；\n```xml\n<!--jackson-core是最底层的核心包，不能独立运行-->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-core</artifactId>\n            <version>2.9.9</version>\n        </dependency>\n        <!--还需要引进databind(数据绑定,用以核心交互)\n        和annotations(注解,用以简化开发)-->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.9.9</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-annotations</artifactId>\n            <version>2.9.9</version>\n        </dependency>\n```\n◇当我们加载好jackson后，springmvc会自动利用其进行JSON的序列化，不需要额外的配置；\n◇在控制器类中增加findByPersonId()方法示例JSON序列化的使用方法\n```java\n/*在这里返回的并非字符串或者ModelAndView，而是一个实体对象\n    * 如果我们返回一个实体对象并且方法上设置为@ResponseBody或者类\n    * 上设置了@RestController那么springmvc就会自动的使用jackson\n    * 对这个对象进行JSON序列化的输出,从而避免了手动拼接字符串的麻烦*/\n    @GetMapping(\"/person\")\n    public Person findByPersonId(Integer id){\n        Person p = new Person();\n        if (id == 1) {\n            p.setName(\"莉莉\");\n            p.setAge(22);\n        } else if (id == 2) {\n            p.setName(\"张珊\");\n            p.setAge(20);\n        }\n        return p;\n    }\n\n/*返回多个对象,当程序返回以后，list集合就会产生一个JSON数组，包含每一个\nJSON序列化后的对象*/\n    @GetMapping(\"/persons\")\n    public List<Person> findPersons(){\n        List list = new ArrayList();\n        Person p1=new Person();\n        p1.setName(\"lily\");\n        p1.setAge(22);\n        Person p2=new Person();\n        p2.setName(\"leon\");\n        p2.setAge(23);\n        list.add(p1);\n        list.add(p2);\n        return list;\n    }\n```\n◇启动后浏览器输入http://localhost:8080/restful/person?id=1，页面显示JSON字符串：{\"name\":\"莉莉\",\"age\":22}\n输入http://localhost:8080/restful/persons，显示JSON数组：[{\"name\":\"lily\",\"age\":22},{\"name\":\"leon\",\"age\":23}]\n◇在客户端显示JSON对象数组；\n```java\n /*查询所有人员的函数*/\n        $(function () {\n            $(\"#btnPersons\").click(function () {\n                $.ajax({\n                    url:\"/restful/persons\",\n                    type:\"get\",\n                    dataType:\"json\",\n                    success: function (json) {\n                        console.info(json);/*浏览器的控制台打印json信息*/\n                        for (var i = 0; i < json.length; i++) {\n                            var p = json[i];\n                            $(\"#divPersons\").append(\"<h2\"+p.name+\"-\"+p.age+\"h2>\")\n                        }\n                    }\n                })\n            })\n        })\n            \n    <input type=\"button\" id=\"btnPersons\" value=\"查询所有人员\">\n    <!--将查询的人员放入下面的div中-->\n    <div id=\"divPersons\"></div>\n```\n◇但是在时间处理上jackson做得并不理想；在Person中额外的增加日期属性birthday;并将人员的birthday设置为当前时间以便于演示；\n◇通过JSON对时间类型进行输出的时候，得到的是一串很长的数字，这个数字是从1970年到现在为止的毫秒数，而非具体的时间；因此jackson提供了内置的格式化注解@JsonFormat，可以将时间按指定格式进行输出；将该注解写在类的时间类型属性上；\n```java\n    private Integer age;\n    @JsonFormat(pattern =\"yyy-MM-dd HH:mm:ss\")\n    private Date birthday;\n```\n但这样又会出现问题，会发现时间与我们的正确时间不一致，相差了8个小时；因为jackson在对对象序列化的时候，对日期类型会按照伦敦天文台的时区作为起点，而北京时间和伦敦差了八个时区；具体的做法还需要修改注解，我们额外的增加timezone=\"GMT+8\",即增加了八个时区，修改为@JsonFormat(pattern =**\"yyy-MM-dd HH:mm:ss\"**,timezone = **\"GMT+8\"**)；\n## 浏览器的跨域访问\n### 浏览器的同源策略\n◇同源策略阻止从一个域加载的脚本去获取另一个域上的资源;即如果我们把client.html文件下载到桌面再用浏览器打开的话，就相当于一个域了(C:/Desktop/client.html)，所以无法访问原来的资源；\n◇只要协议、域名、端口有任何一个不同，都被当作是不同的域\n◇那么如何进行跨域访问呢？浏览器Console看到Access-Control-Allow-Origin就代表跨域了\n### 同源策略示例\n![image.png](RESTful风格的应用/1634385595364-3599ac60-4094-4cd2-aa8a-59d5b7a3744b.png)\n◇第一个，域名、端口、协议都不同；第二个协议不同；第三个域名不同；第四个端口不同(默认网站端口为80)；第五个在本机测试的时候，localhost和127.0.0.1虽然从系统的层面上都指向了本机，但它们却是不同的域；\n\n### HTML中允许跨域的标签\n◇&lt;img&gt;  - 显示远程图片\n◇&lt;script&gt; - 加载远程js\n◇&lt;link&gt;    - 加载远程css\n\n## SpringMVC跨域访问\n### CORS跨域资源访问\n◇CORS是一种机制,使用额外的HTTP头通知浏览器可以访问其他域 \n◇URL响应头包含 Access-Control-*指明请求允许跨域  \n### 解决跨域访问的方法\n◇ @CrossOrigin－ Controller跨域注解  ，只是在当前controller中生效\n◇ <mvc:cors> - Spring MVC全局跨域配置 \n◇在服务器的提供端(也就是接收请求的端)配置跨域;\n```java\n//方法一\n//origins说明允许被哪些其他域名访问,可以写多个,也可以使用*表示所有域都可以进行访问,但不推荐\n/*@CrossOrigin(origins = \"*\",maxAge = 3600)maxAge表示设置预检请求的缓存时间为3600秒\nmaxAge参数说明我们可以将预检请求的处理结果进行缓存;如果在指定的缓存时间内，同样的请求在进行\n访问就可以不用再进行预检请求了;\n*/\n@CrossOrigin(origins = {\"http://localhost:8080\"})\npublic class RestfulController {\n....\n}\n```\n◇当我们查看Request Headers（请求头）时，会看到Sec-Fetch-Mode:cors 表明这是一个跨域访问；\n### CORS全局配置\n◇打开applicationContext.xml配置文件进行设置；\n```xml\n    <mvc:cors>\n        <!--子标签mvc：mapping 映射\n        path对应了当前应用的url地址;\n        allowed-origins表示允许被哪些域名进行访问,可以进行多个域名的书写\n        max-age预检请求处理结果的缓存时间\n        -->\n        <mvc:mapping path=\"/restful/**\"\n                     allowed-origins=\"http://localhost:8080,http://www.gamest.com\"\n                     max-age=\"3600\"/>\n    </mvc:cors>\n```\n\n","tags":["开发"],"categories":["Spring","SpringMVC基础"]},{"title":"SpringMVC入门与数据绑定","url":"/p/b016.html","content":"## 周课介绍\n### Spring MVC\n![image.png](SpringMVC入门与数据绑定/1633767307961-da03edbb-a53f-461d-8013-31977b688b90.png)\n### Restful开发风格\n![image.png](SpringMVC入门与数据绑定/1633767365393-c0e20976-0aeb-4cfa-888f-e819e3ad3fe3.png)\n## Spring MVC\n### 课程介绍\n◇Spring MVC入门                ◇Spring MVC数据绑定\n◇Restful开发风格                 ◇Spring MVC拦截器\n### MVC到底是什么\n◇MVC是一种著名的架构模式；View就是我们通常说的界面部分，用于和用户进行交互，比如通过界面显示查询结果，提供表单等；而模型通常指的是数据，如果放在java代码里就是业务逻辑的部分；在MVC的设计理念中，如果前面视图中某个表格的数据来自于后端的Model中，并非视图通过java主动的调用model中的某一个方法来获取数据，而是要通过控制器；控制器相当于中介，作为控制器，是整个MVC架构中最核心的部分，其用途就是接收视图中所传入的数据，然后再根据数据调用后端的业务逻辑得到结果，再将后端得到的结果返回到视图中；\n![image.png](SpringMVC入门与数据绑定/1633767696416-64f8f281-fca5-46ac-8502-59d96086b2cc.png)\n◇Spring MVC是Spring体系的轻量级Web MVC框架\n◇Spring MVC的核心Controller控制器，用于处理请求，产生响应；在MVC中，界面是不允许直接访问后端的Model业务逻辑的，而是通过控制器作为一个中间者传递调用，这样的好处是让我们的界面和后端的java业务逻辑解耦，提高了程序的可维护性；\n◇Spring MVC基于Spring IOC容器运行，所有对象被IOC管理，提高了程序的健壮性与稳定性；\n\n### Spring 5.x 版本变化\n◇Spring 5.x最低要求JDK8与J2EE 7(Servlet 3.1/Tomcat 8.5+)\n◇Spring 5.x支持JDK8/9,可以使用新特性\n◇Spring 5.x最重要的新特性支持响应式编程(即基于事件来的，当触发某一事件后就会在后端自动的执行某一段代码)作为响应式编程，是一种新的开发理念和风格；\n### Spring MVC官方文档学习\n◇进入spring.io官网，project->spring-framework->Features->spring mvc  [链接](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)\n## IDEA环境下创建Maven WebApp\n◇打开idea->new->Maven->SDk:java1.8以上版本->next->GroupId:com.lcg->ArtifactId:first-springmvc->next->设置工程保存路径->finish->Enable Auto-Import（自动导入依赖）\n◇创建好以后，还需要进行如下设置使创建的标准maven工程具备web能力: 选中工程名称->File->Project Structure->Facets->+->web(进行web能力的嵌入)->选中工程名->OK->配置web描述符文件(web.xml)所存储的路径：first-springmvc\\src\\main\\webapp\\WEB-INF\\web.xml->勾选版本为3.1->设置存储页面的目录（就在上一项操作的下方）:src\\main\\webapp->下方设置默认上下文为:/->OK->是否创建目录：yes->Create Artifact（根据前面的设置自动配置运行的方式）->OK;\n◇在webapp目录下创建一个测试页面index.html;然后进行Tomcat的配置；右上角Add Configuration->Templates(配置一个模板): TomcatServer->Local->Application server(应用服务器)->configure->Tomcat Home:Tomcat的安装路径(apache-tomcat-8.5.40)->OK-OK; 模板配置好后，再次点击Add Configuration->+->Tomcat Server ->Local->Deployment->+->Artifact->Application context:/->Server->On 'Update' action(说明在页面发生改变以后如何来生效，默认选项为Restart server即重启服务才会生效):改为Update classes and resources(说明在Tomcat启动过程中，如果idea中的页面代码发生变化不需要重启Tomcat，直接可以更新；这种方式称为热部署)->HTTP port（可以根据自己的需要修改端口，默认为8080）:80->OK; 这样就完成了web的配置；\n## Spring MVC环境配置\n### 配置步骤\n1.Maven依赖spring-webmvc\n```java\n//阿里云的仓库\n<repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n    <dependencies>\n    //依赖环境\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n    </dependencies>\n```\n2.web.xml配置DispatcherServlet\n◇DispatchServlet是springmvc最重要的一个类，其作用就是对所有请求进行拦截；类似公司的前台一样，接待不同的客户，然后根据客户的需求向公司对应的部门请求处理；\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n         version=\"3.1\">\n   <!-- DispatchServlet-->\n    <servlet>\n        <servlet-name>springmvc</servlet-name> <!--这里名字是可以自定义的，但一般约定如此-->\n       <!--DispatchServlet是Spring MVC最核心的对象\n           DispatchServlet用于拦截Http请求，\n           并根据请求的URL调用与之对应的Controller方法，\n           来完成Http请求的处理-->\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n      <!--  加载applicationContext.xml\n            告诉DispatcherServlet在IOC容器启动时\n            加载哪一个目录下的哪个xml文件; classpath表示类路径\n            main\\resources下的xml文件会自动加载到类路径中-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:applicationContext.xml</param-value>\n        </init-param>\n        <!--在Web应用启动时自动创建Spring IOC容器，\n           并初始化DispatcherServlet，以提高响应速度;如果没有这个配置，\n           则会在第一次访问url的时候进行容器的创建和初始化工作-->\n        <load-on-startup>0</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <!--\"/\" 代表拦截所有请求-->\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n3.配置applicationContext的mvc标记\n```java\n//声明部分\n//schema部分\n  <!--\n    context:component-scan 标签作用\n    在Spring IOC初始化过程中,自动创建并管理com.lcg.springmvc及子包中\n    拥有以下注解的对象.\n    @Repository\n    @Service\n    @Controller\n    @Component\n    -->\n    <context:component-scan base-package=\"com.lcg.springmvc\"></context:component-scan>\n    <!--启用Spring MVC的注解开发模式 -->\n    <mvc:annotation-driven/>\n    <!--将图片、js、css等静态资源排除在外(即不被拦截)，可提高执行效率-->\n    <mvc:default-servlet-handler/>\n```\n4.开发Controller控制器\n```java\n/*在配置文件中,context：component-scan所描述的包中包含了这个测试类\n* 因此增加Controller注解，所以在IOC容器初始化时会自动的将TestController\n* 初始化并由IOC容器所管理，且spring也自动该类是一个springmvc的控制器*/\n@Controller\npublic class TestController {\n    @GetMapping(\"/t\")//用于将当前方法绑定某个get方式请求的url，比如localhost/t\n    @ResponseBody //直接向响应提供字符串数据，不跳转页面\n    public String test(){\n        return \"SUCCESS\";\n    }\n}\n```\n5.在运行测试之前，还需要进行Tomcat的配置；因为一些底层依赖还没有加到当前的发布目录(WEB-INF)中，所以需要进行加入；具体做法为：右上角Edit Configuration->Deployment->编辑web exploded->将右侧的依赖全选，put到左边的目录中去->OK\n◇热部署状态下，如果修改了源码，只需要右键Reload Changed Classes（对类进行重新编译）则不要重启Tomcat；\n### SpringMVC处理示意图\n![image.png](SpringMVC入门与数据绑定/1633851296390-cd695bbf-ddc8-4002-a5f5-c4f3151ed46f.png)\n◇打开浏览器输入网址以后，需要向服务器发送请求，假设请求发送的地址是：http://localhost/t；那么这个请求就会发送到本机的Tomcat上，而Tomcat自然启动了springmvc的应用，此时请求会被DispatcherServlet拦截，DispatcherServlet会在Controller中寻找哪个方法映射了t，则DispatcherServlet会知道使用test()方法来处理这个请求，然后请求进入test方法，并返回一个响应体;\n## Spring MVC数据绑定\n◇什么是数据绑定：即springmvc中的controller控制器的某一个方法是如何与url进行绑定的，在前面的演示中我们使用了GetMapping这个注解进行绑定，那还有其他的方法吗？答案是肯定的；\n### URL Mapping(URL映射)\n◇URL Mapping指将URL于Controller方法绑定\n◇通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务\n### URL Mapping注解\n◇@RequestMapping - 通用绑定 \n◇@GetMapping - 绑定Get请求 \n◇@PostMapping - 绑定Post请求  \n### 注解使用案例\n◇见firstspringmvc项目\n```java\n@Controller\npublic class URLMappingController {\n    @GetMapping(\"/g\")\n    @ResponseBody\n    public String getMapping(){\n        return \"This is get method\";\n    }\n    @PostMapping(\"/p\")\n    @ResponseBody\n    public String postMapping(){\n        return \"This is post method\";\n    }\n}\n```\n◇以上代码运行后，当浏览器中输入/p时会出现405报错，因为直接在浏览器输入地址是get请求，而程序后端里\"/p\"映射的是post请求，出现了请求不一致的情况；那么如何处理post请求呢？可以通过html表单来完成post请求；于是修改index.htm，增加表单，并将提交的地址设置为\"/p\"，指明提交的方法为post；\n```java\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n   <form action=\"/p\" method=\"post\">\n       <input type=\"submit\" value=\"提交\">\n   </form>\n</body>\n</html>\n```\n◇通常RequestMapping 注解是放在类上面的，大多数情况下用于URL的全局设置；作为URL可能有多级结构，比如，要求URLMappingController所有的映射地址都是以/um作为前缀来进行访问，那么GetMapping和PostMapping都要在原来的映射地址前增加/um(如/um/p)，如果方法过多的话，都要这样进行一一设置，过于繁琐；而RequestMapping 放在类上就可以进行全局设置了，直接进行注解@RequestMapping (\"/um\"),这样，请求的地址必须在前面加入/um才能够访问成功；\n◇如果将RequestMapping 注解放在方法上，则不再区分get/post请求，但并不推荐这样使用；当然使用RequestMapping 注解也可以指定其请求方法，如@RequestMapping (value=\"/g\", method=RequestMethod.GET)\n## 接收请求参数\n◇在大多数情况下一个请求发过来的时候需要包含一些数据，这些数据大多以请求参数来体现的，比如说我们用户登录的时候需要输入用户名和密码，那么这些数据就会以post请求参数的形式发送到controller的方法中；\n### 接收请求参数的常用方法\n◇使用Controller方法参数接收\n```java\n<form action=\"/m1\" method=\"post\">\n<input name=\"username\"/>\n<input name=\"password\"/>\n</form>\n-------------------------------------------------------------- \n@PostMapping(\"/m1\")\n@ResponseBody\n   /*SpringMVC允许进行类型转换，如果在前面进行表单校验的时候\n    Password只允许输入数字，那向服务器提交以后，因为password\n    只是数字，所以可以强制转换为Long类型；因此在接收时，直接可以\n    将形参设置为Long类型，而不需手动转换*/\npublic String post(String username , Long password){\n return username + \":\" + password;\n}\n```\n◇使用Java Bean接收数据\n```java\n<form action=\"/m1\" method=\"post\">\n<input name=\"username\"/>\n<input name=\"password\"/>\n</form>\n----------------------------------------------------------------- \n@PostMapping(\"/m1\")\n@ResponseBody\npublic String post(User user){\n return user.getUsername() + \":\" + user.getPassword();\n}\n\n```\n### Controller方法\n◇html表单\n```java\n   <form action=\"/p\" method=\"post\">\n       <input name=\"username\"><br/>\n       <input name=\"password\"><br/>\n       <input type=\"submit\" value=\"提交\">\n   </form>\n```\n◇controller\n```java\n @PostMapping(\"/p\")\n    @ResponseBody\n    public String postMapping(String username,String password){\n        System.out.println(username+\":\"+password);\n        return \"submit success\";\n    }\n```\n◇ 对于get请求如何接收请求参数呢？如localhost/g?managet_name=lily就是一个带有请求参数的get请求，在java中只有驼峰命名法，所以不能使用managet_name作为参数名来接收请求参数；则需要一个特殊的注解@RequestParam(\"manager_name\"),其放在接收请求的参数前，括号里面填写映射的地址，即请求参数名；作为请求中的manager_name这个参数在运行时会被动态的注入到managerName这个参数中\n```java\n    @GetMapping(\"/g\")\n    @ResponseBody\n    public String getMapping(@RequestParam(\"manager_name\") String managerName){\n        System.out.println(\"mangerName:\"+managerName);\n        return \"This is get method\";\n    }\n```\n### Java Bean方法\n◇假设表单有一百个输入项，那么问题来了，难道我们需要将这一百个参数都在controller的方法中列举出来吗？并且还需要将接收的一百个参数通过set方法进行对象的转化，这样做显然麻烦；为了解决这个问题，springmvc运行我们将前台输入的数据保存为指定的java bean，一步到位，完成了由数据到对象的转换工作；\n◇创建entity实体包，并在实体包下创建实体类User\n```java\npackage com.lcg.springmvc.entity;\n\npublic class User {\n    private String username;\n    private Long password;\n    //get&ser方法;\n}\n```\n◇controller\n```java\n/*在这里直接将实体类当做参数；springmvc会自动的创建对象\n    * 并且根据前面的请求结合参数名进行一一的赋值,在实体类中属性的\n    * 名字必须和前台的传入参数名保持一致*/\n    @PostMapping(\"/p1\")//也要将表单请求提交的地址改为p1\n    @ResponseBody\n    public String postMapping1(User user){\n        System.out.println(user.getUsername()+\":\"+user.getPassword());\n        return \"This is post method\";\n    }\n```\n◇**public **String postMapping1(User user，String username)；这样会对user赋值，也会给username这个参数赋值；即不管参数中写了多少个username或者多少个实体对象，只要它们用于username这个属性或者参数，只要符合这个规则那么springmvc都会对其进行赋值；\n## 综合训练：调查问卷\n![image.png](SpringMVC入门与数据绑定/1634001914013-bf055739-65e3-41f3-9c97-d97ee4285e90.png)\n◇像这种一次性选择多个数据的情况，在springmvc中如何进行处理呢？\n\n### 知识点\n◇利用数组或List接收请求中的复合数据\n◇利用@RequestParam为参数设置默认值\n◇使用Map对象接收请求参数及注意事项\n### URI绝对路径与相对路径\n![image.png](SpringMVC入门与数据绑定/1634002605204-1c7322bb-cbe5-479f-afb7-1526d252a47e.png)\n◇所谓URI是统一资源标识符的意思，它包含我们平时使用的URL；\n◇假设**左图**是开发的某一个应用，我们访问的uri上下文假设叫project，而project包含如图的结构；**右图**表示在index.html中引用js文件使用的相对路径和绝对路径；右图错误的使用方法，以\"/\"开头，是一个绝对路径，但是并没有加上上下文路径，除非我们设置上下文为\"/\"根路径时才可以；\n◇**相对地址的应用案例**：<form action=\"./apply\" method=\"post\">当使用了相对路径以后，如果访问的页面地址为http://localhost:8080/[上下文路径]/form.html;那么当表单提交以后，其处理请求的地址为http://localhost:8080/[上下文路径]/apply，因为使用了相对路径，则不管前面的上下文路径设置的是什么，只需要保证我们的提交地址apply和当前的html在同一个层级上那么请求就会送达而不会产生404错误；通过使用相对路径可以降低我们对于web工程设置的依赖；\n\n### 代码演示\n◇form.html略，详见项目form;\n◇对于我们的表单，包含了三种数据，前面两种都是单个数据，最后一种是复合数据(一次性会提交多个数据)，springmvc对复合数据的接收提供了两种方案，一种使用数组接收，另一种使用ArrayList进行接收；\n◇创建FormController类；使用数组进行接收复合数据\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    //假设value设置一个表单中不存在的n，如果我设置了value这个属性的话，那么以value为准，\n不再以name进行接收，而是value接收后再出入到name中 defaultValue即默认值；如果表单不存在的话，\n    默认值就是设置的ANON；由于表单中并不存在n这个参数，所以当我们提交的时候，即使填了名字\n    也会使用默认的value注入到参数name中；当然，如果我们设置value=\"name\"的话，由于表单中有name\n    这个参数，所以填了名字可以注入到apply的name参数中，而不填的话，就会使用默认值ANON注入；\n    public String apply(@RequestParam(value = \"n\",defaultValue = \"ANON\")String name, String course, Integer[] purpose){\n        System.out.println(name);\n        System.out.println(course);\n        for (Integer p : purpose) {\n            System.out.println(p);\n        }\n        return \"SUCCESS\";\n    }\n```\n◇前面提到我们的controller类中方法的参数名需要和请求的参数名一致，这样就会完成自动注入；但是，在我们的表单中，有很多都是进行匿名提交的，它并没有包含name参数，在这种情况下，name必然是一个空的对象，那么对于空的对象进行操作时，程序很可能报错；解决这一问题的方法是使用@RequestParam给参数设置默认值；\n◇如果使用List进行复合数据的接收，需要在参数前增加@RequestParam注解，这样springmvc才知道请求中的复合数据要被转换为List进行存储；\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    public String apply(String name, String course, @RequestParam List<Integer> purpose){\n         //与上类似\n    }\n```\n◇对于一组结构化的数据，我们通常使用对象来进行接收；那么在对象情况下，这个List依然能够进行接收；\n我们额外的创建实体包，并创建表单对象类Form;\n```java\npublic class Form {\n    private String name;\n    private String course;\n    private List<Integer> purpose;//复合数据\n    ...\n    }\n```\n在控制器中新建方法使用对象来接收\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    public String apply(Form form){\n        return \"SUCCESS\";\n    }\n```\n◇当然，也可以使用Map来进行参数的接收，Map可以一次性接收表单项的结果，也得在方法参数前加上注解@RequestParam\n```java\n    @PostMapping(\"/apply\")\n    @ResponseBody\n    public String apply(@RequestParam Map map){\n        System.out.println(map);\n        return \"SUCCESS\";\n    }\n```\n但是，对于复合数据，Map是无法接收的，Map默认情况下只会保留复合数据中的第一个数据，其余都会丢失；\n​\n\n## 关联对象赋值\n◇关联对象赋值即在一个对象中引用了另一个对象，需要在这个被引用对象进行赋值的操作；\n◇复杂内容表单\n```java\n用户名:<input name=\"username\">\n密码: <input name=\"password\">\n-------------------------------------- \n姓名:<input name=\"name\">\n身份证号:<input name=\"idno\">\n过期时间:<input name=\"expire\">\n```\n◇对于这张表单来说，包含了两个内容，一个是注册信息，一个是身份信息；对于这个表单来说，可以创建一个对象，然后通过springmvc自动对其进行赋值，但是这样做并不完美；如果按照严格的面向对象的设计方式对表单进行接收的话，需要创建两个类一个User类和一个身份类，并且用户类中包含身份类；\n◇用户类\n```java\npublic class User{\n private String username;\n private String password;\n private IDcard idcard = new IDCard();//实例化关联对象，对象名为idcard\n //getter and setter ...\n}\n```\n◇身份类\n```java\npublic class IDcard{\n private String name;\n private String idno;\n private Date expire;\n //getter and setter ...\n}\n```\n◇那么如何对这样的关联对象进行赋值呢？我们需要修改表单的属性名；将关联对象的的对象名(idcard)作为原有属性的前缀，这样通过springmvc接收数据的时候会自动的将三个属性按照名称对应关系依次进行赋值；\n```java\n用户名:<input name=\"username\">\n密码: <input name=\"password\">\n------------------------------------------- \n姓名:<input name=\"idcard.name\">\n身份证:<input name=\"idcard.idno\">\n过期时间:<input name=\"idcard.expire\">\n```\n## 日期类型转换\n◇全世界各地对日期的表达方式是不一样的；欧美一般采用月日年的表达方式，而国内采用年月日的形式；我们如何接收程序中的日期数据并将其转换为日期对象呢？\n◇假设在注册用户的时候，需要提交注册时间(createTime)这个输入项，那么我们只需要在controller的方法中增加一个参数String createTime就可以了，但大多数的情况下，我们需要将字符串转换为日期对象，那么我们直接将参数改为Date createTime，程序运行时会产生日期格式不一致的问题，当我们输入2020-02-02时，会出现400的错误，一般400错误往往就是我们无法将数据转换为目标类型所致；因此我们需要手动转换才可以，但springmvc为我们早有准备，只需要在日期参数前加上@DateTimeFormat这个注解就行了，此注解用于按照指定的格式将前台接收的字符串转换为对应的date对象，在转换前需要指定其格式是什么，需要给此注解增加patten参数；如@DateTimeFormat(pattent=\"yyyy-MM-dd\");注意这里的格式需要与前台输入的对象一致；\n◇在实体对象中，也要给日期属性增加注解，才能够完成Date类型的转换；\n```java\nprivate Long password;\n@DateTimeFormat(pattent=\"yyyy-MM-dd\")\nprivate Date createTime;\n```\n◇如果对于大量的需要进行日期类型转换的参数，那么都要一 一 加上注解，则过于麻烦，为了解决这个问题，可以设置全局的默认时间转换机制；\n作为全局的日期转换机制，需要新建一个converter(转换器)包，其中保存的都是转换器，开发一个日期转换类MyDateConverter;\n对于日期转换器springmvc要求必须实现Converter接口，在接口中得实现两个泛型，String和Date因为我们是希望把前台的字符串转换为日期类型；\n```java\npublic class MyDateConverter implements Converter<String,Date>{//实现接口\n    public Date convert(String s){\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");//定义格式\n        try{\n             Date d = sdf.parse(s);//开始转换\n            return d;\n        }catch (ParseException e){\n           return null;\n        }\n    }\n}\n```\n◇作为当前的类，需要在applicationContext.xml中进行配置，让springmvc知道该类是一个转换类;配置方法如下：\n```java\n//下面的配置只是让springmvc知道有这个转换类要想和springmvc进行联动，还需要修改下面\n的driven配置，额外增加conversion-service属性，并将下面定义好的beanid放到这个属性中；\n<mvc:annotation-driven conversion-service=\"conversionService\"/>\n\n//增加bean进行定义，id可自行定义，但通常如下定义，class为转换服务的工厂类，\n其作用就是通知springmvc有哪些自定义的转换类\n<bean id=\"conversionService\" \n    class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n        <property name=\"converters\">//转换类定义的地方\n            <set>//作为converters这个属性，它是一个set集合，使用set标签进行描述\n                <bean class=\"com.lcg.springmvc.converter.MyDateConverter\"/>\n            </set>\n        </property>\n </bean>\n```\n◇如果我们既配置了全局的转换类，又设置了注解，则springmvc会优先使用转换器类来进行转换而注解会被忽略掉，因此我们一般二者选其一使用；\n◇对于转换器类只有一种日期格式，那出现了特殊的日期格式要求怎么办呢？那么这时候我们就要对转换器输入的字符串的日期格式进行判断，来使用不同的日期格式进行解析\n## 解决中文乱码\n### Web应用的中文乱码由来\n◇Tomcat默认使用字符集ISO-8859-1,属于西欧字符集，不支持中文；\n◇解决乱码的核心是将ISO-8859-1转换为UTF-8\n◇Controller中请求与响应都需要设置UTF-8字符集\n### 中文乱码的配置\n◇Get请求乱码 - server.xml增加URIEncoding属性\n◇Post请求乱码 - web.xml配置CharacterEncodingFilter\n◇Response响应乱码 - Spring配置StringHttpMessageConverter(消息转换器)\n### 代码演示\n◇**解决Get请求乱码**，需要在文件夹中找到Tomcat的server.xml文件，本机的路径为F:\\JAVA\\Tomcat\\apache-tomcat-8.5.34\\conf\\server.xml；进行修改，在Connector port=\"8080\"处的代码后增加URIEncoding=\"UTF-8\"\n```java\n    <Connector executor=\"tomcatThreadPool\"\n               port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" URIEncoding=\"UTF-8\"/>\n```\n◇在Tomcat8.0以后的版本，URIEncoding默认就是UTF-8，所以在8.0以后的版本不需要进行配置；\n◇**解决Post请求乱码**，需要在工程的web.xml中配置一个filter，filter是javabean的标准组件，用于对请求进行过滤；在这里name设置为字符集过滤，过滤类为有springmvc提供的字符编码过滤器\n```xml\n    <!--配置过滤器-->\n    <filter>\n        <filter-name>characterFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param><!--配置参数-->\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value><!--特殊需求下会用GBK-->\n        </init-param>\n    </filter>\n    \n    <!--使过滤器生效,配置filter的映射地址-->\n    <filter-mapping>\n        <filter-name>characterFilter</filter-name>\n        <url-pattern>/*</url-pattern><!--代表对所有的url进行拦截-->\n    </filter-mapping>\n```\n◇**解决响应中的中文乱码**，需要在applicationContext配置文件中进行设置，在原有的启用注解的标签中增加消息转换器类，首先将原有的标签内容放开，然后在mvc：annotation-driven标签体中增加message-converters(用来设置消息的转换器)，在其下配置的转换器可以对响应中的消息进行调整，这里的converters是个复数，在其下增加一个bean，class为StringHttpMessageConverter(对于http响应中的文本进行转换，如何转换还需要bean下的配置)\n```xml\n <!--启用Spring MVC的注解开发模式 -->\n    <mvc:annotation-driven conversion-service=\"conversionService\">\n        <mvc:message-converters><!--增加消息转换器类-->\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                <property name=\"supportedMediaTypes\">\n                    <list><!--supportedMediaTypes代表支持的媒体类型，是一个集合，所以用list描述-->\n                        <!--在servlet中解决响应乱码如下配置\n                        response.setContentType(\"text/html;charset=utf-8\")-->\n                        <value>text/html;charset=utf-8</value><!--用于说明响应输出对应的字符类型-->\n                    </list>\n                </property>\n            </bean>\n        </mvc:message-converters>\n    </mvc:annotation-driven>\n```\n## 响应输出结果\n◇响应中产生结果主要有两种方式，一种是采用@ResponseBody注解直接产生响应文本显示在客户端浏览器上；\n另一种是ModelAndView对象，利用模板引擎渲染输出，也就是利用我们之前写好的JSP或者freemaker这样的模板引擎再结合数据动态渲染产生页面；\n### @ResponseBody\n◇@ResponseBody直接产生响应体的数据，过程不涉及任何视图；\n◇@ResponseBody可产生标准字符串/JSON/XML等格式数据；\n◇@ResponseBody被StringHttpMessageConverter所影响\n### ModelAndView\n◇如果要在springmvc响应中进行页面展现的话，就需要使用这个ModelAndView对象；\n◇ModelAndView对象是指\"模型(数据)与视图(界面)\"对象\n◇通过ModelAndView可将包含数据对象与模板引擎进行绑定\n◇springmvc中默认的view是jsp，也可以配置其他的模板引擎\n◇页面展现的方法controller类中的showview方法；\n```java\n    @GetMapping(\"/view\")/*映射地址*/\n    public ModelAndView showView(){\n        /*jsp作为模板引擎*/\n        ModelAndView mav = new ModelAndView(\"/view.jsp\");\n        return mav;\n    }\n```\n◇view.jsp\n```java\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n     <h1>这是一个视图页面</h1>\n</body>\n</html>\n```\n◇这样，我们能够通过showview方法访问view.jsp的页面，但是，上面的代码我们通过url直接访问view.jsp也是可以的; 因此通过controller访问view.jsp的意义是为了完成数据的动态展现，所以假设我们需要将请求传来的用户编号，我们把数据查询出来得到一个user对象，然后在jsp中把user对象进行展现；\n```java\n    @GetMapping(\"/view\")/*映射地址*/\n    public ModelAndView showView(Integer userId){\n        /*jsp作为模板引擎*/\n        ModelAndView mav = new ModelAndView(\"/view.jsp\");\n        User user = new User();\n        if (userId == 1) {\n            user.setUsername(\"lily\");\n        } else if (userId == 2) {\n            user.setUsername(\"smith\");\n        }\n        /*addObject的含义是在当前的请求中增加一个对象，对象的别名可以设置为u,第二个参数是\n        * 我们要存放的数据，该数据可以是一个java对象*/\n        mav.addObject(\"u\",user);\n        return mav;\n    }\n```\n◇修改jsp部分,通过EL表达式来进行数据的动态传入\n```java\n<h1>这是一个视图页面</h1>\n     <hr>\n     <h2>Username:${u.username}</h2>\n```\n然后在浏览器中输入localhost/view?userId=1;会发现页面的展现的username为lily,将userId改为2则name变为Smith；数据是由controller中动态的查询产生，而界面由jsp动态渲染；通过这个例子可以看出springmvc模式设计的核心，mvc一直强调视图和模型解耦，有利于程序的维护；\n## ModelAndView\n◇mav.addObject()方法设置的属性默认存放在当前请求中；\n◇默认ModelAndView使用请求转发(forward)至页面，请求转发就是把当前送给showview方法的请求原封不动的传递给view.jsp，即jsp和controller中的请求是同一个，而mav.addObject方法只是向当前的请求中存放数据；\n◇重定向使用new ModelAndView(\"redirect:/index.jsp\")\n◇如果我们使用页面重定向，即将new ModelAndView(\"redirect:/view.jsp\"),那么我们的jsp页面将接收不到数据；因为重定向是controller通知客户端浏览器重新建立一个新的请求来访问view.jsp的地址；\n◇那么重定向使用的场景也有很多，例如那种需要调转的页面和当前请求中的数据没有关系的时候，比如在用户注册的时候，需要跳转到网站首页，那么网站首页就和用户注册的数据没有太大关系；\n◇ ModelAndView mav = new ModelAndView(\"/view.jsp\")；也可写为 ModelAndView mav = new ModelAndView()；mav.setViewName(\"/view.jsp\");如果/view.jsp去掉\"/\"的话，就代表相对地址，相对于我们当前的访问地址(在控制类上通过@RequestMapping(**\"/um\"**)设置的全局地址)，也就是说，去掉以后我们在浏览器访问到的页面是在程序中的webapp/um/view.jsp；而不是webapp/view.jsp；um文件夹是自己创建的，和RequestMapping设置的一致；\n◇如何利用String与ModelMap实现和ModelAndView一样的作用；如果没有数据需要传递的话，可以没有ModelMap对象参数；\n```java\n    /*String与ModelMap\n    * ModelMap对应模型数据，通过ModelMap向里设值可以给我们的页面提供数据\n    * 方法直接返回string字符串\n    * Controller方法返回String的两种情况\n    * 1.方法被@ResponseBody注解描述，SpringMVC直接响应String字符串本身\n    * 2.方法不存在@ResponseBody，则SpringMVC处理String指代的视图(页面)\n    * */\n    //@ResponseBody //直接向响应提供字符串数据，不跳转页面\n    public String showView1(Integer userId, ModelMap modelMap) {\n        String view = \"/view.jsp\";/*设置显示的页面*/\n        User user = new User();\n        /*模拟数据获取*/\n        if (userId == 1) {\n            user.setUsername(\"lily\");\n        } else if (userId == 2) {\n            user.setUsername(\"smith\");\n        }\n        modelMap.addAttribute(\"u\",user);/*与addObject的作用完全相同*/\n        return view;\n    }\n```\n## SpringMVC整合Freemarker\n### 三个步骤\n◇一般分为以下三步：**pom.xml引入依赖、启用Freemarker模板引擎、 配置Freemarker参数  **\n◇pox.xml引入freemarker的依赖,还要引入spring上下文的依赖包spring-context-support(该模块提供了spring对freemaker的整合支持类)\n```java\n<dependency>\n <groupId>org.freemarker</groupId>\n <artifactId>freemarker</artifactId>\n <version>2.3.28</version>\n </dependency>\n <dependency>\n <groupId>org.springframework</groupId>\n <artifactId>spring-context-support</artifactId>\n <version>5.1.9.RELEASE</version>\n </dependency>\n```\n◇第二步需要通知springmvc我们要使用用Freemarker模板引擎，在applicationContext.xml中增加如下配置，其作用是通知springmvc我们的默认引擎有jsp改为了FreeMarkerViewResolver；\n```java\n<bean id=\"ViewResolver\" \nclass=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\">\n <!-- 设置响应输出，并解决中文乱码 -->\n <property name=\"contentType\" value=\"text/html;charset=utf-8\"></property>\n <!-- 指定Freemarker模板文件扩展名 -->\n <property name=\"suffix\" value=\".ftl\"/>\n </bean>\n```\n◇第三步，对Freemarker本身进行参数设置，定义一个bean，类指向Freemarker的配置类；\n注意第三步设置的UTF-8是在模板与数据绑定渲染过程中使用的字符集，而在上一步设置utf-8是指在渲染完成后，向客户端浏览器响应时，响应体中使用的字符集；\n```java\n<bean id=\"freemarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\">\n<!--设置模板保存的目录；WEB-INF目录是无法被直接访问的，Tomcat无法直接解析freemarker\n    模板引擎，因此为了保证模板的安全，就需要把模板文件放在外侧无法访问的WEB-INF目录下\n    一般新增一个ftl文件用于存放freemarker文件-->\n<property name=\"templateLoaderPath\" value=\"/WEB-INF/ftl\"/>\n<!--其他模板引擎设置-->\n<property name=\"freemarkerSettings\">\n<props>\n<!--设置Freemarker脚本与数据渲染时使用的字符集-->\n<prop key=\"defaultEncoding\">UTF-8</prop>\n</props>\n</property>\n</bean>\n```\n### 代码示例\n◇首先按上面步骤进行配置\n◇在controller包中新增FreemarkerController类\n```java\npackage com.lcg.springmvc.controller;\n\nimport com.lcg.springmvc.entity.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\n@RequestMapping(\"/fm\")\npublic class FreemarkerController {\n    public ModelAndView showTest(){\n        /*只写/test,而不写扩展名是因为前面我们已经设置了扩展名为.ftl\n        * '/'代表了根路径，而此时根路径并不是指webapp目录，而是我们定义的\n        * WEB-INF/ftl,在这里我们写的文件名为test，则应该在ftl目录下创建\n        * test.ftl文件*/\n        ModelAndView mav = new ModelAndView(\"/test\");\n        User user = new User();\n        user.setUsername(\"张珊\");\n        mav.addObject(\"u\", user);\n        return mav;\n    }\n}\n```\n◇创建test.ftl模板文件，语法在前面的章节有讲\n```java\n<h1>${u.username}</h1>\n```\n◇因为引入了依赖，但是IDEA并不会将依赖发布，因此需要对发布的信息进行配置，即编辑Web exploded，加入新增的两个依赖，使其运行时能发布到Tomcat中；只要pom.xml配置文件中增加了新的依赖，都要编辑Web exploded\n◇在浏览器中输入:localhost/fm/test，即可出现张珊字样；\n​\n\n","tags":["Spring"],"categories":["Spring","SpringMVC基础"]},{"title":"Spring JDBC与事务管理","url":"/p/d79b.html","content":"## 课程介绍\n◇Spring JDBC与JdbcTemplate对象 \n◇声明式事务与两种配置方式 \n◇声明式事务七种事务传播行为  \n## Spring JDBC \n### 简介\n◇Spring JDBC是Spring生态用于处理关系型数据库的模块 \n◇Spring JDBC对JDBC API进行封装，极大简化开发工作量 \n◇JdbcTemplate是Spring JDBC核心类，提供数据CRUD方法 \n◇有Mybatis为什么还需要Spring JDBC？\n答：这两者面向的对象不一样，Mybatis封装程度较高，适合中小企业做软件的敏捷开发，让程序员可以快速的完成数据库的交互工作；但是封装程度高意味着执行效率较低；而Spring JDBC只是对原始的JDBC的API进行简单封装，执行效率较高；\n### Spring JDBC的使用步骤 \n◇Maven工程引入依赖spring-jdbc \n◇applicationContext.xml配置DataSource数据源 \n◇在Dao注入JdbcTemplate对象,实现数据CRUD  \n## jdbcTemplate实现增删改查\n**代码实现(jdbc/s01)**\n◇由于代码过于繁多，因此不再展示。仅将代码中主要方法思路记下。具体代码见文件夹的项目；\n### 执行查询\n**◇核心配置文件pom.xml **\n加载底层依赖：spring-context, spring-jdbc, mysql-connector-java;\n**◇新增实体类Employee**\n实体成员和数据库保持一致。\n**◇新增Dao**\n**jdbcTemplate**.queryForObject()方法的含义是进行指定的查询(查询单条语句)，将唯一返回的数据转换为对应的对象，第一个参数是sql语句，第二个参数是与sql语句对应的参数(如sql需要查询的属性)一般用new object数组实现，如**new **Object[]{\"研发部\"}；最后一个参数是**new **BeanPropertyRowMapper<Employee>(Employee.**class**)，其中BeanPropertyRowMapper的含义是指将bean属性和每一行的列进行一一匹配，即从数据库记录到实体对象的转化；\n**jdbcTemplate**.query()方法用于查询复合数据，默认返回list集合，参数和queryForObject()方法一致；\n**◇applicationContext.xml配置文件**\n定义数据源，说明要连接哪一个数据库，用户名，密码等；\n配置JdbcTemplate以提供数据CRUD(增删改查)的API；\n为Dao注入JdbcTemplate对象，只有注入以后，我们的具体的业务方法才可以去掉用jdbcTemplate相应的API来完成数据库的增删改查操作；\n◇如果查询的字段没有与之对应的实体属性，该怎么办？\n答：使用**jdbcTemplate**.queryForList()方法，将查询结果作为列表返回，同时将每一条数据按map对象进行包裹；该方法前两个参数和上述一致，但没有第三个参数；List中没一条数据都是一个Map对象，Map的Key是原始的字段名，Value是字段名所对应的数值；通过此方法，不过结果有没有对应的实体属性，都将其放入Map中，安装键值对的规则进行保存，每一个Map就对应着一条记录；\n```java\n //将查询结果作为Map进行封装\nList<Map<String, Object>> maps = jdbcTemplate.queryForList(sql, new Object[]{dname});\n```\n### 执行插入\n◇插入的方法为**jdbcTemplate.**update()方法；第一个参数为sql语句，第二个为传入的参数(new Object[])；new Object[]的数据来源从实体类的get中将与之对应的属性进行提取；\n```java\npublic void insert(Employee employee){\n        String sql = \"insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)\";\n        //利用update方法实现数据写入操作\n        jdbcTemplate.update(sql,new Object[]{\n           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()\n        });\n    }\n```\n### 执行更新\n◇更新的方法和插入方法一样；只不过SQL语句不同；update方法有一个返回值，代表执行本次sql语句所真实影响的数据条目；\n```java\n    public int update(Employee employee){\n        String sql = \"UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?\";\n        int count = jdbcTemplate.update(sql, new Object[]{employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()});\n        return count;\n    }\n```\n◇测试用例\n```java\n    @Test\n    public void  testUpdate(){\n        Employee employee = employeeDao.findById(8888);\n        employee.setSalary(employee.getSalary() + 1000);\n        int count = employeeDao.update(employee);\n        System.out.println(\"本次更新\" + count + \"条数据\");\n    }\n```\n### 执行删除\n◇执行删除的方法也是update；\n```java\n   public int delete(Integer eno){\n        String sql = \"delete from employee where eno = ?\";\n        return jdbcTemplate.update(sql, new Object[]{eno});\n    }\n```\n## Spring事务管理\n### 什么是事务 \n◇事务是以一种可靠的、一致的方式，访问和操作数据库的 程序单元 \n◇ 通俗地说：要么把事情做完，要么什么都不做，不要做一半 \n◇ 事务依赖于数据库实现,MySQL通过事务区作为数据缓冲地带  \n### 编程式事务\n◇编程式事务是指通过代码手动提交回滚事务的事务控制方法\n◇SpringJDBC通过TransactionManager事务管理器实现事务控制\n◇事务管理器提供commit/rollback方法进行事务提交与回滚\n### 代码演示编程式事务(s01)\n◇需求分析：最近公司入职了十名新员工，需要将这十名新员工批量的导入到员工表当中，对于导入的要求，要么一次性全部导入，要么什么都不做；\n◇通过需求分析可知，需要通过事务来进行控制。业务逻辑的代码一般写在service包里，所以新增service；\n**◇EmployeeService**\n底层依赖于EmployeeDao；增加batchImport()方法，用于批量导入；利用for循环模拟十名员工；数据插入调用方法**employeeDao**.insert();\nService写好后还要在applicationContext中进行配置，beanId为employeeService，class指向service类；属性注入employeeDao;\n但是，这样写的代码并不正确；因为通过打印日志可以看出这十个员工数据的插入并不是在同一事务中进行的。\n在pom.xml中加载日志组件logback-classic，Spring框架默认集成此组件；\n◇那么要怎么实现事务批量导入呢？\n作为编程式事务，需要配置bean对象，beanId为transactionManager，意为事务管理器，其用途就是控制事务的提交和回滚；class为org.springframework.jdbc.datasource.DataSourceTransactionManager;  基于数据源的事务管理器，需要绑定数据源；ref=\"dataSource\"；在需要进行事务控制的类里边进行transactionManager的注入；\n**private **DataSourceTransactionManager **transactionManager**;在生成get和set方法；然后在applicationContext配置文件的Service配置中注入事务管理器的bean: \n```java\n    <bean id=\"employeeService\" class=\"com.imooc.spring.jdbc.service.EmployeeService\">\n        <property name=\"employeeDao\" ref=\"employeeDao\"/>\n        <property name=\"transactionManager\" ref=\"transactionManager\"/>\n    </bean>\n```\n作为batchImport需要进行事务管理，所以在此方法执行前增加事务默认的标准配置；开始一个事务，说明此段代码后的所有增删改查都进入了事务管理；\n```java\n    public void batchImport(){\n        //定义了事务默认的标准配置\n        TransactionDefinition definition = new DefaultTransactionDefinition();\n        //开始(创建)一个事务,返回的对象为事务状态,事务状态说明当前事务的执行阶段\n        TransactionStatus status = transactionManager.getTransaction(definition);\n        try {\n            for (int i = 1; i <= 10; i++) {\n                /*if (i == 3) {\n                    throw new RuntimeException(\"意料之外的异常\");\n                }*/\n                Employee employee = new Employee();\n                employee.setEno(8000 + i);\n                employee.setEname(\"员工\" + i);\n                employee.setSalary(4000f);\n                employee.setDname(\"市场部\");\n                employee.setHiredate(new Date());\n                employeeDao.insert(employee);\n            }\n            //提交事务,参数为status\n            transactionManager.commit(status);\n        }catch (RuntimeException e){\n            //出现异常，回滚事务\n            transactionManager.rollback(status);\n            throw e;//可以捕获异常，也可以抛出异常，视具体业务而定\n        }\n\n    }\n```\n通过事务，已经执行成功的sql语句并非直接修改在表中，而是在事务区内，当所有的事务都执行成功后才写入到数据表中，如果遇到异常则会进行回滚；\n◇编程式事务的优点：代码写在程序中，对程序员友好；缺点：存在人为的风险，产生数据不完整的情况；\n### 声明式事务\n◇声明式事务指使用配置或注解，在不修改源码情况下通过配置形式自动实现事务控制，声明式事务的本质就是AOP环绕通知；\n◇ 当目标方法执行成功时,自动提交事务 \n◇ 当目标方法抛出运行时异常时,自动事务回滚  \n### 配置过程\n◇配置TransactionManager事务管理器\n◇配置事务通知与事务属性\n◇为事务通知绑定PointCut切点(PointCut说明在哪个类哪个方法上应用通知)\n### 代码演示声明式事务(s02)\n◇声明式事务直接在配置文件中配置即可\n**◇applicationContext的配置**\n第一步，和编程式一样需要配置事务管理器，绑定数据源；\n第二步，事务通知配置；需要新增命名空间:**xmlns:tx=\"http://www.springframework.org/schema/tx\"**\n以及命名空间所对应的url的描述文件(xsd)得实际地址；以及AOP的命名空间(**xmlns:aop=\"http://www.springframework.org/schema/aop\"**)和实际的xsd文件地址\n```java\nhttp://www.springframework.org/schema/tx\nhttps://www.springframework.org/schema/tx/spring-tx.xsd\n\nhttp://www.springframework.org/schema/aop\nhttps://www.springframework.org/schema/aop/spring-aop.xsd\n```\n事务通知配置，决定哪些方法使用事务，哪些方法不使用事务，配置方法如下：\npropagation表示设置事务的传播行为，propagation=\"REQUIRED\"表示需要使用事务；read-only=\"true\"表示当前方法是只读的，propagation=\"NOT_SUPPORTED\"表示方法不支持事务；\n```java\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <tx:attributes>\n            <!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 -->\n            <tx:method name=\"batchImport\" propagation=\"REQUIRED\"/>\n            <tx:method name=\"batch*\" propagation=\"REQUIRED\"/>\n            <!-- 设置所有findXXX方法不需要使用事务 -->\n            <tx:method name=\"find*\" propagation=\"NOT_SUPPORTED\" read-only=\"true\"/>\n            <tx:method name=\"get*\" propagation=\"NOT_SUPPORTED\" read-only=\"true\"/>\n            //其他选项，一律按如下实现\n            <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n        </tx:attributes>\n    </tx:advice>\n```\n第三步，定义切点作用范围，并关联到通知上\n```java\n<!--3. 定义声明式事务的作用范围-->\n    <aop:config>\n        <aop:pointcut id=\"pointcut\" expression=\"execution(* com.imooc..*Service.*(..))\"/>\n        //与通知关联\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/>\n    </aop:config>\n```\n### 事务传播行为\n◇事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式\n◇XML：<tx:method name=\"...\" propagation=\"REQUIRED\"/>\n◇注解：@Transactional(propagation=Propagation.REQUIRED)\n◇如果还有大量的类似batchImport的批量任务需要开发，则可以创建一个专用于批量导入的服务类BatchService，类的方法可以有很多批量导入的方法；批量导入的服务执行入口放在EmployeeService服务类里边；需要为批量服务类进行bean配置以及注入；\n```java\n    <bean id=\"batchService\" class=\"com.imooc.spring.jdbc.service.BatchService\">\n        <property name=\"employeeDao\" ref=\"employeeDao\"/>\n    </bean>\n```\n### 事务传播行为七种类型\n![image.png](SpringJDBC与事务管理/1633676701801-8ff4303e-1a5d-4f38-9b35-95adeb808314.png)\n◇代码分析\n--EmployeeService类中的批量导入方法\n\n```java\n public void startImportJob(){\n        batchService.importJob1();\n        if(1==1){\n            throw new RuntimeException(\"意料之外的异常\");\n        }\n        batchService.importJob2();\n        System.out.println(\"批量导入成功\");\n    }\n```\n--方法的配置情况\n```java\n <tx:method name=\"importJob1\" propagation=\"REQUIRED\"/>\n <tx:method name=\"importJob2\" propagation=\"REQUIRED\"/>\n <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n```\n◇通过配置信息可以知道对于方法startImportJob()以及其里面嵌套的方法importJob1和~2都是具有事务的；\n对于外侧的方法startImportJob在运行时会创建一个事务，而嵌套调用的importJob1和~2在执行时发现外侧已经有了现成的事务，所以在运行时内侧的事务就会加入到外侧的事务中，也就意味着在执行start方法的时候，整体是在一个事务中完成的数据的增删改操作；如图所示，红色框为主方法的事务，蓝框为子方法的事务，\n![image.png](SpringJDBC与事务管理/1633677913394-16f82101-b0f1-4094-9393-a165fbd94d0c.png)\n因此当子方法1执行成功了，但子方法2执行前遇到了异常，总的事务也会进行回滚，导致方法1无法写入数据进数据库；\n◇如果我们期望无论是方法1还是方法2，只要方法执行成功，就能够成功写入数据库，彼此互不干扰，该如何实现呢？我们可以更改配置项，将原来的配置改为\n\n```java\n<tx:method name=\"importJob1\" propagation=\"REQUIRES_NEW\"/>\n<tx:method name=\"importJob2\" propagation=\"REQUIRES_NEW\"/>\n<tx:method name=\"*\" propagation=\"REQUIRED\"/>\n```\nREQUIRES_NEW表示针对于两个子方法，在运行过程中都会产生新的事务；该方法执行过程如下图\n![image.png](SpringJDBC与事务管理/1633678405307-1da3421c-293a-4f2d-8970-a68631305b50.png)\n\n### 注解配置声明式事务\n代码演示(s03)\n◇核心配置文件pom.xml与上面相同\n◇applicationContext.xml没有配置部分，然后利用component-scan来设置扫描的基本包是哪个；然后定义数据源，初始化JdbcTemplate,配置事务管理器，这三项是必须要配置的bean；最后启用注解形式声明式事务；\n\n```java\n    <!--数据源-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n        <property name=\"url\"\n                  value=\"jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n    </bean>\n    <!--JdbcTemplate-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n    <!--事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n    <!-- 启用注解形式声明式事务 -->\n    <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n```\n◇在Dao类中，利用@Resource完成对象的注入；\n◇在service中，使用@Service完成IOC容器的实例化，在service依赖的每一个dao上进行@Resource完成dao的注入;\n◇利用注解进行事务的配置，则只需将声明式注解@Transactional放在需要的类上,说明事务配置应用于当前类所有方法，默认事务传播为REQUIRED；也可以自行设置@Transactional(propagation = Propagation.REQUIRED);\n当然对于不同的方法，也可以进行不同的设置，只需在方法上进行注解配置即可；例如在查询的方法上选择不使用事务，并且只读；\n```java\n@Service\n//声明式事务核心注解\n//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED\n@Transactional\npublic class EmployeeService {\n    @Resource\n    private EmployeeDao employeeDao;\n    @Resource\n    private BatchService batchService;\n\n    @Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true)\n    public Employee findById(Integer eno){\n        return employeeDao.findById(eno);\n    }\n```\n\n","tags":["Spring"],"categories":["Spring","Spring基础"]},{"title":"Spring AOP面向切面编程","url":"/p/7cef.html","content":"## 课程介绍 \n◇ 介绍Spring AOP与相关概念名词 \n◇ Spring AOP开发与配置流程 \n◇ Spring 五种通知类型与应用场景  \n## Spring中的可插拔组件技术  \n◇假设软件模块A是系统的用户管理模块，B是系统的员工管理模块，这两个模块都有自己的各种各样的员工业务逻辑类，执行过程从上到下。要求：两个模块从上到下处理业务的过程中，都要进行权限过滤，只有拥有权限的用户才能进入对应的模块；实现方法：利用面向切面编程技术；所谓面向切面编程就是指在软件运行过程中，在执行前或者执行后都可以额外增加相应的扩展功能(称之为切面，Aspect)，如下图的权限切面和日志切面；\n![image.png](SpringAOP面向切面编程/1633054465138-34c81581-9016-4f4d-9afb-d3be05dc9924.png)\n\n## Spring AOP \n◇Spring AOP - Aspect Oriented Programming 面向切面编程 \n◇AOP的做法是将通用、与业务无关的功能抽象封装为切面类 \n◇切面可配置在目标方法的执行前、后运行，真正做到即插即用  \n◇在不修改源码的情况下对程序行为进行扩展\n## 初识AOP编程\n◇业务背景：在工程中有员工和用户两个service及dao；现在需要在service和dao的方法执行之前在控制台打印它们各自执行的时间(不是指时间大小)，通过这些信息我们可以知道在一天什么时间段是应用程序负载最高的时刻；如果采用直接在执行方法前打印输出系统时间，由于程序有很多类，类中也有很多方法，所以这个方法过于繁琐，因此采用Spring AOP技术，在这些方法执行前进行拦截，先打印时间，然后再去执行方法内部的方法；具体项目见AOP/s01\n◇pom.xml核心配置\n\n```java\n<dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n        <!--aspectjweaver是Spring AOP的底层依赖-->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.5</version>\n        </dependency>\n    </dependencies>\n```\n◇创建aspect包，在其下创建MethodAspect类用于扩展功能编写\n```java\npackage com.lcg.spring.aop.aspect;\n\nimport org.aspectj.lang.JoinPoint;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n//切面类\npublic class MethodAspect {\n    //切面方法,用于扩展额外功能\n    //JoinPoint 连接点,通过连接点可以获取目标类/方法的信息\n    public void printExecutionTime(JoinPoint joinPoint){\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n        String now = sdf.format(new Date());\n        String className = joinPoint.getTarget().getClass().getName();//获取目标类的名称\n        String methodName = joinPoint.getSignature().getName();//获取目标方法名称\n        System.out.println(\"---->\" + now + \":\" + className + \".\" + methodName);\n        Object[] args = joinPoint.getArgs();//获取到传入目标方法的参数\n        System.out.println(\"---->参数个数:\" + args.length);\n        for(Object arg:args){\n            System.out.println(\"---->参数:\" + arg);\n        }\n    }\n\n    public void doAfterReturning(JoinPoint joinPoint,Object ret){\n        System.out.println(\"<----返回后通知:\" + ret);\n    }\n    public void doAfterThrowing(JoinPoint joinPoint,Throwable th){\n        System.out.println(\"<----异常通知:\" + th.getMessage());\n    }\n    public void doAfter(JoinPoint joinPoint){\n        System.out.println(\"<----触发后置通知\");\n    }\n}\n\n```\n◇在applicationContext中配置（开头部分schema不同于以前的配置，需要添加一部分）\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <bean id=\"userDao\" class=\"com.lcg.spring.aop.dao.UserDao\"/>\n    <bean id=\"employeeDao\" class=\"com.lcg.spring.aop.dao.EmployeeDao\"/>\n    <bean id=\"userService\" class=\"com.lcg.spring.aop.service.UserService\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n    <bean id=\"employeeService\" class=\"com.lcg.spring.aop.service.EmployeeService\">\n        <property name=\"employeeDao\" ref=\"employeeDao\"/>\n    </bean>\n    <!-- AOP配置 -->\n    <bean id=\"methodAspect\" class=\"com.lcg.spring.aop.aspect.MethodAspect\"></bean>\n    <aop:config>//此标签由AOP命名空间提供\n        <!-- PointCut 切点,使用execution表达式描述切面的作用范围 -->\n        <!-- execution(public * com.lcg..*.*(..)) 说明切面作用在com.lcg包下的所有类的所有方法上 -->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(public * com.lcg..*.*(..))\"></aop:pointcut>-->\n        <!--只对所有Service类生效-->\n        <aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*Service.*(..))\"></aop:pointcut>\n        <!--只对所有返回值为String类型方法生效-->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(String com.lcg..*Service.*(..))\"></aop:pointcut>-->\n        <!--对方法名进行约束 -->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*Service.create*(..))\"></aop:pointcut>-->\n        <!-- 对参数进行约束 -->\n        <!--<aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*Service.*(String,*))\"></aop:pointcut>-->\n        \n        <!-- 定义切面类 让IOC容器认为这个bean是一个切面类-->\n        <aop:aspect ref=\"methodAspect\">\n            <!-- before前置通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() -->\n            <aop:before method=\"printExecutionTime\" pointcut-ref=\"pointcut\"/>//pointcut-ref指向定义的切点;        \n        </aop:aspect>\n    </aop:config>\n</beans>\n```\n## AOP关键概念 \n### Spring AOP与AspectJ的关系  \n◇Eclipse AspectJ,一种基于Java平台的面向切面编程的语言 \n◇Spring AOP使用了AspectJ切入点匹配功能 \n◇Spring AOP利用代理技术实现对象运行时功能扩展  \n### 几个关键概念\n![image.png](SpringAOP面向切面编程/1633086185761-39f8cae3-34da-48c9-8ea6-3f720722d114.png)\n### AOP配置过程\n◇依赖Aspect                                  ◇实现切面类和切面方法\n◇配置Aspect Bean                         ◇定义PointCut\n◇配置Advice\n### JoinPoint核心方法\n![image.png](SpringAOP面向切面编程/1633088659918-690d3c9d-3b43-43b2-97c5-cbc47ec7214a.png)\n## PointCut切点表达式\n◇完整方法的描述：         public void com.lcg.service.UserService.createUser(形参1，形参2，...)\n◇切点表达式：execution(public   *    com.lcg      ..             *       .        *         (            ..              ) )\n◇ * - 通配符    .. - 包通配符      (..) - 参数通配符\n◇切点表达式的含义：去匹配com.lcg包下所有类的所有公用方法；\n◇(*,*)-代表两个参数；  *可以替换为string\n## 五种通知类型\n### 归纳\n![image.png](SpringAOP面向切面编程/1633086260010-1fe93912-8ac0-4246-8adf-4d07b8500275.png)\n### 特殊的\"通知\" - 引介增强\n◇引介增强(IntroductionInterceptor)是对类的增强，而非方法\n◇引介增强允许在运行时为类目标增加新属性或方法\n◇引介增强允许在运行时改变类的行为，让类随运行环境动态变更\n### 代码示例\n◇目标方法\n```java\npublic void doAfterReturning(JoinPoint joinPoint,Object ret){\n        System.out.println(\"<----返回后通知:\" + ret);\n    }\n    public void doAfterThrowing(JoinPoint joinPoint,Throwable th){\n        System.out.println(\"<----异常通知:\" + th.getMessage());\n    }\n    public void doAfter(JoinPoint joinPoint){\n        System.out.println(\"<----触发后置通知\");\n    }\n```\n◇配置\n```java\n<aop:aspect ref=\"methodAspect\">\n            <!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() -->\n            <aop:before method=\"printExecutionTime\" pointcut-ref=\"pointcut\"/>\n            <!--返回后通知,returning表示哪个参数接收目标方法的返回值-->\n            <aop:after-returning method=\"doAfterReturning\" returning=\"ret\" pointcut-ref=\"pointcut\"/>\n            <!--异常通知-->\n            <aop:after-throwing method=\"doAfterThrowing\" throwing=\"th\" pointcut-ref=\"pointcut\"/>\n            <!--最后通知，目标方法运行后执行-->\n            <aop:after method=\"doAfter\" pointcut-ref=\"pointcut\"></aop:after>\n        </aop:aspect>\n```\n## 详解环绕通知(Around Advice)\n### 利用AOP进行方法性能筛选\n◇案例背景，在实际工作中可能遇到这种情况：由于不断的数据累积，用户量的增大，可能会导致我们生产环境中系统越来越慢，那我们如何定位到是哪一个方法运行慢呢？解决方法：利用AOP技术在方法执行前以及执行后记录时间，两相减即为执行时长，把超过指定时长的方法输出到日志中去；但由于需要记录一前一后两个时间，所以采用环绕通知来实现；\n### 代码示例(AOP/S02)\n◇切面类\n```java\npackage com.lcg.spring.aop.aspect;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class MethodChecker {\n    ////ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行\n    public Object check(ProceedingJoinPoint pjp) throws Throwable {\n        try {\n            long startTime = new Date().getTime();\n            Object ret = pjp.proceed();//执行目标方法,返回的对象ret即为目标方法的返回值\n            long endTime = new Date().getTime();\n            long duration = endTime - startTime; //执行时长\n            if(duration >= 1000){\n                String className = pjp.getTarget().getClass().getName();\n                String methodName = pjp.getSignature().getName();\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n                String now = sdf.format(new Date());\n                System.out.println(\"=======\" + now + \":\" + className + \".\" + methodName + \"(\" + duration + \"ms)======\");\n            }\n            return ret;//返回\n        } catch (Throwable throwable) {\n            System.out.println(\"Exception message:\" + throwable.getMessage());\n            throw throwable;//直接抛出异常\n        }\n    }\n}\n\n```\n◇配置\n```java\n<aop:config>\n    <aop:pointcut id=\"pointcut\" expression=\"execution(* com.lcg..*.*(..))\"></aop:pointcut>\n    <aop:aspect ref=\"methodChecker\">\n        <!--环绕通知-->\n        <aop:around method=\"check\" pointcut-ref=\"pointcut\"/>\n    </aop:aspect>\n</aop:config>\n```\n◇应用程序入口\n```java\npublic class SpringApplication {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        UserService userService = context.getBean(\"userService\", UserService.class);\n        userService.createUser();\n    }\n}\n```\n## 利用注解配置Spring AOP\n**代码示例(AOP/S03)**\n◇pom.xml加载jar包，完成底层依赖；\n◇applicationContext配置文件增加注解相关的配置\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <!--组件扫描,初始化IoC容器-->\n    <context:component-scan base-package=\"com.lcg\"/>\n    <!--启用Spring AOP注解模式-->\n    <aop:aspectj-autoproxy/>\n</beans>\n```\n◇将dao类以及service类进行上节课ioc注解相关的配置，如@Repository和@Service等\n◇切面类注解\n```java\npackage com.lcg.spring.aop.aspect;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n@Component //标记当前类为组件\n@Aspect //说明当前类是切面类\npublic class MethodChecker {\n    //环绕通知,参数为PointCut切点表达式\n    @Around(\"execution(* com.lcg..*Service.*(..))\")\n    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行\n    public Object check(ProceedingJoinPoint pjp) throws Throwable {\n        try {\n            long startTime = new Date().getTime();\n            Object ret = pjp.proceed();//执行目标方法\n            long endTime = new Date().getTime();\n            long duration = endTime - startTime; //执行时长\n            if(duration >= 1000){\n                String className = pjp.getTarget().getClass().getName();\n                String methodName = pjp.getSignature().getName();\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n                String now = sdf.format(new Date());\n                System.out.println(\"=======\" + now + \":\" + className + \".\" + methodName + \"(\" + duration + \"ms)======\");\n            }\n            return ret;\n        } catch (Throwable throwable) {\n            System.out.println(\"Exception message:\" + throwable.getMessage());\n            throw throwable;\n        }\n    }\n}\n\n```\n## 代理模式\n### Spring AOP实现原理\n◇Spring基于代理模式实现功能动态扩展，包含两种形式\n◇目标类拥有接口，通过JDK动态代理实现功能扩展\n◇目标类没有接口，通过CGLib组件实现功能扩展\n### 静态代理\n◇代理模式通过代理对象对原对象的实现功能扩展\n◇所谓代理模式，其核心理念是实现一个代理类，在代理类中持有最原始的委托类；代理类和委托类实现共同的接口；而客户通过代理类来完成所需的功能\n![image.png](SpringAOP面向切面编程/1633227288993-6f02aa5f-5d59-4c02-ad4b-52ad7c10b046.png)\n**代码演示(AOP/S04)**\n◇创建接口UserService\n\n```java\npublic interface UserService {\n    public void createUser();\n}\n```\n◇创建接口的实现类UserServiceImpl（委托类）\n```java\npublic class UserServiceImpl implements UserService{\n    public void createUser() {\n        System.out.println(\"执行创建用户业务逻辑\");\n    }\n}\n```\n◇案例背景：现在需要将方法执行的时间打印出来，在前面已经讲过Spring AOP技术来实现。但是在代理模式中如何实现呢？如果要实现这个功能的扩展就必须基于UserService接口创建对应的代理类，同时在代理类中去持有与之对应的具体实现；\n◇创建UserServiceProxy（代理类）\n```java\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n//静态代理是指必须手动创建代理类的代理模式使用方式\npublic class UserServiceProxy implements UserService{\n    //持有委托类的对象\n    private UserService userService ;\n    //创建代理对象的时候，通过外侧传入某一个UserService的实现类为内部的委托类赋值，相当于持有委托类\n    public UserServiceProxy(UserService userService){\n        this.userService = userService;\n    }\n\n    public void createUser() {\n        System.out.println(\"=====\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\").format(new Date()) +\"=========\");\n        userService.createUser();\n    }\n}\n```\n◇主程序（客户）\n```java\npublic class Application {\n    public static void main(String[] args) {\n        UserService userService = new UserServiceProxy(new UserServiceImpl());\n        userService.createUser();\n    }\n}\n```\n◇代理模式是可以嵌套使用的，因此在代理类的构造方法中参数为接口类的某一个实现而非具体的接口实现类UserServiceImpl；嵌套使用案例：再创建一个代理类，实现一些后置功能，然后在这个代理类中传入参数为另一个代理类的实现；**new **UserServiceProxy1(**new **UserServiceProxy(**new **UserServiceImpl()))因为参数不管是什么对象，只要实现了接口类即可；缺点：随着功能的不断扩大，每一个具体的实现类都至少拥有一个代理类，这种方式称为静态代理。\n### JDK动态代理\n◇静态代理与动态代理最显著的区别是静态代理必须手动创建代理类，而动态代理根据接口的结构运行时在内存中进行生成。\n**代码实现（AOP/S05）**\n◇EmployeeService接口\n```java\npublic interface EmployeeService {\n    public void createEmployee();\n}\n```\n◇EmployeeServiceImpl实现类\n```java\npublic class EmployeeServiceImpl implements EmployeeService {\n    public void createEmployee() {\n        System.out.println(\"执行创建员工业务逻辑\");\n    }\n}\n```\n◇创建ProxyInvocationHandler类，实现重要的接口InvocationHandler\n```java\n/**\n * InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强\n * InvocationHandler实现类与切面类的环绕通知类似\n */\npublic class ProxyInvocationHandler implements InvocationHandler {\n    private Object target;//目标对象\n    private ProxyInvocationHandler(Object target){\n        this.target = target;\n    }\n    /**\n     * 必须实现这个invoke()方法\n     * 在invoke()方法对目标方法进行增强\n     * @param proxy 代理类对象\n     * @param method 目标方法对象\n     * @param args 目标方法实参\n     * @return 目标方法运行后返回值\n     * @throws Throwable 目标方法抛出的异常\n     */\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"=====\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\").format(new Date()) +\"=========\");\n        Object ret = method.invoke(target, args);//调用目标方法,相当于ProceedingJoinPoint.proceed()\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        UserService userService = new UserServiceImpl();\n        ProxyInvocationHandler invocationHandler = new ProxyInvocationHandler(userService);\n        //动态创建代理类\n        /*newProxyInstance方法基于接口动态创建代理类,三个参数（类加载器，类要实现的接口，如何对目标方法进行扩展）*/\n        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),\n                userService.getClass().getInterfaces(),\n                invocationHandler);\n        userServiceProxy.createUser();\n\n        //动态代理,必须实现接口才可以运行\n        EmployeeService employeeService = new EmployeeServiceImpl();\n        EmployeeService employeeServiceProxy = (EmployeeService)Proxy.newProxyInstance(employeeService.getClass().getClassLoader(),\n                employeeService.getClass().getInterfaces(),\n                new ProxyInvocationHandler(employeeService));\n        employeeServiceProxy.createEmployee();\n    }\n}\n```\n### JDK动态代理解析\n◇[CSDN参考链接](https://jiankunking.blog.csdn.net/article/details/52143504)\n◇Proxy是JDK反射包提供的类，其作用是根据已有接口来生成对应的代理类。\n\n![image-20220223204518735](SpringAOP面向切面编程/image-20220223204518735.png)\n\n### CGLib实现代理类\n◇CGLib是运行时字节码增强技术\n◇Spring AOP扩展无接口类使用CGLib\n◇AOP会运行时生成目标继承类字节码的方式进行行为扩展\n◇如下图，假设有一个最原始的Service类，类中有一个findById()方法;该Service类没有实现任何接口，因此无法实现JDK的动态代理。Spring会自动使用CGLib通过继承的方式来对类进行扩展。这个类是在jvm运行过程中自动生成的，生成规则是：原类名+$$+EnhancerByCGLIB\n![image.png](SpringAOP面向切面编程/1633250112821-72b8f05b-0992-4d48-95a4-208734a4e2dd.png)\n\n","tags":["Spring"],"categories":["Spring","Spring基础"]},{"title":"Spring Ioc容器与Bean管理","url":"/p/ddb.html","content":"## 内容说明\n### Spring loC\n![image.png](SpringIoc容器与Bean管理/1630934849961-68c37275-c326-42dd-8c9f-76cfafd3018f.png)\n### Spring AOP\n![image.png](SpringIoc容器与Bean管理/1630934894951-889d3e71-8aa4-4b9e-9d01-59f2309a0ead.png)\n### Spring JDBC与声明式事务\n![image.png](SpringIoc容器与Bean管理/1630934966182-c5242625-3f9e-4dca-bb7f-b9c938d16a41.png)\n## 课程介绍 \n◇Spring快速入门              ◇Spring XML配置 \n◇对象实例化配置             ◇依赖注入配置 \n◇注解与Java Config         ◇Spring 单元测试  \n## Spring 快速入门 \n### 生活中的烦恼   \n◇苹果这个对象的控制权是由客户发起的，客户必须掌握所有对象的特征细节后才能做出选择；\n![image.png](SpringIoc容器与Bean管理/1630896908927-dca53881-2a3f-4257-a25b-b18849a33964.png)\n\n### 现实中的商机 \n◇客户将获取对象的权利交个水果摊老板，有老板替顾客做出选择；\n![image.png](SpringIoc容器与Bean管理/1630896927455-4bbc1576-c9c6-4121-87fa-8faeba7edb6a.png)\n\n### IoC控制反转 \n◇IoC控制反转,全称Inverse of Control,是一种设计理念 \n◇由代理人来创建与管理对象,消费者通过代理人来获取对象 \n◇IoC的目的是降低对象之间直接耦合   \n◇对象直接引用导致对象硬性关联，程序难以扩展维护 \n![image.png](SpringIoc容器与Bean管理/1630896883840-020fd28b-142f-4a04-a184-3ff5e61c3694.png)\n◇ 加入IoC容器将对象统一管理，让对象关联变为弱耦合  \n![image.png](SpringIoc容器与Bean管理/1630897013449-8f132662-7b2a-46a3-9c48-86b23d169e58.png)\n\n### DI依赖注入 \n◇IoC是设计理念,是现代程序设计遵循的标准,是宏观目标 \n◇DI(Dependency Injection)是具体技术实现,是微观实现 \n◇DI在Java中利用反射技术实现对象注入(Injection)  \n\n## Spring  \n[官网](https://spring.io/)\n### Spring的含义 \n◇Spring可从狭义与广义两个角度看待 \n◇狭义的Spring是指Spring框架(Spring Fremework) \n◇广义的Spring是指Spring生态体系 \n\n### 狭义的Spring框架 \n◇Spring框架是企业开发复杂性的一站式解决方案 \n◇Spring框架的核心是IoC容器与AOP面向切面编程 \n◇Spring IoC负责创建与管理系统对象，并在此基础上扩展功能 \n### 广义的Spring生态体系   \n![image.png](SpringIoc容器与Bean管理/1630936934175-c8cf8bd3-8a1a-4b42-b5c9-2aca583eb41b.png)\n### 传统开发方式 \n◇对象直接引用导致对象硬性关联，程序难以扩展维护  \n![image.png](SpringIoc容器与Bean管理/1630897484380-d37f95ca-a896-4b39-8386-450ce02a9638.png)\n\n### Spring IoC容器 \n◇IoC容器是Spring生态的地基,用于统一创建与管理对象依赖  \n![image.png](SpringIoc容器与Bean管理/1630897523216-2350d7a4-dc59-41b0-a257-85960d5a2356.png)\n\n### Spring IoC容器职责 \n◇对象的控制权交由第三方统一管理(IoC控制翻转) \n◇利用Java反射技术实现运行时对象创建与关联(DI依赖注入) \n◇基于配置提高应用程序的可维护性与扩展性 \n### Spring IoC初体验 \n◇妈妈在早餐后给三个孩子分发餐后水果 \n◇盘子里装有三个苹果: 红富士/青苹果/金帅 \n◇孩子们口味不同: 莉莉喜欢甜的/安迪喜欢酸的/露娜喜欢软的  \n## 代码示例\n#### 传统代码\n --实体类\n```java\npublic class Apple {\n    private String title;\n    private String color;\n    private String origin;\n               ...\n }\n\npublic class Child {\n    private String name;\n    private Apple apple;\n    ...\n    public void eat(){\n        System.out.println(name+\"吃到了\"+apple.getOrigin()+\"种植的\"+apple.getTitle());\n    }\n}\n```\n --应用入口\n```java\npublic class Application {\n    public static void main(String[] args) {\n        Apple a1 = new Apple(\"红富士\", \"红色\", \"欧洲\");\n        Apple a2 = new Apple(\"青苹果\", \"绿色\", \"中亚\");\n        Apple a3 = new Apple(\"金帅\", \"黄色\", \"中国\");\n        Child lily = new Child(\"莉莉\", a1);\n        Child andy = new Child(\"安迪\", a2);\n        Child luna = new Child(\"露娜\", a3);\n        lily.eat();\n        andy.eat();\n        luna.eat();\n    }\n}\n```\n◇缺点分析：①苹果的描述写死在代码中，若描述改变需要修改源代码；②对象的数量固定的，若要新增对象需要修改源代码，程序的可维护性，可扩展性不足；③对象是硬关联的，每个孩子喜欢的苹果不同则需要修改源码，比较死板；\n#### Spring Ioc\n◇加载配置\n```java\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n    </dependencies>\n```\n◇applicationContext.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--在IoC容器启动时，自动有Spring实例化Apple对象，取名sweetApple放入到容器中-->\n    <bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"红富士\"></property>\n        <property name=\"origin\" value=\"欧洲\"></property>\n        <property name=\"color\" value=\"红色\"></property>\n    </bean>\n    <bean id=\"sourApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"青苹果\"></property>\n        <property name=\"origin\" value=\"中亚\"></property>\n        <property name=\"color\" value=\"绿色\"></property>\n    </bean>\n    <bean id=\"softApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"金帅\"></property>\n        <property name=\"origin\" value=\"中国\"></property>\n        <property name=\"color\" value=\"黄色\"></property>\n    </bean>\n    <!--孩子 -->\n    <bean id=\"lily\" class=\"com.lcg.spring.ioc.entity.Child\">\n        <property name=\"name\" value=\"lily\"/>\n        <property name=\"apple\" ref=\"sweetApple\"/>\n    </bean>\n    <bean id=\"andy\" class=\"com.lcg.spring.ioc.entity.Child\">\n        <property name=\"name\" value=\"andy\"/>\n        <property name=\"apple\" ref=\"sourApple\"/>\n    </bean>\n    <bean id=\"luna\" class=\"com.lcg.spring.ioc.entity.Child\">\n        <property name=\"name\" value=\"luna\"/>\n        <property name=\"apple\" ref=\"softApple\"/>\n    </bean>\n</beans>\n```\n◇应用接口\n```java\npublic class SpringApplication {\n    public static void main(String[] args) {\n        //加载指定的配置文件\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        Apple sweetApple = context.getBean(\"sweetApple\", Apple.class);\n        System.out.println(sweetApple.getTitle());\n        //从IoC容器中提取beanId=lily的对象\n        Child lily = context.getBean(\"lily\", Child.class);\n        Child andy = context.getBean(\"andy\", Child.class);\n        Child luna = context.getBean(\"luna\", Child.class);\n        lily.eat();\n        andy.eat();\n        luna.eat();\n    }\n```\n◇这样，通过Ioc容器，将程序代码转变为配置文本，维护性更好，让对象与对象之间有效的解耦\n## XML管理对象(Bean)  \n### 三种配置方式 \n◇基于XML配置Bean        \n◇基于注解配置Bean         \n◇基于Java代码配置Bean  \n###  applicationContext.xml  \n```java\n<bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n <property name=\"title\" value=\"红富士\"></property>\n <property name=\"origin\" value=\"欧洲\"></property>\n <property name=\"color\" value=\"红色\"></property>\n</bean>\n```\n### XML方式创建IoC容器  \n```java\n//创建IoC容器并根据配置文件创建对象\nApplicationContext context = new \nClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n```\n### Spring框架组成模块  \n◇四层，核心为第二层\n![image.png](SpringIoc容器与Bean管理/1630897823185-2161c56c-32a7-4329-9432-24b4449a80e0.png)\n\n### ApplicationContext实现类 \n◇ClassPathXmlApplicationContext \n◇AnnotationConfigApplicationContext \n◇WebApplicationContext \n\n### 实例化Bean的三种方式 \n◇基于构造方法对象实例化 \n◇基于静态工厂实例化 \n◇基于工厂实例方法实例化  \n#### 构造方法实例化对象 \n```java\npublic Apple(String title,Stirng color,String origin){\n    System.out.println(\"通过带参构造方法创建对象,\"+this);\n    this.title=title;\n    this.color=color;\n    this.origin=origin;\n}\n```\n**利用构造方法参数名实例化  **\n◇如果对象不止一个构造函数，则按照对应的参数(个数，类型)来进行设置;\n```java\n<bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\"> \n <!-- 没有constructor-arg则代表调用默认构造方法实例化 -->\n <constructor-arg name=\"title\" value=\"红富士\"/>\n <constructor-arg name=\"origin\" value=\"欧洲\"/> \n <constructor-arg name=\"color\" value=\"红色\"/>\n</bean>\n```\n**利用构造方法参数位置实例化**  \n```java\n<bean id=\"sweetApple\" class=\"com.imooc.spring.ioc.entity.Apple\"> \n <!-- 利用构造方法参数位置实现对象实例化 -->\n <constructor-arg index=\"0\" value=\"红富士\"/>\n <constructor-arg index=\"1\" value=\"红色\"/>\n <constructor-arg index=\"2\" value=\"欧洲\"/>\n</bean>\n```\n#### 工厂模式实例化对象 \n◇创建工厂类\n  --创建静态工厂类AppleStaticFactory,使得创建对象的代码被隐藏，主要目的是在ioc容器之外通过程序的形式组织对象；好处：可以在创建对象的过程中赋予额外的行为(如日志输出等),\n```java\n/**\n * 静态工厂通过静态方法创建对象，隐藏创建对象的细节\n */\npublic class AppleStaticFactory {\n    public static Apple createSweetApple(){\n        Apple apple = new Apple();\n        apple.setTitle(\"红富士\");\n        apple.setOrigin(\"欧洲\");\n        apple.setColor(\"红色\");\n        return apple;\n    }\n}\n```\n--在applicationContext.xml中配置\n```java\n    <!--利用静态工厂获取对象，加上工厂方法-->\n    <bean id=\"apple4\" class=\"com.lcg.spring.ioc.factory.AppleStaticFactory\"\n          factory-method=\"createSweetApple\"/>\n```\n#### 工厂实例：在ioc容器中对工厂进行实例化\n --在factory中创建AppleFactoryInstance（苹果工厂实例）\n```java\n\n/**\n * 工厂实例方法创建对象是指Ioc容器对工厂类进行实例化并调用相应的实例方法创建对象的过程\n */\npublic class AppleFactoryInstance {\n    public  Apple createSweetApple(){\n        Apple apple = new Apple();\n        apple.setTitle(\"红富士\");\n        apple.setOrigin(\"欧洲\");\n        apple.setColor(\"红色\");\n        return apple;\n    }\n}\n```\n --在Ioc容器中进行实例化和使用\n```java\n<!-- 利用工厂实例方法获取对象-->\n    <bean id=\"factoryInstance\" class=\"com.lcg.spring.ioc.factory.AppleFactoryInstance\"/>\n    <bean id=\"apple5\" factory-bean=\"factoryInstance\" factory-method=\"createSweetApple\"/>\n```\n## 从IoC容器获取Bean  \n```java\n//第一个参数BeanId，第二个Bean的实际类型\nApple sweetApple = context.getBean(\"sweetApple\" , Apple.class);\n//或者单参数方法，进行强制转换\nApple sweetApple = (Apple)context.getBean(\"sweetApple\");\n//打印输出\nSystem.out.println(sweetApple.getTitle());\n```\n### id与name属性相同点 \n◇bean id与bean name都是设置对象在IoC容器中唯一标识 \n◇两者在同一个配置文件中都不允许出现重复 \n◇两者允许在多个配置文件中出现重复,新对象覆盖旧对象 \n### id与name属性区别\n◇id要求更为严格,一次只能定义一个对象标识(推荐)\n◇name更为宽松,一次允许定义多个对象标识：name=apple1,apple2，...\n◇tips: id与name的命名要求有意义,按驼峰命名书写 \n◇当没有id与name的bean默认使用类名全称作为bean标识\n## 路径匹配表达式  \n### 加载单个配置文件  \n◇路径表达式用于加载配置文件\n```java\n//创建IoC容器并根据配置文件创建对象\nApplicationContext context = new \nClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");//参数即路径表达式\n\n```\n### 加载多个配置文件\n```java\nString[] configLocations = new \n String[]{\"classpath:applicationContext.xml\"\n ,\"classpath:applicationContext-1.xml\"};\nApplicationContext context = new \nClassPathXmlApplicationContext(configLocations);\n```\n### 路径表达式  \n![image.png](SpringIoc容器与Bean管理/1630911452907-cd3d11a0-5a18-48c6-acfb-8bd4d8605996.png)\n## 对象依赖注入  \n![image.png](SpringIoc容器与Bean管理/1630911749557-eddc3615-b954-41fc-b63d-41d88b26d3fd.png)\n◇依赖注入是指运行时将容器内对象利用反射赋给其他对象的操作,即将两个对象关联起来\n◇基于setter方法注入对象 \n◇基于构造方法注入对象  \n\n### 利用setter实现静态数值注入  \n```java\n<bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n<!--IoC容器自动利用反射机制运行时调用setXXX方法给属性赋值 -->\n <property name=\"title\" value=\"红富士\"/>\n <property name=\"color\" value=\"红色\"/>\n <property name=\"origin\" value=\"欧洲\"/>\n</bean>\n```\n### 利用setter实现对象注入 \n```java\n<bean id=\"lily\" class=\"com.lcg.spring.ioc.entity.Child\">\n <property name=\"name\" value=\"莉莉\"/>\n <!--利用ref注入依赖对象 -->\n <property name=\"apple\" ref=\"sweetApple\"/>//属性ref代表\"关联\"\n</bean>\n```\n### IoC在实际项目中的应用\n◇创建两个配置文件applicationContext-dao.xml和applicationContext-service.xml供两名员工开发，前者主要有实习生来实现，因为比较简单，而后者是核心文件，需要有经验的工程师进行开发。\n◇创建BookDao接口\n```java\npackage com.lcg.spring.ioc.bookshop.dao;\npublic interface BookDao {\n    public void insert();\n}\n```\n◇创建BookImpl实现类\n```java\npackage com.lcg.spring.ioc.bookshop.dao;\npublic class BookDaoImpl implements BookDao {\n    public void insert(){\n        System.out.println(\"向MySQL Book表插入一条数据\");\n    }\n}\n```\n◇创建BookService\n```java\npackage com.lcg.spring.ioc.bookshop.service;\n\nimport com.lcg.spring.ioc.bookshop.dao.BookDao;\n\npublic class BookService {\n    private BookDao bookDao;\n    public void purchase(){\n        System.out.println(\"正在执行图书采购业务方法\");\n        bookDao.insert();\n    }\n\n    public BookDao getBookDao() {\n        return bookDao;\n    }\n\n    public void setBookDao(BookDao bookDao) {\n        this.bookDao = bookDao;\n    }\n}\n```\n◇配置applicationContext-dao.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"bookDao\" class=\"com.lcg.spring.ioc.bookshop.dao.BookDaoImpl\">\n\n    </bean>\n</beans>\n```\n◇配置applicationContext-service.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"bookService\" class=\"com.lcg.spring.ioc.bookshop.service.BookService\">\n        <!--两个开发人员以这种id=bookDao的约定方式来进行对象的关联\n        这样能够实现两者开发互不干扰，如果要进行换数据库的话，只需要\n        更改dao配置文件就行了\n        -->\n        <property name=\"bookDao\" ref=\"bookDao\"/>\n    </bean>\n</beans>\n```\n### 基于构造方法注入对象 \n◇使用Child类的构造方法\n```java\npublic Child(String name,Apple apple){\n    this.name=name;\n    this.apple=apple;\n}\n```\n ◇在applicationContext.xml中进行配置\n```java\n<bean id=\"sourApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"青苹果\"></property>\n        <property name=\"origin\" value=\"中亚\"></property>\n        <property name=\"color\" value=\"绿色\"></property>\n</bean>\n<bean id=\"andy\" class=\"com.lcg.spring.ioc.entity.Child\">\n     <constructor-arg name=\"name\" value=\"安迪\"/> //name表示参数，value表示赋值\n     //利用反射技术将sourApple苹果对象做为参数传入带参构造函数中\n     <constructor-arg name=\"apple\" ref=\"sourApple\"/>  //ref用于关联sourApple\n</bean>\n```\n### 注入集合对象 \n ◇注入List  \n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someList\">\n <list>\n <value>具体值</value>\n <ref bean=\"beanId\"></ref>\n </list>\n </property>\n</bean>\n```\n◇ 注入Set  \n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someSet\">\n <set>\n <value>具体值</value>\n <ref bean=\"beanId\"></ref>\n </set>\n </propery>\n</bean>\n```\n ◇注入Map  \n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someMap\">\n <map>//子标签\n <entry key=\"k1\" value=\"v1\"></entry>//每一个entry就相当于一个键值对\n <entry key=\"k2\" value-ref=\"beanId\"></entry>\n </map>\n </property>\n</bean>\n```\n◇ 注入Properties （属性类型）\n```java\n<bean id=\"...\" class=\"...\">\n <property name=\"someProperties\">\n <props>\n <prop key=\"k1\">v1</prop>//key和value必须是字符串\n <prop key=\"k2\">v2</prop>\n </props>\n </property>\n</bean>\n```\n### 案例-公司资产清单\n◇创建Computer类（作为公司资产）\n```java\npackage com.lcg.spring.ioc.entity;\n\npublic class Computer {\n    private String brand;\n    private String type;\n    private String sn;\n    private Float price;\n    public Computer() {\n    }\n\n    public Computer(String brand, String type, String sn, Float price) {\n        this.brand = brand;\n        this.type = type;\n        this.sn = sn;\n        this.price = price;\n    }\n     //...get&set..\n    //重写toString方便程序演示\n    @Override\n    public String toString() {\n        return \"Computer{\" +\n                \"brand='\" + brand + '\\'' +\n                \", type='\" + type + '\\'' +\n                \", sn='\" + sn + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n\n```\n◇创建公司类\n```java\npackage com.lcg.spring.ioc.entity;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class Company {\n    private Set<String> rooms;\n    private Map<String,Computer> computers;\n    private Properties info;\n    //...get&set..\n    @Override\n    public String toString() {\n        return \"Company{\" +\n                \"rooms=\" + rooms +\n                \", computers=\" + computers +\n                \", info=\" + info +\n                '}';\n    }\n}\n```\n◇applicationContext配置\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"c1\" class=\"com.lcg.spring.ioc.entity.Computer\">\n        <constructor-arg name=\"brand\" value=\"联想\"/>\n        <constructor-arg name=\"type\" value=\"台式机\"/>\n        <constructor-arg name=\"sn\" value=\"8389283012\"/>\n        <constructor-arg name=\"price\" value=\"3085\"/>\n    </bean>\n\n    <bean class=\"com.lcg.spring.ioc.entity.Computer\">\n        <constructor-arg name=\"brand\" value=\"微星\"/>\n        <constructor-arg name=\"type\" value=\"台式机\"/>\n        <constructor-arg name=\"sn\" value=\"8389280012\"/>\n        <constructor-arg name=\"price\" value=\"3000\"/>\n    </bean>\n\n    <bean class=\"com.lcg.spring.ioc.entity.Computer\">\n        <constructor-arg name=\"brand\" value=\"华硕\"/>\n        <constructor-arg name=\"type\" value=\"笔记本\"/>\n        <constructor-arg name=\"sn\" value=\"9089380012\"/>\n        <constructor-arg name=\"price\" value=\"6000\"/>\n    </bean>\n\n    <bean id=\"company\" class=\"com.lcg.spring.ioc.entity.Company\">\n        <property name=\"rooms\">\n            <set>//set集合不允许出现重复数据，会自动去重\n                <value>2001-总裁办</value>\n                <value>2003-总经理办公室</value>\n                <value>2010-研发部会议室</value>\n                <value>2010-研发部会议室</value>\n            </set>\n        </property>\n        <property name=\"computers\">\n            <map>\n                <!--方法一、使用value-ref，前提是bean c1已创建-->\n                <entry key=\"dev-88172\" value-ref=\"c1\"/>\n                <!--方法二、使用内置bean，不用额外创建,但这个bean对象只能用于此处-->\n                <entry key=\"dev-88173\">\n                    <bean class=\"com.lcg.spring.ioc.entity.Computer\">\n                        <constructor-arg name=\"brand\" value=\"联想\"/>\n                        <constructor-arg name=\"type\" value=\"笔记本\"/>\n                        <constructor-arg name=\"sn\" value=\"1280258012\"/>\n                        <constructor-arg name=\"price\" value=\"5060\"/>\n                    </bean>\n                </entry>\n            </map>\n        </property>\n\n        <property name=\"info\">\n            <props>//只允许字符串\n                <prop key=\"phone\">010-12345678</prop>\n                <prop key=\"address\">北京市朝阳区XX路XX大厦</prop>\n                <prop key=\"website\">http://www.xxx.com</prop>\n            </props>\n        </property>\n    </bean>\n</beans>\n```\n## 查看容器内对象 \n### 获取对象\n◇如何查看容器内有多少对象，写在内部使用的bean不会产生beanID，即无法用此方法获取内部的bean\n```java\n//获取容器内所有beanId数组\nString[] beanNames = context.getBeanDefinitionNames();\n```\n◇获取bean的类型、内容\n```java\nfor (String beanName:beanNames){\n       System.out.println(beanName);\n       //获取类型，首先传入参数beanName,返回object对象,再通过getClass得到类对象,然后得到类名\n       System.out.println(\"类型:\" + context.getBean(beanName).getClass().getName());\n       System.out.println(\"内容:\" + context.getBean(beanName));\n     }\n```\n◇如果没有设置beanID，则默认为类的全名+#+数字序号，若要查看匿名的bean，只输入类的全名只显示第一个匿名的bean，想要具体输出哪一个匿名的bean需要+#+数字序号\n```java\nComputer c1 = context.getBean(\"com.lcg.spring.ioc.entity.Computer#2\", Computer.class);\n```\n### bean scope属性 \n◇bean scope属性用于决定对象何时被创建与作用范围 \n◇bean scope配置将影响容器内对象的数量 \n◇bean scope默认值singleton(单例),指全局共享同一个对象实例\n◇默认情况下bean会在IoC容器创建后自动实例化,全局唯一  \n### scope用法  \n```java\n<bean id=\"bookDao\"\n class=\"com.lcg.spring.ioc.bookshop.dao.BookDaoOracleImpl\"\n scope=\"prototype\" /> //增加scope\n```\n### bean scope属性清单  \n◇bean scope有六个备选值\n![image.png](SpringIoc容器与Bean管理/1630912828587-c5400c8d-c90f-4ec9-a45c-f97e30bd07c0.png)\n\n### singleton单例示意图  \n![image.png](SpringIoc容器与Bean管理/1630912880476-638a2d81-eea8-40f2-8d2a-5aab6bf98b14.png)\n### singleton的线程安全问题  \n◇用户1设置num=1，然后输出\n![image.png](SpringIoc容器与Bean管理/1630913442004-f3433618-87ea-4bfd-969b-8001de77b38c.png)\n◇用户1设置num=1，过了几毫秒，用户2设置num=2，由于全局只有一个对象，所以num=2，且当用户1的输出时，会输出2\n![image.png](SpringIoc容器与Bean管理/1632401257175-2a43283a-7f8d-47cd-a62c-0d6c58f90bba.png)\n\n### prototype多例示意图  \n◇prototype在容器中多实例,占用更多资源,不存在线程安全问题  \n![image.png](SpringIoc容器与Bean管理/1632401691625-447396bc-7cc1-40f6-b7ec-a8aa795a2bba.png)\n\n### singleton与prototype对比  \n![image.png](SpringIoc容器与Bean管理/1632401797814-885953de-835e-47e8-800e-b8fd70c0dc05.png)\n### bean scope的实际应用\n◇对于某一个属性，如果在运行过程中是恒定不变的，就可以设置单例模式。\n◇创建UserDao\n\n```java\npackage com.lcg.spring.ioc.dao;\npublic class UserDao {\n    public UserDao(){\n        System.out.println(\"UserDao已创建:\" + this);\n    }\n}\n```\n◇创建UserService\n```java\npackage com.lcg.spring.ioc.service;\nimport com.lcg.spring.ioc.dao.UserDao;\npublic class UserService {\n    private UserDao userDao;\n    public UserService(){\n        System.out.println(\"UserService已创建:\" + this);\n    }\n    public UserDao getUserDao() {\n        return userDao;\n    }\n    public void setUserDao(UserDao userDao) {\n        System.out.println(\"调用setUserDao:\" + userDao);\n        this.userDao = userDao;\n    }\n}\n```\n◇applicationContext.xml配置文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n   <bean id=\"userDao\" class=\"com.lcg.spring.ioc.dao.UserDao\" scope=\"prototype\"/>\n   <bean id=\"userService\" class=\"com.lcg.spring.ioc.service.UserService\" scope=\"prototype\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n   </bean>\n</beans>\n```\n◇主程序入口\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.entity.Order;\nimport com.lcg.spring.ioc.service.UserService;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class SpringApplication {\n    public static void main(String[] args) {\n        ApplicationContext context =\n            new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        System.out.println(\"======IoC容器已初始化=======\");\n       /* 创建userDao\n        UserDao userDao1 = context.getBean(\"userDao\", UserDao.class);\n        UserDao userDao2 = context.getBean(\"userDao\", UserDao.class);\n        UserDao userDao3 = context.getBean(\"userDao\", UserDao.class);*/\n        UserService userService1 = context.getBean(\"userService\", UserService.class);\n        UserService userService2 = context.getBean(\"userService\", UserService.class);\n        UserService userService3 = context.getBean(\"userService\", UserService.class);\n        UserService userService4 = context.getBean(\"userService\", UserService.class);\n    }\n}\n```\n## bean的生命周期  \n![bean生命周期.png](SpringIoc容器与Bean管理/1632468115442-463d426e-a10d-4800-8395-8a1be644f3a2.png)\n### 细节调整 \n◇prototype时对象创建与init-method延迟至执行业务 代码阶段 \n◇prototype时对象不再受IoC容器管理,不会触发 destroy-method \n◇延迟加载lazy-init属性可让对象创建与初始化延迟到 执行代码阶段  \n### 生命周期在实战中的运用  \n◇创建订单实体类\n```java\npackage com.lcg.spring.ioc.entity;\npublic class Order {\n    private Float price;\n    private Integer quantity;\n    private Float total;\n\n    public Order(){\n        System.out.println(\"创建Order对象,\" + this);\n    }\n\n    public void init(){\n        System.out.println(\"执行init()方法\");\n        total = price * quantity;//计算总价\n    }\n    public void pay(){\n        System.out.println(\"订单金额为:\" + total);\n    }\n    public Float getPrice() {\n        return price;\n    }\n    public void setPrice(Float price) {\n        System.out.println(\"设置price:\" + price);\n        this.price = price;\n    }\n    public Integer getQuantity() {\n        return quantity;\n    }\n    public void setQuantity(Integer quantity) {\n        System.out.println(\"设置quantity:\" + quantity);\n        this.quantity = quantity;\n    }\n    public Float getTotal() {\n        return total;\n    }\n    public void setTotal(Float total) {\n        this.total = total;\n    }\n    public void destroy(){\n        System.out.println(\"释放与订单对象相关的资源\");\n    }\n}\n```\n◇配置order\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"order1\" class=\"com.lcg.spring.ioc.entity.Order\" \n        init-method=\"init\" destroy-method=\"destroy\">\n        <property name=\"price\" value=\"19.8\"/>\n        <property name=\"quantity\" value=\"1000\"/>\n    </bean>\n</beans>\n```\n◇主程序\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.entity.Order;\nimport com.lcg.spring.ioc.service.UserService;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class SpringApplication {\n    public static void main(String[] args) {\n        ApplicationContext context =\n            new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        System.out.println(\"======IoC容器已初始化=======\");\n        Order order1 = context.getBean(\"order1\", Order.class);\n        order1.pay();\n        //销毁IoC容器方法\n        ((ClassPathXmlApplicationContext) context).registerShutdownHook();\n    }\n}\n```\n◇运行结果\n![image.png](SpringIoc容器与Bean管理/1639625401117-bbde845e-26d7-464d-bbe5-eb3229f9a57d.png)\n\n### 实现极简IoC容器  \n◇创建实体类Apple\n```java\npublic class Apple {\n    private String title;\n    private String color;\n    private String origin;\n    ...\n}\n```\n◇创建配置文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans>\n    <bean id=\"sweetApple\" class=\"com.lcg.spring.ioc.entity.Apple\">\n        <property name=\"title\" value=\"红富士\"/>\n        <property name=\"color\" value=\"红色\"/>\n        <property name=\"origin\" value=\"欧洲\"/>\n    </bean>\n</beans>\n```\n◇创建接口\n```java\npackage com.lcg.spring.ioc.context;\n\npublic interface ApplicationContext {\n    public Object getBean(String beanId);\n}\n```\n◇核心配置文件部分代码\n```java\n    <repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n\n\n    <dependencies>\n        <!-- Dom4j是Java的XML解析组件 -->\n        <dependency>\n            <groupId>org.dom4j</groupId>\n            <artifactId>dom4j</artifactId>\n            <version>2.1.1</version>\n        </dependency>\n        <!-- Jaxen是Xpath表达式解释器 -->\n        <dependency>\n            <groupId>jaxen</groupId>\n            <artifactId>jaxen</artifactId>\n            <version>1.1.6</version>\n        </dependency>\n    </dependencies>\n```\n◇创建类\n◇在Ioc容器初始化的过程中，遇到了对象实例化，就去调用Class.forName、newInstance方法来利用反射技术实现对象的创建;如果遇到了property这个标签，则利用Method对象实现方法的调用\n```java\npackage com.lcg.spring.ioc.context;\n\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.Node;\nimport org.dom4j.io.SAXReader;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\nimport java.net.URLDecoder;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n    private Map iocContainer = new HashMap();\n    public ClassPathXmlApplicationContext(){\n        try{\n            //得到配置文件的地址\n            String filePath = \n                this.getClass().getResource(\"/applicationContext.xml\").getPath();\n            //使用URL解码\n            filePath = new URLDecoder().decode(filePath, \"UTF-8\");\n            SAXReader reader = new SAXReader();\n            //读取指定文件,所有的xml文件都会放在document中\n            Document document = reader.read(new File(filePath));\n            //按照xml格式依次读取,getRootElement()得到根节点,\n            // selectNodes(\"bean\")将所有根节点的bean标签获取\n            List<Node> beans = document.getRootElement().selectNodes(\"bean\");\n            for(Node node : beans){\n                Element  ele = (Element)node;\n                //读取属性\n                String id = ele.attributeValue(\"id\");\n                String className = ele.attributeValue(\"class\");\n                //forName(className)加载指定的类\n                Class c = Class.forName(className);\n                Object obj = c.newInstance();//通过默认构造方法创建Apple类的实例\n                List<Node> properties = ele.selectNodes(\"property\");\n                //遍历属性\n                for(Node p : properties){\n                    Element property = (Element) p;\n                     //读取name及其对应的值\n                    String propName = property.attributeValue(\"name\");\n                    String propValue = property.attributeValue(\"value\");\n                    //组织set方法，substring(1)代表从第二个字符将之后的所有字符串进行截取\n                    String setMethodName = \"set\" + \n                        propName.substring(0,1).toUpperCase()+propName.substring(1);\n                    System.out.println(\"准备执行\" + setMethodName + \"方法注入数据\");\n                    //通过getMethod方法调用\n                    Method setMethod = c.getMethod(setMethodName, String.class);\n                    setMethod.invoke(obj,propValue);//通过setter方法注入数据\n                }\n                //将id和obj放入容器中，即ioc对刚才创建的对象赋予beanId进行管理\n                iocContainer.put(id,obj);\n            }\n            System.out.println(iocContainer);\n            System.out.println(\"IOC容器初始化完毕\");\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    public Object getBean(String beanId){\n        return iocContainer.get(beanId);\n    }\n}\n\n```\n◇入口类\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.context.ApplicationContext;\nimport com.lcg.spring.ioc.context.ClassPathXmlApplicationContext;\nimport com.lcg.spring.ioc.entity.Apple;\npublic class Application {\n    public static void main(String[] args) {\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext();\n        Apple apple = (Apple)context.getBean(\"sweetApple\");\n        System.out.println(apple);\n    }\n}\n```\n## 基于注解配置IoC容器  \n### 基于注解的优势 \n◇摆脱繁琐的XML形式的bean与依赖注入配置 \n◇基于\"声明式\"的原则,更适合轻量级的现代企业应用 \n◇让代码可读性变得更好,研发人员拥有更好的开发体验  \n### 三类注解 \n◇组件类型注解-声明当前类的功能与职责 \n◇自动装配注解-根据属性特征自动注入对象 \n◇元数据注解-更细化的辅助IoC容器管理对象的注解  \n### 四种组件类型注解 \n◇语义注解是组件注解的细化\n```java\n@Component    组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化\n@Controller   语义注解,说明当前类是MVC应用中的控制器类\n@Service      语义注解,说明当前类是Service业务服务类\n@Repository   语义注解,说明当前类用于业务持久层,通常描述对应Dao类\n```\n###  开启组件扫描  \n◇regex表示排除扫描，即类名符合com.imooc.exl.*的正则表达式就不会被ioc容器进行实例化\n![image.png](SpringIoc容器与Bean管理/1632644213443-2887e008-68d5-442b-b82f-eceead2d9772.png)\n\n### 代码示例\n◇创建applicationContext.xml，和传统的配置不一样,额外的增加了context命名空间\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n    <!-- component-scan在IoC容器初始化时自动扫描四种组件类型注解并完成实例化\n        @Repository\n        @Service\n        @Controller\n        @Component\n     -->\n    <context:component-scan base-package=\"com.lcg\"/>\n</beans>\n```\n◇剩余代码见项目s07；\n###  两类自动装配注解  \n◇自动装配注解即在ioc容器运行的过程中自动的为某个属性注入数据，推荐按名称装配\n◇在属性上方进行装配注解和在setXX方法上方进行都可以完成对象的注入，但是在属性上方进行装配Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值，不再执行set方法。_如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入_\n◇如果出现两个类(比方说不同的数据库)实现同一个接口,并且两个类都进行了语义注解(dao的注解为@Repository)，则在运行时会报错，因为出现了两个bean对象。在s07项目中Service类中进行了IUserDao的自动注解，但由于两个dao类都实现了IUserDao接口，则不知道选择哪一个。解决方法：①在userDao中去@Repository注解，这样userDao就不会被Ioc容器管理了；②引入额外的注解@Primary，表示如果出现多个bean对象的话，主要采用有此注解的；\n◇两个不同的Dao\n```java\n//组件类型注解默认beanId为类名首字母小写\n//beadId = userDao\n@Repository\npublic class UserDao implements IUserDao {\n    public UserDao() {\n        System.out.println(\"正在创建UserDao:\" + this);\n    }\n}\n```\n```java\n@Repository\n@Primary\npublic class UserOracleDao implements IUserDao {\n    public UserOracleDao() {\n        System.out.println(\"正在创建UserOracleDao:\" + this);\n    }\n}\n```\n◇因此，为了避免出现这种情况，一般采用按名称进行注入；\n```java\npackage com.lcg.spring.ioc.service;\nimport com.lcg.spring.ioc.dao.IUserDao;\nimport org.springframework.stereotype.Service;\nimport javax.annotation.Resource;\n\n@Service\npublic class DepartmentService {\n    /**\n     * 1. @Resource设置name属性,则按name在IoC容器中将bean注入\n     * 2. @Resource未设置name属性\n     * 2.1 以属性名作为bean name在IoC容器中匹配bean,如有匹配则注入\n     * 2.2 按属性名未匹配,则按类型进行匹配,同@Autowired,需加入@Primary解决类型冲突\n     * 使用建议:在使用@Resource对象时推荐设置name或保证属性名与bean名称一致(规范属性名)\n     */\n//    @Resource(name = \"userOracleDao\") 设置userOracleDao为name属性\n//    private IUserDao uDao;\n    @Resource\n    private IUserDao userDao; //这里属性名为userDao(规范属性名),以其作为name属性\n\n    public void joinDepartment(){\n        System.out.println(userDao);\n    }\n}\n```\n![image.png](SpringIoc容器与Bean管理/1632657405828-7a0f304b-7b46-4865-a138-c2e341b27348.png)\n### 元数据注解  \n◇@Scope(**\"prototype\"**)_//设置单例/多例,XML中 bean scope完全相同 _\n◇@PostConstruct _//XML中bean init-method完全相同，即初始化方法_\n◇@Value(**\"${metaData}\"**)_//读取config.properties的metaData属性值_\n![image.png](SpringIoc容器与Bean管理/1632709510231-6f4d768f-1268-4ce8-aca7-a057100d1bb9.png)\n\n### @Value的读取属性文件  \n◇@value参数书写格式为\"${属性名}\"\n◇config.properties应用程序的配置信息，基于字符串的键值对，需要在applicationContext中进行加载，加载语句为：\n\n```xml\n<!--通知Spring IoC容器初始化时加载属性文件-->\n<context:property-placeholder location=\"classpath:config.properties\"/>\n```\n◇config.properties配置信息\n```java\nmetaData=lcg.com\n//数据库的连接属性，通过增加前缀connection来说明，在引用时也得书写完整字符串\nconnection.driver=xxxxx \nconnection.url=xxx\nconnection.username=xxx\nconnection.password=xxx\n```\n◇xml文件配置维护起来比较方便，但是不便于开发；而注解形式配置开发方便但维护的时候需要修改源代码\n◇示例代码\n```java\n@Service\n@Scope(\"prototype\")//设置单例/多例,XML中 bean scope完全相同\npublic class UserService {\n    @Value(\"${metaData}\")//读取config.properties的metaData属性值\n    private String metaData;\n    @Value(\"${connection.password}\")\n    private String password;\n\n    public UserService() {\n        System.out.println(\"正在创建UserService:\" + this);\n    }\n\n    @PostConstruct //XML中bean init-method完全相同\n    public void init() {\n        System.out.println(\"初始化UserService对象,metaData=\" + metaData);\n    }\n\n    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值\n    //不再执行set方法\n    @Autowired\n    private IUserDao udao;//private->public\n\n    public IUserDao getUdao() {\n        return udao;\n    }\n\n\n    /*@Autowired\n    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入\n    public void setUdao(UserDao udao) {\n        System.out.println(\"setUdao:\" + udao);\n        this.udao = udao;\n    }*/\n}\n```\n## 基于Java Config配置IoC容器  \n### 基于Java Config的优势 \n◇完全摆脱XML的束缚,使用独立Java类管理对象与依赖 \n◇注解配置相对分散,利用Java Config可对配置集中管理 \n◇可以在编译时进行依赖检查,不容易出错  \n◇一般用于敏捷开发\n### Java Config核心注解  \n◇项目演示见s08。\n![image.png](SpringIoc容器与Bean管理/1632712740006-91604ef1-c78a-44ca-b1f0-50eac3ea237c.png)\n◇使用config类代替xml配置\n\n```java\npackage com.lcg.spring.ioc;\n\nimport com.lcg.spring.ioc.controller.UserController;\nimport com.lcg.spring.ioc.dao.EmployeeDao;\nimport com.lcg.spring.ioc.dao.UserDao;\nimport com.lcg.spring.ioc.service.UserService;\nimport org.springframework.context.annotation.*;\n\n@Configuration //指明当前类是一个配置类,用于替代applicationContext.xml\n@ComponentScan(basePackages = \"com.lcg\")//进行扫描\npublic class Config {\n    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名\n    public UserDao userDao(){\n        UserDao userDao = new UserDao();\n        System.out.println(\"已创建\" + userDao);\n        return userDao;\n    }\n\n    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名\n    @Primary\n    public UserDao userDao1(){\n        UserDao userDao = new UserDao();\n        System.out.println(\"已创建\" + userDao);\n        return userDao;\n    }\n\n    @Bean\n    //先按name尝试注入,name不存在则按类型注入\n    public UserService userService(UserDao udao , EmployeeDao employeeDao){\n        UserService userService = new UserService();\n        System.out.println(\"已创建\" + userService);\n        userService.setUserDao(udao);\n        System.out.println(\"调用setUserDao:\" + udao);\n        userService.setEmployeeDao(employeeDao);\n        return userService;\n    }\n\n    @Bean //<bean id=\"xxx\" clas=\"xxx\">\n    @Scope(\"prototype\")\n    public UserController userController(UserService userService){\n        UserController userController = new UserController();\n        System.out.println(\"已创建\" + userController);\n        userController.setUserService(userService);\n        System.out.println(\"调用setUserService:\" + userService);\n        return userController;\n    }\n}\n\n```\n◇Java Config初始化方式\n```java\npublic class SpringApplication {\n    public static void main(String[] args) {\n        //基于Java Config配置IoC容器的初始化\n        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        System.out.println(\"=========================\");\n        String[] ids = context.getBeanDefinitionNames();\n        for(String id : ids){\n            System.out.println(id + \":\" + context.getBean(id));\n        }\n    }\n}\n```\n## Spring单元测试\n### Spring Test 测试模块  \n◇Spring Test是Spring中用于测试的模块 \n◇Spring Test对JUnit单元测试框架有良好的整合 \n◇通过Spring Test可在JUnit在单元测试时自动初始化IoC容器  \n### Spring与JUnit4整合过程 \n◇Maven工程依赖spring-test \n◇利用@RunWith与@ContextConfiguration描述测试用例类 \n◇测试用例类从容器获取对象完成测试用例的执行\n### 代码演示\n  ◇核心配置pom.xml\n```java\n<dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.2.6.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n```\n◇applicationContext配置文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"userDao\" class=\"com.lcg.spring.ioc.dao.UserDao\">\n    </bean>\n    <bean id=\"userService\" class=\"com.imooc.spring.ioc.service.UserService\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n</beans>\n```\n◇dao类(模拟功能)\n```java\npublic class UserDao {\n    public void insert(){\n        System.out.println(\"新增用户数据\");\n    }\n}\n```\n◇service类\n```java\npublic class UserService {\n    private UserDao userDao;\n\n    public void createUser(){\n        System.out.println(\"调用创建用户业务代码\");\n        userDao.insert();\n    }\n\n    public UserDao getUserDao() {\n        return userDao;\n    }\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n}\n```\n◇测试用例类\n```java\nimport com.lcg.spring.ioc.service.UserService;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport javax.annotation.Resource;\n\n//将Junit4的执行权交由Spring Test模块,在测试用例执行前自动初始化IoC容器\n@RunWith(SpringJUnit4ClassRunner.class)//RunWith运行器\n//此注解说明要加载哪个配置文件,locations是一个数组,保存配置文件位置\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class SpringTestor {\n    @Resource\n    private UserService userService;//进行属性的注入\n\n    @Test\n    public void testUserService(){\n        userService.createUser();//在测试用例中进行调用\n    }\n}\n```\n## 总结与回顾 \n◇Spring快速入门           ◇Spring XML配置 \n◇对象实例化配置           ◇依赖注入配置\n◇注解与Java Config       ◇Spring 单元测试\n\n\n\n","tags":["Spring"],"categories":["Spring","Spring基础"]},{"title":"Redis入门","url":"/p/d40.html","content":"## 课程介绍  \n◇Redis介绍与安装 \n◇掌握在Java中操作Redis \n◇掌握Redis的常用命令与数据类型  \n\n## Redis介绍 \n◇Redis是Key-Value型NoSQL数据库 ,即每一个数据都有键和值；\n◇Redis将数据存储在内存中，同时也能持久化到磁盘 \n◇Redis常用于缓存，利用内存的高效提高程序的处理速度  \n## Redis特点 \n◇ 速度快              ◇ 广泛的语言支持 \n◇ 持久化              ◇ 多种数据结构 \n◇ 主从复制           ◇ 分布式与高可用 \n\n## Redis的安装与启动 \n### 在Linux系统中安装Redis \n◇进入[redis官网](https://redis.io/)\n◇创建redis目录，安装gcc用于make编译\n◇安装命令\n```\n$ wget https://download.redis.io/releases/redis-5.0.2.tar.gz\n$ tar xzf redis-5.0.2.tar.gz\n$ cd redis-5.0.2\n$ make\n```\n◇启动redis: 在src目录中redis-server开启服务器；redis-cli进行客户端连接；\n◇[root@master redis-5.0.2]# ./src/redis-server redis.conf #启动命令\n### 在Windows系统中安装Redis  \n◇进入github[下载](https://github.com/MicrosoftArchive/redis)\n◇点击releases，下载zip文件进行解压\n◇在终端(cmd)进入解压目录中，dir查看文件；\n◇安装命令：redis-server  redis.windows.conf\n◇由于Windows的版本过旧，仅做学习使用；\n## Redis的常用基本配置  \n![image.png](Redis入门/1630301413623-fa8ca9d5-879a-45c2-9331-146cbba40f2f.png)\n◇编辑redis.conf（配置文件）定位到136行，有一个daemonize（是否后台运行，守护进程)，改为yes即可进行守护；这样启动后，不会出现redis的logo并且启动会只要虚拟机运行，则redis一直提供服务；netstat -tulpn#查看系统占用的端口，进而查看redis是否运行；若要关闭redis，可以杀死进程或者利用客户端关闭；\n◇redis-cli即redis客户端，用来执行redis指令；进入方法：./src/redis-cli 退出命令：exit\n◇在客户端使用命令:ping 若出现PONG 则说明redis正常运行；关闭redis进程：./src/redis-cli shutdown\n◇在redis.conf文件可以使用vim命令修改相关配置；\n◇修改redis端口后需要指定端口进行连接， ./src/redis-cli -p 6380 #指定6380端口进行连接\n◇redis的数据库名字为数字0~15；如果觉得数据库数量不够用，可以在配置文件中设置，在大概186行出的databases进行修改;\n◇在配置文件的507行有个#requirepass foobared,说明默认密码是foobared，将注释取消，修改为12345。这样在使用redis时需要使用密码了。在启动后，输入命令：auth 12345即可\n◇在263行，有dir ./即数据的保存目录；dump.rdb就是redis的全量备份。\n\n## Redis通用命令  \n![image.png](Redis入门/1630301443965-582fbcdb-70a6-42ef-8a1b-d04ef40c75fe.png)\n◇示例\n\n```\n./src/redis-cli -p 6379 #连接客户端\nauth 12345 #输入密码\nselect 0 #选择0号数据库\nset name lily #在当前数据库中增加一个key=name,value=lily的数据\nget name #获取数据\nset name lee #会将前面的数据覆盖掉\nkeys * #查询所有的key\ndbsize #显示当前数据库的数据总量\ndel name #删除name这个key\n```\n## Redis数据类型  \n◇ String - 字符串类型     ◇ Hash - Hash类型 \n◇ List - 列表类型             ◇ Set - 集合类型 \n◇ Zset - 有序集合类型  \n## String 字符串类型 \n![image.png](Redis入门/1630301541873-e169dfb8-2a11-44db-b001-d364dad29ec1.png)\n\n##  字符串命令  \n![image.png](Redis入门/1630301585498-ea031812-7b93-44fb-bf1f-d358bd0e47b2.png)\n## Hash键值类型   \n◇Hash类型用于存储结构化数据  \n![image.png](Redis入门/1630301642145-939a3186-55d0-47e9-a6fc-7c83e0178a14.png)\n\n## Hash 命令  \n![image.png](Redis入门/1630301692289-f55f142a-ad1a-4e01-bf37-bf1c9d1b3503.png)\n## List列表类型 \n◇List列表就是一系列字符串的“数组”，按插入顺序排序 \n◇List列表最大长度为2的32次方-1，可以包含40亿个元素  \n## List 命令  \n◇rpush listkey c b a - 右侧插入 \n◇lpush listkey f e d - 左侧插入 \n◇ d e f c b a\n◇rpop listkey - 右侧弹出 \n◇lpop listkey - 左侧弹出  \n## List 指令  \n◇llen listkey - 获取长度 \n◇lrange listkey 0 2\n◇lrange listkey 1 -1 获取子集  \n## Set与Zset集合类型 \n◇Set集合是字符串的无序集合，集合成员是唯一的 \n◇Zset集合是字符串的有序集合，集合成员是唯一的  \n## Java客户端-Jedis \n◇Jedis是Java语言开发的Redis客户端工具包 \n◇Jedis只是对Redis命令的封装,掌握Redis命令便可轻易上手  \n### Jedis使用演示  \n◇编辑配置文件redis.conf，在88行处：protected-mode yes #是否开启保护模式，设置为no关闭，允许其他ip主机连接进来\n◇在69行处bind 127.0.0.1改为0.0.0.0表示任意ip主机都可以访问进来；\n◇设置防火墙放行6379端口：firewall-cmd --zone=public --add-port=6379/tcp --permanent; firewall-cmd --reload#重载\n◇查看redis服务器的IP地址\n◇Windows上[下载jedis](https://github.com/redis/jedis)\n◇利用maven进行下载\n\n```xml\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>2.9.0</version>\n</dependency>\n```\n### 在IDEA中创建maven工程\n◇JedisTestor\n```java\npublic class JedisTestor {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"192.168.132.144\" , 6379);//虚拟机IP地址，redis服务器端口号\n        try {\n            jedis.auth(\"12345\");//输入密码\n            jedis.select(2);\n            System.out.println(\"Redis连接成功\");\n            //字符串\n            jedis.set(\"sn\" , \"7781-9938\");\n            String sn = jedis.get(\"sn\");\n            System.out.println(sn);\n            jedis.mset(new String[]{\"title\" , \"婴幼儿奶粉\" , \"num\" , \"20\"});\n            List<String> goods =  jedis.mget(new String[]{\"sn\" , \"title\" , \"num\"});\n            System.out.println(goods);\n            Long num = jedis.incr(\"num\");\n            System.out.println(num);\n            //Hash\n            jedis.hset(\"student:3312\" , \"name\" , \"张晓明\");\n            String name = jedis.hget(\"student:3312\" , \"name\");\n            System.out.println(name);\n            Map<String,String> studentMap = new HashMap();\n            studentMap.put(\"name\", \"李兰\");\n            studentMap.put(\"age\", \"18\");\n            studentMap.put(\"id\", \"3313\");\n            jedis.hmset(\"student:3313\", studentMap);\n            Map<String,String> smap =  jedis.hgetAll(\"student:3313\");\n            System.out.println(smap);\n            //List\n            jedis.del(\"letter\"); //将letter列表删除,否则后面会依次叠加\n            jedis.rpush(\"letter\" , new String[]{\"d\" , \"e\" , \"f\"});\n            jedis.lpush(\"letter\" ,  new String[]{\"c\" , \"b\" , \"a\"});\n            List<String> letter =  jedis.lrange(\"letter\" , 0 , -1);\n            jedis.lpop(\"letter\");\n            jedis.rpop(\"letter\");\n            letter = jedis.lrange(\"letter\", 0, -1);\n            System.out.println(letter);\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally {\n            jedis.close();\n        }\n\n    }\n}\n```\n### 利用Jedis缓存数据  \n◇创建实体类Good\n```java\npublic class Goods {\n    private Integer goodsId;\n    private String goodsName;\n    private String description;\n    private Float price;\n    ...\n}\n\n```\n◇创建缓存示例类\n```java\n\npublic class CacheSample {\n    public CacheSample(){\n        Jedis jedis = new Jedis(\"192.168.132.144\");\n        try {\n            List<Goods> goodsList = new ArrayList<Goods>();\n            //初始化模拟数据\n            goodsList.add(new Goods(8818, \"红富士苹果\", \"\", 3.5f));\n            goodsList.add(new Goods(8819, \"进口脐橙\", \"\", 5f));\n            goodsList.add(new Goods(8820, \"进口香蕉\", \"\", 25f));\n            jedis.auth(\"12345\");\n            jedis.select(3);//选择redis的三号数据库\n            //将每一个二进制存储的java对象序列化为json字符串以便redis存储\n            for (Goods goods : goodsList) {\n                String json = JSON.toJSONString(goods);\n                System.out.println(json);\n                String key = \"goods:\" + goods.getGoodsId();\n                jedis.set(key , json);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            jedis.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new CacheSample();\n        System.out.printf(\"请输入要查询的商品编号：\");\n        String goodsId = new Scanner(System.in).next();\n        Jedis jedis = new Jedis(\"192.168.132.144\");\n        try{\n            jedis.auth(\"12345\");\n            jedis.select(3);\n            String key = \"goods:\" + goodsId;\n            if(jedis.exists(key)){\n                String json = jedis.get(key);\n                System.out.println(json);\n                //json字符串转换为java对象\n                Goods g = JSON.parseObject(json, Goods.class);\n                System.out.println(g.getGoodsName());\n                System.out.println(g.getPrice());\n            }else{\n                System.out.println(\"您输入的商品编号不存在，请重新输入！\");\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally {\n            jedis.close();\n        }\n    }\n}\n\n```\n\n","tags":["Redis"],"categories":["Java数据库","Linux与Redis基础"]},{"title":"Linux基础和Java环境搭建","url":"/p/c40f.html","content":"## 内容简介\n◇Linux基础入门\n![image.png](Linux基础和Java环境搭建/1629881600929-861c5540-c71f-4186-b9f5-ae2f5453bf19.png)\n◇Linux进阶应用\n![image.png](Linux基础和Java环境搭建/1629902441633-e553b490-a782-4a8c-bf13-112f3324acb5.png)\n◇Redis应用入门\n![image.png](Linux基础和Java环境搭建/1629902552805-78f40e53-3374-43dc-8d18-b673821de5ad.png)\n\n## 主要知识点\n◇介绍Linux与CentOS      ◇讲解Linux基础命令 \n◇yum应用安装与卸载     ◇CentOS的权限与系统安全 \n◇Linux文本工具与命令   ◇部署OA项目至Linux服务器  \n## 操作系统\n### 什么是操作系统 \n◇操作系统(Operating System)是应用程序运行的基础支撑环境 \n◇操作系统作用是管理和控制计算机系统的硬件与软件资源 \n◇Intel x86架构上常见的操作系统:Windows、Linux、Unix...  \n### Linux操作系统\n◇Linux是开源的基于Intel x86架构的类Unix多用户操作系统 \n◇Linux是目前最主要的服务器端操作系统 \n◇互联网大厂都在使用Linux作为服务器主要操作系统  \n### Linux为什么受欢迎 \n◇免费使用，自由传播    ◇支持多任务、多用户、多CPU \n◇高效而灵活                  ◇兼容任意x86架构计算机 \n◇强大易用的系统命令    ◇完整的应用软件生态  \n### Linux发行版本 \n◇Linux系统内核(kernel)提供了Linux操作系统的核心功能 \n◇不同开发商在内核基础上扩展封装,形成了不同发行版本 \n◇常见发行版：Red Hat Linux、CentOS、Ubuntu、SUSE...  \n### Linux发行版选择建议 \n◇桌面系统:Ubuntu\n◇服务器操作系统: CentOS（免费）、Red Hat Linux（收费） \n◇特定需求: Debian(稳定性)、Fedora(新特性)、麒麟Linux(国产)  \n## CentOS - 社区企业操作系统\n### 简介\n◇基于Red Hat Enterprice Linux 的开源企业级Linux发行版本 \n◇各版本CentOS都会获得十年的支持,与RHEL保持同步更新 \n◇CentOS采用社区支持,同时修正了RHEL许多BUG   \n### CentOS版本选择 \n◇CentOS 5/6 : 历史版本,已被淘汰 \n◇CentOS 7 : 主流版本,稳定成熟,大多数服务器的首选版本 \n◇CentOS 8 : 全新版本,基于最新内核,不排除存在漏洞隐患  \n## 安装CentOS 7.7  \n### CentOS 7 运行要求 \n◇CPU : 1核,建议2核以上 \n◇内存 : 1G,建议2G以上 \n◇硬盘 : 预留20G可用空间  \n### 开启CPU虚拟化\n◇Ctrl+Alt+Delete打开任务管理器->性能->查看右下角虚拟化是否已启用\n◇若未启动,则应开启CPU虚拟化，由于电脑型号不同，具体方法可百度\n### 安装VMware Workstation虚拟机\n◇[在VMware中搭建CentOS ](https://blog.csdn.net/weixin_36522099/article/details/106959969) \n## Linux系统目录\nLinux倒挂树形目录结构  \n![image.png](Linux基础和Java环境搭建/1629975406516-bb1ea1f7-fab0-4da8-8303-a12633159db2.png)\n◇\"/\"是所有目录的顶点,称为\"根目录\" \n◇不同目录下的数据可分布在不同磁盘,所有目录按规则组织与命名 \n◇Linux也区分绝对路径与相对路径  \n### 常见系统目录\n![image.png](Linux基础和Java环境搭建/1629975580379-b983d605-acc6-4e15-be66-c7eb638aea3d.png)\n![image.png](Linux基础和Java环境搭建/1629975605738-db5bbc1c-10c7-45fa-a10f-b3dda57685e7.png)\n\n## Linux远程管理\n### SSH客户端\n ◇SSH是专为远程登录和其他网络服务提供的安全性协议 \n◇SSH分为两个不兼容版本1.x与2.x,默认通过SSH2.x连接 \n◇基于SSH远程连接工具有很多,最常见的是Xshell与SecureCRT \n### Xshell与Xftp \n◇Xshell是著名的Linux客户端,常用于在Windows下远程访问 \n◇Xshell同时还支持Telent、RLogin、Serial等其他连接方式 \n◇Xftp是Xshell配套组件，用于向服务器上传/下载文件  \n### Xshell与Xftp安装与配置  \n◇在官方网站安装个人版\n◇在虚拟机终端输入ifconfig查看虚拟机的ip地址\n◇新建xshell会话，连接后输入用户名和密码即可\n<img src=\"Linux基础和Java环境搭建/1629978963671-fd31e45c-c4c0-4fc0-b4eb-a66bd9787a1c.png\" alt=\"image.png\" style=\"zoom: 67%;\" />\n◇在Xshell顶部绿色的新建文件传输打开，可以进行文件的传输\n![image.png](Linux基础和Java环境搭建/1629979354707-b035a667-88ab-4732-b0de-37ad49bfbcb7.png)\n\n## Linux文件操作命令\n### Linux命令格式 \n◇命令 [参数选项] [文件或路径] \n### Linux文件操作核心命令 \n![image.png](Linux基础和Java环境搭建/1629979553331-35a0fe9d-22c7-4753-a083-a1a9916b591d.png)\n◇clear     清屏   ◇rmdir 删除空目录\n◇cd时输入某个路径的前一个字母后可以按Tab进行自动补全\n◇命令 --help可以查看命令的参数等相关信息\n◇mv 重命名格式：mv old.c  new.c ;移动格式：mv old.c /xx/xx 也可以移动整个文件夹\n◇不要轻易使用rm -rf，这样会强制迭代删除而不进行询问，rm -r迭代删除进行询问\n\n### vim文本编辑器 \n◇vi是Linux重要的文字编辑工具,vim是它的增强版 \n◇vim用于在远程环境下用命令形式对文本进行在线编辑 \n◇用法格式: vim [选项] [文件] \n### vim三种模式 \n◇普通模式:默认模式,文本只读,不可编辑 \n◇编辑模式:编辑文本模式,普通模式按i键进入,Esc键退出 \n◇命令模式:执行保存、搜索、退出等操作\n### vim重要快捷键\n![image.png](Linux基础和Java环境搭建/1629980002766-5c22ebbf-1dc8-4840-9a9b-44410e4e2520.png)\n## Linux文本工具\n### 常用文本工具   \n![image.png](Linux基础和Java环境搭建/1630068704114-ec0a4e45-4072-42bc-8618-ee730f5ffd2e.png)\n### 文件输入与输出 \n◇文件输入：< (重写) 或者 << (追加)          ◇文件输出：> (重写) 或者 >> (追加) \n◇echo \"xxxx\" >> log.txt 将xxxx文本追加写入到log.txt文件中\n◇合并文件：cat hello.txt myname.txt >> full.txt\n◇tail full.txt --显示文件尾部内容;   tail -n 2 full.txt --显示文件最后两行\n◇tail -f full.txt --动态监测文件末尾所产生的新行; ctrl+c退出\n◇grep lcg test.txt --查找test.txt文件中包含lcg字符串的文本行,字符串可以是正则表达式\n◇grep -v lcg test.txt --查找test.txt文件中不包含lcg字符串的文本行\n◇ll | grep -E \"log[0-9]{1,5}.txt\" --进行文件的筛选，查看所有日志文件 -E表示使用扩展正则表达式；{1,5}表示数字位数为1~5；\n## 文件打包与压缩 \n### Linux压缩程序-gzip \n◇gzip是Linux系统的文件压缩程序 \n◇gzip压缩包文件扩展名.gz \n◇大流量的网站默认都在使用gzip进行数据压缩传输   \n\n### tar打包与压缩 \n◇tar是Linux系统将多个文件打包和压缩的工具 \n◇tar本质是打包软件，扩展名.tar \n◇tar可结合gzip或其他压缩工具实现打包压缩，扩展名.tar.gz \n◇压缩命令: tar zcvf tomcat.tar.gz /usr/local/tomcat \n◇解压缩命令: tar zxvf tomcat.tar.gz -C /usr/local/tomcat   \n\n### tar常用可选项  \n<img src=\"Linux基础和Java环境搭建/1630068871801-23d4fefb-c44f-409e-bb11-51dd710ab2f9.png\" alt=\"image.png\"  />\n\n## 安装与卸载应用程序  \n### 为CentOS安装应用程序 \n◇在CentOS中安装第三方应用程序包含两种方式:\n◇rpm:Red Hat软件包管理器,相当于应用程序安装文件的执行者 \n◇编译安装:用户自己从网站下载程序源码进行编译安装 \n### yum与rpm的关系 \n◇rpm安装过程中,需要用户自己解决依赖问题 \n◇yum通过引入软件仓库,联网下载rpm包及依赖,并依次自动安装 \n◇yum是rpm的前端程序,其目的就是简化rpm的安装过程\n### yum常用命令 \n◇yum search 应用名 #在仓库中查询是否存在指定应用 \n◇yum install -y 应用名 #全自动下载安装应用及其依赖  \n◇yum info 应用名 #查看软件详细信息 \n◇yum list installed 应用名 #查看已安装的应用程序 \n◇rpm -ql 应用名 #查看安装后输出的文件清单 \n◇yum remove -y 应用名 #全自动卸载指定应用  ，-y表示遇到询问都用y\n## 编译方式安装 \n### 编译方式安装应用程序\n◇如yum仓库未提供rpm,往往需要采用编译安装方式 \n◇编译安装是指从应用官网下载源码后,对源码进行编译后使用 \n◇编译命令: make #使用对应编译器对源码编译生成可执行文件  \n### yum与编译安装比较  \n![image.png](Linux基础和Java环境搭建/1630070373099-9af554f6-920f-4c76-9782-70dc5c1dc783.png)\n### 编译安装Redis\n◇利用xftp将下载好的压缩包文件上传到linux；然后解压；进入redis-4.0.14目录；安装gcc编译器：yum install -y gcc;\n◇有时候第一次make编译出错后，可能改变了原来的文件结构，因此纠正错误后下一次编译时需要将解压后的目录删除重新解压；当出现Hint: It's a good idea to run 'make test' ;)时代表编译成功；\n◇编译安装后的应用程序redis-server存放在src中，在启动redis-server前需要加载上一级目录下的redis.conf配置文件;即启动命令为:./src/redis-server redis.conf  启动后ctrl+c退回命令状态\n## Linux进阶应用\n### Linux系统管理命令\n◇使用ifconfig查看网卡ip\n![image.png](Linux基础和Java环境搭建/1630146548264-3229c8fc-d16f-4ace-9c4b-4d140a726bc0.png)\n◇netstat 查看网络端口号：netstat -tulpn 或 netstat -ano\n◇Recv-Q:接收队列；Send-Q:发送队列; LISTEN表示网络状态正在被监听;PID:进程编号；Program name创建网络连接的应用\n![image.png](Linux基础和Java环境搭建/1630146738224-1f08c511-0871-4f93-8fdc-1b45678b64a5.png)\n◇netstat 常用选项\n![image.png](Linux基础和Java环境搭建/1630146946866-e7e838d8-a463-417b-9b9c-0603f83dfba4.png)\n◇查看进程: ps -ef ，箭头处5412指PID；杀掉进程：kill -9 PID\n◇一般使用应用程序退出来关闭进程，而不是强制杀掉进程，因为可能造成数据丢失\n◇ps -ef | grep vim ; | 表示通道，即ps -ef查询产生的数据像通过通道一样送入到后一个指令\n![image.png](Linux基础和Java环境搭建/1630147070833-32dca895-ace6-45ad-a972-0cb3f0471b45.png)\n\n## 应用服务化  \n### 简介\n◇ 应用服务化是指让应用程序以服务方式在系统后台运行 \n◇ Linux系统对服务化应用进行统一管理 \n◇ 服务管理命令：systemctl    \n### systemctl  \n![image.png](Linux基础和Java环境搭建/1630147494122-9ac16bd2-3b54-497a-be4c-2ef65b16ca12.png)\n◇.pid文件用来保存进程编号\n◇将redis服务化，需要在/usr/lib/systemd/system目录下创建 vim redis.service；在文件中写入配置：\n\n```\n[Unit]\nDescription=Redis\nAfter=syslog.target network.target remote-fs.target nss-lookup.target #表示在这些服务启动以后才能启动redis\n\n[Service]\nType=forking #forking代表后台运行\nPIDFile=/run/redis_6379.pid\n#说明启动时执行server，加载配置文件\nExecStart=/home/lcg/0/redis-4.0.14/src/redis-server /home/lcg/0/redis-4.0.14/redis.conf\n#关闭,-s采用正常流程进行退出；-9表示强制退出\nExecStop=/bin/kill -s QUIT $MAINPID\nPrivateTmp=True #为每一个服务设置私有的Tmp临时文件目录\n\n[Install]\nWantedBy=multi-user.target #将当前的redis服务分配到multi-user服务组上；\n```\n◇systemctl daemon-reload #对所有service进行重载;\n◇systemctl start redis #启动服务； systemctl status redis #查看状态\n## Linux用户与权限 \n### 用户 \n◇ Linux是多用户多任务系统,包含两个概念:用户与用户组 \n◇ 用户与账户是同一概念,用于登录系统与区分资源权限 \n◇ 用户让系统变的更安全,同时也保护了用户的个人数字资产\n### 用户组 \n◇ 用户组就是将用户分组,隶属用户自动拥有组权限 \n◇ 一个用户可隶属于多个组,用户可任意切换当前组 \n◇ 用户组的出现让用户权限管理变更轻松 \n### 用户与用户组常用命令  \n![image.png](Linux基础和Java环境搭建/1630152748335-c52d7d9a-f0cc-4e31-a1ef-204bfebbaead.png)\n◇分组：usermod -g [组名] [用户名]\n◇让用户拥有多个组： usermod -G [组名1],[组名2] [用户名];通过newgrp进行切换\n◇将用户连接系统: 打开->创建系统副本：然后用新建的用户密码登录\n◇groups #查看用户隶属于哪个组\n◇chown用法：chown [用户名]:[组名] [文件名]\n\n## 项目内部文件权限管理实践 \n### 文件权限代码表  \n![image.png](Linux基础和Java环境搭建/1630153162614-19019fff-aa2c-483e-83e3-46715e47ab51.png)\n◇每个颜色表示一组，共三组；eg:drwxr-xr-x; 其中-代表没有对应属性，此处即没有w(完整的一组是rwx)\n◇在目录上r-x不允许写是指不准修改目录名\n\n### chmod命令 \n◇ chmod 750: 组用户可读写，其他用户不允许访问 \n◇ chmod 777: 所有用户拥有完整权限 \n◇ chmod 700: 只有属主拥有完整权限 \n◇chmod  750 dev-document/(文件名/) #示例操作，\n### sudo超级管理员命令\n◇ sudo可以让普通用户拥有超级管理员的执行权限 \n◇ 普通用户要进行经过超级管理员授权才能使用 \n◇ 授权命令：visudo  \n◇普通模式下输入：100gg 快速定位到100行,无法再屏幕上看到命令；在此处的root ALL-(ALL) ALL下增加一行：\n[用户名] ALL-(ALL) ALL 即可授权用户拥有sudo命令；第一个ALL代表用户可以从任意计算机进行连接；第二个ALL表示切换用户，最后一个ALL代表运行执行所有命令；\n◇:wq保存文件后，使用命令visudo -c进行文件的格式检查;\n## CentOS7防火墙firewall\n### 什么是防火墙 \n◇ 防火墙是借助硬件和软件对内外部网络环境的保护措施 \n◇ CentOS 7基于firewall实现应用层防火墙,CentOS6基于iptables \n◇ firewall-cmd是firewall的核心命令 \n### firwall-cmd \n◇ systemctl start|restart firewalld #启动防火墙 \n◇ firewall-cmd --state | --reload #查看状态,重载防火墙 \n◇ firewall-cmd --zone=public --permanent --add-port=8502/tcp  \n### 对外开放Tomcat  \n◇解压apache-tomcat-9.0.34.tar.gz；进入apache-tomcat-9.0.34/bin目录启动startup.sh文件：./startup.sh \n◇增加放行端口：firewall-cmd --zone=public --permanent --add-port=8080/tcp #zone代表区域；permanent表示永久更改；将add改成remove即可去除端口;8000-9000可以用来进行端口范围的设置\n◇将防火墙进行重载\n## Bash Shell\n### 什么是Shell \nu Shell是一个用c语言编写的脚本解释器,是用户通过代码操作 Linux的桥梁 \nu Shell脚本描述要执行的任务,完成系列复杂操作,文件通常以.sh后缀 \nu Shell脚本通过Shell解释器执行,按解释器分类分为多种类型  \n### Linux Shell 分类\n![image.png](Linux基础和Java环境搭建/1630222283043-b5cd5a06-bbf9-4590-96b0-7028756802c4.png)\n### 一键发布Tomcat应用程序\n◇vim deploy_tomcat.sh创建脚本\n```\necho \"准备下载Tomcat9\"\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.52/bin/apache-tomcat-9.0.52.tar.gz\necho \"正在解压Tomcat9\"\ntar zxf apache-tomcat-9.0.52.tar.gz\necho \"防火墙开放8080端口\"\nfirewall-cmd --zone=public --permanent --add-port=8080/tcp\nfirewall-cmd --reload\necho \"启动Tomact\"\ncd ./apache-tomcat-9.0.52/bin\n./startup.sh\n```\n◇启动脚本文件：/bin/bash deploy_tomcat.sh;或./deploy.tomcat.sh\n## 部署OA项目\n### 部署架构\n![image.png](Linux基础和Java环境搭建/1630243029737-67057a7c-0650-4d8c-b630-bd8eab42b589.png)\n◇创建两个虚拟机CentosDB,CentosWEB，均最小化安装(不要图形界面);然后在界面输入: yum install -y net-tools.x86_64 #安装ifconfig等命令;\n◇使用Xshell进行远程连接；\n\n### Centos安装MySQL8\n◇yum search mysql-community #查看是否安装了mysql社区版\n◇mkdir mysql #在/usr/local目录下新建目录存放mysql\n◇wget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm) #获取下载\n◇yum install -y wget #安装wget 命令\n◇yum localinstall -y mysql80-community-release-el7-3.noarch.rpm #从本地安装rpm文件\n◇以上只是安装了mysql的安装源，还没有完成mysql的安装；\n◇yum install -y mysql-community-server #进行安装   ctrl+c可以停止安装\n◇cd /var/cache/yum/x86_64/7/mysql80-community/packages/ #进入yum下载的缓存路径\n◇进入官网找到Mysql Red Hat Enterprise Linux/ Oracle Linux；选择系统版本Linux 7 X86_64； 下载RPM Bundle；然后将这一组rpm文件传到缓存路径中；此时重新执行yum install -y mysql-community-server命令；以此可解决跨国服务器下载缓慢问题；\n◇systemctl start mysqld #启动服务  systemctl status mysqld #查看服务状态\n◇systemctl enable mysqld #设置为开机启动\n### 初始化MySQL8\n◇vi  /var/log/mysqld.log #进入mysql日志 在第3~4行可以看到自动生成的密码\n◇mysql -uroot -p #输入密码进行登录\n◇alter user 'root'@'localhost' identified with mysql_native_password by 'newpassword'(需要包含字母大小写以及数字，特殊符号，长度大于8位) 回车加上';' 即可修改，with mysql_native_password做与navicat的兼容考虑；\n◇默认的root用户只能从本机登录；use mysql #使用数据库； select host,user from user;#查询主机和用户\n◇update user set host='%' where user='root';#将root用户的host改为%,即任意设备都可以使用root用户连接mysql服务器; flush privileges #使刚才修改的权限立即生效\n◇exit #退出mysql\n◇放行3306端口并重载，使之能够远程访问mysql；\n◇打开Navicat，新建连接：主机即虚拟机的IP地址；\n### 部署配置Web应用服务\n◇yum search jdk #查看仓库中包含哪些版本的jdk;openjdk表示开源jdk\n◇yum install -y java-1.8.0-openjdk #安装jdk\n◇java -version #查看\n◇安装Tomcat;\n◇将oa项目的war包传到虚拟机中，解压；\n◇将解压后的oa目录移动：mv lcg_oa ./apache-tomcat-9.0.34/webapps/\n◇进入webapps目录，vim ./lcg_oa/WEB-INF/classes/mybatis-config.xml(yum install vim-common#安装vim基础包，yum install vim-enhanced#安装增强包)\n◇/root全文查找，在连接字符串的地方进行调整；将localhost改为mysql服务器的IP地址，密码改为相应的密码\n◇回到上一层目录进行Tomcat的配置: vim ./conf/server.xml ->搜索/8080->将端口改为80->按pagedown跳到最后\n->在Host标签上增加<Context path=\"/\" docBase=\"lcg_oa\"/>#将oa这个web应用映射的上下文路径指向根路径->:wq保存\n◇启动tomcat：./bin/startup.sh\n◇放行80端口，并重载\n◇在虚拟机DB中，屏蔽掉任意主机都能访问的3306端口；重载；\n◇firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"web服务器的IP地址\" port protocol=\"tcp\" port=\"3306\" accept\" #-rich-rule利用规则放行端口，这样就能放行指定主机指定端口的访问;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Linux"],"categories":["Java数据库","Linux与Redis基础"]},{"title":"项目完整实现","url":"/p/d371.html","content":"## 动态显示功能菜单\n### 第一部分：实现底层\n◇sql语句\n```sql\n-- 如何获取编号为 1的用户拥有哪些功能？\nSELECT DISTINCT n.* \nFROM\n\tsys_role_user ru,\n\tsys_role_node rn,\n\tsys_node n \nWHERE\n\tru.role_id = rn.role_id \n\tAND rn.node_id = n.node_id \n\tAND user_id = 1 \nORDER BY\n\tn.node_code\n```\n◇创建与数据库对应的Node节点类\n```sql\npublic class Node {\n    private Long nodeId;\n    private Integer nodeType;\n    private String nodeName;\n    private String url;\n    private Integer nodeCode;\n    private Long parentId;\n    ...\n    }\n```\n◇创建rbac.xml\n```sql\n<mapper namespace=\"rbacmapper\">\n    <!--获取用户编号对应的功能列表-->\n    <select id=\"selectNodeByUserId\" parameterType=\"Long\" resultType=\"com.lcg.oa.entity.Node\">\n        select distinct n.*\n        from\n        sys_role_user ru , sys_role_node rn , sys_node n\n        where\n        ru.role_id = rn.role_id and user_id = #{value} and rn.node_id = n.node_id\n        order by n.node_code\n    </select>\n</mapper>\n```\n◇创建dao对sql语句进行调用\n```sql\npublic class RbacDao {\n    public List<Node> selectNodeByUserId(Long userId) {\n        return (List)MybatisUtils.executeQuery(\n                sqlSession -> sqlSession.selectList(\n                        \"rbacmapper.selectNodeByUserId\", userId));\n    }\n}\n```\n◇在UserService中进行dao的调用\n```sql\nprivate RbacDao rbacDao = new RbacDao();\npublic List<Node> selectNodeByUserId(Long userId) {\n        List<Node> nodeList = rbacDao.selectNodeByUserId(userId);\n        return nodeList;\n    }\n```\n◇进行测试\n```sql\n @Test\n    public void selectNodeByUserId(){\n        List<Node> nodeList = userService.selectNodeByUserId(2l);//l表示长整型\n        System.out.println(nodeList);\n    }\n```\n### 第二部分：实现跳转\n◇更改LonginServlet增加返回项\n```sql\nresult.put(\"redirect_url\", \"/index\");\n```\n◇更改login.html用于接收新加的返回项\n```sql\n//跳转url\nwindow.location.href=json.redirect_url;\n```\n◇创建IndexServlet,并将index.html改为index.ftl\n```sql\n@WebServlet(name = \"IndexServlet\", urlPatterns = \"/index\")\npublic class IndexServlet extends HttpServlet {\n    private UserService userService = new UserService();\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        User user = (User)session.getAttribute(\"login_user\");\n        List<Node> nodeList = userService.selectNodeByUserId(user.getUserId());\n        request.setAttribute(\"node_list\",nodeList);\n        request.getRequestDispatcher(\"/index.ftl\").forward(request,response);\n    }\n}\n```\n◇如何把在登录页面login的用户登录信息保存，并用于后面的功能区分？方法是使用范围更广的session对象\n即在LonginServlet中进行如下更改：\n```sql\n//调用业务逻辑\nUser user = userService.checkLogin(username, password);\nHttpSession session = request.getSession();\n//向session存入登录用户信息,属性名:login_user\nsession.setAttribute(\"login_user\" , user);\n```\n◇修改index.ftl实现动态显示功能\n```xml\n <!--可折叠导航栏-->\n            <ul class=\"layui-nav layui-nav-tree\">\n                <#list node_list as node>\n                    <#if node.nodeType == 1>\n                        <!--父节点 模块 自定义属性：data-node-id-->\n                        <li class=\"layui-nav-item layui-nav-itemed\">\n                            <a href=\"javascript:void(0)\">${node.nodeName}</a>\n                            <dl class=\"layui-nav-child module\" data-node-id=\"${node.nodeId}\"></dl>\n                        </li>\n                    </#if>\n                    <#if node.nodeType == 2>\n                        <!--子节点 功能 自定义属性：data-parent-id-->\n                        <dd class=\"function\" data-parent-id=\"${node.parentId}\">\n                            <a href=\"javascript:void(0)\" target=\"ifmMain\">${node.nodeName}</a>\n                        </dd>\n                    </#if>\n                </#list>\n            </ul>\n```\n## Xml配置下实现Mapper接口\n◇创建员工实体类\n```xml\npublic class Employee {\n    private Long employeeId;\n    private String name;\n    private Long departmentId;\n    private String title;\n    private Integer level;\n}\n```\n◇创建dao接口\n```java\npublic interface EmployeeDao {\n    public Employee selectById(Long employeeId);\n}\n```\n◇创建mapper与接口对应\n```xml\n...\n    <!--namespace与包名要一致-->\n<mapper namespace=\"com.lcg.oa.dao.EmployeeDao\">\n    <!--id与方法名对应 parameterType与方法参数类型一致\n     resultType与方法返回类型一致-->\n    <select id=\"selectById\" parameterType=\"Long\" resultType=\"com.lcg.oa.entity.Employee\">\n        select * from adm_employee where employee_id = #{value}\n    </select>\n</mapper>\n```\n◇创建员工service ([getMapper的原理](https://blog.csdn.net/lbllol365))\n```java\n\npublic class EmployeeService {\n    /**\n     * 按编号查找员工\n     * @param employeeId 员工编号\n     * @return 员工对象，不存在时返回null\n     */\n    public Employee selectById(Long employeeId) {\n        return (Employee) MybatisUtils.executeQuery(sqlSession->{\n            //匹配相关的Mapper,sql语句原理可网上搜getMapper\n            //这里传入一个类对象后,就会得到一个可用的Dao接口\n            EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);\n            return employeeDao.selectById(employeeId);\n        });\n    }\n}\n```\n◇修改indexservlet\n```java\n\n@WebServlet(name = \"IndexServlet\", urlPatterns = \"/index\")\npublic class IndexServlet extends HttpServlet {\n    private UserService userService = new UserService();\n    private EmployeeService employeeService = new EmployeeService();\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        //得到当前登录用户对象\n        User user = (User)session.getAttribute(\"login_user\");\n        Employee employee = employeeService.selectById(user.getEmployeeId());\n        //获取登录用户可用功能模块列表\n        List<Node> nodeList = userService.selectNodeByUserId(user.getUserId());\n        //放入请求属性\n        request.setAttribute(\"node_list\",nodeList);\n        //放入session，范围更大,生命周期更长\n        session.setAttribute(\"current_employee\",employee);\n        //请求发至ftl进行展现\n        request.getRequestDispatcher(\"/index.ftl\").forward(request,response);\n    }\n}\n```\n◇修改首页\n```html\n<!--用户信息-->\n${current_employee.name}[部门-${current_employee.title}]\n```\n◇要想获取到部门，由于涉及到另外一张表，则按上面流程开发即可\n## 基于MD5算法对密码进行加密\n### MD5摘要算法\n◇MD5信息摘要算法广泛使用的密码散列函数\n◇MD5可以产生出一个128位的散列值用于唯一标识源数据\n◇项目中通常使用MD5作为敏感数据的加密算法\n### MD5特点 \n◇压缩性,MD5生成的摘要长度固定 \n◇抗修改,源数据哪怕有一个字节变化,MD5也会有巨大差异 \n◇不可逆,无法通过MD5反向推算源数据  \n### Apache Commons Codec \n◇Commons-Codec是Apache提供的编码/解码组件 \n◇通过Commons-Codec可轻易生成源数据的MD5摘要 \n◇MD5摘要方法: String md5 = DigestUtils.md5Hex(源数据)  \n◇增加依赖并放入发布的工程中\n### 使用方法\n◇增加依赖并放入发布的工程中\n```html\n        <dependency>\n            <groupId>commons-codec</groupId>\n            <artifactId>commons-codec</artifactId>\n            <version>1.14</version>\n        </dependency>\n```\n◇新增工具类\n```html\npublic class MD5Utils {\n    public static String md5Digest(String source) {\n        return DigestUtils.md5Hex(source);\n    }\n}\n```\n◇进行测试\n```html\n    @Test\n    public void md5Digest() {\n        System.out.println(MD5Utils.md5Digest(\"test\"));\n    }\n```\n### 敏感数据\"加盐\"混淆\n◇防止MD5被通过穷举法解密\n◇加盐方法\n```html\n    /**\n     * 对源数据加盐混淆后生成MD5摘要\n     * @param source 源数据\n     * @param salt 盐值\n     * @return MD5摘要\n     */\n    public static String md5Digest(String source, Integer salt) {\n        char[] ca = source.toCharArray();//字符数组\n        for (int i = 0; i < ca.length; i++) {\n            ca[i] = (char)(ca[i] + salt);\n        }\n        String target = new String(ca);\n        String md5 = DigestUtils.md5Hex(target);\n        return md5;\n    }\n```\n◇修改数据库sys_user表，添加salt字段,并将密码替换为加密后的MD5\n◇修改UserServlet\n```html\n//对前台输入的密码加盐混淆后生成MD5，与保存在数据库中的MD5密码进行比对\n        String md5 = MD5Utils.md5Digest(password, user.getSalt());\n        if (!md5.equals(user.getPassword())) {\n            throw new BussinessException(\"L002\", \"密码错误\");\n        }\n```\n## 实现注销功能\n◇即将保存在session中的用户登录信息清空\n◇创建servlet\n```html\n@WebServlet(name = \"LogoutServlet\",urlPatterns = \"/logout\")\npublic class LogoutServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        request.getSession().invalidate();//将当前会话清空\n        response.sendRedirect(\"/login.html\");\n    }\n}\n```\n◇修改index.ftl的注销按钮\n```html\n<!--注销按钮-->\n <li class=\"layui-nav-item\"><a href=\"/logout\">注销</a></li>\n```\n## 开发多级审批流程\n### 请假流程\n![image.png](项目实现/1629534603151-e5acea37-c1d7-4d81-a00c-44dc5aed535d.png)\n### 工作流程表设计\n![image.png](项目实现/1629534801614-f5435e56-73a6-4b7b-96d5-cf14aa718c9a.png)\n### 设计约束\n◇每一个请假单对应一个审批流程 \n◇请假单创建后,按业务规则生成部门经理、总经理审批任务 \n◇审批任务的经办人只能审批自己辖区内的请假申请 \n◇所有审批任务\"通过\",代表请假已经批准 \n◇任意审批任务\"驳回\"操作,其余审批任务取消,请假申请被驳回 \n◇请假流程中任意节点产生的操作都要生成对应的系统通知  \n### 新建数据库表\n◇请假单表\n![image.png](项目实现/1629535785248-df741014-3be2-491a-a49e-5cae76b65c01.png)\n◇处理流程表\n![image.png](项目实现/1629536465016-6c9047ef-981f-45f7-9667-771b7d355182.png)\n◇通知表\n![image.png](项目实现/1629549863768-811195fc-df94-4f7d-93a1-b1321685b5cb.png)\n\n## 实现Dao与数据交互\n### 创建表的实体类\n◇LeaveForm.class\n◇ProcessFlow.class\n◇Notice.class\n\n### 创建Dao接口\n◇LeaveFormDao\n```java\npublic interface LeaveFormDao {\n    public void insert(LeaveForm form);\n\n    public List<Map> selectByParams(@Param(\"pf_state\") String pfState, @Param(\"pf_operator_id\") Long operatorId);\n\n    public LeaveForm selectById(Long formId);\n\n    public void update(LeaveForm form);\n}\n```\n◇ProcessFlowDao\n```java\npublic interface ProcessFlowDao {\n    public void insert(ProcessFlow processFlow);\n\n    public void update(ProcessFlow processFlow);\n\n    public List<ProcessFlow> selectByFormId(Long formId);\n}\n```\n◇NoticeDao\n```java\npublic interface NoticeDao {\n    public void insert(Notice notice);\n\n    public List<Notice> selectByReceiverId(Long receiverId);\n}\n```\n### 创建对应的mapper\n◇leave_form.xml\n```xml\n<mapper namespace=\"com.lcg.oa.dao.LeaveFormDao\">\n    <!--useGeneratedKeys是否使用自增主键；keyProperty实体中的主键；keyColumn数据库表中的主键-->\n    <insert id=\"insert\" parameterType=\"com.lcg.oa.entity.LeaveForm\"\n    useGeneratedKeys=\"true\" keyProperty=\"formId\" keyColumn=\"from_id\">\n        INSERT INTO adm_leave_form( employee_id, form_type, start_time, end_time, reason, create_time, state)\n        VALUES ( #{employeeId}, #{formType}, #{startTime}, #{endTime}, #{reason}, #{createTime}, #{state})\n    </insert>\n</mapper>\n```\n◇process_flow.xml\n```xml\n<mapper namespace=\"com.lcg.oa.dao.ProcessFlowDao\">\n    <insert id=\"insert\" parameterType=\"com.lcg.oa.entity.ProcessFlow\"\n            useGeneratedKeys=\"true\" keyColumn=\"process_id\" keyProperty=\"processId\">\n      INSERT INTO adm_process_flow(form_id, operator_id, action, result, reason, create_time , audit_time , order_no , state,is_last)\n      VALUES (#{formId}, #{operatorId}, #{action}, #{result}, #{reason}, #{createTime} , #{auditTime} , #{orderNo} , #{state} , #{isLast});\n    </insert>\n\n    <update id=\"update\" parameterType=\"com.lcg.oa.entity.ProcessFlow\">\n      UPDATE adm_process_flow SET form_id = #{formId}, operator_id = #{operatorId}, action = #{action}, result = #{result}, reason = #{reason}, create_time = #{createTime}, audit_time = #{auditTime}, order_no = #{orderNo}, state = #{state}, is_last = #{isLast}\n      WHERE process_id = #{processId}\n    </update>\n\n    <select id=\"selectByFormId\" parameterType=\"Long\" resultType=\"com.lcg.oa.entity.ProcessFlow\">\n        select * from adm_process_flow where form_id = #{value} order by order_no\n    </select>\n</mapper>\n```\n◇notice.xml\n```xml\n<mapper namespace=\"com.lcg.oa.dao.NoticeDao\">\n    <insert id=\"insert\" parameterType=\"com.lcg.oa.entity.Notice\"\n            useGeneratedKeys=\"true\" keyProperty=\"noticeId\" keyColumn=\"notice_id\">\n        INSERT INTO sys_notice( receiver_id, content, create_time) VALUES (#{receiverId}, #{content}, #{createTime})\n    </insert>\n\n    <select id=\"selectByReceiverId\" parameterType=\"Long\" resultType=\"com.lcg.oa.entity.Notice\">\n        select * from sys_notice where receiver_id = #{value} order by create_time desc limit 0,100\n    </select>\n</mapper>\n```\n## 开发请假申请功能\n### 前期准备\n◇EmployeeDao增加代码\n```java\n /**\n     * 根据传入员工对象获取上级主管对象\n     * @param employee 员工对象\n     * @return 上级主管对象\n     */\n    public Employee selectLeader(@Param(\"emp\") Employee employee);\n```\n◇在employee.xml中增加对应的sql语句\n```java\n<select id=\"selectLeader\" parameterType=\"com.lcg.oa.entity.Employee\" resultType=\"com.lcg.oa.entity.Employee\">\n        select * from adm_employee\n        where \n        <if test=\"emp.level&lt;7\"> <!--'<'的转义-->\n            level = 7 and department_id = #{emp.departmentId}\n        </if>\n        <if test=\"emp.level == 7\"> \n            level = 8\n        </if>\n        <if test=\"emp.level == 8\">\n            employee_id = #{emp.employeeId}\n        </if>\n    </select>\n```\n◇新增业务常量，用来保存指定时间之类的数据\n```java\npublic class BussinessConstants {\n    public static final int MANAGER_AUDIT_HOURS=36;//总经理请假审批时间阈值\n}\n```\n### 创建service\n◇请假单流程服务LeaveFormService\n```java\npublic class LeaveFormService {\n    /**\n     * 创建请假单\n     *\n     * @param form 前端输入的请假单数据\n     * @return 持久化后的请假单对象\n     */\n    public LeaveForm createLeaveForm(LeaveForm form) {\n        //1.持久化form表单数据,8级以下员工表单状态为processing,8级(总经理)状态为approved\n        //2.增加第一条流程数据,说明表单已提交,状态为complete\n        //3.分情况创建其余流程数据\n        //3.1 7级以下员工,生成部门经理审批任务,请假时间大于72小时,还需生成总经理审批任务\n        //3.2 7级员工,生成总经理审批任务\n        //3.3 8级员工,生成总经理审批任务,系统自动通过\n    }\n}\n```\n### 创建控制器\n◇LeaveFormServlet\n```java\n@WebServlet(name = \"LeaveFormServlet\",urlPatterns = \"/leave/*\")\npublic class LeaveFormServlet extends HttpServlet {\n    private LeaveFormService leaveFormService = new LeaveFormService();\n    private Logger logger = LoggerFactory.getLogger(LeaveFormServlet.class);\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        \n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request,response);\n    }\n    /**\n     * 创建请假单\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    private void create(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 接收各项请假单数据\n        ...\n            //2. 调用业务逻辑方法\n            ...\n        //3. 组织响应数据\n            ...\n    }\n}\n```\n## 实现请假申请功能\n ◇表单html文件部分代码 \n```java\n<script>\n\n        var layDate = layui.laydate; //Layui日期选择框JS对象\n        var layForm = layui.form; //layui表单对象\n        var $ = layui.$; //jQuery对象\n        //日期时间范围\n        layDate.render({\n            elem: '#daterange' //表示将id为daterange的文本框渲染成日期选择框\n            ,type: 'datetime'  //日期+时间\n            ,range: true\n            ,format: 'yyyy年M月d日H时'\n            ,done: function(value, start, end){//自动触发事件\n                //选择日期后出发的时间,设置startTime与endTime隐藏域,按照服务器要求的格式\n                var startTime = start.year + \"-\" + start.month + \"-\" + start.date + \"-\" + start.hours;\n                var endTime = end.year + \"-\" + end.month + \"-\" + end.date + \"-\" + end.hours;\n                console.info(\"请假开始时间\",startTime);\n                $(\"#startTime\").val(startTime);\n                console.info(\"请假结束时间\",endTime);\n                $(\"#endTime\").val(endTime);\n            }\n        });\n\n        //表单提交时间,data.field由Layui提供可以获取表单所有数据，并封装成键值对\n        layForm.on('submit(sub)', function(data){\n            console.info(\"向服务器提交的表单数据\",data.field);\n            $.post(\"/leave/create\",data.field,function (json) {\n                console.info(json);\n                if(json.code == \"0\"){\n                    /*SweetAlert2确定对话框*/\n                    swal({\n                        type: 'success',\n                        html: \"<h2>请假单已提交,等待上级审批</h2>\",\n                        confirmButtonText: \"确定\"\n                    }).then(function (result) {//点击确定后的触发事件\n                        window.location.href=\"/forward/notice\";//跳转到指定路径\n                    });\n                }else{\n                    swal({\n                        type: 'warning',\n                        html: \"<h2>\" + json.message + \"</h2>\",\n                        confirmButtonText: \"确定\"\n                    });\n                }\n            },\"json\");\n            return false;\n        });\n\n</script>\n```\n\n◇[sweetalert官网](https://sweetalert.js.org),用来美化对话框\n◇新增控制器ForwardServlet，通用的页面跳转的servlet，可以支持跳转多个页面\n```java\n@WebServlet(name = \"ForwardServlet\",urlPatterns = \"/forward/*\")\npublic class ForwardServlet extends HttpServlet {\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String uri = request.getRequestURI();\n        /**\n         * /forward/form\n         * /forward/a/b/c/form\n         */\n        String subUri = uri.substring(1);// forward/form; forward/a/b/c/form\n        String page = subUri.substring(subUri.indexOf(\"/\"));// /form; /a/b/c/form\n        request.getRequestDispatcher(page+\".ftl\").forward(request,response);\n    }\n}\n\n```\n◇将数据库node表的url填上\n![image.png](项目实现/1629643640665-e8f0db6d-9480-4d4c-ac94-20b31826033a.png)\n◇修改index.ftl,将href改为${node.url}\n\n```java\n<a href=\"${node.url}\" target=\"ifmMain\">${node.nodeName}</a>\n```\n## 请假审批功能\n### 新增sql语句\n◇在leave_form.xml中新增查询，多个参数（工作流程任务状态；经办人）查询请假单，由于查询的字段来自不同的表，所以返回类型也是map而非某个实体类\n```xml\n    <select id=\"selectByParams\" parameterType=\"java.util.Map\" resultType=\"java.util.Map\">\n        select f.* ,e.name , d.*\n        from\n          adm_leave_form f,adm_process_flow pf , adm_employee e , adm_department d\n        where\n          f.form_id = pf.form_id\n          and f.employee_id = e.employee_id\n          and e.department_id = d.department_id\n          and pf.state = #{pf_state} and pf.operator_id = #{pf_operator_id}\n    </select>\n```\n◇在Dao中增加相应的接口对应\n```java\n//多个参数采用注解形式说明其在xml中的参数类型,名称须一致\npublic List<Map> selectByParams(@Param(\"pf_state\") String pfState, \n                                @Param(\"pf_operator_id\") Long operatorId);\n```\n### 修改Service\n◇在LeaveFormService中新增方法用来获取请假单\n```java\n /**\n     * 获取指定任务状态及指定经办人对应的请假单列表\n     * @param pfState ProcessFlow任务状态\n     * @param operatorId 经办人编号\n     * @return 请假单及相关数据列表\n     */\n    public List<Map> getLeaveFormList(String pfState, Long operatorId) {\n        return (List<Map>) MybatisUtils.executeQuery(sqlSession->{\n            LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class);\n            List<Map> formList = dao.selectByParams(pfState, operatorId);\n            return formList;\n        });\n    }\n```\n◇在Servlet中对service进行调用\n```java\nif (methodName.equals(\"create\")) {\n            this.create(request,response);\n        } else if (methodName.equals(\"list\")) {\n            this.getLeaveFormList(request, response);\n        } \n\n/**\n     * 查询需要审核的请假单列表\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    private void getLeaveFormList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        User user = (User) request.getSession().getAttribute(\"login_user\");\n        List<Map> formList = leaveFormService.getLeaveFormList(\"process\", user.getEmployeeId());\n        Map result = new HashMap();\n        //4个属性满足layUI数据表格的要求\n        result.put(\"code\", \"0\");//表示服务器端处理成功\n        result.put(\"msg\", \"\");//服务器返回的具体文本消息\n        result.put(\"count\", formList.size());//所有数据的总数\n        result.put(\"data\", formList);//显示的对象列表\n        String json = JSON.toJSONString(result);\n        response.getWriter().println(json);\n    }\n```\n### 新增ftl文件用来审批\n◇部分代码\n```java\n<script>\n    var $ = layui.$;\n    //将毫秒数转换为\"yyyy-MM-dd HH时\"字符串格式\n    function formatDate(time){\n        var newDate = new Date(time);\n        return newDate.getFullYear() + \"-\" +\n            (newDate.getMonth() + 1) + \"-\" + newDate.getDate()\n            + \" \" + newDate.getHours() + \"时\";\n    }\n    // 将table渲染为数据表格\n    layui.table.render({\n        elem : \"#grdFormList\" , //选择器\n        id : \"grdFormList\" , //id\n        url : \"/leave/list\" , //ajax请求url\n        page : false , //是否分页 true-是 false-否\n        cols :[[ //列描述\n            {title : \"\" , width:70 , style : \"height:60px\" , type:\"numbers\"}, // numbers代表序号列\n            {field : \"create_time\" , title : \"申请时间\" , width : 150 , templet: function (d) {\n                //templet代表对数据进行加工后再显示\n                return formatDate(d.create_time)\n            }},\n            {field : \"form_type\" , title : \"类型\" , width : 100 , templet: function(d){\n                switch (d.form_type) {\n                    case 1:\n                        return \"事假\";\n                    case 2:\n                        return \"病假\";\n                    case 3:\n                        return \"工伤假\";\n                    case 4:\n                        return \"婚假\";\n                    case 5:\n                        return \"产假\";\n                    case 6:\n                        return \"丧假\";\n                }\n            }},\n            {field : \"department_name\" , title : \"部门\" , width : 100},\n            {field : \"name\" , title : \"员工\" , width : 100},\n            {field : \"start_time\" , title : \"起始时间\" , width : 150, templet: function (d) {\n                    return formatDate(d.start_time)\n                }},\n            {field : \"end_time\" , title : \"结束时间\" , width : 150 , templet: function (d) {\n                    return formatDate(d.end_time)\n                }},\n            {field : \"reason\" , title : \"请假原因\" , width : 350 },\n            {title : \"\" , width:150 ,type:\"space\" , templet : function(d){\n                var strRec = JSON.stringify(d);\n                console.info(\"请假单数据\", strRec);\n                //将请假单数据存放至data-laf属性中\n                return \"<button class='layui-btn layui-btn-danger layui-btn-sm btn-audit' data-laf=\" + strRec + \" >审批</button>\";\n            }}\n        ]]\n    })\n\n    // 绑定每一行的审批按钮\n    $(document).on(\"click\" , \".btn-audit\" , function(){\n        //初始化表单\n        $(\"#divDialog form\")[0].reset();\n        $(\"#divDialog form form-item-value\").text(\"\");\n        //获取当前点击按钮的请假单数据,回填至显示项\n        var laf = $(this).data(\"laf\");\n        $(\"#dname\").text(laf.department_name);\n        $(\"#name\").text(laf.name);\n        $(\"#startTime\").text(formatDate(laf.start_time));\n        $(\"#endTime\").text(formatDate(laf.end_time));\n        $(\"#reason\").text(laf.reason);\n        $(\"#formId\").val(laf.form_id);\n        //弹出layui对话框\n        layui.layer.open({\n            type : \"1\" , //页面层\n            title : \"请假审批\" , //标题\n            content : $(\"#divDialog\") , //指定对话框容器对象\n            area : [\"500px\" , \"400px\"] , //尺寸\n            end : function(){ //销毁后触发事件\n                $(\"#divDialog\").hide();\n            }\n        })\n    })\n    /**\n     * 提交审批数据\n     */\n    layui.form.on(\"submit(audit)\" , function(data){\n        $.ajax({\n            url : \"/leave/audit\", //审核URL\n            data : data.field ,\n            type : \"post\" ,\n            success: function (json) {\n                //关闭所有layui对话框\n                layui.layer.closeAll();\n                //显示处理结果\n                if(json.code == \"ok\"){\n                    swal({\n                        type: 'success',\n                        html: \"<h2>请假已审批完毕</h2>\",\n                        confirmButtonText: \"确定\"\n                    }).then(function (result) {\n                        window.location.href=\"/forward/notice\";\n                    });\n                }else{\n                    swal({\n                        type: 'warning',\n                        html: \"<h2>\" + json.msg + \"</h2>\",\n                        confirmButtonText: \"确定\"\n                    });\n                }\n            }\n        })\n        return false;\n    })\n\n</script>\n```\n◇出现错误：Page template not found\n可能是ftl文件没有找到；解决方法：重启Tomcat或者将ftl文件删除后重新创建再重启Tomcat\n## 实现审批业务逻辑\n### 审批流程可能出现的三种情况\n①需要总经理审批的，中间节点处理完成，并且部门经理审批通过，则后续节点reday->process\n②中间节点有驳回，则后续所有节点变为cancel\n③如果当前节点是最后一个，无论审批通过还是拒绝，执行完以后整个流程都会结束，所有节点状态都变为complete，同时表单状态变为处理结果\n### 代码实现 \n--在process_flow.xml中新增查询语句，通过FormId查询所有的处理表单数据，并且新增更新语句，用来更新任务状态\n```xml\n<update id=\"update\" parameterType=\"com.lcg.oa.entity.ProcessFlow\">\n      UPDATE adm_process_flow SET form_id = #{formId}, operator_id = #{operatorId}, action = #{action}, result = #{result}, reason = #{reason}, create_time = #{createTime}, audit_time = #{auditTime}, order_no = #{orderNo}, state = #{state}, is_last = #{isLast}\n      WHERE process_id = #{processId}\n    </update>\n\n    <select id=\"selectByFormId\" parameterType=\"Long\" resultType=\"com.lcg.oa.entity.ProcessFlow\">\n        select * from adm_process_flow where form_id = #{value} order by order_no\n    </select>\n```\n--在接口中将刚才新增的两条查询语句的方法写上\n```java\n    public LeaveForm selectById(Long formId);\n\n    public void update(LeaveForm form);\n```\n--在leave_form.xml在新增sql语句\n```java\n<select id=\"selectById\" parameterType=\"Long\" resultType=\"com.imooc.oa.entity.LeaveForm\">\n        select * from adm_leave_form where form_id = #{value}\n    </select>\n\n    <update id=\"update\" parameterType=\"com.imooc.oa.entity.LeaveForm\">\n        UPDATE adm_leave_form SET employee_id = #{employeeId} , form_type = #{formType}, start_time = #{startTime}, end_time = #{endTime}, reason = #{reason}, state = #{state} ,create_time = #{createTime} WHERE form_id = #{formId}\n    </update>\n```\n--在LeaveForm中新增对应的方法\n```java\n public LeaveForm selectById(Long formId);\n\n public void update(LeaveForm form);\n```\n--在LeaveFormService中新增方法，部分代码\n```java\n/**\n     * 审核请假单\n     * @param formId 表单编号\n     * @param operatorId 经办人(当前登录员工)\n     * @param result 审批结果\n     * @param reason 审批意见\n     */\n    public void audit(Long formId , Long operatorId , String result , String reason){\n        MybatisUtils.executeUpdate(sqlSession->{\n            //1.无论同意/驳回，当前任务状态变更为complete\n            //2.如果当前任务是最后一个节点，代表流程结束，更新请假单状态为对应的approve/refused\n            //3.如果当前任务不是最后一个节点且审批通过，那下一个节点的状态：ready->process\n            //4.如果当前任务不是最后一个节点且审批驳回，则后续所有任务状态变为cancel，请假单状态变为refused\n        })\n    }\n```\n### 完整实现请假审批\n◇在LeaveFormServlet中新建方法用来处理审批操作\n```java\n/**\n     * 处理审批操作\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    private void audit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String formId = request.getParameter(\"formId\");\n        String result = request.getParameter(\"result\");\n        String reason = request.getParameter(\"reason\");\n        User user = (User)request.getSession().getAttribute(\"login_user\");\n        Map mpResult = new HashMap();\n        try {\n            leaveFormService.audit(Long.parseLong(formId), user.getEmployeeId(), result, reason);\n            mpResult.put(\"code\", \"0\");\n            mpResult.put(\"message\", \"success\");\n        }catch(Exception e){\n            logger.error(\"请假单审核失败\",e);\n            mpResult.put(\"code\", e.getClass().getSimpleName());\n            mpResult.put(\"message\", e.getMessage());\n        }\n        String json = JSON.toJSONString(mpResult);\n        response.getWriter().println(json);\n    }\n```\n◇url绑定\n```java\nelse if (methodName.equals(\"audit\")) {\n            this.audit(request, response);\n        }\n```\n◇修改audit.ftl，新增dataType；\n```java\nurl : \"/leave/audit\", //审核URL\n            data : data.field ,\n            type : \"post\" ,\n            dataType :\"json\", //服务器返回类型为json字符串\n```\n◇将成功的判断条件由\"ok\"改为**if**(json.**code **== **\"0\"**){_//0，代表成功，与后台一致_\n◇将提示信息由**html**: **\"<h2>\" **+ json.msg + **\"</h2>\"**,改为 json.**message **\n## 开发系统通知功能\n### 创建系统消息\n◇消息的触发时机：①当员工提交请假申请时；②当请假流程中间节点发生变化时\n◇部分代码\n--请假申请时\n```java\n //String.format用于输出指定格式的字符串\n String noticeContent = String.format(\"您的请假申请[%s-%s]已提交，请等待上机审批.\"\n        ,sdf.format(form.getStartTime()), sdf.format(form.getEndTime()));\nnoticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));//存放数据库\n//通知部门经理审批\nnoticeContent = String.format(\"%s-%s提起请假申请[%s-%s],请尽快审批\"\n        ,employee.getTitle(),employee.getName(),sdf.format(form.getStartTime())\n         ,sdf.format(form.getEndTime()));\n noticeDao.insert(new Notice(dmanger.getEmployeeId(),noticeContent));\n```\n--审批直接完成时\n```java\n//2.如果当前任务是最后一个节点，代表流程结束，更新请假单状态为对应的approve/refused\nLeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);\nLeaveForm form = leaveFormDao.selectById(formId);\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd-HH时\");\nEmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);\nEmployee employee = employeeDao.selectById(form.getEmployeeId());//表单提交人信息\nEmployee operator = employeeDao.selectById(operatorId);//任务经办人信息\nNoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);\nif (process.getIsLast() == 1) {\n    form.setState(result);//approve|refused\n    leaveFormDao.update(form);\n    String strResult = null;\n    if (result.equals(\"approve\")) {\n        strResult = \"批准\";\n    } else if (result.equals(\"refused\")) {\n        strResult = \"驳回\";\n    }\n    String noticeContent = \n        String.format(\"您的请假申请[%s-%s]%s%s已%s,审批意见:%S,审批流程已结束\"\n        ,sdf.format(form.getStartTime()), sdf.format(form.getEndTime())\n        ,operator.getTitle(),operator.getName(),strResult,reason);//发给表单提交人的通知\n    noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent));\n    //发给审批人的通知\n    noticeContent = \n        String.format(\"%s-%s提起请假申请[%s-%s]您已%s,审批意见:%s,审批流程已结束\" ,\n         employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) \n          , sdf.format(form.getEndTime()), strResult , reason);\n    noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent));\n```\n--审批还需要总经理处理时\n```java\n//3.如果当前任务不是最后一个节点且审批通过\n if (result.equals(\"approved\")) {\n//消息1: 通知表单提交人,部门经理已经审批通过,交由上级继续审批\nString noticeContent1 = \n    String.format(\"您的请假申请[%s-%s]%s%s已批准,审批意见:%s ,请继续等待上级审批\" ,\n                  sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),\n                  operator.getTitle() , operator.getName(),reason);\nnoticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));\n\n//消息2: 通知总经理有新的审批任务\nString noticeContent2 = \n    String.format(\"%s-%s提起请假申请[%s-%s],请尽快审批\" ,\n         employee.getTitle() , employee.getName() , sdf.format( form.getStartTime())\n                  , sdf.format(form.getEndTime()));\nnoticeDao.insert(new Notice(readyProcess.getOperatorId(),noticeContent2));\n\n//消息3: 通知部门经理(当前经办人),员工的申请单你已批准,交由上级继续审批\nString noticeContent3 =\n    String.format(\"%s-%s提起请假申请[%s-%s]您已批准,审批意见:%s,申请转至上级领导继续审批\" ,\n         employee.getTitle() , employee.getName()\n           , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason);\nnoticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent3));\n }else if(result.equals(\"refused\")) {\n     //4.如果当前任务不是最后一个节点且审批驳回\n     for(ProcessFlow p:readyList){\n         p.setState(\"cancel\");\n         processFlowDao.update(p);\n     }\n     form.setState(\"refused\");\n     leaveFormDao.update(form);\n     //消息1: 通知申请人表单已被驳回\n     String noticeContent1 = \n         String.format(\"您的请假申请[%s-%s]%s%s已驳回,审批意见:%s,审批流程已结束\" ,\n                       sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),\n                       operator.getTitle() , operator.getName(),reason);\n     noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));\n\n     //消息2: 通知经办人表单\"您已驳回\"\n     String noticeContent2 = \n         String.format(\"%s-%s提起请假申请[%s-%s]您已驳回,审批意见:%s,审批流程已结束\" ,\n     employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) \n                       , sdf.format(form.getEndTime()), reason);\n     noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent2));\n                }\n```\n### 显示系统消息\n◇在notice.xml中新增查询语句\n```java\n<select id=\"selectByReceiverId\" parameterType=\"Long\" resultType=\"com.lcg.oa.entity.Notice\">\n        select * from sys_notice where receiver_id = #{value} order by create_time desc limit 0,100\n    </select>\n```\n◇在dao中进行定义\n```java\npublic List<Notice> selectByReceiverId(Long receiverId);\n```\n◇新增NoticeService\n```java\n/**\n * 消息服务\n */\npublic class NoticeService {\n    /**\n     * 查询指定员工的系统消息\n     * @param receiverId\n     * @return 最近100条消息列表\n     */\n    public List<Notice> getNoticeList(Long receiverId){\n        return (List)MybatisUtils.executeQuery(sqlSession -> {\n            NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);\n            return noticeDao.selectByReceiverId(receiverId);\n        });\n    }\n}\n```\n◇创建NoticeServlet向客户端返回数据\n\n```java\n@WebServlet(name = \"NoticeServlet\" , urlPatterns = \"/notice/list\")\npublic class NoticeServlet extends HttpServlet {\n    private NoticeService noticeService = new NoticeService();\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        User user = (User)request.getSession().getAttribute(\"login_user\");\n        List<Notice> noticeList = noticeService.getNoticeList(user.getEmployeeId());\n        Map result = new HashMap<>();\n        result.put(\"code\", \"0\");\n        result.put(\"msg\", \"\");\n        result.put(\"count\", noticeList.size());\n        result.put(\"data\", noticeList);\n        String json = JSON.toJSONString(result);\n        response.setContentType(\"text/html;charset=utf-8\");\n        response.getWriter().println(json);\n    }\n}\n\n```\n◇notice.ftl页面部分代码\n```java\n<script>\n    layui.table.render({\n        elem : \"#grdNoticeList\" ,\n        id : \"grdNoticeList\" ,\n        url : \"/notice/list\" ,//请求数据的地址\n        page : false ,\n        cols :[[\n            {field : \"\" , title : \"序号\" , width:\"10%\" , style : \"height:60px\" , type:\"numbers\"},\n            {field : \"create_time\" , title : \"通知时间\" , width : \"20%\" , templet: function (d) {\n                    var newDate = new Date(d.createTime);\n                    return newDate.getFullYear() + \"-\" +\n                        (newDate.getMonth() + 1) + \"-\" + newDate.getDate()\n                        + \" \" + newDate.getHours() + \":\" + newDate.getMinutes() + \":\" + newDate.getSeconds();\n                }},\n            {field : \"content\" , title : \"通知内容\" , width : \"60%\"}\n        ]]\n    })\n\n</script>\n```\n◇修改index.ftl使用户一登录就能看到通知消息，即将首页内置框架绑定到notice上\n```java\n <!--主体部分采用iframe嵌入其他页面-->\n    <div class=\"layui-body\" style=\"overflow-y: hidden\">\n        <iframe name=\"ifmMain\" src=\"/forward/notice\" style=\"...\"></iframe>\n    </div>\n```\n\n\n\n\n","tags":["MyBaits"],"categories":["Java数据库","OA系统项目"]},{"title":"项目介绍及基础实现","url":"/p/2f49.html","content":"##  课程介绍 \n◇需求说明与环境准备 \n◇开发基于RABC的访问控制模块 \n◇开发多级请假审批流程  \n\n##  办公自动化OA系统 \n◇办公自动化系统(Office Automation)是替代传统办公的解决方案 \n◇OA系统是利用软件技术构建的单位内部办公平台,用于辅助办公 \n◇利用OA系统可将办公数据数字化,可极大提高办公流程执行效率，项目完整代码见[oa](https://github.com/618dt/JavaPractice/tree/main/oa)\n\n##  需求介绍 \n◇办公OA系统要求采用多用户B/S架构设计开发 \n◇HR为每一位员工分配系统账户,员工用此账户登录系统 \n◇公司采用分级定岗,从1-8依次提升,不同岗位薪资水平不同  \n◇6级(含)以下员工为业务岗,对应人员执行公司业务事宜 \n◇7-8级为管理岗,其中7级为部门经理,8级为总经理 \n◇业务岗与管理岗员工可用系统功能不同,要求允许灵活配置  \n 需求介绍-请假流程 \n◇公司所有员工都可以使用”请假申请”功能申请休假 \n◇请假时间少于72小时,部门经理审批后直接通过 \n◇请假时间大于72小时,部门经理审批后还需总经理进行审批\n◇部门经理只允许批准本部门员工申请 \n◇部门经理请假需直接由总经理审批 \n◇总经理提起请假申请,系统自动批准通过   \n![image.png](项目介绍/1629078647393-4553179d-4d5e-4bdb-a5e7-5754c0f49278.png)\n\n##  搭建基础架构  \n###  框架&组件 \n◇MySQL 8                 ◇Mybatis 3.5 \n◇Alibaba Druid         ◇Servlet 3.1 \n◇Freemarker 2.3       ◇LayUI 2.5  \n### 搭建数据库\n◇新建数据库lcg-oa，字符集选择utf8m4，排序规则默认\n### 创建Maven工程\n◇新建maven项目oa，JDK选择1.8\n◇进行工程设置以便将项目发布到服务器上：File->Project Structure->Modules->+->Web->Path:改为oa\\src\\main\\webapp\\WEB-INF\\web.xml;version:3.1; Web Resource Directory:选中webapp目录->Create Artifact->OK\n◇配置Tomcat:在工具栏上点击Add Configuration->+->Tomcat Server->Local(用本地的Tomcat来运行)->勾选After lanuch自动打开浏览器->HTTP port :80->Deployment(运行部署配置)->+->Artifact->Application context(应用上下文):/  ->Apply->OK->下方为弹出Web面板\n### 配置文件\n◇pom.xml配置\n```xml\n//使用阿里云镜像仓库提高下载速度\n    <repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n//项目依赖\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.3</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.19</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>  //阿里巴巴连接池\n            <artifactId>druid</artifactId>\n            <version>1.1.14</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>      //单元测试\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n        <dependency>\n            <groupId>ch.qos.logback</groupId> //集成日志\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n    </dependencies>\n```\n◇mybatis核心配置文件：在resource目录下创建mybatis-config.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <settings>\n        <!--开启驼峰命名转换 form_id -> formId-->\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n    </settings>\n    <environments default=\"dev\">\n        <!--开发环境配置-->\n        <environment id=\"dev\">\n            <!--事务管理器采用JDBC方式-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--利用Mybatis自带连接池管理连接\n            <dataSource type=\"POOLED\">-->\n            <!--MyBatis与Druid的整合-->\n            <dataSource type=\"com.lcg.oa.datasource.DruidDataSourceFactory\">\n                <!--JDBC连接属性-->\n                <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" //连接字符串lcg-oa是数据库名\n                     value=\"jdbc:mysql://localhost:3306/lcg-oa ? useSSL=false&amp;\n                     useUnicode=true&amp;characterEncoding=UTF-8&amp;\n                     serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"www.LCG.com\"/>\n                <!--连接池初始连接数-->\n                <property name=\"initialSize\" value=\"10\"/>\n                <!--连接池最大连接数-->\n                <property name=\"maxActive\" value=\"20\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"mappers/test.xml\"/>\n    </mappers>\n</configuration>\n```\n ◇java目录下创建com.lcg.oa.utils.MybatisUtils工具类用于对Mybatis进行加载，SessionFactory对象的创建等初始化工作\n```java\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.function.Function;\npublic class MybatisUtils {\n    //利用static(静态)属于类不属于对象,且全局唯一\n    private static SqlSessionFactory sqlSessionFactory = null;\n    //利用静态块在初始化类时实例化sqlSessionFactory\n    static{\n        Reader reader = null;\n        try{\n            reader = Resources.getResourceAsReader(\"mybatis-config.xml\");\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n        }catch(IOException e){\n            //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    /**\n     * 执行SELECT查询SQL\n     * @param func 要执行查询语句的代码块\n     * @return 查询结果\n     *具体的查询交给Function实现，在进行查询之前对sqlSession进行了打开和自动关闭\n     *Function<T,R>函数式接口，对应一个输入且需要返回数据的功能代码\n     */\n    public static Object executeQuery(Function<SqlSession,Object> func){\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        try {\n            //apply方法用于返回函数执行的结果\n            Object obj = func.apply(sqlSession);\n            return obj;\n        }finally {\n            sqlSession.close();\n        }\n    }\n\n    /**\n     * 执行INSERT/UPDATE/DELETE写操作SQL\n     * @param func 要执行的写操作代码块\n     * @return 写操作后返回的结果\n     */\n    public static Object executeUpdate(Function<SqlSession,Object> func){\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        try {\n            Object obj = func.apply(sqlSession);\n            sqlSession.commit();\n            return obj;\n        }catch (RuntimeException e){\n            sqlSession.rollback();\n            throw e;\n        }finally{\n            sqlSession.close();\n        }\n    }\n}\n\n```\n◇解决![image.png](项目介绍/1629083017280-f122b9d6-77bf-4a8c-90de-abdfa7304826.png)问题；函数式接口需要jdk1.8版本以上，但maven中统一按照1.5版本进行编译，因此需要在pom.xml配置文件中进行相关设置；在build块中，用于描述当前程序构建的各种细节；在build块中对maven的编译插件进行设置\n```xml\n<build>\n        <plugins>\n            <plugin>\n                <!--利用Maven编译插件将编译级别提高至1.8,解决lambda表达式错误-->\n                <groupId>org.apache.maven.plugins</groupId>\n                <!--maven-compiler-plugin是Maven自带的编译插件-->\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.3</version>\n                <configuration>\n                    <!--检查源码采用1.8规则,默认为1.5-->\n                    <source>1.8</source>\n                    <!--按1.8规则生成字节码-->\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n◇mybatis执行sql的时候要有对应的mapper.xml文件，并且在核心配置文件(mybatis-config.xml)中进行配置；在resource目录下创建mappers目录用于存放此类文件，在其中创建一个test.xml文件进行测试\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \n\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"test\">\n    <select id=\"sample\" resultType=\"String\">\n        select 'success'  //不从任何表中获取数据，只是返回success字符串\n    </select>\n</mapper>\n\n//核心配置文件配置\n    <mappers>\n        <mapper resource=\"mappers/test.xml\"/>\n    </mappers>\n\n//测试类进行测试，引用lambada表达式\npublic class MybatisUtilsTestor {\n    @Test\n    public void testcase1(){\n        String result = (String)MybatisUtils.executeQuery(sqlSession->{\n            String out = (String)sqlSession.selectOne(\"test.sample\");\n            return out;\n        });\n        System.out.println(result);\n    }\n    @Test\n    public void testcase2(){\n        String result = (String) MybatisUtils.executeQuery(\n                sqlSession -> sqlSession.selectOne(\"test.sample\"));\n        System.out.println(result);\n    }\n}\n```\n### 连接池设置\n◇oa目录下创建子包datasource，在其下创建类DruidDataSourceFactory(数据源工厂类)\n◇执行顺序：首先通过构造方法创建空的数据源对象，然后调用setProperties方法读取xml文件\n并对刚才实例化的数据源进行属性设置；如果在获取数据源的时候必须要进行额外操作，则应重写\ngetDataSource方法\n```java\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\n\npublic class DruidDataSourceFactory extends UnpooledDataSourceFactory {\n    public DruidDataSourceFactory(){\n        this.dataSource = new DruidDataSource();\n    }\n    /**\n     * DataSource是javax.sql包提供的接口，用来说明所有的数据源都要实现这个接口\n     * DruidDataSource当然也实现了这个接口；这样，当需要更换数据库连接池时，只需要\n     * 实例化不同的DataSource实现类即可\n     *\n     */\n    @Override//进行重写代码：code->override 是否进行重写视连接池的类型而定\n    public DataSource getDataSource() {\n        try {\n            ((DruidDataSource)this.dataSource).init();//初始化Druid数据源\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n        return this.dataSource;\n    }\n}\n```\n### 整合Freemarker\n◇pom.xml增加依赖\n```java\n <!--Freemarker依赖-->\n        <dependency>\n            <groupId>org.freemarker</groupId>\n            <artifactId>freemarker</artifactId>\n            <version>2.3.29</version>\n        </dependency>\n        <!--servlet-api-->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n            <!--依赖只参与编译测试,不进行发布-->\n            <scope>provided</scope>\n        </dependency>\n```\n◇web.xml进行配置servlet\n```java\n <servlet>\n        <!--FreemakrerServlet用于读取解析ftl文件-->\n        <servlet-name>freemakrer</servlet-name>\n        <servlet-class>freemarker.ext.servlet.FreemarkerServlet</servlet-class>\n        <!-- 定义模板的存储路径 -->\n        <init-param>\n            <param-name>TemplatePath</param-name>\n            <param-value>/WEB-INF/ftl</param-value>\n        </init-param>\n        <init-param>\n            <!--default_encoding用于设置读取ftl文件时采用的字符集,进而避免中文乱码的产生-->\n            <param-name>default_encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>freemakrer</servlet-name>\n        <url-pattern>*.ftl</url-pattern>\n    </servlet-mapping>\n```\n◇在WEB-INF目录下创建ftl目录，然后将test.html移入并改为test.ftl (freemarker脚本)\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>LCG</title>\n</head>\n<body>\n <h1>${result}</h1>//数据库查询结果\n</body>\n</html>\n```\n◇在com.lcg.oa.test下创建一个TestServlet\n```java\n@WebServlet(name = \"TestServlet\",urlPatterns = \"/test\")//映射地址\npublic class TestServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String result = (String)MybatisUtils.executeQuery(sqlSession->sqlSession.selectOne(\"test.sample\"));\n        request.setAttribute(\"result\",request);\n        //请求转发\n        request.getRequestDispatcher(\"test.ftl\").forward(request,response);\n    }\n}\n```\n◇在运行测试前还需进行相关设置：File->Project Structure->Artifacts->将右侧Maven资源全选右键->Put into->OK\n◇配置日志文件logback.xml\n\n## 开发基于RBAC的权限控制模块\n### RBAC-基于角色的访问控制\n◇Role-Based Access Control \n◇基于角色权限控制(RBAC)是面向企业安全策略的访问控制方式 \n◇RBAC核心思想是将控制访问的资源(功能或者特定资料等)与角色(Role)进行绑定 \n◇系统的用户(User)与角色(Role)再进行绑定,用户便拥有对应权限  \n### RBAC底层设计\n![image.png](项目介绍/1629192797971-cd125468-ee9d-4f8a-a083-a800853972cb.png)\n### 创建数据库表\n◇角色表，表名：模块名_具体表名 sys_role\n![image.png](项目介绍/1629203711258-089bc764-c434-4933-acbe-d85d034be818.png)![image.png](项目介绍/1629204606757-07b14e75-04d6-47ef-8ea2-a966cdc645cc.png)\n◇资源表sys_node\n![image.png](项目介绍/1629204453547-3d5d55a3-5ac9-4bfa-a015-119d1bf80b41.png)![image.png](项目介绍/1629205041804-b52055e5-70f2-462f-8286-9e16273e3edc.png)\n◇关联表sys_role_node\n![image.png](项目介绍/1629205018455-8a722cb7-2f30-42a2-bc24-6e48d8ef7913.png)<img src=\"项目介绍/1629205194942-4ead9aee-f85c-4198-a365-48da65f5757c.png\" alt=\"image.png\"/>\n\n◇其他表的创建(此处省略)\n\n##  基于LayUI开发登录页\n### LayUI前端框架\n◇[官方网站](https://www.layui.com/)\n◇在webapp目录下创建resources文件夹(用来存放web应用所有相关的引用资源) 将layui文件夹粘贴到其下\n### 开发登录页面\n◇在webapp目录下新建login.html\n◇进行项目热部署：Tomcat->Edit Configurations->On 'Update' action:改为Update classes and resources->ok\n然后按shift+F9就能进行热部署了\n### 开发后台与数据库交互\n◇创建实体类User\n◇创建sql语句的xml文件user.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"usermapper\">\n    <select id=\"selectByUsername\" parameterType=\"String\" resultType=\"com.lcg.oa.entity.User\">\n        select * from sys_user where username = #{value}\n    </select>\n</mapper>\n```\n◇每次增加mapper后必须到mybatis-config中进行配置\n```xml\n<mapper resource=\"mappers/user.xml\"/>\n```\n◇创建dao完成与user表的交互\n```java\n\npublic class UserDao {\n    /**\n     * 按用户名查询用户表\n     * @param username 用户名\n     * @return User对象包含对应的用户信息,null则代表对象不存在\n     */\n    public User selectByUsername(String username){\n        User user = (User)MybatisUtils.executeQuery(sqlSession -> sqlSession.selectOne(\"usermapper.selectByUsername\" , username));\n        return user;\n    }\n}\n```\n◇创建Service\n```java\npublic class UserService {\n    private UserDao userDao =new UserDao();//记得实例化，否则出现空指针异常\n        /**\n     * 根据前台输入进行登录校验\n     * @param username 前台输入的用户名\n     * @param password 前台输入的密码\n     * @return 校验通过后,包含对应用户数据的User实体类\n     * @throws BussinessException L001-用户名不存在,L002-密码错误\n     */\n    public User checkLogin(String username,String password){\n        User user = userDao.selectByUsername(username);\n        if (user == null) {\n            //抛出用户不存在异常\n            throw new BussinessException(\"L001\", \"用户名不存在\");\n        }\n        if (!password.equals(user.getPassword())) {\n            throw new BussinessException(\"L002\", \"密码错误\");\n        }\n        return user;\n    }\n}\n```\n◇自定义异常\n```java\n/**\n * 业务逻辑异常，继承自运行时异常\n */\npublic class BussinessException extends RuntimeException {\n    private String code;//异常编码，异常的以为标识\n    private String message;//异常的具体文本消息\n\n    public BussinessException(String code, String msg) {\n        super(code + \":\" + msg);\n        this.code=code;\n        this.message=msg;\n    }\n\n    public String getCode() {\n        return code;\n    }\n\n    public void setCode(String code) {\n        this.code = code;\n    }\n\n    @Override\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n}\n```\n◇箭头指向需要测试的类名，Ctrl+Shift+T 生成测试用例类，将需要测试的方法进行勾选\n◇空指针异常：在出错代码处做一个断点，可以找出具体哪个对象为空，有时候出现空指针可能是对象没有实例化，在创建时new 类名()即可;\n### 与前台联通\n◇创建控制器controller\n```java\n@WebServlet(name = \"LoginServlet\", urlPatterns = \"/check_login\")\npublic class LoginServlet extends HttpServlet {\n    //日志文件 LoginServlet.class即LoginServlet类的类对象;(对象有实例对象和类对象两种)\n    Logger logger = LoggerFactory.getLogger(LoginServlet.class);\n    private UserService userService = new UserService();\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) \n        throws ServletException, IOException {\n        request.setCharacterEncoding(\"utf-8\");\n        response.setContentType(\"text/html;charset=utf-8\");\n        //接收用户输入\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        //保存输出的内容\n        Map<String, Object> result = new HashMap<>();\n        try {\n            //调用业务逻辑\n            User user = userService.checkLogin(username, password);\n            //返回项\n            result.put(\"code\", \"0\");\n            result.put(\"message\", \"success\");\n        } catch (BussinessException e) {\n            logger.error(e.getMessage(), e);\n            result.put(\"code\", e.getCode());\n            result.put(\"message\", e.getMessage());\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            //由于系统自带异常没有code，用e.getClass().getSimpleName()得到的类名来充当\n            result.put(\"code\", e.getClass().getSimpleName());\n            result.put(\"message\", e.getMessage());\n        }\n        //返回对应结果\n        String json = JSON.toJSONString(result);\n        response.getWriter().println(json);//向客户端返回\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) \n        throws ServletException, IOException {\n\n    }\n}\n\n```\n◇pom.xml加载fastjson依赖，并加入发布的项目中\n```java\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.62</version>\n        </dependency>\n```\n◇修改login.html文件增加提交数据功能\n![image.png](项目介绍/1629385897890-60923e74-375b-4921-b681-576d7d53d36c.png)\n\n```java\n<div class=\"oa-container\">\n    <h1 style=\"text-align: center;margin-bottom: 20px\">交通控股办公OA系统</h1>\n    <form class=\"layui-form\">\n        <div class=\"layui-form-item\">\n            <input type=\"text\" id=\"username\" lay-verify=\"required\" name=\"username\" placeholder=\"请输入用户名\" autocomplete=\"off\" class=\"layui-input\" >\n        </div>\n        <div class=\"layui-form-item\">\n            <input type=\"password\" id=\"password\" lay-verify=\"required\" name=\"password\" placeholder=\"请输入密码\" autocomplete=\"off\" class=\"layui-input\" >\n        </div>\n        <div class=\"layui-form-item\">\n            <!--lay-filter即layui专属的id，autocomple表示是否显示历史输入-->\n            <button class=\"layui-btn layui-btn-fluid\" lay-submit lay-filter=\"login\">登录</button>\n        </div>\n    </form>\n</div>\n<script src=\"/resources/layui/layui.all.js\"></script>\n<script>\n    // 表单提交事件\n    /*on代表捕捉事件，里面参数为submit即提交事件，login表示绑定哪个提交按钮才会触发这段代码*/\n    layui.form.on(\"submit(login)\" , function(formdata){//data参数包含了当前表单的数据\n        console.log(formdata);\n        //发送ajax请求进行登录校验\n        layui.$.ajax({\n            url : \"/check_login\",\n            data : formdata.field, //提交表单数据\n            type : \"post\",\n            dataType : \"json\" ,\n            success : function(json){\n                console.log(json);\n                if(json.code == \"0\"){ //登录校验成功\n                    layui.layer.msg(\"登录成功\");\n                }else{\n                    layui.layer.msg(json.message);\n                }\n            }\n        })\n        return false;//submit提交事件返回true则表单提交,false则阻止表单提交\n    })\n</script>\n    \n```\n### 开发功能首页\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>交通控股OA系统</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n    <link rel=\"stylesheet\" href=\"/resources/layui/css/layui.css\">\n</head>\n\n<body class=\"layui-layout-body\">\n<!-- Layui后台布局CSS -->\n<div class=\"layui-layout layui-layout-admin\">\n    <!--头部导航栏-->\n    <div class=\"layui-header\">\n        <!--系统标题-->\n        <div class=\"layui-logo\" style=\"font-size:18px\">交通控股OA系统</div>\n        <!--右侧当前用户信息-->\n        <ul class=\"layui-nav layui-layout-right\">\n            <li class=\"layui-nav-item\">\n                <a href=\"javascript:void(0)\">\n                    <!--图标-->\n                    <span class=\"layui-icon layui-icon-user\" style=\"font-size: 20px\">\n                    </span>\n                    <!--用户信息-->\n                    姓名[部门-职务]\n                </a>\n            </li>\n            <!--注销按钮-->\n            <li class=\"layui-nav-item\"><a href=\"#\">注销</a></li>\n        </ul>\n    </div>\n    <!--左侧菜单栏-->\n    <div class=\"layui-side layui-bg-black\">\n        <!--可滚动菜单-->\n        <div class=\"layui-side-scroll\">\n            <!--可折叠导航栏-->\n            <ul class=\"layui-nav layui-nav-tree\">\n                <!--父节点-->\n                <li class=\"layui-nav-item layui-nav-itemed\">\n                    <a href=\"javascript:void(0)\">模块1</a>\n                    <dl class=\"layui-nav-child module\" data-node-id=\"1\"></dl>\n                </li>\n                <!--子节点-->\n                <dd class=\"function\" data-parent-id=\"1\">\n                    <a href=\"javascript:void(0)\" target=\"ifmMain\">功能1</a>\n                </dd>\n                <dd class=\"function\" data-parent-id=\"1\">\n                    <a href=\"javascript:void(0)\" target=\"ifmMain\">功能2</a>\n                </dd>\n                <dd class=\"function\" data-parent-id=\"1\">\n                    <a href=\"javascript:void(0)\" target=\"ifmMain\">功能3</a>\n                </dd>\n                <li class=\"layui-nav-item layui-nav-itemed\">\n                    <a href=\"javascript:void(0)\">模块2</a>\n                    <dl class=\"layui-nav-child module\" data-node-id=\"2\"></dl>\n                </li>\n                <dd class=\"function\" data-parent-id=\"2\">\n                    <a href=\"javascript:void(0)\" target=\"ifmMain\">功能3</a>\n                </dd>\n                <dd class=\"function\" data-parent-id=\"2\">\n                    <a href=\"javascript:void(0)\" target=\"ifmMain\">功能4</a>\n                </dd>\n                <dd class=\"function\" data-parent-id=\"2\">\n                    <a href=\"javascript:void(0)\" target=\"ifmMain\">功能5</a>\n                </dd>\n            </ul>\n        </div>\n    </div>\n    <!--主体部分采用iframe嵌入其他页面-->\n    <div class=\"layui-body\" style=\"overflow-y: hidden\">\n        <iframe name=\"ifmMain\" style=\"border: 0px;width: 100%;height: 100%\"></iframe>\n    </div>\n    <!--版权信息-->\n    <div class=\"layui-footer\">\n        Copyright © gamest. All Rights Reserved.\n    </div>\n</div>\n<!--LayUI JS文件-->\n<script src=\"/resources/layui/layui.all.js\"></script>\n<script>\n    //将所有功能根据parent_id移动到指定模块下\n    layui.$(\".function\").each(function () {\n        var func = layui.$(this);\n        var parentId = func.data(\"parent-id\");\n        layui.$(\"dl[data-node-id=\" + parentId + \"]\").append(func);\n    })\n    //刷新折叠菜单\n    layui.element.render('nav');\n</script>\n</body>\n\n```\n\n","tags":["MyBaits"],"categories":["Java数据库","OA系统项目"]},{"title":"MyBaits进阶","url":"/p/fb2c.html","content":"## MyBatis日志管理  \n### 什么是日志 \n◇日志文件是用于记录系统操作事件的记录文件或文件集合 \n◇日志保存历史数据,是诊断问题以及理解系统活动的重要依据  \n### SLF4j与Logback \n![image.png](MyBatis进阶/1628599313923-5abfc2e2-0d7c-4efe-8078-f5601db8fca6.png)\n\n**代码示例**​\n◇配置依赖\n```xml\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n```\n ◇产生的日志(部分)\n```xml\n20:53:41.109 [main] DEBUG goods.selectByTitle - ==>  Preparing: select * from t_goods where title = ? order by title desc \n20:53:41.131 [main] DEBUG goods.selectByTitle - ==> Parameters: '' or 1=1 or title='【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版'(String)\n20:53:41.298 [main] DEBUG goods.selectByTitle - <==      Total: 0\n```\n◇自定义日志格式：在resource目录新建logback.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n  <!--ConsoleAppender是指在控制台输出日志 pattern指定日志输出格式，示例格式即\n  线程，时间，按5个字符右对齐，说明哪个类产生的日志(最多36字符超过压缩)，具体日志内容 换行 \n-->\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>[%thread] %d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <!--\n        日志输出级别(优先级高到低):\n        error: 错误 - 系统的故障日志\n        warn: 警告 - 存在风险或使用不当的日志\n        info: 一般性消息\n        debug: 程序内部用于调试信息\n        trace: 程序运行的跟踪信息\n     -->\n    <root level=\"debug\">\n        <appender-ref ref=\"console\"/>\n    </root>\n</configuration>\n```\n## MyBatis动态SQL\n ◇动态SQL是指根据参数数据动态组织SQL的技术  \n```xml\n<select id=\"dynamicSQL\" parameterType=\"java.util.Map\" resultType=\"com..Goods\">\nselect * from t_goods\n<where>\n<if test=\"categoryId != null\">\nand category_id = #{categoryId}\n</if>\n<if test=\"currentPrice != null\">\nand current_price &lt; #{currentPrice}\n</if>\n</where>\n</select>\n```\n◇示例代码\n```xml\n<select id=\"dynamicSQL\" parameterType=\"java.util.Map\" \n        resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods\n        <where>\n          <if test=\"categoryId != null\">\n              and category_id = #{categoryId}\n          </if>\n          <if test=\"currentPrice != null\">\n              and current_price &lt; #{currentPrice}  //小于号转义符\n          </if>\n        </where>\n    </select>\n\n    @Test\n    public void testDynamicSQL() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Map param = new HashMap();\n            param.put(\"categoryId\", 44);\n            param.put(\"currentPrice\", 500);\n            //查询条件\n            List<Goods> list = session.selectList(\"goods.dynamicSQL\", param);\n            for(Goods g:list){\n                System.out.println(g.getTitle() + \":\" +\n                        g.getCategoryId()  + \":\" + g.getCurrentPrice());\n\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## MyBatis二级缓存\n### 缓存简介\n◇我们从数据库中查询到某一条数据后，因为业务的要求还需要这条数据，那么按照原始的方法就还需要在数据库中查询到该数据；因为MySql是将数据存放在硬盘上的，而硬盘的读取访问速度不是特别快；而且我们这里第一次获取和第二次获取记录的时候，都返回相同的数据；因此我们可以在第一次查询数据时，将该数据暂时保存到内存的某一个区域中，第二次查询时直接从内存的对应区域取出即可，因为内存的访问速度快，这样就能够提高查询的速度；在Mybatis中存在了两级缓存；\n◇ 一级缓存默认开启,缓存的数据范围为SqlSession会话，即在一次SqlSession会话中，对数据库中的某个数据进行重复读取，Mybatis就会利用到这个缓存来提高程序的处理速度；\n◇ 二级缓存手动开启,属于范围Mapper Namespace ，范围比SqlSession大的多；\n### 缓存的范围  \n![image.png](MyBatis进阶/1628648358170-3c4957c8-1a4f-4c0b-9266-d477a41ad6d0.png)\n### 二级缓存运行规则 \n◇二级开启后默认所有查询操作均使用缓存 \n◇写操作使用commit提交时对该namespace缓存强制清空，保证商品一致性；如第一个用户查询到商品，而第二个用户将此商品名称改了，那么这时候就会将namespace缓存强制清空，第一个用户再次查询该商品时就得从数据库中获取了；\n◇配置useCache=false可以不用缓存 \n◇在某一sql语句中配置flushCache=true代表执行完该sql语句后强制清空缓存\n◇代码示例\n```java\n//测试一级缓存\n    @Test\n    public void testLv1Cache() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            //这里执行了两次sql查询，由于使用了缓存，所以在日志中可以看到只打印出一条sql语句\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            Goods goods1 = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode() + \":\" + goods1.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);//关闭了会话\n        }\n\n        try{\n            session = MyBatisUtils.openSession();\n            //由于前面关闭了会话，这里是新的会话，需要对数据库进行查询\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            session.commit();//commit提交时对该namespace缓存强制清空\n            //由于前面对缓存进行了强制清空，所以还需要访问数据库\n            Goods goods1 = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode() + \":\" + goods1.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n\n //测试二级缓存 \n //在mapper标签下添加cache标签\n<!--开启了二级缓存\n        eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除\n            1.LRU – 最近最久未使用:移除最长时间不被使用的对象。\n            O1 O2 O3 O4 .. O512\n            14 99 83 1     893\n            2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。\n            3.SOFT – 软引用:移除基于垃圾收集器状态和软引用规则的对象。\n            4.WEAK – 弱引用:更积极的移除基于垃圾收集器状态和弱引用规则的对象。\n            5.LFU - 最近最少使用：移除最近访问频率最低的对象\n      flushInterval代表间隔多长时间自动清空缓存，单位毫秒，600000毫秒为10分钟\n    -->\n    <cache eviction=\"LRU\" flushInterval=\"600000\" size=\"512\" readOnly=\"true\"/>\n\n    @Test\n    public void testLv2Cache() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n\n        try{\n            //这里虽然是新的会话，但是由于是二级缓存，所以还是可以从内存中提取数据；\n            session = MyBatisUtils.openSession();\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.hashCode());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n◇缓存标签的属性：\neviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除            \n            1.LRU – 最近最久未使用:移除最长时间不被使用的对象。\n            O1 O2 O3 O4 .. O512\n            14 99 83 1     893\n            2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。\n            3.SOFT – 软引用:移除基于垃圾收集器状态和软引用规则的对象。\n            4.WEAK – 弱引用:更积极的移除基于垃圾收集器状态和弱引用规则的对象。\n flushInterval代表间隔多长时间自动清空缓存，单位毫秒\nsize 缓存存储上限，用于保存对象或集合(1个集合算1个对象)的数量上限\nreadOnly 设置为true，代表返回只读缓存，每次从缓存取出的是缓存对象本身，这种执行效率较高\n                设置为false，代表每次取出的是缓存对象的\"副本\"，每一次取出的对象都是不同的，这种安全性较高\n◇一些缓存相关的属性：useCache=\"false\"代表查询结果不被放入缓存，常用于读取全部数据的SQL语句中\n执行完insert语句需要立即清空缓存，flushCache=\"true\"在sql执行后强制清空缓存 \n\n## MyBatis多表级联查询  \n### 实体关系分析  \n![image.png](MyBatis进阶/1628753256241-93038a3b-4c03-4530-ace1-ddb89972beda.png)\n### 商品和详情对象关联查询\n**一对多**\n◇增加实体类GoodsDetail\n```xml\npublic class GoodsDetail {\n    private Integer gdId;\n    private Integer goodsId;\n    private String gdPicUrl;\n    private Integer gdOrder;\n}\n```\n◇配置\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"goodsDetail\">\n    <select id=\"selectByGoodsId\" parameterType=\"Integer\"\n            resultType=\"com.lcg.mybatis.entity.GoodsDetail\">\n        select * from t_goods_detail where goods_id = #{value}\n    </select>\n</mapper>\n```\n◇表达一个Goods对象有多个GoodsDetail对象：在Goods类中增加**private **List<GoodsDetail> **goodsDetails**;\n◇Goods.xml中\n```xml\n<!--\n    resultMap可用于说明一对多或者多对一以及多表查询(前面学过)的映射逻辑\n    id 是resultMap属性引用的标志,需要和其他resultMap区分开\n    type 在一对多的关系中指向One的实体(Goods)\n-->\n<resultMap id=\"rmGoods1\" type=\"com.lcg.mybatis.entity.Goods\">\n    <!-- 映射goods对象的主键到goods_id字段 -->\n    <id column=\"goods_id\" property=\"goodsId\"></id>\n    <!--\n        collection(集合)专用于描述Goods实体中的goodsDetails这个List数据从哪来的; 其含义是,在\n        select * from t_goods limit 0,10 得到结果后,对所有Goods对象遍历得到goods_id字段值,\n        并代入到goodsDetail命名空间的 selectByGoodsId的SQL中执行查询,\n        将得到的\"商品详情\"集合赋值给goodsDetails 这个List对象.\n    -->\n    <collection property=\"goodsDetails\" select=\"goodsDetail.selectByGoodsId\"\n                column=\"goods_id\"/>\n</resultMap>\n<select id=\"selectOneToMany\" resultMap=\"rmGoods1\">\n    select * from t_goods limit 0,10\n</select>\n```\n◇在核心配置文件(mybatis-config.xml)中进行注册\n```xml\n    <mappers>\n        <mapper resource=\"mappers/goods.xml\"/>\n        <mapper resource=\"mappers/goods_detail.xml\"/>\n    </mappers>\n```\n◇测试\n```xml\n@Test\n    public void testOneToMany() throws Exception {\n        SqlSession session = null;\n        try {\n            session = MyBatisUtils.openSession();\n            List<Goods> list = session.selectList(\"goods.selectOneToMany\");\n            for(Goods goods:list) {\n               System.out.println(goods.getTitle() + \":\" + goods.getGoodsDetails().size());\n            }\n        } catch (Exception e) {\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n**多对一**\n◇在实体类GoodsDetail中增加**private **Goods **goods**;\n◇在goods_detail.xml文件中进行对像关联的描述\n```xml\n <resultMap id=\"rmGoodsDetail\" type=\"com.lcg.mybatis.entity.GoodsDetail\">\n        <!--主键关联-->\n        <id column=\"gd_id\" property=\"gdId\"/>\n        <!--结果关联-->\n        <result column=\"goods_id\" property=\"goodsId\"/>\n        <!--association关联标签，用于多对一-->\n        <association property=\"goods\" select=\"goods.selectById\" \n                     column=\"goods_id\"></association>\n    </resultMap>\n    <select id=\"selectManyToOne\" resultMap=\"rmGoodsDetail\">\n        select * from t_goods_detail limit 0,20\n    </select>\n```\n◇测试  项目见F:mybatis;\n## 分页插件PageHelper  \n### 分页查询的麻烦事 \n◇当前页数据查询 - select * from tab limit 0,10 \n◇总记录数查询 - select count(*) from tab \n◇程序计算总页数、上一页页码、下一页页码  \n◇MyBatis分页插件PageHelper[官方网站](https://pagehelper.github.io/)\n### pageHelper使用流程\n◇maven引入PageHelper与jsqlparser \n```xml\n       //pom.xml中\n       <dependency>\n            <groupId>com.github.pagehelper</groupId>\n            <artifactId>pagehelper</artifactId>\n            <version>5.1.10</version>\n        </dependency>\n        <dependency>\n            <groupId>com.github.jsqlparser</groupId>\n            <artifactId>jsqlparser</artifactId>\n            <version>2.0</version>\n        </dependency>\n```\n◇mybatis-config.xml增加Plugin配置 \n```xml\n    <plugins>\n        <plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\n            <!--设置数据类型 -->\n            <property name=\"helperDialect\" value=\"mysql\"/>\n            <!--分页合理化 -->\n            <property name=\"reasonable\" value=\"true\"/>\n        </plugin>\n    </plugins>\n```\n◇代码中使用PageHelper.startPage()自动分页  \n```xml\n    <select id=\"selectPage\" resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods where current_price &lt; 1000\n    </select>\n@Test\n    public void testSelectPage() throws Exception {\n        SqlSession session = null;\n        try {\n            session = MyBatisUtils.openSession();\n            /*startPage方法会自动将下一次查询进行分页*/\n            PageHelper.startPage(2,10);\n            Page<Goods> page = (Page) session.selectList(\"goods.selectPage\");\n            System.out.println(\"总的页数:\" + page.getPages());\n            System.out.println(\"总记录数:\" + page.getTotal());\n            System.out.println(\"开始行号:\" + page.getStartRow());\n            System.out.println(\"结束行号:\" + page.getEndRow());\n            System.out.println(\"当前页码:\" + page.getPageNum());\n            List<Goods> data = page.getResult();//当前页数据\n            for (Goods g : data) {\n                System.out.println(g.getTitle());\n            }\n            System.out.println(\"\");\n        } catch (Exception e) {\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## 不同数据库的分页实现\n###  MySQL分页  \n```xml\n//第一个参数代表起始行号，第二个是偏移量\nselect * from table limit 10,20;\n```\n###  Oracle  \n```sql\nselect t3.* from (\n select t2.*, rownum as row_num from ( --rownum是伪列：无需声明直接使用的列，将前20条数据筛选\n select * from table order by id asc --用于查询\n ) t2 where rownum<=20\n) t3 \nwhere t2.row_num>11 --第三层嵌套用于起始位置的筛选\n```\n###  SQL Server 2000  \n```sql\nselect top 3 * from table --top语句在sql语句执行完后获取前几条数据\nwhere \n id not in \n (select top 15 id from table)\n```\n###  SQL Server 2012+  \n```sql\nselect * from table order by id \n offset 4 rows fetch next 5 rows only --offset偏移量 fetch next向后取多少行\n --若id为1的话即从第5(1+4)行开始向后取5条数据\n```\n## MyBatis配置C3P0连接池\n◇pom.xml进行配置\n```sql\n        <dependency>\n            <groupId>com.mchange</groupId>\n            <artifactId>c3p0</artifactId>\n            <version>0.9.5.4</version>\n        </dependency>\n```\n◇在mybatis创建datasoutce包，再新建C3P0DataSourceFactory类，继承自UnpooledDataSourceFactory以便于连接\n```sql\n/**\n * C3P0与MyBatis兼容使用的数据源工厂类\n */\npublic class C3P0DataSourceFactory extends UnpooledDataSourceFactory {\n    public C3P0DataSourceFactory(){\n        this.dataSource = new ComboPooledDataSource();\n    }\n}\n```\n◇在mybatis-config.xml配置文件中将<dataSource>的type改为com.lcg.mybatis.datasource.C3P0DataSourceFactory;因为不同的连接池对属性的命名规则不同，所以有以下更改：driver->driverClass , url->jdbcUrl , username->user\n```xml\n            <dataSource type=\"com.lcg.mybatis.datasource.C3P0DataSourceFactory\">\n                <property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"jdbcUrl\" value=\"\"/>\n                <property name=\"user\" value=\"root\"/>\n                <property name=\"password\" value=\"www.LCG.com\"/>\n                <property name=\"initialPoolSize\" value=\"5\"/>\n                <property name=\"maxPoolSize\" value=\"20\"/>\n                <property name=\"minPoolSize\" value=\"5\"/>\n            </dataSource>\n```\n## MyBatis批处理  \n◇goods.xml增加批处理的SQL语句\n```xml\n <!--INSERT INTO table-->\n    <!--VALUES (\"a\" , \"a1\" , \"a2\"),(\"b\" , \"b1\" , \"b2\"),(....)-->\n    <insert id=\"batchInsert\" parameterType=\"java.util.List\">\n        INSERT INTO t_goods(title, sub_title, original_cost, \n      current_price, discount, is_free_delivery, category_id)\n        VALUES\n        <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\">\n          (#{item.title},#{item.subTitle}, #{item.originalCost},\n        #{item.currentPrice}, #{item.discount}, #{item.isFreeDelivery}, #{item.categoryId})\n        </foreach>\n    </insert>\n    @Test\n    public void testBatchInsert() throws Exception {\n        SqlSession session = null;\n        try {\n            long st = new Date().getTime();\n            session = MyBatisUtils.openSession();\n            List list = new ArrayList();\n            for (int i = 0; i < 10000; i++) {\n                Goods goods = new Goods();\n                goods.setTitle(\"测试商品\");\n                goods.setSubTitle(\"测试子标题\");\n                goods.setOriginalCost(200f);\n                goods.setCurrentPrice(100f);\n                goods.setDiscount(0.5f);\n                goods.setIsFreeDelivery(1);\n                goods.setCategoryId(43);\n                //insert()方法返回值代表本次成功插入的记录总数\n                list.add(goods);\n            }\n            session.insert(\"goods.batchInsert\", list);\n            session.commit();//提交事务数据\n            long et = new Date().getTime();\n            System.out.println(\"执行时间:\" + (et - st) + \"毫秒\");\n//            System.out.println(goods.getGoodsId());\n        } catch (Exception e) {\n            if (session != null) {\n                session.rollback();//回滚事务\n            }\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n◇批量插入数据的局限：①无法获得插入数据的id；②批量生成的SQL太长，可能会被服务器拒绝\n◇批量删除\n```xml\n<!--delete from t_goods where goods_id in (1920,1921,...)-->\n   <delete id=\"batchDelete\" parameterType=\"java.util.List\">\n        DELETE FROM t_goods WHERE goods_id in\n     <foreach collection=\"list\" item=\"item\" index=\"index\" open=\"(\" close=\")\" separator=\",\">\n           #{item}\n     </foreach>\n   </delete>\n    @Test\n    public void testBatchDelete() throws Exception {\n        SqlSession session = null;\n        try {\n            long st = new Date().getTime();\n            session = MyBatisUtils.openSession();\n            List list = new ArrayList();\n            list.add(1920);\n            list.add(1921);\n            list.add(1922);\n            session.delete(\"goods.batchDelete\", list);\n            session.commit();//提交事务数据\n            long et = new Date().getTime();\n            System.out.println(\"执行时间:\" + (et - st) + \"毫秒\");\n//          System.out.println(goods.getGoodsId());\n        } catch (Exception e) {\n            if (session != null) {\n                session.rollback();//回滚事务\n            }\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## MyBatis注解开发\n### Mybatis常用注解\n◇把原有放在xml的标签语句放在程序中\n![image.png](MyBatis进阶/1628925337535-f97712fe-fea0-4be2-87bd-c66e102d765b.png)\n◇创建dao包，然后创建GoodsDAO接口\n\n```java\npublic interface GoodsDAO {\n    @Select(\"select * from t_goods where current_price between  \n        #{min} and #{max} order by current_price limit 0,#{limt}\")\n    public List<Goods> selectByPriceRange(@Param(\"min\") Float min ,\n      @Param(\"max\") Float max ,@Param(\"limt\") Integer limt);\n\n    @Insert(\"INSERT INTO t_goods(title, sub_title, original_cost,\n      current_price, discount, is_free_delivery, category_id)\n      VALUES (#{title} , #{subTitle} , #{originalCost}, #{currentPrice}, \n      #{discount}, #{isFreeDelivery}, #{categoryId})\")\n    //<selectKey>\n    @SelectKey(statement = \"select last_insert_id()\" , \n      before = false , keyProperty = \"goodsId\" , resultType = Integer.class)\n    public int insert(Goods goods);\n\n    @Select(\"select * from t_goods\")\n    //<resultMap>\n    @Results({\n            //<id>\n          @Result(column = \"goods_id\" ,property = \"goodsId\" , id = true) ,\n            //<result>\n            @Result(column = \"title\" ,property = \"title\"),\n            @Result(column = \"current_price\" ,property = \"currentPrice\")\n    })\n    public List<GoodsDTO> selectAll();\n}\n```\n◇在核心配置文件mybatis-config.xml中进行相应说明\n```xml\n    <mappers>\n        <!--<mapper class=\"com.lcg.mybatis.dao.GoodsDAO\"/> 指向接口，下为简便方法-->\n        <package name=\"com.lcg.mybatis.dao\"/>\n    </mappers>\n```\n◇测试类\n```java\n@Test\n    public void testSelectByPriceRange() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            //传入类对象\n            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);\n            List<Goods> list = goodsDAO.selectByPriceRange(100f, 500f, 20);\n            System.out.println(list.size());\n        }catch (Exception e){\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n\n        }\n    }\n/**\n     * 新增数据\n     * @throws Exception\n     */\n    @Test\n    public void testInsert() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = new Goods();\n            goods.setTitle(\"测试商品\");\n            goods.setSubTitle(\"测试子标题\");\n            goods.setOriginalCost(200f);\n            goods.setCurrentPrice(100f);\n            goods.setDiscount(0.5f);\n            goods.setIsFreeDelivery(1);\n            goods.setCategoryId(43);\n            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);\n            //insert()方法返回值代表本次成功插入的记录总数\n            int num = goodsDAO.insert(goods);\n            session.commit();//提交事务数据\n            System.out.println(goods.getGoodsId());\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n    @Test\n    public void testSelectAll() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);\n            List<GoodsDTO> list = goodsDAO.selectAll();\n            System.out.println(list.size());\n        }catch (Exception e){\n            throw e;\n        } finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n}\n```\n\n","tags":["MyBaits"],"categories":["Java数据库","MyBaits"]},{"title":"MyBaits入门","url":"/p/f37d.html","content":"## MyBatis课程介绍\n### MyBatis入门使用\n![image.png](MyBatis入门/1628238899331-11e1e3ae-ea4c-48e1-b933-0cece45283b9.png)\n### MyBatis高级特性\n![image.png](MyBatis入门/1628239064225-a53dd20e-0d65-4c5e-acc9-0dc429a8d32e.png)\n##  认识框架-Framework  \n###  生活中的框架  \n![image.png](MyBatis入门/1628239313228-062756fe-2b58-4e3b-902e-c73bf87d0331.png)\n![image.png](MyBatis入门/1628239334642-ca21d0cd-4c30-4653-8811-2537f6edd963.png)\n\n### 软件开发中框架 \n◇框架是可被应用开发者定制的应用骨架 \n◇框架是一种规则,保证开发者遵循相同的方式开发程序 \n◇框架提倡”不要重复造轮子”,对基础功能进行封装  \n### 框架的优点 \n◇极大提高了开发效率 \n◇统一的编码规则,利于团队管理 \n◇灵活配置的应用,拥有更好的维护性  \n### SSM开发框架  \n![image.png](MyBatis入门/1628239469486-ecff36a6-0968-4804-8f26-63c745ed2252.png)\n## 介绍MyBatis  \n### 什么是MyBatis \n◇MyBatis是优秀的持久层框架 \n◇MyBatis使用XML将SQL与程序解耦,便于维护\n◇MyBatis学习简单,执行高效,是JDBC的延伸 \n### MyBatis开发流程 \n◇引入MyBatis依赖                          ◇创建核心配置文件 \n◇创建实体(Entity)类                        ◇创建Mapper映射文件 \n◇初始化SessionFactory                   ◇利用SqlSession对象操作数据  \n## 单元测试与JUnit 4\n### 单元测试 \n◇单元测试是指对软件中的最小可测试单元进行检查和验证 \n◇测试用例是指编写一段代码对已有功能(方法)进行校验 \n◇JUnit 4是Java中最著名的单元测试工具,主流IDE内置支持  \n### JUnit 4使用方法 \n◇引入JUnit Jar包或增加Maven依赖 \n◇编写测试用例验证目标方法是否正确运行 \n◇在测试用例上增加@Test注解开始单元测试  \n### JUnit 4使用入门  \n◇创建Maven项目\n --pom.xml配置\n```java\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n</dependencies>\n```\n --main中创建类\n```java\npublic class Calculator {\n    public int add(int a, int b) {\n        return a+b;\n    }\n\n    public int subtract(int a, int b) {\n        return a - b;\n    }\n\n    public int multiply(int a, int b) {\n        return a * b;\n    }\n\n    public float divide(int a, int b) {\n        return (a*1f)/b;\n    }\n}\n```\n --test中创建测试类,测试类或测试方法前有√则为正确运行,也要看程序运行和预期是否相同\n```java\npublic class CalculatorTest {\n    private Calculator cal = new Calculator();\n    //测试用例命名规则\n    //1.与原方法保持一致add\n    //2.在原方法前增加test前缀testAdd\n    @Test\n    public void testAdd(){\n        int result = cal.add(3, 5);\n        System.out.println(result);\n    }\n\n    @Test\n    public void subtract() {\n        int result = cal.subtract(1, 2);\n        System.out.println(result);\n    }\n\n    @Test\n    public void multiply() {\n        int result = cal.multiply(1, 2);\n        System.out.println(result);\n    }\n\n    @Test\n    public void divide() {\n        float result = cal.divide(1, 2);\n        System.out.println(result);\n    }\n}\n\n```\n◇快速生成测试类方法：选中需要测试的类->Code->Generate->Test\n◇可以同时运行多个测试类\n## MyBatis环境配置  \n### mybatis-config.xml \n◇ MyBatis采用XML格式配置数据库环境信息 \n◇ MyBaits环境配置标签 \n◇ environment包含数据库驱动、URL、用户名与密码 \n### 项目演示\n◇IDEA支持数据库面板，DataBase->+ ->DataSource->MySql\n◇pom.xml配置\n```java\n<repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.1</version>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.47</version>\n        </dependency>\n        <!--增加junit用于测试 -->\n\n    </dependencies>\n```\n◇在main/resources目录下创建mybatis-config.xml文件\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--设置默认指向的数据库,这里默认指向dev-->\n    <environments default=\"dev\">\n        <!--配置环境，不同的环境不同的id名字-->\n        <environment id=\"dev\">\n            <!-- 采用JDBC方式对数据库事务进行commit/rollback -->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--采用连接池方式管理数据库连接-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\n    \"jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;characterEncoding=UTF-8\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"www.LCG.com\"/>\n            </dataSource>\n        </environment>\n    </environments>\n</configuration>\n```\n## SqlSessionFactory \n◇ SqlSessionFactory是MyBatis的核心对象 \n◇ 用于初始化MyBatis,创建SqlSession对象 \n◇ 保证SqlSessionFactory在应用中全局唯一 \n### SqlSession \n◇ SqlSession是MyBatis操作数据库的核心对象 \n◇ SqlSession使用JDBC方式与数据库交互 \n◇ SqlSession对象提供了数据表CRUD对应方法    \n### 项目演示\n◇pom.xml中增加junit依赖用于测试\n◇JUNIT单元测试类\n```java\npublic class MyBatisTestor {\n    @Test\n    public void testSqlSessionFactory()throws IOException {\n        //按照字符流方式进行.xml文件的读取，返回Reader对象\n        Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\");\n        //初始化SqlSessionFactory对象，同时通过reader对象解析xml文件\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n        System.out.println(\"SessionFactory加载成功\");\n        SqlSession sqlSession = null;\n        try {\n            //创建SqlSession对象，SqlSession是JDBC的扩展类，用于与数据库交互\n            sqlSession = sqlSessionFactory.openSession();\n            //进行数据库的交互\n            Connection connection = sqlSession.getConnection();\n            System.out.println(connection);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            /*如果type=\"POOLED\",代表使用连接池，close则是将连接回收到连接池中\n            * 如果type=\"UNPOOLED\",代表直连，close则会调用Connection.close()\n            * 方法关闭连接*/\n            if(sqlSession!=null){\n                sqlSession.close();\n            }\n        }\n    }\n    \n    //测试工具类\n     @Test\n    public void testMyBatisUtils()throws Exception{\n        SqlSession sqlSession = null;\n        try {\n            sqlSession = MyBatisUtils.openSession();\n            Connection connection = sqlSession.getConnection();\n            System.out.println(connection);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            MyBatisUtils.closeSession(sqlSession);\n        }\n    }\n}\n```\n◇初始化工具类\n```java\npublic class MyBatisUtils {\n    //利用static(静态)属于类不属于对象，且全局唯一\n    private static SqlSessionFactory sqlSessionFactory = null;\n\n    //利用静态块在初始化类时实例化sqlSessionFactory\n    static {\n        Reader reader = null;\n        try {\n            reader = Resources.getResourceAsReader(\"mybatis-config.xml\");\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n        } catch (IOException e) {\n            e.printStackTrace();\n            //初始化错误时，通过抛出异常ExceptionInInitializerError通知调用者\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n    \n    /**\n     * openSession 创建一个新的SqlSession对象\n     * 对于工具类的方法大都使用static描述，\n     * 这样通过类名和方法名就可以直接使用了\n     * @return SqlSession对象\n     */\n    public static SqlSession openSession() {\n        return sqlSessionFactory.openSession();\n    }\n\n    /**\n     * 释放一个有效的SqlSession对象\n     *\n     * @param session 准备释放SqlSession对象\n     */\n    public static void closeSession(SqlSession session) {\n        if (session != null) {\n            session.close();\n        }\n    }\n}\n\n```\n## MyBatis数据查询\n### MyBatis数据查询步骤 \n◇创建实体类(Entity)                 ◇创建Mapper XML \n◇编写SQL标签                         ◇开启驼峰命名映射 \n◇新增                                       ◇SqlSession执行select语句 \n###  项目演示\n◇生成实体类，entity\n```java\npublic class Goods {\n    private Integer goodsId;//商品编号\n    private String title;//标题\n    private String subTitle;//子标题\n    private Float originalCost;//原始价格\n    private Float currentPrice;//当前价格\n    private Float discount;//折扣率\n    private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮\n    private Integer categoryId;//分类编号\n    ...\n}\n```\n◇在Resources目录中创建mapper(映射器)文件，在其中创建xml文件;goods.xml文件说明了实体类和哪一张表对应\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><!--与config中的不同 -->\n<!--命名空间用来区分 -->\n<mapper namespace=\"goods\">\n    <!--编写sql标签,resultType说明查询结果返回的实体类 -->\n    <select id=\"selectAll\" resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods order by goods_id desc limit 10\n    </select>\n</mapper>\n```\n◇新建了goods.xml后还需要在mybatis-config.xml中进行声明\n![image.png](MyBatis入门/1628332975684-1cd84570-03e0-4c7a-8f40-a0b5fcd43d7f.png)\n◇驼峰命名转换(在mybatis-config中配置)，数据表字段不区分大小写，但java属性区分大小写；防止读取数据库数据时丢失一些例如goods_id字段的数据\n\n```java\n    <settings>\n        <!-- goods_id ==> goodsId 驼峰命名转换 -->\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n    </settings>\n```\n◇编写测试\n```java\n    @Test\n    public void testSelectAll() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            List<Goods> list = session.selectList(\"goods.selectAll\");\n            for(Goods g : list){\n                System.out.println(g.getTitle());\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## Sql传参\n###  查询 - select\n```java\n<select id=\"selectById\" parameterType=\"Integer\"\nresultType=\"com.lcg.mybatis.entity.Goods\">\nselect * from t_goods where goods_id = #{value}\n</select>\n```\n### 项目示例\n**①单个参数**\n◇在goods.xml中新增一个select查询\n```java\n<select id=\"selectById\" parameterType=\"Integer\" resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods where goods_id = #{value}\n    </select>\n```\n◇进行测试\n```java\n/**\n     * 传递单个SQL参数\n     * @throws Exception\n     */\n    @Test\n    public void testSelectById() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = session.selectOne(\"goods.selectById\" , 1603);\n            System.out.println(goods.getTitle());\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n**②多个参数**\n**◇**session.selectxxx方法无法传递多个参数，所以利用Java.Util.Map键值对来进行多个参数的传递，即参数名为键，值为参数值\n◇新增查询\n```java\n    <select id=\"selectByPriceRange\" parameterType=\"java.util.Map\" \n        resultType=\"com.lcg.mybatis.entity.Goods\">\n        select * from t_goods\n        where current_price between #{min} and #{max}\n        limit 0,#{limt}\n    </select>\n```\n◇测试\n```java\n /**\n     * 传递多个(3个)SQL参数\n     * @throws Exception\n     */\n    @Test\n    public void testSelectByPriceRange() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Map param = new HashMap();\n            param.put(\"min\",100);\n            param.put(\"max\" , 500);\n            param.put(\"limt\" , 10);\n            List<Goods> list = session.selectList(\"goods.selectByPriceRange\", param);\n            for(Goods g:list){\n                System.out.println(g.getTitle() + \":\" + g.getCurrentPrice());\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n ③多表关联\n◇Sql语句\n```xml\n<!-- 利用LinkedHashMap保存多表关联结果\n        MyBatis会将每一条记录包装为LinkedHashMap对象\n        key是字段名  value是字段对应的值 , 字段类型根据表结构进行自动判断\n        优点: 易于扩展,易于使用\n        缺点: 太过灵活,无法进行编译时检查\n     -->\n<select id=\"selectGoodsMap\" resultType=\"java.util.LinkedHashMap\">\n        select g.*,c.category_name from t_goods g, t_category c\n        where g.category_id = c.category_id\n    </select>\n```\n◇测试\n```xml\n@Test\n    public void testSelectGoodsMap() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            List<Map> list = session.selectList(\"goods.selectGoodsMap\");\n            for(Map map : list){\n                System.out.println(map);\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## ResultMap结果映射 \n◇ResultMap可以将查询结果映射为复杂类型的Java对象 \n◇ResultMap适用于Java对象保存多表关联结果 \n◇ResultMap支持对象关联查询等高级特性  \n**项目示例**\n◇创建类别实体\n```xml\npublic class Category {\n    private Integer categoryId;\n    private String categoryName;\n    private Integer parentId;\n    private Integer categoryLevel;\n    private Integer categoryOrder;\n ...\n}\n```\n◇创建新包dto，用来进行对原始数据的扩展，保存以及传递;如在包中创建GoodsDTO对原始的Goods进行扩展\n```xml\n//Data Transfer Object--数据传输对象\npublic class GoodsDTO {\n    private Goods goods = new Goods();\n    private Category category = new Category();\n    private String test;\n...\n}\n```\n◇结果映射\n```xml\n<!--结果映射-->\n    <resultMap id=\"rmGoods\" type=\"com.lcg.mybatis.dto.GoodsDTO\">\n        <!--设置主键字段与属性映射-->\n        <id property=\"goods.goodsId\" column=\"goods_id\"></id>\n        <!--设置非主键字段与属性映射-->\n        <result property=\"goods.title\" column=\"title\"></result>\n        <result property=\"goods.originalCost\" column=\"original_cost\"></result>\n        <result property=\"goods.currentPrice\" column=\"current_price\"></result>\n        <result property=\"goods.discount\" column=\"discount\"></result>\n        <result property=\"goods.isFreeDelivery\" column=\"is_free_delivery\"></result>\n        <result property=\"goods.categoryId\" column=\"category_id\"></result>\n        <result property=\"category.categoryId\" column=\"category_id\"></result>\n        <result property=\"category.categoryName\" column=\"category_name\"></result>\n        <result property=\"category.parentId\" column=\"parent_id\"></result>\n        <result property=\"category.categoryLevel\" column=\"category_level\"></result>\n        <result property=\"category.categoryOrder\" column=\"category_order\"></result>\n        <result property=\"test\" column=\"test\"/>\n    </resultMap>\n    <select id=\"selectGoodsDTO\" resultMap=\"rmGoods\">\n        select g.* , c.*,'1' as test from t_goods g , t_category c\n        where g.category_id = c.category_id\n    </select>\n```\n◇测试\n```xml\n@Test\n    public void testSelectGoodsDTO()throws Exception{\n        SqlSession session = null;\n        try {\n            session = MyBatisUtils.openSession();\n            List<GoodsDTO> list = session.selectList(\"goods.selectGoodsDTO\");\n            for(GoodsDTO g:list){\n                System.out.println(g.getGoods().getTitle());\n            }\n        } catch (Exception e) {\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n## MyBatis数据写入\n### 数据库事务\n◇数据库事务是保证数据操作完整性的基础\n![image.png](MyBatis入门/1628513637346-4dc8cb72-ae9e-46b1-8732-63a7f3f9c3b3.png)\n\n### MyBatis写操作包含三种\n◇插入 -  insert\n```xml\n<insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\nINSERT INTO `babytun`.`t_goods`( `title`, `sub_title`, `original_cost`, current_price`)\nVALUES ( #{title}, #{subTitle}, #{originalCost}, #{currentPrice})\n<selectKey resultType=\"int\" keyProperty=\"goodsId\" order=\"AFTER\">\n<!-- 当前连接中最后产生的id号 -->\nselect last_insert_id()\n</selectKey>\n</insert>\n\n--示例代码\n <insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n        insert into t_goods(title, sub_title, original_cost, current_price, \n                            discount, is_free_delivery,category_id)\n        value (#{title} , #{subTitle} , #{originalCost}, \n               #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId})\n   //用来将新插入的id回填到类中\n        <selectKey resultType=\"Integer\" keyProperty=\"goodsId\" order=\"AFTER\">\n            select last_insert_id()\n        </selectKey>\n    </insert>\n    @Test\n    public void testInsert() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            Goods goods = new Goods();\n            goods.setTitle(\"测试商品\");\n            goods.setSubTitle(\"测试子标题\");\n            goods.setOriginalCost(200f);\n            goods.setCurrentPrice(100f);\n            goods.setDiscount(0.5f);\n            goods.setIsFreeDelivery(1);\n            goods.setCategoryId(43);\n            //insert()方法返回值代表本次成功插入的记录总数\n            int num = session.insert(\"goods.insert\", goods);\n            session.commit();//提交事务数据\n            System.out.println(goods.getGoodsId());\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n◇更新 -  update\n```xml\n<update id=\"update\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n        UPDATE t_goods\n        SET\n          title = #{title} ,\n          sub_title = #{subTitle} ,\n          original_cost = #{originalCost} ,\n          current_price = #{currentPrice} ,\n          discount = #{discount} ,\n          is_free_delivery = #{isFreeDelivery} ,\n          category_id = #{categoryId}\n        WHERE\n          goods_id = #{goodsId}\n    </update>\n @Test\n    public void testUpdate() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            //通过selectOne方法得到指定商品编号的goods对象\n            Goods goods = session.selectOne(\"goods.selectById\", 739);\n            goods.setTitle(\"更新测试商品\");\n            int num = session.update(\"goods.update\" , goods);\n            session.commit();//提交事务数据\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n\n```\n◇删除 -  delete\n```xml\n <!--delete from t_goods where goods_id in (1920,1921)-->\n    <delete id=\"delete\" parameterType=\"Integer\">\n        delete from t_goods where goods_id = #{value}\n    </delete>\n @Test\n    public void testDelete() throws Exception {\n        SqlSession session = null;\n        try{\n            session = MyBatisUtils.openSession();\n            int num = session.delete(\"goods.delete\" , 739);\n            session.commit();//提交事务数据\n        }catch (Exception e){\n            if(session != null){\n                session.rollback();//回滚事务\n            }\n            throw e;\n        }finally {\n            MyBatisUtils.closeSession(session);\n        }\n    }\n```\n### selectKey与useGeneratedKeys的区别\n◇selectKey标签的用法\n```xml\n <insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n       INSERT INTO SQL语句\n        <selectKey resultType=\"Integer\" keyProperty=\"goodsId\" order=\"AFTER\">\n            select last_insert_id()\n        </selectKey>\n    </insert>\n```\n◇useGeneratedKeys属性用法\n```xml\n<insert>\n   parameterType=\"com.lcg.mybatis.entity.Goods\"\n   useGeneratedKeys=\"true\"\n   keyProperty=\"goodsId\"\n   KeyColumn=\"goods_id\"\n  INSERT INTO SQL 语句\n</insert>\n```\n**二者区别**\n◇selectKey标签需要明确编写获取最新主键的SQL语句\n◇useGeneratedKeys属性会自动根据驱动生成对应SQL语句\n◇selectKey适用于所有的关系型数据库\n◇useGeneratedKeys只适用于能够\"自增主键\"类型的数据库\n◇在Oracle(非自增)中selectKey的用法\n```xml\n <insert id=\"insert\" parameterType=\"com.lcg.mybatis.entity.Goods\">\n       INSERT INTO SQL语句\n        <selectKey resultType=\"Integer\" keyProperty=\"goodsId\" order=\"BEFORE\">\n            select seq_goods.nextval as id from dual\n        </selectKey>\n    </insert>\n```\n## MyBatis预防SQL注入攻击\n### SQL注入攻击\n ◇SQL注入是指攻击者利用SQL漏洞,绕过系统约束,越权获取数据的攻击方式  \n```xml\nSQL代码:\nselect * from a where name ='\"+ name+\"'\";\n正常情况:\nname:张三 -> select * from a where name='张三';\nSQL注入攻击:\nname:' or 1=1 or 1='\nselect * from a where name='' or 1=1 or 1=''\n```\n### MyBatis两种传值方式 \n◇${}文本替换,未经任何处理对SQL文本替换 \n◇ #{}预编译传值,使用预编译传值可以预防SQL注入  \n## MyBatis工作流程\n![image.png](MyBatis入门/1628585431174-e99c3d94-a034-4cf0-8882-0cee59cca82f.png)\n◇首先在Java应用中创建mybatis-config.xml文件，用于全局配置，这个配置文件包含了全局设置项、环境配置、mapper声明等核心配置信息；然后在程序的运行过程中通过SqlSessionFactoryBuilder构造器对象来build(构造)SqlSessionFactory工厂类对象；该工厂类对象需要保证全局唯一，用于创建SqlSession对象；SqlSession是我们用于对数据库增删改查的核心对象，它要解析与之对应的mapper.xml文件，每一个mapper.xml文件中包含了大量的sql语句；我们通过SqlSession来访问mapper.xml文件，进而执行其中的sql语句；在SqlSession中主要提供了四种方法(insert | update | delete | select)和数据库进行交互；在进行写的操作时，不要忘记对事务进行相应的提交和回滚；在交互完毕后，应当关闭会话任务，这样我们的底层数据库连接要么被连接池回收要么就直接释放掉；SessionClose这个操作一般放在finally块中，保证它一定能够执行；\n","tags":["MyBaits"],"categories":["Java数据库","MyBaits"]},{"title":"Lambda表达式","url":"/p/8609.html","content":"## 课程介绍 \n◇实例讲解Lambda语法 \n◇基于Lambda实现函数式编程 \n◇Stream流式处理  \n## 初识Lambda表达式  \n### 什么是Lambda表达式 \n◇JDK8开始支持Lambda表达式,用来让程序编写更优雅 \n◇利用Lambda可以更简洁的实现匿名内部类与函数声明与调用 \n◇基于Lambda提供stream流式处理极大简化对集合的操作  \n### 传统代码  \n```java\nList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n//实现集合排序\nCollections.sort(names, new Comparator<String>() {\n@Override\npublic int compare(String a, String b) {\nreturn b.compareTo(a);\n}\n});\n```\n### 使用Lambda表达式\n```java\nList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n//通过lambda表达式简化匿名类的编写\nCollections.sort(names, (a,b) -> b.compareTo(a));\n```\n##  Lambda表达式语法  \n###  Lambda语法格式  \n![image.png](Lambda表达式/1628129093309-0703436d-3189-4b06-a49a-3dd455c97aa9.png)\n### Lambda表达式示例  \n```java\n//四则运算接口\ninterface MathOperation {\nint operation(int a, int b);\n}\n```\n```java\npublic class LambdaSample {\n    public static void main(String[] args) {\n        //1.标准使用方式\n        //约束条件：Lambda表达式只能实现有且仅有一个抽象方法的接口，java称为\"函数式接口\"\n        MathOperation addition = (Integer a,Integer b)->{\n            System.out.println(\"加法运算\");\n            return a + b + 0f;//加上0f隐式的将结果转换为浮点型，与接口数据类型对应\n        };\n        System.out.println(addition.operation(3,9));\n        //2.Lambda允许参数类型忽略\n        MathOperation substraction = (a,b)->{\n            System.out.println(\"减法运算\");\n            return a-b+0f;\n        };\n        //3.单行实现代码可以省略大括号和return\n        MathOperation multiplication = (a,b)->a*b+0f;\n    }\n}\n//传统方法：新建一个class类，在类中定义运算方法，然后再实例化进行运算\n```\n## 函数式编程  \n### 什么是函数式编程 \n◇函数式编程是基于函数式接口并使用lambda表达的编程方式 \n◇函数式编程理念是将代码作为可重用数据代入到程序运行中 \n◇函数式编程强调\"你想做什么\",而不是\"你想怎么做\"  \n### 什么是函数式接口 \n◇函数式接口是有且只有一个抽象方法的接口 \n◇Java中拥有大量函数式接口,如java.lang.Runnable \n◇JDK8后提供了一系列新的函数式接口,位于java.util.function \n◇函数式接口的注解@FunctionInterface用来进行抽象方法检查，防止接口中存在多个方法\n### 函数式接口Predicate \n◇Predicate是新增的函数式接口,位于java.util.function \n◇Predicate用于测试传入的数据是否满足判断要求 \n◇Predicate接口需要实现test()方法进行逻辑判断  \n### 函数式编程示例  \n◇示例一\n```java\npublic class PredicateSample {\n    public static void main(String[] args) {\n        Predicate<Integer> predicate = n->n>4;\n        boolean result = predicate.test(5);\n        System.out.println(result);\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    /*   传统方法判断奇数，代码写死，不灵活\n         for(Integer num:list){\n            if(num%2==1){\n                System.out.println(num);\n            }\n        }*/\n        filter(list,n->n%2==1);//判断奇数，直接传参数即可\n        filter(list,n->n%2==0);//判断偶数\n    }\n    public static void filter(List<Integer> list,Predicate<Integer> predicate){\n        for(Integer num:list){\n            if(predicate.test(num)){\n                System.out.print(num + \" \");\n            }\n        }\n    }\n}\n```\n### 函数式编程与面向对象编程比较  \n![image.png](Lambda表达式/1628129379547-304e9c37-fd96-4baf-9943-4bd9c4eb18d7.png)\n## 函数式接口  \n### JDK8常用函数式接口  \n![image.png](Lambda表达式/1628129449949-b8221a19-cc47-4028-8504-49abae762bf2.png)\n### 函数式接口的应用  \n```java\n//Function函数式接口说明闭包要求输入参数并返回数据\nFunction<String, String> fn = (str) -> str.toUpperCase();\nString result = fn.apply(\"admin\"); //apply用于执行方法返回结果\nSystem.out.println(result);\n//Consumer函数式接口说明闭包只要求输入参数,但不会返回数据\nConsumer<String> c = arg -> {\nSystem.out.println(arg);\n};\nc.accept(\"hello\"); //accept只接受参数,没有任何结果返回\n```\n◇利用Function函数式接口生成定长随机字符串\n```java\npublic class FunctionSample {\n    public static void main(String[] args) {\n        Function<Integer,String> randomStringFunction = len->{\n            String chars=\"abcdefghijklmnopqrstuvwxyz0123456789\";\n            StringBuffer stringBuffer = new StringBuffer();\n            Random random = new Random();\n            for(int i=0;i<len;i++){\n                //截取某一个字符的位置\n                int position = random.nextInt(chars.length());\n                //charAt方法按照指定位置将字符提取出来\n                stringBuffer.append(chars.charAt(position));\n            }\n            return stringBuffer.toString();\n        };\n        String randomString = randomStringFunction.apply(5);\n        System.out.println(randomString);\n    }\n}\n```\n## Stream流式处理\n◇Stream流式处理是建立在Lambda基础上的多数据处理技术 \n◇Stream对集合数据处理进行高度抽象,极大简化代码量 \n◇Stream可对集合进行迭代,去重,筛选,排序,聚合等一系列处理  \n### Stream示例  \n```java\n//获取List集合中最大的偶数\nOptional<Integer> op = Arrays.asList(1,2,3,4,5,6).stream()\n.filter(x -> x%2 == 0)//先进行筛选,得到偶数\n.sorted((a,b) -> b-a)//b-a表示降序,a-b表示升序\n.findFirst();//取第一个,这里即最大的\nSystem.out.println(op.get());\n```\n### Stream常用方法  \n![image.png](Lambda表达式/1628129577239-b2769d4b-57df-4c3d-9ddf-edc3c57fabb9.png)\n### Stream操作实例\n◇Stream流的五种创建方式；最常用的为1,2两种  \n```java\npublic class StreamGenerator {\n    //1.基于数组创建\n    @Test\n    public void generator1(){\n        String[] arr = {\"莉莉\", \"安迪\", \"明明\", \"牛牛\"};\n        Stream<String> stream = Stream.of(arr);\n        stream.forEach(s->System.out.println(s));\n    }\n    //2.基于集合创建\n    @Test\n    public void generator2(){\n        List<String> list = new ArrayList<>();\n        list.add(\"莉莉\");\n        list.add(\"安迪\");\n        list.add(\"马马\");\n        list.add(\"牛牛\");\n        Stream<String> stream = list.stream();\n        stream.forEach(s-> System.out.println(s));\n    }\n    //3.利用generate方法创建无限长度流\n    @Test\n    public void generator3(){\n        //bound限制产生的随机数小于其参数\n        Stream<Integer> stream = Stream.generate(() -> new Random().nextInt(1000));\n        //limit用来限制流的最大长度，不设置则为无限\n        stream.limit(10).forEach(i-> System.out.println(i));\n    }\n    //4.基于迭代器创建\n    @Test\n    public void generator4(){\n        //seed：起始的数据；n+1表示每一次循环步长为1\n        Stream<Integer> stream = Stream.iterate(1, n -> n + 1);\n        stream.limit(100).forEach(i-> System.out.println(i));\n    }\n    //5.基于字符序列创建\n    @Test\n    public void generator5(){\n        String str = \"hello你好\";\n        IntStream stream = str.chars();\n        //输出为字母的ASCII码或者汉字的Unicode编码;将c强制转换成char类型即可输出原字符\n        stream.forEach(c -> System.out.println((char)c));\n    }\n}\n```\n◇Stream流的常用方法\n```java\npublic class StreamMethod {\n    //1.提取集合中所有偶数并求和\n    @Test\n    public void case1(){\n        //List的泛型设为String类型,否则编译器默认s为object,而parseInt不支持object类型\n        List<String> list = Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\");\n        int sum = list.stream() //获取stream对象\n            .mapToInt(s->Integer.parseInt(s)) //mapToInt将流中的每一个数据转换为整数\n            .filter(n->n%2==0)//对流中数据进行过滤\n            .sum();//将所有数据进行求和，数据只能为整数\n        System.out.println(sum);\n    }\n    //2.所有名字首字母大写\n    @Test\n    public void case2(){\n        List<String> list = Arrays.asList(\"lily\",\"smith\",\"jackson\",\"bob\");\n        List newList = list.stream()\n                /*substring()截取位置为a到b的字符串，\n                若只有一个参数，则此参数表示从该位置截取\n                到最后*/\n                .map(s -> s.substring(0, 1).toUpperCase()+s.substring(1))\n                //.forEach(s -> System.out.println(s));只能进行打印，没有保存\n                //collect对流数据进行收集，生成新的List/Set(Set可以将重复数据自动清除)\n                .collect(Collectors.toList());//可以将转换后的结果保存到新的List中\n        System.out.println(newList);\n    }\n    //3.将所有奇数从大到小进行排序，且不许出现重复\n    //Set方法可以清楚重复数据，但没有顺序，排序功能会失效\n    @Test\n    public void case3(){\n        List<Integer> list = Arrays.asList(1,60,38,21,51,60,51,73);\n        List newList = list.stream().distinct()//去除重复的流数据\n                .filter(n->n%2==1)\n                .sorted((a,b)->b-a)\n                .collect(Collectors.toList());\n        System.out.println(newList);\n    }\n}\n```\n### 如何通过oracle官网学习Stream流的方法\n◇[官网地址](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html):百度java.util.stream\n◇查看每一个方法的作用\n​\n\n\n\n","tags":["Lambda"],"categories":["Java数据库","框架前置知识"]},{"title":"Java反射","url":"/p/7c7c.html","content":"## 课程介绍\n◇介绍反射及作用 \n◇讲解反射四个核心类 \n◇反射在项目中的应用 \n## 主要知识点 \n◇反射的作用 \n◇Class类 \n◇Constructor构造方法类 \n◇Method方法类 \n◇Field成员变量类  \n## 什么是反射Reflect \n◇反射(Reflect)是在运行时动态访问类与对象的技术 \n◇反射是JDK1.2版本后的高级特性,隶属于java.lang.reflect \n◇大多数Java框架都基于反射实现参数配置、动态注入等特性  \n◇反射方法与传统方法对比,传统方法要增加乘法类时需要再写一个if else而反射方法支持动态增加方法的功能\n```java\n /**\n     * 传统的创建对象方式\n     */\n    public static void case1(){\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"请输入计算类名:\");\n        String op = scanner.next();\n        System.out.print(\"请输入a:\");\n        int a = scanner.nextInt();\n        System.out.print(\"请输入b:\");\n        int b = scanner.nextInt();\n        MathOperation mathOperation = null;\n        if(op.equals(\"Addition\")){\n            mathOperation = new Addition();\n        }else if(op.equals(\"Subtraction\")) {\n            mathOperation = new Subtraction();\n        }else if(op.equals(\"Multiplication\")){\n            mathOperation = new Multiplication();\n        }else{\n            System.out.println(\"无效的计算类\");\n            return;\n        }\n        float result = mathOperation.operate(a, b);\n        System.out.println(result);\n    }\n\n    /**\n     * 利用反射创建对象更加灵活\n     */\n    public static void case2(){\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"请输入计算类名:\");\n        String op = scanner.next();\n        System.out.print(\"请输入a:\");\n        int a = scanner.nextInt();\n        System.out.print(\"请输入b:\");\n        int b = scanner.nextInt();\n        MathOperation mathOperation = null;\n        try {\n            mathOperation = \n                (MathOperation) Class.forName(\"com.lcg.reflect.\" + op).newInstance();\n        }catch(Exception e){\n            System.out.println(\"无效的计算类\");\n            return;\n        }\n        float result = mathOperation.operate(a, b);\n        System.out.println(result);\n    }\n```\n## 反射的核心类 \n◇Class类 \n◇Constructor构造方法类 \n◇Method方法类 \n◇Field成员变量类 \n## Class类  \n◇Class是JVM中代表\"类和接口\"的类 \n◇Class对象具体包含了某个特定类的结构信息 \n◇通过Class对象可获取对应类的构造方法/方法/成员变量  \n###  Class核心方法  \n![image.png](Java反射/1627994260419-a7f327ff-16ef-4c68-82b0-f4bf86f15749.png)\n###  利用Class创建对象  \n```java\npublic class ClassSample {\n    public static void main(String[] args) {\n        try {\n            //Class.forName()方法将指定的类加载到jvm,并返回对应Class对象(得到员工类对象)\n            Class employeeClass = Class.forName(\"com.imooc.reflect.entity.Employee\");\n            System.out.println(\"Employee已被加载到jvm\");\n            //newInstance通过默认构造方法创建新的对象(实例化),返回Object对象，需要强制转换\n            Employee emp = (Employee)employeeClass.newInstance();\n            System.out.println(emp);\n        } catch (ClassNotFoundException e) {\n            //类名与类路径书写错误是抛出\"类无法找到\"异常\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            //非法访问异常,当在作用域外访问对象方法或成员变量时抛出\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            //对象无法被实例化,抛出\"实例化异常\"\n            e.printStackTrace();//抽象类(abstract)无法被实例化\n        }\n    }\n}\n```\n## Constructor构造方法类 \n◇Constructor类是对Java类中的构造方法的抽象 \n◇Contructor对象包含了具体类的某个具体构造方法的声明 \n◇通过Constructor对象调用带参构造方法创建对象  \n###  Constructor类核心方法  \n![image.png](Java反射/1627996525920-b349474c-5ebe-4cda-a6fa-dcf70573d893.png)\n###  利用Constructor创建对象  \n```java\npublic class ConstructorSample {\n    public static void main(String[] args) {\n        try {\n            //得到员工类的类对象\n            Class employeeClass = Class.forName(\"com.lcg.reflect.entity.Employee\");\n            //得到Employee类中包含有四个参数的构造方法对象,Class[]类型数组\n            Constructor constructor = employeeClass.getConstructor(new Class[]{\n                    Integer.class,String.class,Float.class,String.class\n            });\n            //通过指定构造方法传入数据,创建对象\n            Employee employee = (Employee) constructor.newInstance(new Object[]{\n                    100,\"李磊\",3000f,\"研发部\"\n            });\n            System.out.println(employee);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            //没有找到与之对应格式的方法\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            //当被调用的方法的内部抛出了异常而没有被捕获时\n            e.printStackTrace();\n        }\n    }\n}\n```\n## Method方法类 \n◇Method对象指代某个类中的方法的描述 \n◇Method对象使用classObj.getMethod()方法获取 \n◇通过Method对象调用指定对象的对应方法  \n### Method类核心方法  \n![image.png](Java反射/1627996618023-85940d99-f781-4daf-8279-76c4a76ff3c6.png)\n### 利用Method执行方法  \n```java\n/**\n * 利用Method方法类调用\n */\npublic class MethodSample {\n    public static void main(String[] args) {\n        try {\n            Class employeeClass = Class.forName(\"com.lcg.reflect.entity.Employee\");\n            Constructor constructor = employeeClass.getConstructor(new Class[]{\n                    Integer.class, String.class, Float.class, String.class\n            });\n            //传入参数时用Object[]对象数组\n            Employee employee = (Employee) constructor.newInstance(new Object[]{\n                    100, \"李磊\", 3000f, \"研发部\"\n            });\n            Method updateSalaryMethod = employeeClass.getMethod(\"updateSalary\", new Class[]{\n                    Float.class\n            });\n            Employee employee1 = (Employee) updateSalaryMethod.invoke(employee, new Object[]{1000f});\n            System.out.println(employee1);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n##  Field成员变量类 \n◇Field对应某个具体类中的成员变量的声明 \n◇Field对象使用classObj.getField()方法获取 \n◇通过Field对象可为某对象成员变量赋值/取值  \n###  Field类核心方法  \n![image.png](Java反射/1627996714885-1ad3a503-3276-4d82-aa14-3ed8abf131de.png)\n###  利用Field赋值与取值  \n```java\n...\n//获取员工姓名Field成员变量对象\nField enameField = employeeClass.getField(\"ename\");\n//成员变量赋值\nenameField.set(employee,\"李雷\");\n//成员变量取值，参数为对象名\nString ename = (String)enameField.get(employee);\n```\n##  getDeclared系列方法 \n◇getDeclaredConstructor(s)|Method(s)|Field(s)获取对应对象(构造方法，方法，成员变量) ,+s表示获取所有(多个)\n◇getConstructor(s)|Method(s)|Field(s)只能获取public对象  \n◇访问非作用域内构造方法、方法、成员变量,会抛出异常  \n◇public变量.get()直接获取，非public变量先通过类对象获取到get方法再来调用get方法获取\n```java\nClass employeeClass = Class.forName(\"com.lcg.reflect.entity.Employee\");\nConstructor constructor = employeeClass.getConstructor(new Class[]{\n    Integer.class, String.class, Float.class, String.class\n        });\nEmployee employee = (Employee) constructor.newInstance(new Object[]{\n    100, \"李磊\", 3000f, \"研发部\"\n    });\n//获取当前类所有成员变量\nField[] fields = employeeClass.getDeclaredFields();\nfor(Field field : fields){\n    //System.out.println(field.getName());\n    //对成员变量区分对待\n    if(field.getModifiers() == 1){ //pubilc修饰\n        Object val = field.get(employee);\n        System.out.println(field.getName() + \":\" + val);\n    }else if(field.getModifiers() == 2){ //private修饰\n        //构造出get方法名,eg: getSalary();\n        String methodName = \"get\" + field.getName().substring(0,1).toUpperCase()\n            + field.getName().substring(1);\n        Method getMethod = employeeClass.getMethod(methodName);//获取类的get方法;\n        Object ret = getMethod.invoke(employee);//执行get方法\n        System.out.println(field.getName() + \":\" + ret);\n    }\n}\n```\n##  反射在项目中的应用   \n◇网站的国际化\n```java\npublic class Application {\n    public static void say(){\n        Properties properties = new Properties();//加载指定配置文件\n        //获取配置文件路径\n        String configPath = Application.class.getResource(\"/config.properties\").getPath();\n        try {\n            configPath = new URLDecoder().decode(configPath,\"UTF-8\");\n            properties.load(new FileInputStream(configPath));\n            //用 Properties.getProperty来读取配置文件里面的(language属性)的属性值\n            String language = properties.getProperty(\"language\");\n            //利用language告知Class获取哪一个指定类并实例化\n            I18N i18n = (I18N)Class.forName(language).newInstance();\n            System.out.println(i18n.say());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        Application.say();\n    }\n}\n```\n\n","tags":["反射"],"categories":["Java数据库","框架前置知识"]},{"title":"工厂模式","url":"/p/177d.html","content":"## 课程介绍 \n◇ 介绍工厂模式的用途与特点 \n◇ 介绍设计模式 \n◇ 掌握工厂模式的项目应用  \n\n## 设计模式 \n◇ 设计模式是前辈总结的设计经验 \n◇ 设计模式的目标是代码更容易理解,更容易维护 \n◇ 通过设计模式可以让代码更加可靠  \n## 设计模式的分类 \n◇ 创建型模式 \n◇ 结构型模式 \n◇ 行为型模式 \n## 工厂模式 \n◇ 工厂模式用于隐藏创建对象的细节 \n◇ 工厂模式核心:工厂类(Factory) \n◇ 工厂模式可细分为简单工厂、工厂方法与抽象工厂  \n## 简单工厂  \n![image.png](工厂模式/1627975803385-c3f9255b-05f0-4a31-874c-4b893aaf5838.png)\n##  项目应用-i18n国际化  \n◇工程结构\n![image.png](工厂模式/1627977675883-ad7ab257-f14f-42ad-aafe-390fd88d3ca1.png)\n◇软件类\n\n```java\npublic class Software {\n   public static void main(String[] args) {\n\t   I18N i18n = I18NFactory.geI18NObject(\"China\");//静态的，不需要new，直接调用方法即可\n\t   System.out.println(i18n.getTitle());\n   }\n}\n```\n◇国际化工厂类\n```java\npublic class I18NFactory {\n   public static I18N geI18NObject(String area) {//静态工厂\n\t   if(area.equals(\"China\")) {\n\t\t   return new Chinese();\n\t   }else if(area.equals(\"UK\")) {\n\t\t   return new English();\n\t   }else if(area.equals(\"Japan\")) {\n\t\t   return new Japanese();\n\t   }else {\n\t\t   return null;\n\t   }\n   }\n}\n```\n◇语言类\n```java\npublic class Chinese implements I18N {\n   public String getTitle() {\n\t   return \"这是中文\";\n   }\n}\n```\n◇接口\n```java\npublic interface I18N {\n  public String getTitle();\n}\n```\n◇面向接口的开发\n##  项目应用-多端应用切换\n◇工程目录\n![image.png](工厂模式/1627993810721-d64e385b-e0f7-4dd9-ab02-1b4bc564436e.png)\n◇工厂类\n\n```java\npublic class DeviceFactory {\n  public static Device getDevice(HttpServletRequest req) {\n\t  String userAgent=req.getHeader(\"user-agent\");\n\t  System.out.println(userAgent);\n\t  if(userAgent.indexOf(\"Windows NT\")!=-1) {\n\t\t  return new DesktopDevice();\n\t  }else if(userAgent.indexOf(\"iPhone\")!=-1 || userAgent.indexOf(\"Android\")!=-1) {\n\t\t  return new MobileDevice();\n\t  }else {\n\t\t  return null;\n\t  }\n  }\n}\n```\n\n","categories":["Java数据库","框架前置知识"]},{"title":"Maven项目管理","url":"/p/316f.html","content":"###  课程介绍  \n ◇ 介绍Maven的核心特性  \n ◇ 掌握Maven的依赖管理  \n ◇ 掌握Maven的打包方式  \n\n###  Maven介绍  \n ◇ Maven 是项目管理工具,对软件项目提供构建与依赖管理  \n ◇ Maven是Apache下的Java开源项目  \n ◇ Maven为Java项目提供了统一的管理方式，已成为业界标准  \n###  Maven核心特性  \n◇ 项目设置遵循统一的规则，保证不同开发环境的兼容性 Maven核心特性 \n◇ 强大的依赖管理，项目依赖组件自动下载、自动更新 \n◇ 可扩展的插件机制，使用简单，功能丰富  \n###  Maven的安装与配置  \n###  Maven的坐标  \n ◇ GroupId：机构或者团体的英文，采用\"逆向域名\"形式书写  \n ◇ ArtifactId：项目名称,说明其用途，例如：cms、oa...  \n ◇ Version：版本号，一般采用\"版本+单词\"形式，例如：1.0.0.RELEASE  \n###  Maven项目标准结构  \n![image.png](Maven项目管理/1627634963647-8798bed9-4a2c-4e9b-8873-7bb418fdba6d.png)\n###  Maven依赖管理 \n◇Maven利用dependency(依赖)自动下载、管理第三发jar\n◇在pom.xml文件中配置项目依赖的第三方组件\n◇maven自动将依赖从远程仓库下载至本地仓库，并在工程中引用 \n◇[maven中央仓库检索网站](https://search.maven.org/)\n◇pinyin4j将汉字转换为拼音\n 配置\n```xml\n <dependency>\n\t  <groupId>com.belerweb</groupId>\n\t  <artifactId>pinyin4j</artifactId>\n\t  <version>2.5.1</version>\n\t</dependency>\n```\n 代码\n```java\npublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString str = scan.nextLine();\n\t\tString[] pinyin = PinyinHelper.toHanyuPinyinStringArray('李'); \n\t\tfor(String py : pinyin) {\n\t\t\tSystem.out.println(py);\n\t\t}\n\t}\n```\n◇配置多个jar包:依赖本身也依赖于底层jar包，因此有多个jar包\n###  本地仓库与中央仓库  \n![image.png](Maven项目管理/1627635052884-beae7764-b69b-40ff-8215-a112d76dbd79.png)\n\n 本地仓库目录\n\n![image.png](Maven项目管理/1627733946275-eab3e214-a8aa-4a33-aa28-3b7371428144.png)\n◇创建备份服务器，提高下载速度\n\n```java\n  <repositories>\n    <repository>\n      <!-- 创建私服的地址 -->\n      <id>aliyun</id>\n      <name>aliyun</name>\n      <url>https://maven.aliyun.com/repository/public</url>\n    </repository>\n  </repositories>\n```\n###  项目打包  \n ◇ Maven可将Java项目打包为jar、war包  \n ◇ Maven项目打包是通过Plugins（插件）技术实现  \n ◇ Maven输出Jar包插件：maven-assembly-plugin  \n ◇ 配置文件\n```java\n<build>\n  <!-- 配置插件 -->\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-assembly-plugin</artifactId>\n        <version>2.5.5</version>\n        <configuration>\n          <archive>\n            <mainfest>\n              <mainClass>com.lcg.maven.PinyinTestor</mainClass>\n            </mainfest>\n          </archive>\n          <descriptorRefs>\n          <!--  all in one 在打包时会将所有引用的jar合并到输出的jar文件中 -->\n            <descriptorRef>jar-with-dependencies</descriptorRef>\n          </descriptorRefs>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n```\n ◇ 配置运行\n![image.png](Maven项目管理/1627738334274-d9101c2e-e3dd-43be-b703-6cc97ac65fc9.png)\n◇ 打包成功后的运行命令\n\n```java\njava -jar maven-1-1.0.0-RELEASE-jar-with-dependencies.jar\n```\n###  Maven构建Web工程  \n◇创建maven项目->配置JRE：JRE System Library->properties->Workspace default JRE->Apply and Close\n◇修改JDK编译级别：工程名->properties->Java Compiler->Compiler compliance level(编译级别):1.8-OK\n◇在src/main目录下创建webapp文件夹\n◇工程名->properties->Project Facets->Convert to faceted form->勾选Dynamic Web Module 3.1->Runtimes:指定Apache Tomcat->Further configuration available->Content directory:src/main/webapp->勾选web.xml-OK->Apply and Close\n###  Web工程打包  \n◇[遇见错误](https://blog.csdn.net/cx1110162/article/details/78110277?spm=1001.2014.3001.5506)：将jar文件复制到工程的WEB-INF/lib目录即可\n◇配置：RunConfigurations->MavenBuild->NewConfiguration->Name:build-war->Base directory:指向工程->Goals:package->Apply->Run\n◇pom.xml\n```java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" \n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n        xsi:schemaLocation=\n          \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.lcg</groupId>\n  <artifactId>maven</artifactId>\n  <version>1.0.0-RELEASE</version>\n    <!-- packaging代表输出的格式 -->\n  <packaging>war</packaging>\n  <dependencies>\n    <dependency>\n\t  <groupId>javax.servlet</groupId>\n\t  <artifactId>jstl</artifactId>\n\t  <version>1.2</version>\n    </dependency>\n  </dependencies>\n  <!-- 自定义解压文件名 -->\n  <build>\n  \t<finalName>maven-web</finalName>\n  \t<plugins>\n  \t\t<plugin>\n  \t\t\t<groupId>org.apache.maven.plugins</groupId>\n  \t\t\t<artifactId>maven-war-plugin</artifactId>\n  \t\t\t<version>3.2.2</version>\n  \t\t</plugin>\n  \t</plugins>\n  </build>\n</project>\n```\n###  Maven常用命令  \n◇需要配置环境变量\n◇在cmd中使用\n![image.png](Maven项目管理/1627635155092-1aa7242a-e588-4d42-81df-c93b29c0ceb3.png)\n\n###  修改本地仓库地址  \n◇打开F:\\JAVA\\tool\\apache-maven-3.6.0\\conf中的settings.xml文件\n◇修改49-52处的代码\n```java\n修改前 \n<!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}/.m2/repository\n  <localRepository>/path/to/local/repo</localRepository>\n  -->\n  修改后\n    <!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}/.m2/repository  -->\n  <localRepository>G:/maven-repo</localRepository>\n```\n◇Eclipse中配置：Window->Preferences->Maven->User Settings:选择apache-maven-3.6.0\\conf中的settings.xml文件->Reindex-Apply and Close\n###  在IDEA中配置Maven\n◇Settings->Build,Execution->Build Tools->Maven->Maven home directory: ;User settings file: ;Local repository: \n![image.png](Maven项目管理/1627914341482-b8b8d144-9206-48d8-82e5-94b3fa017a28.png)\n◇创建Maven项目：New Project->Maven->Next->GroupID;ArtifactID;Version->Next->Finish\n◇IDEA关于Maven的快捷键:点击右边的Maven弹出界面,即Maven的常用命令\n![image.png](Maven项目管理/1627915088171-0ea5f377-320d-4db9-90c8-30e2f2f06f5b.png)\n\n","tags":["Maven"],"categories":["Java数据库","框架前置知识"]},{"title":"JDBC入门","url":"/p/8791.html","content":"##  课程介绍  \n◇JDBC快速入门 \n◇精讲JDBC开发细节 \n◇连接池与JDBC进阶使用  \n##  主要知识点  \n◇JDBC使用步骤 \n◇数据库查询方法 \n◇数据库写入方法\n◇SQL注入攻击的应对 \n◇连接池的使用 \n◇Apache Commons DBUtils  \n##  什么是JDBC  \n◇Java数据库连接-Java DataBase Connectivity \n◇JDBC可让Java通过程序操作关系型数据库\n◇JDBC基于驱动程序实现与数据库的连接与操作  \n##  什么是驱动程序  \n![image.png](JDBC入门/1627277427089-85c466be-a249-4635-97bc-01d3aadddf7e.png)\n ◇JDBC驱动程序  \n![image.png](JDBC入门/1627277734522-eff71526-c749-4218-918b-9c681fa21208.png)\n\n##  JDBC的优点  \n◇统一的API,提供一致的开发过程 \n◇易于学习,容易上手,代码结构稳定 \n◇功能强大,执行效率高,可处理海量数据  \n##  JDBC开发简要流程  \n**0.Navicat创建数据库**：字符集采用utf8mb4\n### 1. 加载并注册JDBC驱动 \n◇将MySQL驱动的jar包复制到工程的lib目录->File->Project Structure->Modules(模块)->Dependencies(依赖)->'+'->1->选择lib目录下的jar包，OK->勾选Export->OK\n```sql\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n```\n### 2. 创建数据库连接 \n```sql\n \"jdbc:mysql://localhost:3306/gamest?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\",\n                \"root\",\"www.LCG.com\"\n```\n### 3. 创建Statement对象 \n```sql\nStatement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(\"select * from employee\");\n```\n### 4. 遍历查询结果  \n```sql\nwhile (rs.next()) {\n         Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置\n         String ename = rs.getString(\"ename\");//获取ename列的数据（数据为String型），按名称\n         Float salary = rs.getFloat(\"salary\");\n         String dname = rs.getString(\"dname\");\n         System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n```\n### 5. 关闭连接,释放资源  \n```sql\nif (conn!=null&&conn.isClosed()==false){//防止空指针异常\n         //5. 关闭连接,释放资源\n         conn.close();//如果conn为空，则会出现空指针异常，如执行1.就报错后，conn为空}\n```\n## JDBC开发详细流程\n###  如何获取JDBC驱动Jar  \n◇[Mysql官网下载](https://www.mysql.com/cn/products/connector/)MySQL Connectors ->JDBC Driver for MySQL->由于是跨平台的，选择任意版本即可Ubuntu Linux->直接下载\n###  创建数据库连接代码  \n```sql\nString dbDriver = \"com.mysql.cj.jdbc.Driver\"; //JDBC驱动类\nString dbURL = \"jdbc:mysql://localhost:3306/gamest\" ; //连接字\n符串\nString dbUsername = \"root\"; //数据库用户名\nString dbPassword = \"123456\"; //数据库密码\n//1.加载并初始化JDBC驱动\nClass.forName(dbDriver);\n//2.创建数据库连接\nConnection connection = DriverManager.getConnection(dbURL, dbUsername, dbPassword);\n```\n###  Class.forName的作用  \n◇Class.forName用于加载指定的JDBC驱动类 \n◇Class.forName本质是通知JDBC注册这个驱动类 \n◇驱动由数据库厂商自行开发,连接字符串也不同  \n###  数据库与连接字符串  \n![image.png](JDBC入门/1627288444741-e2147775-ca39-4693-88c7-0f545847efb5.png)\n###  DriverManager  \n◇DriverManager用于注册/管理JDBC驱动程序 \n◇DriverManager.getConnection(连接字符串,用户名,密码) \n◇返回值Connection对象,对应数据库的物理网络连接  \n###  Connection对象  \n◇Connection对象用于JDBC与数据库的网络通信对象 \n◇java.sql.Connection是一个接口，具体由驱动厂商实现 \n◇所有数据库的操作都建立在Connection基础上  \n![image.png](JDBC入门/1627311314818-03c42582-5f5a-4798-8a3a-8062442ab49f.png)\n\n###  MySQL连接字符串  \n◇格式: jdbc:mysql://[主机ip][:端口]/数据库名?参数列表 \n◇主机ip与端口是可选设置,默认值为127.0.0.1与3306 \n◇参数列表采用url编码,格式:参数1=值1&参数2=值2&...  \n###  MySQL连接字符串常用参数  \n![image.png](JDBC入门/1627311449343-e094739a-3298-4553-8e3e-ad1ee903c721.png)\n###  连接数据库的常见问题  \n◇ClassNotFoundException - 类未找到异常 \n◇Connection refuse - 数据库连接被拒绝异常 \n◇Access denied for user - 用户名与密码错误异常  \n##  数据库查询操作  \n◇部分代码\n```sql\n//4. 遍历查询结果\n            /*rs.next()返回布尔值，代表是否存在下一条记录，若有，返回true\n            同时提取下一条记录；如果没有，返回false，循环就会停止*/\n         while (rs.next()){\n           Integer eno = rs.getInt(1);//JDBC中字段索引从1开始\n           String ename = rs.getString(\"ename\");//获取ename列的数据（数据为String型），按名称\n           Float salary = rs.getFloat(\"salary\");\n           String dname = rs.getString(\"dname\");\n           System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n           }\n         //5.关闭连接，释放资源\n            try {\n                if(rs!=null){\n                    rs.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if(stmt!=null){\n                    stmt.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if(conn!=null&&!conn.isClosed()){//不为空并且没有关闭\n                    conn.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n```\n### Statement对象 \n◇Statement是用于执行SQL的工具 \n◇查询方法: ResultSet executeQuery(String sql) \n◇注意: sql参数必须是SELECT 查询SQL语句 \n### ResultSet对象 \n◇ResultSet结果集对象,保存查询结果 \n◇ResultSet采用迭代方式逐行获取每一行表数据 \n◇每一次迭代,使用ResultSet对象的getXXX()方法获取列数据  \n##  SQL注入攻击  \n◇SQL注入攻击是指利用SQL漏洞越权获取数据的黑客行为 \n◇SQL注入攻击根源是未对原始SQL中的敏感字符做特殊处理 \n◇解决方法:放弃Statement改用PreparedStatement处理SQL  \n###  PreparedStatement  \n◇PreparedStatement 预编译Statement是Statement接口的子接口 \n◇PreparedStatement对SQL进行参数化,预防SQL注入攻击 \n◇PreparedStatement比Statement执行效率更高  \n◇原始代码  \n```sql\n// 存在SQL注入风险\n// pdname值为' or 1=1 or 1='时,所有筛选条件均失效\n// SQL: select * from employee where pdname='' or 1=1 or 1='' ;单引号没有处理\nString sql = \"select * from employee where dname='\" + pdname + \"'\" ;\nStatement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery(sql);\nwhile(rs.next()){\n....\n}\n```\n ◇PreparedStatement  \n```sql\n// 利用PreparedStatement预防SQL注入风险\n// 当dname值为' or 1=1 or 1='时 , 查询不到任何结果\n// SQL: select * from employee where dname='\\' or 1=1 or 1=\\'' ;单引号被处理\nString sql = \"select * from employee where dname=?\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setString(1,dname); //设置SQL参数,参数从1开始\nResultSet rs = pstmt.executeQuery();\nwhile(rs.next()){\n....\n}\n```\n◇示例代码\n```java\npackage com.lcg.jdbc.hrapp.command;\n\nimport java.sql.*;\nimport java.util.Scanner;\n\n/**\n * PreparedStatement对象使用方法\n */\npublic class PstmtQueryCommand implements Command {\n    @Override\n    public void execute() {\n        System.out.print(\"请输入部门名称：\");\n        Scanner in = new Scanner(System.in);\n        String pdname = in.nextLine();\n        Connection conn = null;\n        //Statement stmt = null;\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        try {\n            //1. 加载并注册JDBC驱动\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            //2. 创建数据库连接\n            conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/imooc?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true\", \"root\", \"root\");\n            //3. 创建PreparedStatement对象\n            String sql = \"select * from employee where dname=? and eno > ?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setString(1, pdname); //注意:参数索引从1开始\n            pstmt.setInt(2, 3500);//2,即第二个参数\n            //结果集\n            rs = pstmt.executeQuery();\n            //4. 遍历查询结果\n            //rs.next()返回布尔值，代表是否存在下一条记录\n            //如果有，返回true,同时结果集提取下一条记录\n            //如果没有，返回false，循环就会停止\n            while (rs.next()) {\n                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0\n                String ename = rs.getString(\"ename\");\n                Float salary = rs.getFloat(\"salary\");\n                String dname = rs.getString(\"dname\");\n                System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n\n            }\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //5. 关闭连接,释放资源\n            try {\n                if (rs != null) {\n                    rs.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n\n            try {\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n\n            try {\n                if (conn != null && !conn.isClosed()) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n### 错误的使用方式\n◇select * from employee where ?='abc' \n◇select * from employee where salary = ?+100 \n◇select ? from employee where ename = ?  \n##  JDBC实现写数据  \n###  封装DbUtils工具类  \n◇工具类代码\n```sql\npublic class DbUtils {\n    /**\n     * 在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板\n     * 创建新的数据库连接\n     * @return 新的Connection对象\n     * @throws SQLException\n     * @throws ClassNotFoundException\n     */\n    public static Connection getConnection() throws SQLException, ClassNotFoundException {\n        //1. 加载并注册JDBC驱动\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");\n        //2. 创建数据库连接\n        Connection conn = DriverManager.getConnection(\n                \"jdbc:mysql://localhost:3306/gamest?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\",\n                \"root\", \"www.LCG.com\"\n        );\n        return conn;\n    }\n    /**\n     * 关闭连接，释放资源\n     * @param rs 结果集对象\n     * @param pstmt Statement对象\n     * @param conn Connection对象\n     */\n    public static void closeConnection(ResultSet rs, PreparedStatement pstmt,Connection conn){\n        try {\n            if(rs!=null){\n                rs.close();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        try {\n            if(pstmt!=null){\n                pstmt.close();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        try {\n            if(conn!=null&&!conn.isClosed()){\n                conn.close();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n###  JDBC执行INSERT语句  \n```sql\nString sql= \"insert into employee(eno,ename) values(?,?)\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setInt(1,10);\npstmt.setString(2,\"张三\");\n//executeUpdate方法返回记录数\nint cnt = pstmt.executeUpdate(); //cnt=1,表示sql语句所影响的数据库的行数\nSystem.out.println(\"数据新增成功\");\n```\n◇新增员工数据\n```sql\npublic class InsertCommand implements Command{\n    @Override\n    public void execute(){\n        Scanner in = new Scanner(System.in);\n        System.out.println(\"请输入员工编号\");\n        int eno = in.nextInt();\n        System.out.println(\"请输入员姓名\");\n        String ename = in.next();\n        System.out.println(\"请输入员工薪资\");\n        float salary = in.nextFloat();\n        System.out.println(\"请输入隶属部门\");\n        String dname = in.next();\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        try {\n            conn = DbUtils.getConnection();\n            String sql = \"insert into employee(eno,ename,salary,dname) values(?,?,?,?)\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, eno);\n            pstmt.setString(2, ename);\n            pstmt.setFloat(3, salary);\n            pstmt.setString(4, dname);\n            int cnt = pstmt.executeUpdate();//所有写操作都使用executeUpdate\n            System.out.println(\"cnt:\"+cnt);\n            System.out.println(ename+\"员工入职手续办理成功\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }finally {\n            DbUtils.closeConnection(null,pstmt,conn);\n        }\n    }\n}\n```\n###  JDBC执行UPDATE语句  \n```sql\nString sql= \"update employee set salary=salary + 1000 where dname=?\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setString(1,\"研发部\");\n//executeUpdate方法返回记录数\nint cnt = pstmt.executeUpdate();\nSystem.out.println(\"研发部\" + cnt + \"名员工提薪1000元\");\n```\n###  JDBC执行DELETE语句  \n```sql\nString sql= \"delete from employee where eno = ?\";\nPreparedStatement pstmt = conn.prepareStatement(sql);\npstmt.setInt(1, 3395);\n//executeUpdate方法返回记录数\nint cnt = pstmt.executeUpdate();\nSystem.out.println(cnt+\"名员工数据已被删除\");\n```\n##  JDBC中的事务管理  \n### 什么是事务 \n◇事务是以一种可靠的、一致的方式，访问和操作数据库的程序单元 \n◇说人话：要么把事情做完，要么什么都不做，不要做一半 \n◇事务依赖于数据库实现,MySQL通过事务区作为数据缓冲地带  \n###  事务的提交操作  \n![image.png](JDBC入门/1627462586528-28cc5fc3-1e3f-465e-9968-8e89b86516eb.png)\n### 事务的回滚操作\n![image.png](JDBC入门/1627462637835-0f24ab7b-4905-4827-9f32-f494780da680.png)\n\n###  JDBC两种事务模式    \n◇JDBC允许两种事务模式 \n◇自动提交事务模式 \n◇手动提交事务模式  \n####  自动提交事务模式  \n◇自动提交模式是指每执行一次写操作SQL,自动提交事务 \n◇自动提交开启方法: conn.setAutoCommit(true) \n◇自动事务是JDBC默认行为,此模式无法保证多数据一致性  \n####  手动提交事务模式  \n◇手动提交模式是指显式调用commit()与rollback()方法管理事务 \n◇手动提交开启方法: conn.setAutoCommit(false) \n◇手动提交事务可保证多数据一致性,但必须手动调用提交/回滚方法  \n###  实现批量增加员工  \n```sql\n/**\n * JDBC中的事务机制\n */\npublic class TransactionSample {\n    public static void main(String[] args) {\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        try {\n            conn = DbUtils.getConnection();\n            //JDBC默认使用自动提交模式\n            conn.setAutoCommit(false);//设置手动提交\n            String sql = \"insert into employee(eno,ename,salary,dname) values(?,?,?,?)\";\n            for(int i=100;i<200;i++){\n/*                if(i==105){\n                    throw new RuntimeException(\"插入失败\");//模拟抛出异常\n                }*/\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1,i);\n                pstmt.setString(2, \"员工\" + i);\n                pstmt.setFloat(3, 5000);\n                pstmt.setString(4, \"市场部\");\n                pstmt.executeUpdate();\n            }\n            conn.commit();//当for循环全部完成后，才开始进行提交\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                if (conn!=null&&!conn.isClosed()) {\n                    conn.rollback();//发生异常回滚\n                }\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            DbUtils.closeConnection(null,pstmt,conn);\n        }\n    }\n}\n```\n##  基于实体类实现分页数据封装  \n◇实体类代码\n```sql\n/**\n * 员工实体类\n */\npublic class Employee {\n    /**\n     * 需符合javabean的要求\n     * 1.具备默认构造函数\n     * 2.属性私有\n     * 3.存在getter与setter\n     */\n    public Employee(){}\n    private Integer eno;\n    private String ename;\n    private Float salary;\n    private String dname;\n\n    public Integer getEno() {\n        return eno;\n    }\n\n    public void setEno(Integer eno) {\n        this.eno = eno;\n    }\n\n    public String getEname() {\n        return ename;\n    }\n\n    public void setEname(String ename) {\n        this.ename = ename;\n    }\n\n    public Float getSalary() {\n        return salary;\n    }\n\n    public void setSalary(Float salary) {\n        this.salary = salary;\n    }\n\n    public String getDname() {\n        return dname;\n    }\n\n    public void setDname(String dname) {\n        this.dname = dname;\n    }\n\n}\n```\n◇分页命令代码\n```sql\n/**\n * 分页查询员工数据\n */\npublic class PaginationCommand implements Command {\n    @Override\n    public void execute(){\n        Scanner in = new Scanner(System.in);\n        System.out.println(\"请输入页号：\");\n        int page = in.nextInt();\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        List<Employee> list = new ArrayList();//存储查询结果\n        try {\n            conn = DbUtils.getConnection();\n            String sql = \"select * from employee limit ?,10\";//10代表从？开始往后取10条记录\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1,(page-1)*10);//分页公式\n            rs = pstmt.executeQuery();\n            while (rs.next()){\n                Integer eno = rs.getInt(\"eno\");\n                String ename = rs.getString(\"ename\");\n                Float salary = rs.getFloat(\"salary\");\n                String dname = rs.getString(\"dname\");\n                Employee emp = new Employee();\n                emp.setEno(eno);\n                emp.setEname(ename);\n                emp.setSalary(salary);\n                emp.setDname(dname);\n                list.add(emp);//将emp实体加到list集合中\n            }\n            System.out.println(list.size());\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }finally {\n            DbUtils.closeConnection(rs, pstmt, conn);\n        }\n    }\n}\n```\n##  JDBC中Date日期对象的处理  \n◇实体类中添加日期\n```sql\nprivate Date hiredate;\npublic Date getHiredate() {\n        return hiredate;\n    }\npublic void setHiredata(Date hiredate) {\n        this.hiredate = hiredate;\n    }\n```\n◇分页命令添加日期\n```sql\n//JDBC获取日期使用java.sql.Date,其继承自java.util.Date\n//所以两者互相兼容\nDate hiredata = rs.getDate(\"hiredate\");\n emp.setHiredate(hiredate);\n```\n◇向数据库中写入日期时需要使用java.sql.Date\n```sql\nSystem.out.println(\"请输入入职日期\");\n        String strHiredate = in.next();\n        //String 到java.sql.Date分为两步\n        //1.将String转为java.util.Date\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        java.util.Date udHiredate = null;\n        try {\n             udHiredate = sdf.parse(strHiredate);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        //2.将util转为sql\n        long time = udHiredate.getTime();//获取1970年到现在的毫秒数\n        java.sql.Date sdHiredate = new java.sql.Date(time);\n        \npstmt.setDate(5,sdHiredate);//java.sql.Date\n```\n## JDBC数据批处理\n◇批处理部分代码\n```sql\npstmt = conn.prepareStatement(sql);\n            for(int i=100000;i<200000;i++){\n                pstmt.setInt(1,i);\n                pstmt.setString(2, \"员工\" + i);\n                pstmt.setFloat(3, 5000f);\n                pstmt.setString(4, \"市场部\");\n                pstmt.addBatch();//将参数加入批处理任务\n                //pstmt.executeUpdate();\n            }\n            pstmt.executeBatch();//执行批处理任务\n            conn.commit();//当for循环全部完成后，才开始进行提交\n```\n◇批处理效率高的原因：在标准方法中，创建了十万个prepareStatement对象，每一个对象都是新增一条数据；而在批处理方法中，是用一个对象新增十万条数据；\n## 连接池与JDBC进阶使用\n◇连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用\n### 阿里巴巴Druid连接池  \n◇Druid是阿里巴巴开源连接池组件,是最好的连接池之一 \n◇Druid对数据库连接进行有效管理与重用,最大化程序执行效率 \n◇连接池负责创建管理连接,程序只负责取用与归还  \n![image.png](JDBC入门/1627542621734-d1f41e8f-ec79-4286-910d-86feb455549d.png)\n\n###  Druid连接池配置与使用  \n◇配置.properties文件\n```java\n//不需要引号和分号,将初始尺寸和最大尺寸设为一致可便于维护\ndriverClassName=\nurl=\nusername=\npassword=\ninitialSize=10  //初始尺寸:连接池默认创建10个数据库连接\nmaxActive=20 //最大尺寸:数据库不够用时，创建的最大连接数，还不够用则需等待\n```\n◇使用连接池\n```java\n/**\n * Druid连接池配置与使用\n */\npublic class DruidSample {\n    public static void main(String[] args) {\n        //1.加载属性文件\n        Properties properties = new Properties();\n        //作用：获取当前类(DruidSample)路径下对应文件的路径，因为配置文件会随着代码运行而发布到运行文件夹中\n        String propertyFile = DruidSample.class.getResource(\"/druid-cofig.properties\").getPath();\n        //在上面获取的路径中getPath方法会进行URL编码:空格->%20\n        // 如：原始路径：c:\\java code 转换后的路径：c:\\java%20code;\n        // 使用URLDecoder().decode()方法进行容错，将%20还原为空格\n        try {\n            propertyFile = new URLDecoder().decode(propertyFile, \"UTF-8\");\n            properties.load(new FileInputStream(propertyFile));//加载,load参数为文件流\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        ResultSet rs = null;\n\n        try {\n            //2.获取DataSource数据源对象\n            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//DataSource选择sql\n            //3.创建数据库连接\n            conn = dataSource.getConnection();\n            psmt = conn.prepareStatement(\"select * from employee limit 0,10\");\n            rs = psmt.executeQuery();\n            while (rs.next()) {\n                Integer eno = rs.getInt(1);//获取当前行第一列的数据（数据为int型）,按位置\n                String ename = rs.getString(\"ename\");//获取ename列的数据（数据为String型），按名称\n                Float salary = rs.getFloat(\"salary\");\n                String dname = rs.getString(\"dname\");\n                System.out.println(dname + \"-\" + eno + \"-\" + ename + \"-\" + salary);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            /**\n             * 不使用连接池：conn.close()关闭连接\n             * 使用连接池：conn.close()将连接回收至连接池\n             */\n            DbUtils.closeConnection(rs,psmt,conn);\n        }\n    }\n}\n```\n###  扩展知识:C3P0连接池  \n◇配置文件，使用xml且文件名必须为：c3p0-config.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<c3p0-config>\n    <default-config>\n        <property name=\"driveClass\">com.mysql.cj.jdbc.Driver</property>\n        <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/gamest?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</property>\n        <property name=\"user\">root</property>\n        <property name=\"password\">www.LCG.com</property>\n        <property name=\"initialPoolSize\">10</property>\n        <property name=\"maxPoolSize\">20</property>\n    </default-config>\n</c3p0-config>\n```\n◇使用\n```java\npublic class C3P0Sample {\n    public static void main(String[] args) {\n        //1.加载配置文件\n        //2.创建DataSource\n        DataSource dataSource = new ComboPooledDataSource();\n        //3.得到数据库连接\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        ResultSet rs = null;\n        .....\n    }\n}\n```\n###  Apache Commons DBUtils  \n◇commons-dbutils是Apache提供的开源JDBC工具类库 \n◇它是对JDBC的简单封装,学习成本极低 \n◇使用commons-dbutils可以极大简化JDBC编码工作量  \n```java\n/**\n * Apache DBUtils + Druid联合使用\n */\npublic class DbUtilsSample {\n    private static void query(){\n        Properties properties = new Properties();\n        String propertyFile = \n            DruidSample.class.getResource(\"/druid-config.properties\").getPath();\n        try {\n            propertyFile = new URLDecoder().decode(propertyFile, \"UTF-8\");\n            properties.load(new FileInputStream(propertyFile));\n            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n            //利用Apache DbUtils大幅简化了数据的提取过程\n            /**\n             * BeanListHandler将结果集包装成list对象\n             * Object[]{1}用来传递参数，这里表示？=1\n             */\n            QueryRunner qr = new QueryRunner(dataSource);\n            List<Employee> list =  qr.query(\"select * from employee limit ?,10\",\n                    new BeanListHandler<>(Employee.class),\n                    new Object[]{1});\n            for (Employee emp : list) {\n                System.out.println(emp.getEname()+\"--\"+emp.getSalary());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }//自动关闭数据库连接\n    }\n\n    public static void update(){\n        Properties properties = new Properties();\n        String propertyFile = \n            DruidSample.class.getResource(\"/druid-config.properties\").getPath();\n        Connection conn = null;\n        try {\n            propertyFile = new URLDecoder().decode(propertyFile, \"UTF-8\");\n            properties.load(new FileInputStream(propertyFile));\n            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n            conn = dataSource.getConnection();//创建连接\n            conn.setAutoCommit(false);//关闭自动提交\n            String sql1 = \"update employee set salary=salary+10000 where eno=?\";\n            String sql2 = \"update employee set salary=salary-1000 where eno=?\";\n            QueryRunner qr = new QueryRunner();\n            qr.update(conn,sql1,new Object[]{1});\n            qr.update(conn, sql2, new Object[]{100});\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                if (conn!=null&&!conn.isClosed()){\n                    conn.rollback();\n                }\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        }finally {\n            try {\n                if(conn!=null&&!conn.isClosed()){\n                    conn.close();//对数据库连接进行回收，前面手动创建了连接\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) {\n        query();\n        //update();\n    }\n}\n```\n\n","tags":["数据库"],"categories":["Java数据库","Java数据库开发基础"]},{"title":"IDEA开发工具入门","url":"/p/5708.html","content":"## 导学\n◇IntelliJ IDEA开发工具\n![image.png](IntelliJ IDEA开发工具入门/1627031307362-df459f62-a437-412b-98d4-032af338ced4.png)\n◇JDBC\n![image.png](IntelliJ IDEA开发工具入门/1627031379177-38c40c23-926b-4f28-b27e-d9b05895bdf0.png)\n\n◇数据库连接池与DBUtils\n![image.png](IntelliJ IDEA开发工具入门/1627031423402-2d5357f4-8868-460e-bdf3-e131bba797d5.png)\n\n## IDEA开发工具入门\n### IntelliJ IDEA\n◇IDEA全称IntelliJ IDEA ,是Java编程公认的最好的IDE\n◇IDEA提供了大量的智能工具，例如语法提示，代码分析，格式化等\n◇IDEA最核心的特色是它的快捷键，利用快捷键可以极大提高开发效率\n### IDEA的特点\n◇沉浸式开发体验\n◇超强的快捷键体系\n◇智能的代码助手\n◇全栈开发环境\n◇丰富的模板支持\n## IDEA快捷键\n### IDEA窗口快捷键\n◇Find Action即模糊查询所有的功能\n![image.png](IntelliJ IDEA开发工具入门/1627034483641-291f75af-d7ad-48a5-a4d5-fd4466b7a384.png)\n\n\n### 代码快捷键\n![image.png](IntelliJ IDEA开发工具入门/1627035810111-7868b20d-b5b8-44c3-b520-f7fe08cb09e9.png)\n![image.png](IntelliJ IDEA开发工具入门/1627035825273-6cfd6292-c04a-4cfa-ac9a-38797269ca46.png)\n\n### 代码快速定位\n![image.png](IntelliJ IDEA开发工具入门/1627045126097-c1703455-f245-4358-b636-0bebf19ac62e.png)\n### Live Template\n◇也可以自定义，自定义方法为：settings->Editor->Live Template->'+' 2->'+'1;\n​\n\n![image.png](IntelliJ IDEA开发工具入门/1627045672656-22d16bcf-8e69-4516-9915-68c68efec231.png)\n### 运行与打包\n◇打包方法：File->Project Structure->Artifacts->'+' ->JAR->empty->Create Manifest(定义入口类)->默认选中->OK->选择入口类->将右侧的compile output双击添加到左侧(即将编译后的类打入JAR包)->OK->.MF文件创建成功->Build->Build Artifacts ->Action:Bulid->生成jar包\n在生成的jar包上右键选中Open in File path( Show in explore在文件管理器中打开)->在地址栏中删掉地址然后直接输入cmd进入命令行(会自动定位到目录地址)->键入java -jar 文件名.jar\n![image.png](IntelliJ IDEA开发工具入门/1627046432804-188ee97a-c21c-4cd5-b9b4-fa4f47c59270.png)\n\n### 其他快捷键\n◇查看方法返回类型：Ctrl+q\n◇查看方法的具体实现：Ctrl+Alt\n◇方法或类注释：在一个方法或类的开头，输入/**，然后按回车,自动根据参数和返回值生成注释模板\n## IDEA开发Web应用\n◇NewProjece-> Java Enterprise ->服务器选择Tomcat ->勾选WebApplication 3.1->勾选create web.xml->Next->输入工程名称->finish;\n◇如何更改URL的上下文路径: 点击Tomcat下拉框->Edit Configurations ->Deployment->Application context->修改->OK\n◇热部署(即修改项目后在浏览器能直接查看，只支持在DeBug模式下)：点击Tomcat下拉框->Edit Configurations ->Server->On frame deactivation->Update classes and resources->OK \n◇打包Web项目：File->Project Structure->Artifacts->'+'Web Application:Archive->Empty->双击compile output添加到左侧war包中->双击Web facet resource将静态资源放入左侧->OK->Build->Build Artifact ->选择打包文件->Build ->复制.war文件将其放到Tomcat实际运行环境的webapps目录下->在Tomcat/bin目录中双击startup.bat文件启动Tomcat->浏览器输入路径即可\n![image.png](IntelliJ IDEA开发工具入门/1627096260390-f697c0eb-8644-4516-bc22-fa9ba432d2e0.png)\n","tags":["开发"],"categories":["Java数据库","Java数据库开发基础"]},{"title":"MySQL综合应用","url":"/p/c9e2.html","content":"##  数据库的事务机制  \n###  避免写入直接操作数据文件  \n ◇ 如果数据的写入直接操作数据文件是非常危险的事情  \n![image.png](MySQL综合应用/1626917790269-93acb2ad-63b6-4dd4-be0c-2e9fc2a0efb0.png)\n\n###  利用日志来实现间接写入  \n◇ MySQL总共有5种日志，其中只有redo(重做)日志和undo(撤销)日志与事务有关  \n![image.png](MySQL综合应用/1626917898437-0ccbca8d-0d06-4df1-a5bc-55e18b880fe0.png)\n\n###  事务机制（Transaction）  \n◇ RDBMS = SQL语句 + 事务（ACID）  \n◇ 事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要 么全都执行失败  \n###  事务案例  \n◇ 把10部门中MANGER员工调往20部门，其他岗位的员工调往30部门，然后删除10部门  \n![image.png](MySQL综合应用/1626917996276-921161a2-38af-41f5-ae65-e38647751e68.png)\n\n###  管理事务  \n◇ 默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务  \n◇ 为了让多条SQL语句纳入到一个事务之下，可以手动管理事务  \n```sql\nSTART TRANSACTION ;//开启事务\nSQL语句\n[ COMMIT | ROLLBACK ] ;//提交|回滚\n```\n###  事务的ACID属性  \n![image.png](MySQL综合应用/1626918119445-1a0602c1-e9b0-4847-bfce-dcefc14db76d.png)\n####  事务的原子性  \n◇ 一个事务中的所有操作要么全部完成，要么全部失败。事务执行后 ，不允许停留在中间某个状态  \n####  事务的一致性  \n◇ 不管在任何给定的时间、并发事务有多少，事务必须保证运行结果 的一致性  \n◇ 事务可以并发执行，但是最终MySQL却串行执行  \n![image.png](MySQL综合应用/1626918183199-9912d76a-7d0f-43f0-b79e-3a527aa25551.png)\n\n####  事务的隔离性\n◇ 隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务是数据库唯一运行的事物  \n◇ 默认情况下A事务，只能看到日志中该事务的相关数据  \n![image.png](MySQL综合应用/1626918249811-8534a704-899e-49cb-9c39-01d8f26737fc.png)\n\n####  事务的持久性  \n ◇事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化  \n###  事务的四个隔离级别  \n![image.png](MySQL综合应用/1626918389326-5eab4721-6bd8-43a0-bf2e-6a779663c28e.png)\n###  修改事务隔离级别  \n◇在Navicat中开启两个sql面板可以模拟两个不同的事务；Mysql默认的隔离级别是REPEATABLE READ\n◇ READ UNCOMMITTED 代表可以读取其他事务未提交的数据  \n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL \nREAD UNCOMMITTED;\n```\n◇ READ COMMITTED 代表只能读取其他事务提交的数据  \n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL \nREAD COMMITTED;\n```\n◇ REPEATABLE READ 代表事务在执行中反复读取数据，得到的结果是一致的，不会受其他事务影响  \n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL \nREPEATABLE READ;\n```\n###  业务案例  \n①比如说购票场景里面，由于事务之间是隔离的，所以A、B两事务分别对第一条记录进行操作；A事务修改将其改为已售出，但是A事务未进行提交，因此真实的数据还是未售出状态；B事务将其改为已售出，并且很快进行提交；那么当A进行提交时，发现记录变成了已售出，就会发生回滚，即修改失败；虽然说没有产生有歧义的数据，但是动不动就购票失败，十分影响用户体验；因此在这个场景下我们应当允许事务去读取其他事务的临时状态；B事务可以看到A事务里的临时信息，即修改了第一条记录，但未提交；那么B就无法修改此记录；就不会引发数据冲突了；所以这里使用的隔离级别为:READ UNCOMMITTED\n![image.png](MySQL综合应用/1626918423470-5ed66a73-33cf-4fd7-8082-cdefb265ee8a.png)\n②对于银行转账之类的业务场景；就只能让当前事务去读取其他事务已经提交的数据，而不能够去读取其他事务的临时数据;比如说下面的Scott账户，假设B事务执行，需要支出100元，但是还没有提交；而这时A事务进行转账操作，由于可以看到B事务的临时数据，所以A事务看到Scott账户为4900元，提交后，账户变为5900元；但如果B事务由于某些原因回滚的话，原来的操作无效；而此时账户余额却是4900元，凭空少了100元；因此这种场景必须使用READ COMMITTED隔离级别；\n![image.png](MySQL综合应用/1626918537468-9c083613-aa6e-4b96-9e6a-3cb7625db4f6.png)\n③又如，A事务进行某商品的下单购票后未提交事务，但是B事务确将商品价格提高了；那么此时A事务应该根据原价购买；所以隔离级别使用REPEATABLE READ；即不受其他任何事务的影响，无论其他事务提交与否；\n![image.png](MySQL综合应用/1626918633199-35ba965c-25a8-41b6-b280-3a59d1b6d4ee.png)\n\n###  事务的序列化  \n◇ 由于事务并发执行所带来的各种问题，前三种隔离级别只适用在某些业务场景中，但是序列化的隔离性，只有前面的会话结束后(事务提交后)才能执行下一个事务，即让事务逐一执行，不能够并发地执行事务；但是这样会大大降低数据库的并发能力，所以不太常用；  \n```sql\nSET SESSION TRANSACTION ISOLATION LEVEL\nSERIALIZABLE;\n```\n##  数据导入与导出  \n### 数据导出与备份的区别 \n◇ 数据导出，导出的纯粹是业务数据  \n◇ 数据备份，备份的是数据文件、日志文件、索引文件等等  \n![image.png](MySQL综合应用/1626918828306-0b54f018-06c6-4391-8539-16724d411448.png)\n\n###  数据导出的分类  \n![image.png](MySQL综合应用/1626918863615-44b06718-5e90-4bbd-99c0-489bbc76cba0.png)\n###  导出SQL文件  \n◇ mysqldump用来把业务数据导出成SQL文件，其中也包括了表结构  \n```sql\nmysqldump -uroot -p [ no-data ] 逻辑库 > 路径\n```\n◇ 如果业务数据非常多，建议只导出表结构，然后用SELECT INTO OUTFILE把数据导出成文本文档  \n###  导入SQL文件  \n◇ source命令用于导入SQL文件，包括创建数据表，写入记录等  \n```sql\nsql > USE demo ;\nsql > SOURCE backup.sql ;\n```\n\n","tags":["MySQL"],"categories":["Java数据库","MySQL基础"]},{"title":"MySQL基本函数","url":"/p/8500.html","content":"##  MySQL的函数  \n ◇像编程语言利用函数封装业务功能一样，数据库也把一些复杂的功能封装到函数里，供使用者调用  \n ◇也可以自定义函数\n![image.png](MySQL基本函数/1626744661345-6111ef9d-04c3-4761-b727-9ae5c97863f8.png)\n\n## 数字函数  \n###  数字函数（一）  \n![image.png](MySQL基本函数/1626744703126-a396cd11-c086-4a87-b1b4-6312391ae480.png)\n###  数字函数（二）  \n◇三角函数的参数为弧度\n![image.png](MySQL基本函数/1626744716967-68f7ed15-b497-4b9e-9f62-1c2445dbe9ec.png)\n\n## 日期函数\n###  获取系统时间函数  \n◇NOW()函数能获得系统日期和时间，格式yyyy-MM-dd hh:mm:ss \n◇CURDATE()函数能获得当前系统日期，格式yyyy-MM-dd \n◇CURTIME()函数能获得当前系统时间，格式hh:mm:ss  \n###  日期格式化函数  \n![image.png](MySQL基本函数/1626752210323-8c7cf93e-cd79-462d-8331-0f275fd02f86.png)\n◇ DATE_FORMAT()函数用于格式化日期，返回用户想要的日期格式  \n\n```sql\nDATE_FORMAT( 日期, 表达式)\nSELECT ename,DATE_FORMAT(hiredate,\"%Y\")//获取年份的格式\nDATE_FORMAT(hiredate,\"%Y/%m%d\") //返回2021/07/20这种格式\nFROM t_emp;\n```\n###  日期计算的注意事项  \n◇ MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减  \n###  日期偏移计算 \n ◇ DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活  \n```sql\nDATE_ADD( 日期 , INTERVAL 偏移量 时间单位 )\n\nSELECT DATE_ADD(NOW(),INTERVAL 15 DAY);\nSELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE);\n```\n###  计算日期之间相隔的天数  \n◇ DATEDIFF()函数用来计算两个日期之间相差的天数  \n```sql\nDATEDIFF ( 日期 , 日期 )\n```\n###  课堂练习  \n◇ 利用日期函数，查询明年你的生日是星期几？  \n```sql\nSELECT DATE_FORMAT(\"2020-02-19\",\"%w\")\n```\n◇ 利用日期函数，查询1981年上半年入职的员工有多少人？  \n```sql\nSELECT COUNT(*) FROM t_emp\nWHERE DATE_FORMAT(hiredate,\"%Y\")=1981\nAND DATE_FORMAT(hiredate,\"%m\")<=6;\n```\n## 字符函数\n###  字符函数（一）  \n◇INSERT(\"ABC\",1,0,\"DE\")数字1表示从前面的字符串ABC的第一个位置插入后面的字符串DE，0表示替换从插入位置起的0个字符；\n◇REPLACE() 的第二个参数表示被替换的内容，最后一个参数表示替换的内容\n![image.png](MySQL基本函数/1626744868617-349e75c7-1c16-4cd4-bf54-b7ed9fab0132.png)\n\n###  字符函数（二）  \n◇截取字符串起始位置从1开始\n◇填充字符函数第二个参数表示填充到多少字符，而不是填充多少字符；\n![image.png](MySQL基本函数/1626744883419-428def08-c61f-4a7c-b422-7e6c5ecd35fa.png)\n\n### 课堂练习\n◇将某人的姓名的名用*替代  eg: 欧**\n```sql\nSELECT RPAD(SUBSTRING(\"欧宝玉\",1,1),LENGTH(\"欧宝玉\")/3,\"*\");\n```\n## 条件函数\n◇ SQL语句中可以利用条件函数来实现编程语言里的条件判断  \n```sql\nIFNULL( 表达式 , 值 )\nIF( 表达式 , 值1 , 值2 )//如果满足表达式则是值1，否则是值2\n```\n###  条件语句  \n ◇ 复杂的条件判断可以用条件语句来实现，比IF语句功能更强大  \n```sql\nCASE\nWHEN 表达式 THEN 值1 ,\nWHEN 表达式 THEN 值2 , …… , ELSE 值N\nEND\n```\n### 课堂练习  \n◇ 中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B， 打印每名员工获得的礼品。  \n```sql\nSELECT FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno,\nIF(d.dname=\"SALES\",\"礼品A\",\"礼品B\")\nFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno;\n```\n◇ 公司年庆决定组织员工集体旅游，每个部门旅游目的地是不同的。SALES部门去P1地点，ACCOUNTING部门去P2地点 ，RESEARCH部门去P3地点，查询每名员工的旅行地点。  \n```sql\nSELECT \n e.empno,e.ename,\n CASE \n WHEN d.dname=\"SALES\" THEN \"P1\"\n WHEN d.dname=\"ACCOUNTING\" THEN \"P2\"\n WHEN d.dname=\"RESEARCH\" THEN \"P3\"\n END \n AS place\nFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno\n```\n◇ 公司决定为员工调整基本工资，具体调整方案如下：  \n![image.png](MySQL基本函数/1626790167145-a52425b0-80f5-499c-9547-8e4307a1d314.png)\n\n```sql\nUPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno\nLEFT JOIN (SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) t\nON e.deptno=t.deptno\nSET sal=(\nCASE \n  WHEN d.dname=\"SALES\" AND DATEDIFF(NOW(),e.hiredate)/365>=20\n  THEN e.sal*1.1\n  WHEN d.dname=\"SALES\" AND DATEDIFF(NOW(),e.hiredate)/365<20\n  THEN e.sal*1.05\n  WHEN d.dname=\"ACCOUNTING\"  THEN e.sal+300\n  WHEN d.dname=\"RESEARCH\" AND e.sal<t.avg THEN e.sal+200\n  WHEN e.deptno IS NULL THEN e.sal+100\n  END\n);\n```\n\n","tags":["MySQL"],"categories":["Java数据库","MySQL基础"]},{"title":"MySQL基本操作","url":"/p/a881.html","content":"##  数据操作语言：INSERT语句  \n###  INSERT语句  \n ◇ INSERT语句可以向数据表写入记录，可以是一条记录，也可以是多条记录  \n```sql\nINSERT INTO 表名 ( 字段1, 字段2, …… ) \nVALUES ( 值1, 值2, …… ) ;\nINSERT INTO 表名 ( 字段1, 字段2, …… ) \nVALUES ( 值1, 值2, …… ) , ( 值1, 值2, …… ) ;//插入多条记录\n```\n###  INSERT语句方言  \n ◇ MYSQL的INSERT语句还有一种方言语法  \n```sql\nINSERT INTO 表名 SET 字段1=值1, 字段2=值2, …… ;\n```\n###  IGNORE关键字  \n ◇ IGNORE关键字会让INSERT只插入数据库不存在的记录  \n```sql\nINSERT [ IGNORE ] INTO 表名 …… ;\n```\n###  INSERT中的子查询  \n◇ INSERT语句中可以包含子查询语句，代表把子查询的内容写入到数据表 \n◇ 把人数超过5人的部门记录拷贝到新的部门表  \n```sql\nCREATE TABLE t_dept_new LIKE t_dept;\nINSERT INTO t_dept_new(deptno,dname,loc)\n(SELECT d.deptno,d.dname,d.loc FROM t_dept d JOIN\n(SELECT deptno FROM t_emp GROUP BY deptno\nHAVING COUNT(*)>=5) temp\nON d.deptno = temp.deptno\n);\n```\n##  数据操作语言：UPDATE语句  \n###  UPDATE语句  \n- ◇ UPDATE语句用于修改表的记录  \n```sql\n//\"IGNORE\"关键字在UPDATE语句中表示忽略修改数据时遇到冲突的记录，把不冲突的记录写到数据表里\nUPDATE [ IGNORE ] 表名\nSET 字段1=值1, 字段2=值2, ……\n[ WHERE 条件1, 条件2, …… ] \n[ ORDER BY …… ] //排序，如果需要将员工编号+1的话，可以先进行降序否则可能引发主键冲突\n[ LIMIT …… ] //取分页数据\n```\n###  UPDATE语句的表连接  \n ◇ 因为WHERE子句中的子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句  \n```sql\nUPDATE 表1 JOIN 表2 ON 条件\nSET 字段1 = 值1 , 字段2 = 值2 , …… ;\n```\n ◇ 表连接的UPDATE语句可以修改多张表的记录  \n ◇ UPDATE语句的表连接可以演变成下面的样子  \n```sql\nUPDATE 表1 , 表2\nSET 字段1 = 值1 , 字段2 = 值2 , ……\nWHERE 连接条件 ;\n```\n ◇ UPDATE语句的表连接既可以是内连接，又可以是外连接 \n```sql\nUPDATE 表1 [ LEFT | RIGHT ] JOIN 表2 ON 条件\nSET 字段1 = 值1 , 字段2 = 值2 , …… ;\n```\n ◇ 把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门  \n```sql\nUPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno\nSET e.deptno=20\nWHERE e.deptno IS NULL OR (d.dname=\"SALES\" AND e.sal<2000);\n```\n###  课堂练习  \n ◇ 把每个员工的编号和上司的编号+1，用ORDER BY子句完成 \n```sql\nUPDATE t_emp SET empno=empno+1,mgr=mgr+1\nORDER BY empno DESC\n```\n ◇ 把月收入前三名的员工底薪减100元，用LIMIT子句完成  \n```sql\nUPDATE t_emp SET sal=sal-100\nORDER BY sal+IFNULL(comm,0) DESC\nLIMIT 3;\n```\n ◇ 把ALLEN调往RESEARCH部门，职务调整为ANALYST  //牵扯到两张表\n```sql\n//这里不能写连接条件(ON e.deptno=d.deptno)，因为会将A锁定到R部门\nUPDATE t_emp e JOIN t_dept d \nSET e.deptno=d.deptno,e.job=\"ANALYST\"\nWHERE e.ename=\"ALLEN\" AND d.dname=\"RESEARCH\"\n```\n ◇ 把底薪低于公司平均底薪的员工，底薪增加150元  \n```sql\nUPDATE t_emp e JOIN\n(SELECT AVG(sal) AS avg FROM t_emp) t//子查询结果集\nON e.sal<t.avg\nSET e.sal=e.sal+150;\n```\n##  数据操作语言：DELETE语句  \n###  DELETE语句  \n ◇ DELETE语句用于删除记录，语法如下：  \n```sql\nDELETE [ IGNORE ] FROM 表名//IGNORE:能删则删，不能删则忽略，不会报错\n[ WHERE 条件1, 条件2, …… ]\n[ ORDER BY …… ] \n[ LIMIT …… ] ;\n```\n###  DELETE语句的表连接  \n ◇ 因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造DELETE语句  \n```sql\nDELETE 表1 , …… FROM 表1 JOIN 表2 ON 条件\n[ WHERE 条件1 , 条件2 , …… ] \n[ ORDER BY …… ] \n[ LIMIT …… ] ;\n```\n ◇ DELETE语句的表连接既可以是内连接，又可以是外连接  \n```sql\nDELETE 表1 , …… FROM 表1 [ LEFT | RIGHT ] JOIN 表2 \nON 条件 …… ;\n```\n ◇ 删除SALES部门的员工，以及没有部门的员工。  \n```sql\nDELETE e\nFROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno\nWHERE d.dneme=\"SALES\" OR e.deptno IS NULL\n```\n###  快速删除数据表全部记录  \n ◇ DELETE语句是在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里，然后再删除记录。 \n◇ TRUNCATE语句在事务机制之外删除记录，速度远超过DELETE语句  \n```sql\nTRUNCATE TABLE 表名 ;\n```\n###  课堂练习  \n ◇ 删除10部门中，工龄超过20年的员工记录 \n```sql\nDELETE FROM t_emp\nWHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365\n```\n◇ 删除20部门中工资最高的员工记录  \n```sql\nDELETE FROM t_emp\nWHERE deptno=20\nORDER BY sal+IFNULL(comm,0) DESC\nLIMIT 1;\n```\n◇ 删除SALES部门和该部门的全部员工记录 \n```sql\nDELETE e,d\nFROM t_emp e JOIN t_dept d ON e.deptno=d.deptno\nWHERE d.dname=\"SALES\";\n```\n◇ 删除每个低于部门平均底薪的员工记录  \n```sql\nDELETE e\nFROM t_emp e JOIN \n(SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY deptno) t\nON e.deptno = t.deptno AND e.sal<t.avg\n```\n ◇ 删除员工KING和他的直接下属的员工记录，用表连接实现。  \n```sql\nDELETE e\nFROM t_emp e JOIN \n(SELECT empno FROM t_emp WHERE ename=\"KING\") t//结果集里的数据不能删\nON e.mgr=t.empno OR e.empno=t.empno;\n```\n\n","tags":["MySQL"],"categories":["Java数据库","MySQL基础"]},{"title":"SQL简介","url":"/p/a804.html","content":"## 学习目标\n◇ 管理逻辑库和数据表\n   - 创建、删除、修改逻辑库和数据表  \n◇ 了解常用的数据类型和约束  \n   - 字符串、整数、浮点数、精确数字、日期、枚举。主键约束、非空 约束、唯一约束、外键约束等  \n◇ 掌握索引运行机制和使用原则  \n   - 排序为什么可以提高数据检索速度？怎么创建和删除索引？什么条 件下使用索引？  \n##  什么是SQL语言 ？\n◇ SQL 是用于访问和处理数据的标准的计算机语言  \n![image.png](SQL简介/1625838154950-b6a31bc1-f93a-4483-a4bc-a7499a1c4669.png)\n\n###  SQL语言分类  \n![image.png](SQL简介/1625838195563-598330f3-eee6-49ab-b74d-d55f33493ae0.png)\n###  SQL语句注意事项  \n◇ SQL语句不区分大小写，但是字符串区分大小写  \n◇ SQL语句必须以分号结尾  \n◇ SQL语句中的空白和换行没有限制，但是不能破坏语法 \n###  SQL语句的注释   \n◇ SQL语句的注释有两种，分别如下：  \n #这是一段注释\n/*这是另一段注释*/\n##  创建逻辑库  \n![image.png](SQL简介/1625838421553-d4761883-6cd5-47ea-bed3-1e2d07e73537.png)\n##  创建数据表  \n```sql\nCREATE TABLE 数据表 (\n列名1 数据类型 [ 约束 ] [COMMENT 注释] ,\n列名2 数据类型 [ 约束 ] [COMMENT 注释] , ……\n) [ COMMENT = 注释 ] ;\nDROP TABLE 数据表 ;\n```\n```sql\nCREATE TABLE student (\nid INT UNSIGNED PRIMARY KEY ,\nname VARCHAR(20) NOT NULL , sex CHAR(1) NOT NULL ,\nbirthday DATE NOT NULL ,\ntel CHAR(11) NOT NULL ,\nremark VARCHAR(200)\n);\n```\n##  数据表的其他操作  \n```sql\nSHOW tables ;\nDESC student ;   //查看表的结构\nSHOW CREATE TABLE student ;\nDROP TABLE student ;\n```\n##  数据定义语言：数据类型  \n###  数据类型：数字  \n◇DECIMAL相当于用字符来保存数字，所以不存在精度的丢失；参数10表示整数+小数为十位\n参数2表示精确到小数点后两位\n![image.png](SQL简介/1625838928851-acc12aba-1b8a-47cd-a43b-7bb022a49641.png)\n\n###  不精确的浮点数  \n◇ 十进制的浮点数无法在计算机中用二进制精确表达  \n![image.png](SQL简介/1625838986936-842b2ae4-572c-4618-949b-d0874d60b79f.png)\n\n###  数据类型：字符串  \n![image.png](SQL简介/1625839086946-6c97c58c-0b4d-4c4a-9314-535803a59c73.png)\n###  数据类型：日期类型  \n![image.png](SQL简介/1625839693685-beccf98c-d86a-49ae-ba12-ad38022c6eb1.png)\n##  数据定义语言：修改表结构  \n###  添加字段  \n```sql\nALTER TABLE 表名称\nADD 列1 数据类型 [ 约束 ] [COMMENT 注释] , ADD 列2 数据类型 [ 约束 ] [COMMENT 注释] ,\n…… ;\n```\n###  修改字段类型和约束  \n```sql\nALTER TABLE 表名称\nMODIFY 列1 数据类型 [ 约束 ] [COMMENT 注释] , MODIFY 列2 数据类型 [ 约束 ] [COMMENT 注释] ,\n…… ;\n```\n###  修改字段名称  \n```sql\nALTER TABLE 表名称\nCHANGE 列1 新列名1 数据类型 [ 约束 ] [COMMENT 注释] ,\nCHANGE 列2 新列名2 数据类型 [ 约束 ] [COMMENT 注释] ,\n…… ;\n```\n###  删除字段  \n```sql\nALTER TABLE 表名称\nDROP 列1 ,\nDROP 列2 ，\n…… ;\n```\n###  修改表名  \n```sql\nALTER TABLE 表名 RENAME 新表名 \n```\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库的高级查询","url":"/p/1648.html","content":"##  数据操作语言：聚合函数  \n###  什么是聚合函数 \n◇ 聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对数 据求和、求最大值和最小值、求平均值等等。 \n◇ 求公司员工的平均月收入是多少？  \n\n```sql\nSELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;\n```\n### SUM函数  \n ◇ SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0 ，日期类型统计结果是毫秒数相加  \n ◇ SUM函数求和会排除NULL值  \n\n### MAX函数\n ◇ MAX函数用于获得非空值的最大值。  \n ◇ 问题1：查询10和20部门中，月收入最高的员工？  \n```sql\nSELECT MAX(sal+IFNULL(comm,0)) FROM t_emp\nWHERE deptno IN(10,20);\n```\n ◇ 问题2：查询员工名字最长的是几个字符？  \n```sql\nSELECT MAX(LENGTH(ename)) FROM t_emp;\n```\n### MIN函数  \n ◇ MIN函数用于获得非空值的最小值。  \n### AVG函数  \n ◇ AVG函数用于获得非空值的平均值，非数字数据统计结果为0  \n### COUNT函数  \n ◇ COUNT(*)用于获得包含空值的记录数，COUNT(列名)用于获得包 含非空值的记录数。  \n ◇ 查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数？  \n```sql\nSELECT COUNT(*) FROM t_emp\nWHERE deptno IN(10,20) AND sal>=2000\nAND DATEDIFF(NOW(),hiredate)/365>=15; //DATEDIFF指相差的天数\n```\n ◇ 查询1985年以后入职的员工，底薪超过公司平均底薪的员工数量？  \n```sql\nSELECT COUNT(*) FROM t_emp\nWHERE hiredate>=\"1985-01-01\"\nAND sal>AVG(sal);//WHERE 子句不能有聚合函数，这里是错误的？\n```\n##  数据操作语言：分组查询  \n### 为什么要分组？  \n ◇ 默认情况下汇总函数是对全表范围内的数据做统计 \n ◇ GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干 个小的区域，然后针对每个小区域分别进行数据汇总处理  \n### 逐级分组  \n ◇ 数据库支持多列分组条件，执行的时候逐级分组。 \n ◇ 查询每个部门里，每种职位的人员数量和平均底薪  \n### 对SELECT子句的要求  \n ◇ 查询语句中如果含有GROUP BY子句，那么SELECT子句中的内容就 必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在SELECT子句中  \n如下sql语句就是错误的：\n```sql\nSELECT deptno,COUNT(*),AVG(sal),sal //sal字段并不是GROUP BY子句的分组列\nFROM t_emp GROUP BY deptno;\n```\n### 对分组结果集再次做汇总计算  \n```sql\nSELECT deptno,COUNT(*),AVG(sal),MAX(sal),MIN(sal)\nFROM t_emp GROUP BY deptno WITH ROLLUP;\n```\n### GROUP_CONCAT函数  \n ◇ GROUP_CONCAT函数可以把分组查询中的某个字段拼接成一个字符串\n ◇ 查询每个部门内底薪超过2000元的人数和员工姓名    \n```sql\nSELECT deptno,GROUP_CONCAT(ename),COUNT(*)\nFROM t_emp WHERE sal>=2000\nGROUP BY deptno;\n```\n### 各种子句的执行顺序  \n ◇ 查询语句中，GROUP BY子句应该第几个执行？ \nFROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY -> LIMIT  \n## 数据操作语言：HAVING子句  \n###  分组查询遇到的困难？  \n ◇ 查询部门平均底薪超过2000元的部门编号  \n ◇ 因为WHERE子句先于GROUP BY执行，一旦WHERE子句中出现了 汇总函数，数据库根本不知道按照什么范围计算汇总值  \n###  HAVING子句的用途  \n ◇ 可以将聚集函数写在HAVING子句中\n ◇ 查询每个部门中，1982年以后入职的员工超过2个人的部门编号  \n```sql\nSELECT deptno FROM t_emp\nWHERE hiredate>=\"1982-01-01\"\nGROUP BY deptno HAVING COUNT(*)>=2;\nORDER BY deptno ASC\n```\n###  HAVING子句的特殊用法  \n ◇ 按照数字1分组，MySQL会依据SELECT子句中的列进行分组， HAVING子句也可以正常使用  \n```sql\nSELECT deptno,COUNT(*), FROM t_emp\nGROUP BY 1;\n\nSELECT deptno,COUNT(*), FROM t_emp\nGROUP BY 1 HAVING deptno IN (10,20);\n```\n##  数据操作语言：表连接查询  \n###  从多张表中提取数据  \n ◇ 从多张表中提取数据，必须指定关联的条件。如果不定义关联条件 就会出现无条件连接，两张表的数据会交叉连接，产生笛卡尔积。\n![image.png](数据库的高级查询/1626527536343-fe29719d-f14e-4f1f-b2dd-0b875407529f.png) \n ◇ 规定了连接条件的表连接语句，就不会出现笛卡尔积  \n![image.png](数据库的高级查询/1626527554966-ef6bd0c6-0869-473a-807a-aaf8bb2b0479.png)\n\n###  表连接的分类  \n ◇ 表连接分为两种：内连接和外连接 \n ◇ 内连接是结果集中只保留符合连接条件的记录 \n ◇ 外连接是不管符不符合连接条件，记录都要保留在结果集中  \n###  内连接的简介  \n ◇ 内连接是最常见的一种表连接，用于查询多张关系表符合连接条件 的记录。INNER关键字可省略\n![image.png](数据库的高级查询/1626527706776-ea571078-3649-4f98-8763-458cf7d9bea1.png)\n\n###  内连接的多种语法形式  \n```sql\nSELECT …… FROM 表1 JOIN 表2 ON 连接条件 ;\nSELECT …… FROM 表1 JOIN 表2 WHERE 连接条件 ;\nSELECT …… FROM 表1 , 表2 WHERE 连接条件 ;//常用\n```\n###  内连接练习  \n ◇ 查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级？ \n```sql\nSELECT e.empno,e.ename,d.deptno,e.sal,e.job,s.grade\nFROM t_emp e,t_dept d,t_salgrade s \nWHERE e.deptno=d.deptno AND e.sal BETWEEN s.losal AND s.hisal;\n```\n ◇ 内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以  \n ◇ 相同的数据表也可以做表连接  \n ◇ 结果集也可以作为一张“表”来跟其他表连接  \n###  为什么要使用外连接  \n ◇ 如果说陈浩是一名临时人员，没有固定的部门编制，那么我们想查询每名员工和他的部门名称，用内连接就会漏掉陈浩，所以要引入外连接的语法才能解决这个问题  \n![image.png](数据库的高级查询/1626529078875-5839b367-ab6b-4302-adab-a26f1cb433cf.png)\n\n###  外连接简介  \n ◇ 外连接与内连接的区别在于，除了符合条件的记录之外，结果集中 还会保留不符合条件的记录。  \n![image.png](数据库的高级查询/1626579588053-e5d55de3-cb32-46d2-a9b3-aac5f56aee42.png)\n\n###  左连接和右连接  \n ◇ 左外连接就是保留左表所有的记录，与右表做连接。如果右表有符 合条件的记录就与左表连接。如果右表没有符合条件的记录，就用 NULL与左表连接。右外连接也是如此。  \n###  外连接练习  \n ◇ 查询每个部门的名称和部门的人数？  \n```sql\nSELECT  d.dname,COUNT(e.deptno)//忽略右表(t_emp)的NULL记录\nFROM  t_dept d LEFT JOIN t_emp e //保留左表(t_dept)的所有记录\nON d.deptno=e.deptno\nGROUP BY d.deptno;\n```\n◇结果：\n![image.png](数据库的高级查询/1626621372904-af26d4c8-739c-4c3f-9e1c-cae69f7cc554.png)\n ◇ 查询每个部门的名称和部门的人数？如果没有部门的员工，部门名称用NULL代替。  \n\n```sql\n(SELECT  d.dname,COUNT(e.deptno)\nFROM  t_dept d LEFT JOIN t_emp e \nON d.deptno=e.deptno\nGROUP BY d.deptno )  \n    UNION //使用UNION关键字进行左外连接和右外连接的合并\n(SELECT  d.dname,COUNT(*) //保留所有有效记录\nFROM  t_dept d RIGHT JOIN t_emp e \nON d.deptno=e.deptno\nGROUP BY d.deptno )\n```\n◇结果：\n![image.png](数据库的高级查询/1626621411537-c2ca9e43-f9fc-43e4-8616-a7eff4e887a1.png)\n ◇ 查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司 编号、上司姓名、上司部门？  \n\n```sql\nSELECT e1.empno AS '编号',e1.ename AS '姓名',d1.dname AS '部门',\ne1.sal+IFNULL(e1.comm,0) AS '薪水',t.grade AS '薪资等级',\nFLOOR(DATEDIFF(NOW(),e1.hiredate)/365) AS '工龄',\ne1.mgr AS '上司编号',e2.ename AS '上司姓名',d2.dname AS '上司部门' \nFROM t_emp e1 LEFT JOIN t_dept d1 ON e1.deptno=d1.deptno\nLEFT JOIN t_emp e2 ON e1.mgr=e2.empno\nLEFT JOIN t_salgrade t ON e1.sal BETWEEN t.losal AND t.hisal\nLEFT JOIN t_dept d2 ON e2.deptno=d2.deptno;\n```\n◇结果：\n![image.png](数据库的高级查询/1626664826083-f96e349d-cc41-40fc-8a9f-0b996022332a.png)\n\n ◇ UNION关键字可以将多个查询语句的结果集进行合并 ,结果集字段名称、个数需要相同\n```sql\n( 查询语句 ) UNION ( 查询语句 ) UNION ( 查询语句 ) ……\n```\n###  外连接的注意事项  \n ◇ 内连接只保留符合条件的记录，所以查询条件写在ON子句和 WHERE子句中的效果是相同的。但是外连接里，条件写在WHERE 子句里，不合符条件的记录是会被过滤掉的,而不是保留下来。\n①\n使用ON子句\n```sql\nSELECT e.ename,d,dname,d.deptno\nFROM t_emp e\nLEFT JOIN t_dept d ON e.deptno = d.deptno\nAND e.deptno=10;\n```\n结果：\n![image.png](数据库的高级查询/1626665352162-b0b6a378-88e3-4711-9b18-ee194cf32151.png)\n\n发现所有记录都被保留，但不符合条件的记录为空\n②使用WHERE子句\n\n```sql\nSELECT e.ename,d,dname,d.deptno\nFROM t_emp e\nLEFT JOIN t_dept d ON e.deptno = d.deptno\nWHERE e.deptno=10;\n```\n结果：\n![image.png](数据库的高级查询/1626665474286-a40128b4-d895-4759-86f7-d68289ac14ba.png)\n\n##  数据操作语言：子查询  \n###  子查询简介  \n ◇ 子查询是一种查询中嵌套查询的语句 \n ◇ 查询底薪超过公司平均底薪的员工的信息  \n```sql\n SELECT empno,ename,sal\n FROM t_emp\n WHERE sal>=(SELECT AVG(sal) FROM t_emp);\n```\n###  子查询的分类 \n ◇ 子查询可以写在三个地方：WHERE子句、FROM子句、SELECT子 句，但是只有FROM子句子查询是最可取的   \n###  WHERE子查询  \n ◇ 这种子查询最简单，最容易理解，但是却是效率很低的子查询  \n ◇ 查询底薪超过公司平均底薪的员工的信息  \n![image.png](数据库的高级查询/1626670116652-f8ce1b67-2d79-462d-902f-12c22d33e139.png)\n\n###  用表连接替代WHERE子查询  \n ◇ 表连接的优点是子查询只执行一次，查询效率特别高  \n```sql\nSELECT e2.empno,e2.ename\nFROM t_emp e1 JOIN t_emp e2\nON e1.deptno = e2.deptno\nAND e2.ename!=\"FORD\"\nAND e1.ename=\"FORD\";\n```\n###  FROM子查询  \n ◇ 这种子查询只会执行一次，所以查询效率很高，把子查询写在FROM子句中\n ◇ 查询底薪超过公司平均底薪的员工的信息 \n```sql\nSELECT e.empno,e.ename,e.sal,t.avg\nFROM t_emp e JOIN \n(SELECT deptno,AVG(sal) as avg\nFROM t_emp GROUP BY deptno) t\nON e.deptno=t.deptno AND e.sal>=t.avg;\n\n```\n###  SELECT子查询  \n ◇ 这种子查询每输出一条记录的时候都要执行一次，查询效率很低  \n```sql\nSELECT e.empno,e.ename,(SELECT dname FROM t_dept WHERE deptno=e.deptno)\nFROM t_emp e;\n```\n###  相关子查询  \n◇ 查询语句执行的时候要多次的依赖于子查询的结果，这类子查询被 称作相关子查询 \n◇ WHERE子查询和SELECT子查询都属于相关子查询 \n◇ 因为相关子查询要反复多次执行，所以应该避免使用  \n###  单行子查询和多行子查询  \n◇ 单行子查询的结果集只有一条记录，多行子查询结果集有多行记录 \n◇ 多行子查询只能出现在WHERE子句和FROM子句中 \n◇ 子查询一般先写出子查询语句\n◇ 如何用子查询查找FORD和MARTIN两个人的同事？  \n```sql\nSELECT \nFROM t_emp\nWHERE \ndeptno IN //这里子查询结果集为多行记录，所以不能用\"=\",而用\"IN\"表示等于其中一条记录即可\n(SELECT deptno FROM t_emp WHERE ename IN(\"FORD\",\"MARTIN\"))\nAND ename NOT IN(\"FORD\",\"MARTIN\");\n```\n###  WHERE子句中的多行子查询  \n◇ WHERE子句中，可以使用IN、ALL、ANY、EXISTS关键字来处理多行表达式结果集的条件判断 \n◇ 查询比FORD和MARTIN底薪都高的员工信息？  \n```sql\nSELECT ename\nFROM t_emp\nWHERE sal>=ALL\n(SELECT sal FROM t_emp WHERE ename IN(\"FORD\",\"MARTIN\"))\nAND ename NOT IN(\"FORD\",\"MARTIN\");\n```\n###  EXISTS关键字  \n ◇ EXISTS关键字是把原来在子查询之外的条件判断，写到了子查询的里面。  \n```sql\nSELECT …… FROM 表名 WHERE [NOT] EXISTS ( 子查询 ) ;\n```\n ◇ 查询工资等级3和4级的员工信息？  \n```sql\nSELECT empno,ename,sal\nFROM t_emp\nWHERE EXISTS(\nSELECT grade FROM t_salgrade\nWHERE sal BETWEEN losal AND hisal\nAND grade IN(3,4)\n);\n```\n\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库的基本查询","url":"/p/f427.html","content":"##  数据操作语言：普通查询  \n###  记录查询  \n◇ 最基本的查询语句是由 SELECT 和 FROM 关键字组成的  \n◇ SELECT语句屏蔽了物理层的操作，用户不必关心数据的真 实存储，交由数据库高效的查找数据  \n```sql\nSELECT * FROM t_student;\nSELECT id,name,sex FROM t_student;\n```\n###  使用列别名  \n◇ 通常情况下，SELECT子句中使用了表达式，那么这列的名 字就默认为表达式，因此需要一种对列名重命名的机制  \n```sql\nSELECT\n ename,\n sal * 12 AS \"annual_salary\"\n FROM\n emp;\n```\n◇ 重命名只在显示输出的时候使用，数据表列名不会真的改变  \n◇ 查询语句的子句执行顺序  \n![image.png](数据库的基本查询/1625994166757-969465a0-9e0f-4a0b-ad16-e6d3ae59731c.png)\n\n##  数据操作语言：数据分页  \n###  数据分页  \n◇ 比如我们查看朋友圈，只会加载少量部分信息，不用一次性加载全 部朋友圈，那样只会浪费CPU时间、内存和网络带宽\n◇ 如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量。  \n```sql\nSELECT …… FROM …… LIMIT 起始位置 , 偏移量 ;\nSELECT empno,ename FROM t_emp LIMIT 0,20;//20是偏移量而不是终止的\n```\n###  数据分页的简写用法  \n◇如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0  \n◇执行顺序： FROM -> SELECT -> LIMIT  \n##  数据操作语言：结果集排序  \n###  结果集排序  \n◇ 如果没有设置，查询语句不会对结果集进行排序。也就是说，如果 想让结果集按照某种顺序排列，就必须使用ORDER BY子句。  \n```sql\nSELECT …… FROM …… ORDER BY 列名 [ ASC | DESC ] ;\n```\n###  排序关键字  \n ◇ASC代表升序（默认），DESC代表降序 如果排序列是数字类型，数据库就按照数字大小排序，如果是日期 类型就按照日期大小排序，如果是字符串就按照字符集序号排序。  \n###  排序字段内容相同的情况  \n◇ 默认情况下，如果两条数据排序字段内容相同，那么排序会是什么 样子？  \n◇ 如果排序字段内容相同，MySQL会按照主键大小来排序两条数据  \n###  多个排序字段  \n ◇我们可以使用ORDER BY规定首要排序条件和次要排序条件。数据 库会先按照首要排序条件排序，如果遇到首要排序内容相同的记录 ，那么就会启用次要排序条件接着排序  \n```sql\nSELECT empno,ename,sal,hiredate\nFROM t_emp\nORDER BY sal DESC,hiredate ASC;\n```\n###  排序+分页  \n◇ ORDER BY子句书写的时候放在LIMIT子句的前面  \n FROM -> SELECT -> ORDER BY -> LIMIT  \n##  数据操作语言：去除重复记录  \n◇ 假如我们要查询员工表有多少种职业， 如果我们需要去除重复的数据，可以使用DISTINCT关键字来实现  ；\n```sql\nSELECT DISTINCT 字段 FROM …… ;\n```\n◇ 注意事项  ： ①使用DISTINCT的SELECT子句中只能查询一列数据，如果查询多列， 去除重复记录就会失效。  \n② DISTINCT关键字只能在SELECT子句中使用一次  ；\n##  数据操作语言：条件查询\n###  条件查询   \n◇ 很多时候，用户感兴趣的并不是逻辑表里的全部记录，而只是它们 当中能够满足某一种或某几种条件的记录。这类条件要用WHERE子 句来实现数据的筛选  \n```sql\nSELECT …… FROM …… WHERE 条件 [ AND | OR ] 条件 …… ;\n```\n###  四类运算符  \n WHERE语句中的条件运算会用到以下四种运算符：  \n![image.png](数据库的基本查询/1625997158623-77abf14a-54c7-475f-b681-9b41a645994f.png)\n\n###  算数运算符  \n![image.png](数据库的基本查询/1626506515565-3a9d08ca-5c97-4fbd-84e7-3fcdfa11bca4.png)\n###  比较运算符  \n![image.png](数据库的基本查询/1626506532025-a81b1d45-0bcb-4b12-99af-3bf2f1ac8c56.png)\n![image.png](数据库的基本查询/1626506751691-a643c08a-1c57-46a6-8a9e-0f7478ade47b.png)\n\n###  逻辑运算符  \n![image.png](数据库的基本查询/1626506615665-ab58a3e7-4c84-4cb3-b3ce-b8d089816b3e.png)\n###  二进制按位运算  \n◇ 二进制位运算的实质是将参与运算的两个操作数，按对应的二进制数逐位进行逻辑运算。  \n![image.png](数据库的基本查询/1626506691986-8cb9c71e-23fe-4243-a98f-61ecaeb2037e.png)\n\n###  按位运算符  \n![image.png](数据库的基本查询/1626506705766-5f082cda-69bc-4213-8776-6b307ec394b4.png)\n###  WHERE子句的注意事项  \n◇ WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把索引条件，或者筛选掉记录最多的条件写在最左侧  \n```sql\nSELECT empno,ename FROM t_emp\nWHERE ename = \"FORD\" AND sal >= 2000;\n\nSELECT empno,ename FROM t_emp\nWHERE deptno = 10 AND sal >= 2000;\n```\n\n\n###  各种子句的执行顺序  \n 条件查询中，WHERE子句应该是第几个执行？ FROM -> WHERE -> SELECT -> ORDER BY -> LIMIT  \n\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库范式","url":"/p/77e3.html","content":"## 概念\n◇ 构造数据库必须遵循一定的规则，这种规则就是范式  \n◇ 目前关系数据库有6种范式，一般情况下，只满足第三范式即可  \n##  第一范式：原子性  \n◇ 第一范式是数据库的基本要求，不满足这一点就不是关系数据库  \n◇ 数据表的每一列都是不可分割的基本数据项，同一列中不能有多个值，也不能存在重复的属性。\n![image.png](数据库的范式/1625840047827-6aee66b4-51fa-4462-9315-661dcc5bbc8c.png)\n\n##  第二范式：唯一性  \n◇ 数据表中的每条记录必须是唯一的。为了实现区分，通常要为表 加上一个列用来存储唯一标识，这个唯一属性列被称作主键列  \n![image.png](数据库的范式/1625840463558-faa7b806-aebf-4fa1-83d6-1fa49132c68f.png)\n\n##  第三范式：关联性  \n◇ 每列都与主键有直接关系，不存在传递依赖  \n![image.png](数据库的范式/1625840515859-2c1f2750-a72c-4ca8-9693-0097054d1a89.png)\n ◇依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联  \n![image.png](数据库的范式/1625840617006-d3552f4a-77d7-4734-8d1b-f4347315568f.png)\n\n## 字段约束\n◇ MySQL中的字段约束共有四种：  \n![image.png](数据库的范式/1625990627379-e5fb0810-df5e-4398-bd38-3841fc1be58b.png)\n\n### 主键约束\n◇ 主键约束要求字段的值在全表必须唯一，而且不能为NULL值  \n◇ 建议主键一定要使用数字类型，因为数字的检索速度会非常快  \n◇ 如果主键是数字类型，还可以设置自动增长  \n```sql\nCREATE TABLE t_teacher(\nid INT PRIMARY KEY AUTO_INCREMENT,\n.......\n)\n```\n### 非空约束\n◇ 非空约束要求字段的值不能为NULL值  \n◇ NULL值以为没有值，而不是\" \"空字符串  \n```sql\nCREATE TABLE t_teacher(\nid INT PRIMARY KEY AUTO_INCREMENT,\nname VARCHAR(200) NOT NULL,\nmarried BOOLEAN NOT NULL DEFAULT FALSE //设置默认值为false\n);\n```\n### 唯一约束\n◇ 唯一约束要求字段值如果不为NULL，那么在全表必须唯一  \n```sql\nCREATE TABLE t_teacher(\n...\ntel CHAR(11) NOT NULL UNIQUE\n);\n```\n### 外键约束\n◇ 外键约束用来保证关联数据的逻辑关系  \n![image.png](数据库的范式/1625991461738-358528fb-416f-4cef-b409-575041655201.png)\n◇ 外键约束的定义是写在子表上的  \n\n```sql\nCREATE TABLE t_emp(\nempno INT UNSIGNED PRIMARY KEY,\nename VARCHAR(20) NOT NULL,\nsex ENUM(\"MAN\",\"WOMAN\") NOT NULL,\ndeptno INT UNSIGNED NOT NULL,\nhiredate DATE NOT NULL,\nFOREIGN KEY (deptno) REFERENCES t_dept(deptno)\n);\n```\n** 外键约束的闭环问题  **\n◇ 如果形成外键闭环，我们将无法删除任何一张表的记录  \n![image.png](数据库的范式/1625992112385-0da833a2-88ca-4eed-8643-262a3b35b40d.png)\n\n##  数据定义语言：索引  \n###  数据排序的好处  \n◇ 一旦数据排序之后，查找的速度就会翻倍，现实世界跟程 序世界都是如此  \n###  数据表的索引  \n◇ MySQL利用二叉树结构，对数据表的记录排序，从而加速 数据的检索速度  \n![image.png](数据库的范式/1625992297169-2ea7a513-51e5-40b6-b3ca-2aca1f27912d.png)\n\n###  如何创建索引  \n```sql\nCREATE TABLE 表名称 ( ……，\nINDEX [ 索引名称 ] ( 字段 ) ……//给哪一个字段设置索引\n) ;\n```\n###  如何添加与删除索引  \n```sql\nCREATE INDEX 索引名称 ON 表名( 字段 ) ；\nALTER TABLE 表名称 ADD INDEX [ 索引名 ]( 字段 ) ;\nSHOW INDEX FROM 表名 ;   //查看索引情况\nDROP INDEX 索引名称 ON 表名 ;\n```\n###  索引的使用原则  \n◇ 数据量很大，而且经常被查询的数据表可以设置索引 \n◇ 索引只添加在经常被用作检索条件的字段上面 \n◇ 不要在大字段上创建索引\n\n\n\n  \n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"数据库简介","url":"/p/f849.html","content":"## 学习目标\n**了解关系型数据库的重要性**\n  -为什么会出现关系型数据库？有哪些常见的关系型数据库？  \n**掌握MySQL的安装和配置**\n  -怎么安装MySQL数据库？怎么配置MySQL的字符集、端口号、IP 地址绑定、数据目录等等？  \n**实践用户创建、分配权限和密码找回**\n - 如何创建root之外的帐户并分配权限？忘记数据库密码，应该如何 找回？  \n## 课程内容\n![image.png](数据库简介/1625745885993-bc3f8091-5671-49b0-b883-2deeb93953d8.png)\n## 操作系统中数据存放的载体\n◇ Windows、Linux和MacOS都是基于文件的操作系统  \n◇ 文件能保存数据，为什么不用文件来管理数据？\n## 什么是(关系型)数据库系统？\n◇ 数据库系统（DBMS）是指一个能为用户提供信息服务 的系统。它实现了有组织地、动态地储存大量相关数据 的功能，提供了数据处理和信息资源共享的便利手段。\n◇ 关系型数据库系统（RDBMS）是指使用了关系模型的数 据库系统  \n◇ 关系模型中，数据是分类存放的，数据之间可以有联系\n![image.png](数据库简介/1625747084668-a2ccf897-723b-4ed3-b2ff-7306028578de.png)\n\n##  关系型数据库的应用      \n◇ 关系型数据库被应用在非常多的领域  \n![image.png](数据库简介/1625746899055-c7f7b681-d7e6-404e-adf4-955b8c3fbb72.png)\n 关系型数据库可以有效组织和管理大量复杂的数据，所 以关系型数据库才是最重要的数据库产品  \n◇数据库的大规模应用\n![image.png](数据库简介/1625746981059-77d2bbc5-76f7-433c-b1f3-1579d1cb15a1.png)\n◇主流关系型数据库\n![image.png](数据库简介/1625747003200-98e2e0e6-1830-4277-8891-7d4db47274b3.png)\n\n##  什么是NoSQL数据库系统？\n◇ NoSQL数据库指的是数据分类存放，但是数据之间没有关联关系的数据库系统  \n![image.png](数据库简介/1625747164092-f6498682-6d07-4ab0-9c56-c7977aa8d09c.png)\n◇ 主流NoSQL数据库  \n![image.png](数据库简介/1625747213311-ffaffb43-e795-4115-95a5-89ee1ef45a6f.png)\n\n## 用户管理\n◇MySQL客户端  Navicat\n### 重设root密码\n◇ 密码忘记后\n◇ 创建一个TXT文件，定义修改密码的SQL语句  \n\n```csharp\nALTER USER 'root'@'localhost' IDENTIFIED BY\n'123456' ;\n```\n◇以管理员身份打开PowerShell窗口\n![image.png](数据库简介/1625755297789-549f2cdd-2307-4e23-b0cf-b6306fc853d3.png)\n![image.png](数据库简介/1625755485452-38a0d75a-c473-4e30-ba8b-2a4ab32121e1.png)\n◇ 修改my.ini文件，删除之前添加的参数 \nC:\\ProgramData\\MySQL\\MySQL Server 8.0，先打开隐藏文件； \n◇ 重启MySQL服务，用新密码登陆root帐户\n\n## MySQL配置文件  \n◇ 在my.ini文件中，我们可以设置各种MySQL的配置，例 如字符集、端口号、目录地址等等  \n![image.png](数据库简介/1625755710987-887e0744-ef37-4276-9da1-1150300ab70b.png)\n\n```csharp\n[client]\nport=3306   \n[mysql]\nno-beep    #关闭蜂鸣器\n[mysqld]\nport=3306  #端口号\ndatadir=C:/ProgramData/MySQL/MySQL Server 8.0\\Data  #数据目录\ndefault_authentication_plugin=mysql_native_password #密码认证插件\ndefault-storage-engine=INNODB  #默认存储引擎\nsql-mode=\"STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION\"  #开启严格模式\nlog-output=FILE  #用文件记录日志\ngeneral-log=0  #关闭日志输出\ngeneral_log_file=\"LAPTOP-3NL7HPNI.log\"  #日志文件名称\nslow-query-log=1  #开启慢查询日志\nslow_query_log_file=\"LAPTOP-3NL7HPNI-slow.log\" #慢查询日志文件名称\nlong_query_time=10  #大于多少秒的执行SQL被记录在慢查询\nlog-error=\"LAPTOP-3NL7HPNI.err\" #错误日志名称\nlog-bin=\"LAPTOP-3NL7HPNI-bin\"\nserver-id=1 #数据库ID，集群时用到\nreport_port=3306\nlower_case_table_names=1 #把表名转换成小写\nsecure-file-priv=\"C:/ProgramData/MySQL/MySQL Server 8.0/Uploads\" #导入导出数据的目录地址\nmax_connections=151 #最大连接数\ntable_open_cache=2000\ntmp_table_size=21M\nthread_cache_size=10 #线程数量\n.......\n\n```\n","tags":["数据库"],"categories":["Java数据库","MySQL基础"]},{"title":"Freemaker","url":"/p/f1c8.html","content":"## 模板引擎与Freemaker项目实战\n### 什么是模板引擎\n◇模板引擎的目标是\"数据+模板=结果\"\n◇模板引擎将数据与展现有效\"解耦\"\n![1-1.png](FreeMarker/1622635068478-fdaeec0b-c160-499a-8c7b-0d9f899fea1b.png)\n### 主流模板引擎\n◇Java Servlet Page\n◇Fremarker\n◇Beetl\n### Fremarker\n◇Fremarker是免费开源的模板引擎技术\n◇Fremarker脚本为Fremarker Template Language\n◇Fremarker提供了大量内建函数来简化开发\n### JSP与Fremarker\n![image.png](FreeMarker/1622635426423-771b8d0d-39ec-4488-904c-ccfe7bddde90.png)\n### Fremarker快速上手\n代码演示\nftl：${site}-${url}\n```java\npublic class FreemarkerSample1 {\n\n\tpublic static void main(String[] args) \n\t\tthrows TemplateNotFoundException, MalformedTemplateNameException, \n\t\tParseException, IOException, TemplateException {\n\t\t// TODO Auto-generated method stub\n       //1.加载模板\n\t\t//1.1创建核心配置对象\n\t\tConfiguration config = new Configuration(Configuration.VERSION_2_3_31);\n\t\t//1.2设置加载的目录\n\t\tconfig.setClassForTemplateLoading(FreemarkerSample1.class, \"\");\n\t\t//1.3得到模板对象\n\t\tTemplate t = config.getTemplate(\"sample1.ftl\");\n\t   //2.创建数据\n\t\tMap<String,Object> data = new HashMap<String,Object>();\n\t\tdata.put(\"site\", \"百度\");\n\t\tdata.put(\"url\", \"http://www.baidu.com\");\n\t   //3.产生输出\n\t\t//转换类将System.out输出字节流转换为字符输出流\n\t\tt.process(data, new OutputStreamWriter(System.out));\n\t}\n\n}\n```\n### FTL取值\n◇${属性名}             取值，可对属性进行计算\n◇${属性名!默认值}  使用默认值    eg：${author!\"不存在的属性\"}\n◇${属性名?string}   格式化输出    \neg：${date?string(\"yyyy年MM月dd日HH:mm:ss\")}\n### 分支判断\n◇if分支判断\n◇switch分支判断\n```java\n<#if computer.state==1>\n状态:正在使用\n<#elseif computer.state==2>\n状态:闲置\n<#elseif computer.state==3>\n状态:已作废\n</#if> <#-- 闭合 -->\n\n<#switch computer.state>\n    <#case 1>\n    状态:正在使用\n    <#break>\n    <#case 2>\n    状态:闲置\n    <#break>\n    <#case 3>\n    状态:已作废\n    <#break>\n    <#default>\n     状态:无效状态\n     </#switch>\n```\n### list迭代列表\n  --格式\n```java\n<#--student被迭代的集合；stu迭代变量 -->\n<#list student as stu>\n<li>${stu_index}-${stu.name}</li>\n</#list>\n```\n --代码演示\n```java\n<#list computers as c>\n序号:${c_index + 1} <#-- 迭代变量_index保存了循环的索引,从0开始 -->\nSN:${c.sn}\n型号:${c.model}\n<#switch c.state>\n<#case 1>\n状态:使用中\n<#break>\n<#case 2>\n状态:闲置\n<#break>\n<#case 3>\n状态:已作废\n<#break>\n</#switch>\n<#if c.user??>\n用户:${c.user}\n</#if>\n采购日期:${c.dop?string(\"yyyy-MM-dd\")}\n采购价格:${c.price?string(\"0.00\")}\n-------------------------------------------\n</#list>\n\n==========================================\n<#list computer_map?keys as k >\n${k}-${computer_map[k].model}\n${computer_map[k].price?string(\"0.00\")}\n</#list>\n```\n### list迭代Map\n --格式\n```java\n<#list map?keys as key>\n  ${key}:${map[key]}\n</#list>\n```\n### 内建函数\n![image.png](FreeMarker/1622680841881-8fd3d58b-e388-45eb-9faf-2c3bb42399ee.png)\n 代码示例：\n\n```java\n${name?cap_first}\n${brand?upper_case}\n${brand?length}\n${words?replace(\"blood\" , \"*****\")}\n${words?index_of(\"blood\")}\n<#-- 利用?string实现三目运算符的操作 -->\n${(words?index_of(\"blood\") != -1)?string(\"包含敏感词汇\",\"不包含敏感词汇\")}\n\n${n?round}\n${n?floor}\n${n?ceiling}\n\n公司共有${computers?size}台电脑\n第一台:${computers?first.model}\n最后一台:${computers?last.model}\n\n<#-- 集合排序 ?reverse代表反转，将默认的升序排列改为降序 -->\n<#list computers?sort_by(\"price\")?reverse as c>\n\t${c.sn}-${c.price}\n</#list>\n```\n◇[Freemarker参考手册](http://freemarker.foofun.cn/)\n## Freemarker与Servlet整合\n### 代码演示\n --xml配置FreemarkerServlet\n```xml\n<!-- 配置freemarker类，和配置servlet一样 \n  在配置class上可以按住Ctrl若路径出现蓝色下划线则说明路径正确\n  通过设置初始化参数来说明FreemarkerServlet加载哪个目录\n  -->\n  <servlet>\n        <servlet-name>freemarker</servlet-name>\n        <servlet-class>freemarker.ext.servlet.FreemarkerServlet</servlet-class>\n        <init-param>\n             <param-name>TemplatePath</param-name>\n             <param-value>/WEB-INF/ftl</param-value>\n        </init-param>\n  </servlet>\n  <servlet-mapping>\n      <servlet-name>freemarker</servlet-name>\n      <url-pattern>*.ftl</url-pattern>\n  </servlet-mapping>\n```\n--Employee类提供员工类信息\n```java\npublic class Employee {\n     private Integer empno;\n     private String ename;\n     private String department;\n     private String job;\n     private Float salary; \n    \t /*省略构造函数*/\n     }\n```\n--ListServlet为界面准备数据\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\t\t\tthrows ServletException, IOException {\n\t\tList list = new ArrayList();\n\t\tlist.add(new Employee(2020,\"关浩\",\"市场部\",\"客户代表\",6000f));\n\t\tlist.add(new Employee(2021,\"右磊\",\"研发部\",\"运维工程师\",6500f));\n        list.add(new Employee(2022,\"方传输\",\"运输部\",\"交通工程师\",8500f));\n\t\tlist.add(new Employee(2023,\"才刚\",\"董事会\",\"CEO\",120000f));\n\t\trequest.setAttribute(\"employee_list\", list);\n\t\t//请求转发到ftl文件上\n\t\trequest.getRequestDispatcher(\"/employee.ftl\").forward(request, response);\n\t}\n```\n--ftl显示页面\n```xml\n<#-- 遍历集合，将数据填到每一行 -->\n                <#list employee_list as emp>\n                <tr>\n                    <td>${emp_index+1}</td>\n                    <td>${emp.empno?string(\"0\")}</td>\n                    <td>${emp.ename}</td>\n                    <td>${emp.department}</td>\n                    <td>${emp.job}</td>\n                    <td style=\"color: red;font-weight: bold\">\n                      ￥${emp.salary?string(\"0.00\")}</td>               \n                </tr>\n                </#list>      \n```\n### 效果图\n![image.png](FreeMarker/1622685702485-b430b8b9-980b-4c28-9c51-d927d87f91d7.png)\n","tags":["Freemaker"],"categories":["JavaWeb"]},{"title":"监听器","url":"/p/83aa.html","content":"## 监听器 - Listener\n◇监听器是J2EE Servlet模块下的组件\n◇Listener的作用是对Web应用对象的行为进行监控\n◇通过Listener监听自动触发指定的功能代码\n## 三种监听对象\n◇ServletContext - 对全局ServletContext及其属性进行监听\n◇HttpSession - 对用户会话及其属性操作进行监听\n◇ServletRequest - 对请求及属性操作进行监听\n## 过滤器与监听器的区别\n◇过滤器的职责是对URL进行过滤拦截，是主动的执行\n◇监听器的职责是对Web对象进行监听，是被动触发\n## 开发监听器三要素\n◇实现XxxListener接口，不同接口对应不同监听对象\n◇实现每个接口中独有的方法，实现触发监听的后续操作\n◇在web.xml中配置<listener>是使听器生效\n代码演示\n```java\n\n@WebListener//使用注解配置\npublic class FirstListener implements ServletContextListener{\n\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent sce) {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"已销毁\");\n\t}\n\n\t@Override\n\tpublic void contextInitialized(ServletContextEvent sce) {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"已初始化\");\n\t}\n```\n --使用xml配置\n```html\n<listener>\n      <listener-class>com.lcg.listener.FirstListener</listener-class>\n  </listener>\n```\n## 六种常用监听接口\n### 内置对象监听接口\n◇ServletContextListener - 监听ServletContext对象创建、销毁等操作\n◇HttpSessionListener  - 监听HttpSession对象创建、销毁等操作\n◇ServletRequestListener - 监听 HttpServletRequest对象创建、销毁等操作\n### 属性监听接口\n◇ServletContextAttributeListener - 监听全局属性操作\n◇HttpSessionAttributeListener -监听用户会话属性操作\n◇ServletRequestAttributeListener -监听请求属性操作\n## 监听器的应用场景\n### 请求流量分析\n代码演示：\n  --监听器\n```java\n/*导包部分省略*/\n\npublic class RequestTotalListener implements ServletContextListener,ServletRequestListener{\n\n\t@Override\n\tpublic void requestDestroyed(ServletRequestEvent sre) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic void requestInitialized(ServletRequestEvent sre) {\n\t\t// TODO Auto-generated method stub\n\t\t/*排除/rt这个url的访问统计*/\n\t\tHttpServletRequest request = (HttpServletRequest)sre.getServletRequest();\n\t\tString url = request.getRequestURL().toString();\n\t\tif(url.endsWith(\"/rt\")==true) {\n\t\t\treturn;\n\t\t}\n\t\t/*请求初始化，每来一个新的请求，监听器都会执行此方法。则应当在此方法中记录变化的值\n\t\t * 存储结构：TimeList: 10:02  10:03 ...  访问时间\n\t\t *          ValueList: 5       7    ...  访问次数\n\t\t * */\n\t\t//先获取全局属性，再记录 \n\tList<String> timeList =\t(List)sre.getServletContext().getAttribute(\"timeList\");\n\tList<Integer> valueList = (List)sre.getServletContext().getAttribute(\"valueList\");\n\tDate date = new Date();\n\tSimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm\");\n\tString time = sdf.format(date);\n\tif(timeList.indexOf(time)==-1) {\n\t\ttimeList.add(time);//如果时间不存在，则追加\n\t\tvalueList.add(1);\n\t\tsre.getServletContext().setAttribute(\"timeList\", timeList);\n\t\tsre.getServletContext().setAttribute(\"valueList\", valueList);\n\t}else {\n\t\tint index = timeList.indexOf(time);//若存在，则返回时间的索引值\n\t\tint value = valueList.get(index);//根据时间的索引获取value值\n\t\tvalueList.set(index, value+1);\n\t\tsre.getServletContext().setAttribute(\"valueList\", valueList);\n\t}\n\t\n\t}\n\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent sce) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic void contextInitialized(ServletContextEvent sce) {\n\t\t// TODO Auto-generated method stub\n\t\t//全局初始化时间和值两个属性，一个保存时间，一个保存数值\n\t\tList timeList = new ArrayList();\n\t\tList valueList = new ArrayList();\n\t\t//两个属性的值会随着请求变化\n\t\tsce.getServletContext().setAttribute(\"timeList\", timeList);\n\t\tsce.getServletContext().setAttribute(\"valueList\", valueList);\n\t}\n\n}\n\n```\n--Servlet\n```java\n/*导包部分省略*/\n@WebServlet(\"/rt\")\npublic class RequestTotalServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n       \n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public RequestTotalServlet() {\n        super();\n        // TODO Auto-generated constructor stub\n    }\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tServletContext context = request.getServletContext();\n\t\tList<String> timeList = (List)context.getAttribute(\"timeList\");\n\t\tList<Integer> valueList = (List)context.getAttribute(\"valueList\");\n\t\tresponse.setContentType(\"text/html;charset=utf-8\");\n\t/*\tresponse.getWriter().println(timeList.toString());\n\t\tresponse.getWriter().println(\"<br>\");\n\t\tresponse.getWriter().println(valueList.toString());*/\n\t\t//将原来的数据封装成JSON\n\t\tMap result = new HashMap();\n\t\tresult.put(\"timeList\", timeList);\n\t\tresult.put(\"valueList\", valueList);\n\t\tString json = JSON.toJSONString(result);\n\t\tresponse.getWriter().println(json);\n\t}\n\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tdoGet(request, response);\n\t}\n\n}\n```\n  --统计页面\n◇[EChart数据可视化插件](https://echarts.apache.org/zh/index.html)\n```java\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n<script type=\"text/javascript\" src=\"js/echarts.min.js\"></script>\n<script type=\"text/javascript\" src=\"js/jquery-3.6.0.min.js\"></script>\n</head>\n<body>\n    <!-- 为ECharts准备一个具备大小（宽高）的Dom -->\n    <div id=\"main\" style=\"width: 600px;height:400px;\"></div>\n    <script type=\"text/javascript\">\n    function showChart(){\n      //ajax获取./rt的数据，成功后将json数据的数组代替原来的数组\n    $.ajax({\n    \t   url:\"./rt\",\n    \t   type:\"get\",\n    \t   dataType:\"json\",\n    \t   success: function(json){\n    \t\t console.log(json.timeList);\n    \t\t console.log(json.valueList);\n    \t\t// 基于准备好的dom，初始化echarts实例\n    \t\t\tvar myChart = echarts.init(document.getElementById('main'));\n\n    \t\t\t// 指定图表的配置项和数据\n    \t\t\tvar option = {\n    \t\t\t\ttitle : {   //标题\n    \t\t\t\t\ttext : '请求流量分析'  // 标题文本\n    \t\t\t\t},\n    \t\t\t\ttooltip : {},\n    \t\t\t\tlegend : {\n    \t\t\t\t\tdata : [ '访问量' ]\n    \t\t\t\t},\n    \t\t\t\txAxis : {  //x轴坐标数据\n    \t\t\t\t\tdata : json.timeList //json.timeList类型正好是数组\n    \t\t\t\t},\n    \t\t\t\tyAxis : {},\n    \t\t\t\tseries : [ {\n    \t\t\t\t\tname : '访问量',\n    \t\t\t\t\ttype : 'line',//图表形式,bar代表柱状图,line表示折线图\n    \t\t\t\t\tdata : json.valueList\n    \t\t\t\t} ]\n    \t\t\t};\n\n    \t\t\t// 使用刚指定的配置项和数据显示图表。\n    \t\t\tmyChart.setOption(option);\n    \t   }\n       \n       })\n    }\n\t\twindow.setInterval(\"showChart()\",1000);//每一秒执行showChart()函数\n\t</script>\n</body>\n</html>\n```\n### 静态数据预处理\n ◇创建类来定义结构\n ◇创建监听器初始化和设置属性\n ◇利用jst-l来获取属性，展示在页面\n​\n\n","tags":["Listener"],"categories":["JavaWeb"]},{"title":"过滤器","url":"/p/cb9.html","content":"## 基础\n### 初识过滤器\n◇过滤器(Filter)是J2EE servlet模块下的组件\n◇Filter的作用是对URL进行统一的拦截处理\n◇Filter通常用于应用程序层面进行全局处理\n◇过滤链，正向传递请求，最终有ServletJSP处理，然后逆向响应；\n![image.png](过滤器/1622365495819-77ff8c25-9ff8-4525-bd73-6ca7088c5bba.png)\n\n### 开发过滤三要素\n◇任何过滤器都要实现javax.servlet.Filter接口\n◇在Filter接口的doFilter()方法中编写过滤器的功能代码\n◇在web.xml中对过滤器进行配置，说明拦截URL的范围\n### 开发第一个过滤器\n代码演示：\n1.任何过滤器都要实现javax.servlet.Filter接口；在Filter接口的doFilter()方法中编写过滤器的功能代码\n```java\npublic class MyFirstFilter implements Filter{\n\n\t@Override\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"过滤器已生效\");\n\t\tchain.doFilter(request, response);\n\t}\n\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n```\n2.在web.xml中对过滤器进行配置，说明拦截URL的范围\n```java\n  <!-- filter标签用于说明哪个类是过滤器，并在启动时自动加载 -->\n  <filter>\n       <filter-name>MyFirstFilter</filter-name>\n       <filter-class>com.lcg.filter.MyFirstFilter</filter-class>\n  </filter>\n  <!-- filter-mapping标签用于说明过滤器对URL应用的范围，要点有二：\n  1.filter-name 过滤器名称与filter.filter-name保持一致\n  2.url-pattern 说明过滤作用范围，/*代表对所有URL进行过滤 -->\n  <filter-mapping>\n       <filter-name>MyFirstFilter</filter-name>\n       <url-pattern>/*</url-pattern>\n  </filter-mapping>\n```\n### 过滤器生命周期\n\n![image-20220221195446215](过滤器/image-20220221195446215.png)\n\n◇代码演示\n```java\npublic class MyFirstFilter implements Filter{\n\n\t@Override\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"过滤器已销毁\");\n\t}\n\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"过滤器已生效\");\n\t\tchain.doFilter(request, response);\n\t}\n\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"过滤器初始化\");\n\t}\n\n}\n```\n◇运行结果:启动Tomcat后，过滤器自动初始化；  在浏览器进行访问时，如果访问的地址符合过滤策略，则过滤器会生效； 当关闭Tomcat后，过滤器自动销毁；\n### 过滤器特性\n◇过滤器对象在Web应用启动时被创建且全局唯一\n◇唯一的过滤器对象在并发环境中采用\"多线程\"提供服务\n### 过滤器的配置形式\n◇在xml中配置\n### 过滤器的注解形式\n◇在class中注解\n```java\n@WebFilter(filterName=\"MyAnnoationFilter\",urlPatterns=\"/*\")\n```\n### 配置与注解如何选择\n◇配置形式维护性更好，适合应用全局过滤\n◇注解形式开发体验更好，适用于小型项目敏捷开发\n◇尽量避免混合使用\n## 过滤器开发\n### 开发字符集过滤器\n◇web中文乱码的解决\n![image.png](过滤器/1622451277809-0d31cfaf-bef4-4d67-be2b-07533529f06e.png)\n◇缺点：每一个servlet都要单独设置，无法统一设置；\n◇使用字符集过滤器解决：\n\n```java\n@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\t//必须强制转换为HttpServletResponse，与Servlet底层机制有关\n\t\tHttpServletRequest req = (HttpServletRequest)request;\n\t\treq.setCharacterEncoding(\"UTF-8\");\n\t\tHttpServletResponse res = (HttpServletResponse)response;\n\t\tres.setContentType(\"text/html;charset=utf-8\");\n\t\tchain.doFilter(request, response);\n\t}\n```\n### ServletRequest接口\n![image.png](过滤器/1622452191050-6eab257d-a994-4b90-a897-4a518f700785.png)\n### 过滤器参数化\n◇过滤器为了增强灵活性，允许配置信息放在web.xml\n◇在web.xml中配置<init-param>设置过滤器参数\n◇优化字符集过滤器\n 代码演示：\n --xml配置\n```xml\n  <filter>\n       <filter-name>CharacterEncodingFilter</filter-name>\n       <filter-class>com.lcg.filter.CharacterEncodingFilter</filter-class>\n       <init-param>\n         <param-name>encoding</param-name> <!--参数名-->\n         <param-value>UTF-8</param-value>  <!--参数值-->\n       </init-param>\n  </filter> \n```\n--过滤器使用\n```java\n  private String encoding;//类中的全局私有变量\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tencoding = filterConfig.getInitParameter(encoding);//获取前面设置的参数\n\t}\n\n@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\t//必须强制转换为HttpServletResponse，与Servlet底层机制有关\n\t\tHttpServletRequest req = (HttpServletRequest)request;\n\t\treq.setCharacterEncoding(\"encoding\");\n\t\tHttpServletResponse res = (HttpServletResponse)response;\n\t\tres.setContentType(\"text/html;charset=\"+ encoding);\n\t\tchain.doFilter(request, response);\n\t}\n```\n--注解形式配置\n```java\n@WebFilter(filterName=\"CharacterEncodingFilter\",urlPatterns=\"/*\",\ninitParams= {\n\t\t@WebInitParam(name=\"encoding\",value=\"UTF-8\"),\n\t\t@WebInitParam(name=\"p1\",value=\"v1\"),\n\t\t@WebInitParam(name=\"p2\",value=\"v2\")\n})\n```\n### url-pattern设置过滤范围\n**url-pattern常用写法**\n◇/index.jsp - 执行资源精准匹配\n◇/servlet/* - 以前缀进行模糊匹配\n◇*.jsp - 以后缀进行模糊匹配\n**/映射的问题**\n◇/值映射Web应用根路径，且只对Servlet生效\n◇默认首页index.jsp会让/失效\n◇/与/*含义不同，前者指向根路径，后者代表所有\n◇设置默认首页index.jsp，会隐式的跳转到默认根路径：\"/\"，则会使配置的过滤器失效。\n◇设置多个过滤页面，就编写多个<filter-mapping>标签\n◇注解形式\n@WebFilter(filterName=\"\",urlPattrens={\"/\", \"/servlet/*\", \"*.jsp\"})\n### 过滤链开发注意事项\n◇每一个过滤器应具有单独职能\n◇过滤器的执行顺序以<filter-mapping>的书写前后顺序为准\n◇调用chain.doFilter()将请求向后传递\n◇会逆向返回，把输出语句放在chain.doFilter()语句后面，会发现过滤器倒序输出。如代码：\n```java\nchain.doFilter(request, response);\nSystem.out.println(\"I'm Filter A\");\n```\n因为此时先执行chain.doFilter()方法，就会先将请求向后传递，而不先执行打印方法；直到不再向后传递请求后(即到了C)，才执行打印方法，进行逆向的返回；因此会看到打印是C-B-A的逆序；\n◇使用注解形式的执行顺序，按照类名的名称执行；\n### 项目中过滤器的应用场景\n◇多端设备自动匹配\n --代码演示\n```java\npackage com.imooc.filter;\n\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DeviceAdapterFilter implements Filter{\n\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tHttpServletRequest req = (HttpServletRequest)request;\n\t\tHttpServletResponse res = (HttpServletResponse)response;\n\t\t/*\n\t\t /index.html\n\t\t PC: /desktop/index.html\n\t\t MOBILE: /mobile/index.html\n\t\t /test.html\n\t\t PC: /desktop/test.html\n\t\t MOBILE: /mobile/test.html\n\t\t */\n\t\tString uri = req.getRequestURI();\n\t\tSystem.out.println(\"URI:\" + uri);\n        //startWith判断是否以\"\"开头\n\t\tif(uri.startsWith(\"/desktop\") || uri.startsWith(\"/mobile\")) {\n            //如果输入的是正确的手机端和电脑端的uri,则不需处理,直接向后请求\n\t\t\tchain.doFilter(request, response);\n\t\t}else {\n            //否则,根据设备访问特定的uri\n\t\t\tString userAgent = req.getHeader(\"user-agent\").toLowerCase();\n\t\t\tString targetURI=\"\";\n\t\t\tif(userAgent.indexOf(\"android\")!=-1 || userAgent.indexOf(\"iphone\") != -1) {\n\t\t\t\ttargetURI = \"/mobile\" + uri;\n\t\t\t\tSystem.out.println(\"移动端设备正在访问,重新跳转URI:\" + targetURI);\n\t\t\t\t//sendRedirect()方法将页面重定向到指定的URL地址上\n                res.sendRedirect(targetURI);\n\t\t\t}else {\n\t\t\t\ttargetURI = \"/desktop\" + uri;\n\t\t\t\tSystem.out.println(\"PC端设备正在访问,重新跳转URI:\" + targetURI);\n\t\t\t\tres.sendRedirect(targetURI);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n\n```\n\n\n","tags":["Filter"],"categories":["JavaWeb"]},{"title":"Java正则表达式","url":"/p/830d.html","content":"## 什么是正则表达式\n◇正则表达式是检查、匹配字符串的表达式\n◇正则表达式是描述规则，主流语言都有良好支持\n◇字符串校验、查找与替换是正则表达式的主要使用场景\n## 正则表达式案例\n◇检查输入身份证号是否合法(15位，18位)\n◇示例：522725200012140613\n◇正则表达式：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})(\n[0-9]|X)$\n## 字符串匹配范围\n![image.png](Java正则表达式/1622273814688-c95bbe36-4de4-4097-926a-bdd9d272ae4c.png)\n##  元字符\n![image.png](Java正则表达式/1622275128906-171de557-e8e8-49e2-91ec-5cfc99b60ad5.png)\n◇eg：3213.383219  匹配四个整数，六个小数\n正则表达式1：[0-9][0-9][0-9][0-9].[0-9][0-9][0-9][0-9][0-9][0-9] \n可以看出原始方法过于繁琐\n正则表达式2：\\d\\d\\d\\d.\\d\\d\\d\\d\\d\\d\n\n## 多次重复匹配\n![image.png](Java正则表达式/1622275953538-2e523fbb-f7d7-4cdf-896b-aedc908f446a.png)\n## 定位匹配\n![image.png](Java正则表达式/1622292656494-fee0f93c-a372-4d1d-9762-867693b3d037.png)\n## 贪婪模式\n◇在满足条件的情况下尽可能多匹配到字符串（默认）\n◇eg：111222333 正则： \\d{6,8}  结果：11122233\n## 非贪婪模式\n◇在满足条件的情况下尽可能少匹配到字符串\n◇eg：111222333 正则： \\d{6,8}?  结果：111222\n## 表达式分组\n◇分组将\"正则\"分组为多个子表达式\n◇示例：abababcdcdcd \n◇正则表达式： (ab){3}(cd){3}\n## JavaScript表单验证\n --代码演示\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n    <form action=\"#\" method=\"post\" id=\"frmInfo\">\n        <div id=\"err\" style=\"color:red\">\n        \n        </div>\n        <div>\n                    姓名:<input id=\"name\" name=\"name\"/>\n        </div>\n        <div>\n                   身份证:<input id=\"idno\" name=\"idno\"/>\n        </div>\n        <div>\n             <input type=\"submit\"/>\n        </div>\n    </form>\n    <script type=\"text/javascript\">\n            document.getElementById(\"frmInfo\").onsubmit = function(){\n            \t//在JS中定义正则表达式只需在  /正则表达式/\n            \tvar regex1 = /^[\\u4e00-\\u9fa5]{2,8}$/;\n            \tvar regex2 = /^[1234568]\\d{16}[0-9xX]$/\n            \tvar name = document.getElementById(\"name\").value;\n            \tvar idno = document.getElementById(\"idno\").value;\n            \t//利用正则校验数据，true表示匹配\n            \tif(regex1.test(name)==false){\n            \t\tdocument.getElementById(\"err\").innerHTML=\"无效姓名\";\n            \t\treturn false;//在onsubmit中，return false代表表单不提交\n            \t}else if(regex2.test(idno)==false){\n            \t\tdocument.getElementById(\"err\").innerHTML=\"无效身份证号\";\n            \t\treturn false;\n            \t}\n            \telse{\n            \t\talert(\"success\");\n            \t\treturn true;\n            \t}\n            }\n    </script>\n</body>\n</html>\n```\n## Java中Web页面信息提取\n ◇html\n```java\n<!DOCTYPEhtml>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>国际主要城市</title>\n</head>\n<body>\n\t<h1>国际主要城市</h1>\n\t<ul>\n\t\t<li>纽约NewYork</li>\n\t\t<li>伦敦London</li>\n\t\t<li>东京Tokyo</li>\n\t\t<li>巴黎Paris</li>\n\t\t<li>香港HongKong</li>\n\t\t<li>新加坡Singapore</li>\n\t\t<li>悉尼Sydney</li>\n\t\t<li>米兰Milano</li>\n\t\t<li>上海Shanghai</li>\n\t\t<li>北京Beijing</li>\n\t\t<li>马德里Madrid</li>\n\t\t<li>莫斯科Moscow</li>\n\t\t<li>首尔Seoul</li>\n\t\t<li>曼谷Bangkok</li>\n\t\t<li>台北Taipei</li>\n        ...\n\t</ul>\n</body>\n</html>\n```\n◇regex类\n```java\npackage com.lcg.regex;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexSample {\n       public static void main(String[] args) {\n    \t   StringBuilder content = new StringBuilder();\n    \t   try {\n\t\t\tFileInputStream fis = \n\t\t   new FileInputStream(\"F:\\\\JAVA\\\\workspace\\\\regex\\\\WebContent\\\\sample.html\");\n\t\t\t//将二进制流转换为可读的字符串流\n\t\t\tInputStreamReader isr = new InputStreamReader(fis,\"UTF-8\");\n\t\t\t//缓冲流，提高对原始文件的读取效率\n\t\t\tBufferedReader bufferedReader = new BufferedReader(isr);\n\t\t\tString lineText=\"\";\n\t\t\twhile((lineText=bufferedReader.readLine())!=null) {\n\t\t\t\t\n\t\t\t\tcontent.append(lineText+\"\\n\");//将读取到的每一行数据追加到content中\n\t\t\t}\n\t\t\tbufferedReader.close();\n\t\t\t//System.out.println(content);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n    \t   //1.创建正则表达式对象\n    \t   //在字符串中\\前增加一个\\表示原义输出\n    \t  Pattern p = Pattern.compile(\"<li>([\\\\u4e00-\\\\u9fa5]{2,10})([a-zA-Z]+)</li>\");\n    \t  //2.匹配正则表达式\n    \t  Matcher m = p.matcher(content);\n    \t  //3.查找匹配结果\n    \t while( m.find()) {\n             //m.group(0)是匹配的完整字符串,1是第一个分组。\n    \t\t// System.out.println(m.group(0));\n    \t\tString chs = m.group(1);\n    \t\tString eng = m.group(2);\n    \t\tSystem.out.println(chs+\"-\"+eng);\n    \t }\n    \t \n       }\n}\n\n```\n","tags":["正则"],"categories":["JavaWeb"]},{"title":"JQuery与Ajax入门","url":"/p/b52a.html","content":"## JQuery\n### JavaScript库\n◇为了简化JavaScript开发，第三发厂商开发了JavaScript库\n◇主流JavaScript库有：JQuery, Vue.js, AngularJS, React...\n### jQuery介绍\n◇jQuery是一个轻量级的JS库，使用简单\n◇jQuery的核心是选择器，用于获取页面元素\n◇jQuery提供了大量高效方法，开发速度大幅提升\n### jQuery选择器实验室\n```html\n<!DOCTYPE html >\n\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>jQuery实验室</title>\n\n<style>\n.myclass {\n\tfont-style: italic;\n\tcolor: darkblue;\n}\n/* 高亮css类 */\n.highlight {\n\tcolor: red;\n\tfont-size: 30px;\n\tbackground: lightblue;\n}\n</style>\n\n</head>\n\n<body>\n\t<div class=\"section\">\n\t\t<h2>jQuery选择器实验室</h2>\n\t\t<input style=\"height: 24px\" id=\"txtSelector\" />\n\t\t<button id=\"btnSelect\" style=\"height: 30px\">选择</button>\n\t\t<hr />\n\t\t<div>\n\t\t\t<p id=\"welcome\">欢迎来到选择器实验室</p>\n\t\t\t<ul>\n\t\t\t\t<li>搜索引擎：<a href=\"http://www.baidu.com\">百度</a> <span> <a\n\t\t\t\t\t\tstyle=\"color: darkgreen\" href=\"http://www.so.com\">360</a>\n\t\t\t\t</span>\n\t\t\t\t</li>\n\t\t\t\t<li>电子邮箱：<a href=\"http://mail.163.com\">网易邮箱</a> <span> <a\n\t\t\t\t\t\tstyle=\"color: darkgreen\" href=\"http://mail.qq.com\">QQ邮箱</a>\n\t\t\t\t</span>\n\t\t\t\t</li>\n\t\t\t\t<li>中国名校：<a href=\"http://www.tsinghua.edu.cn\">清华大学</a> <span>\n\t\t\t\t\t\t<a style=\"color: darkgreen\" href=\"https://www.pku.edu.cn/\">北京大学</a>\n\t\t\t\t</span>\n\t\t\t\t</li>\n\t\t\t</ul>\n\n\t\t\t<span class=\"myclass \">我是拥有myclass类的span标签</span>\n\n\t\t\t<p class=\"myclass\">我是拥有myclass的p标签</p>\n\t\t\t<form id=\"info\" action=\"#\" method=\"get\">\n\t\t\t\t<div>\n\t\t\t\t\t用户名：<input type=\"text\" name=\"uname\" value=\"admin\" /> 密码：<input\n\t\t\t\t\t\ttype=\"password\" name=\"upsd\" value=\"123456\" />\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t婚姻状况： <select id=\"marital_status\">\n\t\t\t\t\t\t<option value=\"1\">未婚</option>\n\t\t\t\t\t\t<option value=\"2\">已婚</option>\n\t\t\t\t\t\t<option value=\"3\">离异</option>\n\t\t\t\t\t\t<option value=\"4\">丧偶</option>\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"left clear-left\">\n\t\t\t\t\t<input type=\"submit\" value=\"提交\" /> <input type=\"reset\" value=\"重置\" />\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t</div>\n\t</div>\n\t<script type=\"text/javascript\" src=\"js/jquery-3.6.0.min.js\" ></script>\n\t<script type=\"text/javascript\">\n\t\t/*\n\t\t\tid选择器使用\"#id值\"进行选择\n\t\t\tcss选择器使用\".css类名\"进行选择\n\t\t\t$(\".myclass\").addClass(\"highlight\");\n\t\t*/\n\t\t\n\t\t//单击事件\n\t\tdocument.getElementById(\"btnSelect\").onclick = function(){\n\t\t\tvar selector = document.getElementById(\"txtSelector\").value;//获取文本框的值\n\t\t\t//jquery的选择器方法\n\t\t\t//()里是选择器表达式 \n\t\t\t$(\"*\").removeClass(\"highlight\");//清除高亮类\n\t\t\t$(selector).addClass(\"highlight\");//selector本身是字符串，故不用加\"\"\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n### Web页面开发的两个要素\n◇在使用HTML开发页面时，有两个基本点：\n  *选择HTML页面上在哪些元素\n  *在这些元素上做哪些动作\n### jQuery选择器\n◇jQuery选择器用于选中需要操作的页面元素\n◇语法1：jQuery(选择器表达式)\n◇语法2：$(选择器表达式)\n### 基本选择器\n◇基本选择器是jQuery最基础也是最常用的选择器表达式\n![image.png](JQuery与Ajax入门/1622000697052-bd3743b2-5284-4538-8aec-3addb144eca8.png)\n--代码演示\n```html\n$(\"#marital_status\").addClass(\"highlight\");\n$(\".myclass\").addClass(\"highlight\");\n$(\"a\").addClass(\"highlight\");\n$(\".myclass,a,#marital_status\").addClass(\"highlight\");\n```\n### 层叠选择器\n◇层叠选择器是根据元素的位置关系来获取元素的选择器表达式\n![image.png](JQuery与Ajax入门/1622001501455-7caa1401-306c-41d3-9717-de2a8f36711b.png)\n◇后代选择器：选择所有后代\n◇子选择器：只选择直接后代\n◇兄弟选择器：选择prev之后的同级\n### 属性选择器\n◇属性选择器是根据元素的属性值来选择元素的选择器表达式\n![image.png](JQuery与Ajax入门/1622011699656-4fdc2371-67ce-4af1-9a96-bad348a64a3b.png)\neg：$(\"a[href='http://www.baidu.com']\")\n\n\n### 位置选择器与表单选择器（了解即可）\n◇位置选择器是通过位置获取指定的元素，例如\"获取第3个元素\"\n![image.png](JQuery与Ajax入门/1622013491362-933571db-7fd4-4eed-ab07-4ee7bd1dd5f0.png)\neg：$(\".myclass:first\")\n◇表单选择器是获取表单元素的简化形式，例如：获取所有文本框\n![image.png](JQuery与Ajax入门/1622013766935-41de19ac-12ec-4c40-83ba-95c7b835f512.png)\n### 操作元素属性\n◇attr(name|properties|key) - 获取或设置元素属性\n◇removeAttr(name) - 移除元素属性\n代码示例：\n```html\n<script type=\"text/javascript\" src=\"js/jquery-3.6.0.min.js\" ></script>\n<script type=\"text/javascript\">\n\t\tvar href_attr =  $(\"a[href*='163']\").attr(\"href\");//获取href属性\n\t\talert(href_attr);\n\t\t$(\"a[href*='163']\").attr(\"href\" , \"http://www.163.com\");//传递两个参数，则为设置属性\n  \n\t\tvar attr = $(\"a\").attr(\"href\");//获取当前网页的所有超链接\n\t\talert(attr);\n\t\t$(\"a\").removeAttr(\"href\");\n\t</script>\n```\n◇var attr = $(\"a\").attr(\"href\");如果选中多个属性，在用attr获取多个属性值的时候，默认返回第一个href属性值，而设置则会把所有超链接都设置。总之，在获取属性值时，只会返回第一个符合要求的属性值；而设置属性值时，将所有属性值设置。\n### 操作元素的CSS样式\n◇css() -获取或设置匹配元素的样式属性\n◇addClass() -为每个匹配的元素添加指定的类名\n◇removeClass() - 从所有匹配的元素中删除全部或者指定的类\n代码示例：\n```html\n<script type=\"text/javascript\" src=\"js/jquery-3.6.0.min.js\" ></script>\n    <script type=\"text/javascript\">\n     $(\"a\").css(\"color\",\"red\");//将当前页面所有超链接改成红色\n     //一次性设置多个属性值\n     $(\"a\").css({\"color\":\"red\",\"font-weight\":\"bold\",\"font-style\":\"italic\"});\n     var color = $(\"a\").css(\"color\");//获取匹配元素(第一个)属性值\n     $(\"li\").addClass(\"highlight\");//添加类，多个类用空格分开\n    </script>\n```\n### 设置元素内容\n◇val() -获取或设置输入项的值\n◇text() -获取或设置元素的纯文本\n◇html() -获取或设置元素内部的HTML\n代码示例：\n```html\n<script type=\"text/javascript\" src=\"js/jquery-3.6.0.min.js\" ></script>\n    <script >\n       //设置文本框的数据\n       $(\"input[name='uname']\").val(\"adminstrator\");\n       //获取文本框的数据\n      var n =  $(\"input[name='uname']\").val();\n       /*text与html方法最大的区别在于对于文本中的html标签是否\n                  进行转义*/    \n      $(\"span.myclass\").text(\"男儿何不带吴钩\");\n      $(\"p.myclass\").html(\"<b>收取关山五十州</b>\");\n      //获取属性\n      var m = $(\"p.myclass\").html();\n    </script>\n```\n### jQuery事件处理方法\n◇on(\"click\", function) - 为选中的页面元素绑定单击事件\n◇click(function) - 是绑定事件的简写形式\n◇处理方法中提供了event参数包含了事件的相关信息\n![image.png](JQuery与Ajax入门/1622034100363-a2668116-3ab1-415e-a75a-f86d316721e8.png)\n代码示例：\n\n```html\n\t<script type=\"text/javascript\" src=\"js/jquery-3.6.0.min.js\" ></script>\n    <script >\n      $(\"p.myclass\").on(\"click\",function(){\n    \t  //$(this)是指当前事件产生的对象\n    \t  $(this).css(\"background-color\",\"yellow\");    \t  \n      })\n     //简化方法\n      $(\"span.myclass\").click(function(){\n    \t  $(this).css(\"background-color\",\"pink\"); \n      })\n      //键盘事件,输入空格显示红色警告\n      $(\"input[name='uname']\").keypress(function(event){\n    \t  if(event.key==\" \"){\n    \t\t $(this).css(\"color\",\"red\");\n    \t  }\n      })\n    </script>\n```\n## Ajax\n### Ajax介绍\n◇Asynchronous JavaScript And XML(异步的JavaScript和XML)\n◇Ajax可以在不刷新页面的前提下，进行页面局部更新\n◇Ajax不是新的技术，Ajax并不是W3C的标准\n### Ajax的使用流程\n◇创建XmlHttpRequest对象\n   -XmlHttpRequest用于在后台与服务器交换数据，是AJAX的核心\n   -XmlHttpRequest并不是W3C的标准，不同浏览器创建方式不同\n   -通用创建代码：\n\n```html\nvar xmlhttp;\n    \t if(window.XMLHttpRequest){\n    \t\t xmlhttp = new XMLHttpRequest();//火狐，谷歌等新版本浏览器\n    \t }else{\n    \t\t //IE5,IE6等老版本浏览器代码\n    \t\t xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    \t }\n  \n```\n◇发送Ajax请求\n   -xmlhttp.open()用于创建请求\n   -xmlhttp.send()用于发送请求\n   -代码：\n```html\n//发送Ajax请求\n         xmlhttp.open(\"GET\", \"/ajax/content\", \"ture\");//true表示此请求为异步方式\n         xmlhttp.send();\n```\n◇处理服务器响应\n  -xmlhttp.onreadystatechange()事件用于监听AJAX的执行过程\n  -xmlhttp.readyState属性说明XMLHttpRequest当前状态\n  ![image.png](JQuery与Ajax入门/1622037904791-2080ff74-3e5e-4938-917e-213d58d852c9.png)\n  -xmlhttp.status属性服务器响应状态码， 200：成功 ；404：未找到 ...\n  -代码示例：\n\n```html\n        //处理服务器响应\n        xmlhttp.onreadystatechange = function(){\n        \tif(xmlhttp.readyState == 4&& xmlhttp.status == 200){\n        \t\tvar t = xmlhttp.responseText;\n        \t\talert(t);\n        \t\t//处理服务器响应文本\n        \t\tdocument.getElementById(\"divContent\").innerHTML = t;\n        \t}\n        }\n```\n### 利用Ajax实现新闻列表\n 开发模式：\n  ①创建新闻类，设置新闻的格式框架\n\n```java\npackage com.lcg.ajax;\n\npublic class News {\n     private String title;\n     private String date;\n     private String source;\n     private String content;\n     \n     public News() {\n    \t \n     }\n\tpublic News(String title, String date, String source, String content) {\n\t\tsuper();\n\t\tthis.title = title;\n\t\tthis.date = date;\n\t\tthis.source = source;\n\t\tthis.content = content;\n\t}\n\tpublic String getTitle() {\n\t\treturn title;\n\t}\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\tpublic String getDate() {\n\t\treturn date;\n\t}\n\tpublic void setDate(String date) {\n\t\tthis.date = date;\n\t}\n\tpublic String getSource() {\n\t\treturn source;\n\t}\n\tpublic void setSource(String source) {\n\t\tthis.source = source;\n\t}\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\tpublic void setContent(String content) {\n\t\tthis.content = content;\n\t}\n     \n}\n\n```\n②创建Servlet，初始化新闻数据，并将数据[序列化](https://blog.csdn.net/xlgen157387/article/details/79840134)\n```java\npackage com.lcg.ajax;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.alibaba.fastjson.JSON;\n\n/**\n * Servlet implementation class NewsListServlet\n */\n@WebServlet(\"/newslist\")\npublic class NewsListServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n       \n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public NewsListServlet() {\n        super();\n        // TODO Auto-generated constructor stub\n    }\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n        throws ServletException, IOException {\n\t\tList list = new ArrayList();\n\t\tlist.add(new News(\"TIOBE:2018年5月份全球编程语言排行榜\",\"2018-5-1\",\"TIBOE\",\"...\"));\n\t\tlist.add(new News(\"TIOBE:2018年6月份全球编程语言排行榜\",\"2018-6-1\",\"TIBOE\",\"...\"));\n\t\tlist.add(new News(\"TIOBE:2018年7月份全球编程语言排行榜\",\"2018-7-1\",\"TIBOE\",\"...\"));\n\t\tlist.add(new News(\"TIOBE:2018年8月份全球编程语言排行榜\",\"2018-8-1\",\"TIBOE\",\"...\"));\n\t\t//转换为json对象\n        String json = JSON.toJSONString(list);//fastjson为java提供的json对象\n\t\tSystem.out.print(json);\n\t\tresponse.setContentType(\"text/html;charset=UTF-8\");\n        //list集合在早期采用转换为xml传输，现在使用json来序列化，\n\t\tresponse.getWriter().println(json);\n\t}\n\n}\n```\n③实现页面，将json转为html输出\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n   <div id=\"container\">\n      \n   </div>\n   <script type=\"text/javascript\">\n      //1.创建XMLHttpRequest\n      var xmlhttp;\n    \t if(window.XMLHttpRequest){\n    \t\t xmlhttp = new XMLHttpRequest();//火狐，谷歌等新版本浏览器\n    \t }else{\n    \t\t //IE5,IE6等老版本浏览器代码\n    \t\t xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    \t }\n     \n      //2.发送Ajax请求\n       xmlhttp.open(\"GET\", \"/ajax/newslist\", \"ture\");//true表示此请求为异步方式\n         xmlhttp.send();\n       \n       //3.处理服务器响应\n        xmlhttp.onreadystatechange = function(){\n        \tif(xmlhttp.readyState == 4&& xmlhttp.status == 200){\n        \t\tvar text = xmlhttp.responseText;\n        \t\tconsole.log(text);\n        \t\tvar json = JSON.parse(text);//JavaScript内置的JSON对象\n        \t\tconsole.log(json);\n        \t\tvar html =\" \";\n        \t\t//循环输出新闻\n        \t\tfor(var i = 0;i<json.length;i++){\n        \t\t\tvar news = json[i];\n        \t\t\thtml=html+\"<h1>\"+news.title+\"</h1>\";\n        \t\t\thtml=html+\"<h2>\"+news.date+\"&nbsp;\"+news.source+\"</h2>\";//&nbsp表示空格\n        \t\t\thtml=html+\"<hr/>\";//分割\n        \t\t}\n        \t\t//处理服务器响应文本,实现动态加载\n        \t\tdocument.getElementById(\"container\").innerHTML=html;\n        \t}\n        }\n   </script>\n</body>\n</html>\n```\n### 同步与异步的区别\n◇同步：只有前面的执行完成后，后面的才能执行，代码处于阻塞状态；\n◇异步：在网络发送过程中，不进行代码的阻塞；\n## Ajax函数\n### jQuery对Ajax的支持\n◇jQuery对Ajax进行封装，提供了$.ajax()方法\n◇语法：$.ajax(options)\n![image.png](JQuery与Ajax入门/1638068967671-df8f5e0b-0ec4-4195-80c6-90fb17a455c9.png)\n\n- jsonp：解决数据跨域传输问题\n### 函数使用方法\n  --Servlet\n```java\n\t@SuppressWarnings(\"null\")\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t// 获取传递参数?t=pypl|tiobe\n\t\tString type = request.getParameter(\"t\");\n\t\tList list = new ArrayList();\n\t\tif (type != null && type.equals(\"pypl\")) {\n\n\t\t\tlist.add(new News(\"PYPL:2018年4月份全球编程语言排行榜\", \"2018-5-1\", \"PYPL\", \"...\"));\n\t\t\tlist.add(new News(\"PYPL:2018年5月份全球编程语言排行榜\", \"2018-6-1\", \"PYPL\", \"...\"));\n\t\t\tlist.add(new News(\"PYPL:2018年6月份全球编程语言排行榜\", \"2018-7-1\", \"PYPL\", \"...\"));\n\t\t\tlist.add(new News(\"PYPL:2018年7月份全球编程语言排行榜\", \"2018-8-1\", \"PYPL\", \"...\"));\n\n\t\t} else if (type != null && type.equals(\"tiobe\")) {\n\n\t\t\tlist.add(new News(\"TIOBE:2018年4月份全球编程语言排行榜\", \"2018-5-1\", \"TIBOE\", \"...\"));\n\t\t\tlist.add(new News(\"TIOBE:2018年5月份全球编程语言排行榜\", \"2018-6-1\", \"TIBOE\", \"...\"));\n\t\t\tlist.add(new News(\"TIOBE:2018年6月份全球编程语言排行榜\", \"2018-7-1\", \"TIBOE\", \"...\"));\n\t\t\tlist.add(new News(\"TIOBE:2018年7月份全球编程语言排行榜\", \"2018-8-1\", \"TIBOE\", \"...\"));\n\n\t\t}\n\t\tString json = JSON.toJSONString(list);// fastjson为java提供的json对象\n\t\tSystem.out.print(json);\n\t\tresponse.setContentType(\"text/html;charset=UTF-8\");\n\t\tresponse.getWriter().println(json);\n\t}\n```\n--jquery_news.html\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n<script type=\"text/javascript\" src=\"js/jquery-3.3.1.js\"></script>\n<script>\n  //jQuery对Ajax的支持\n$(function(){\n\t$.ajax({\n\t\t\"url\" : \"/ajax/newslist\",\n\t\t\"type\" : \"get\" ,\n\t\t\"data\" : {\"t\":\"pypl\", \"abc\":\"123\", \"uu\":\"777\"},\n\t\t//\"data\":\"t=pypl&abc=123&uu=777\",多个参数时可用json格式写，但最终还是转换为这种形式\n\t\t\"dataType\" : \"json\" ,\n\t\t\"success\" : function(json){\n\t\t\tconsole.log(json);\n\t\t\tfor(var i = 0 ; i < json.length ; i++){\n\t\t\t\t$(\"#container\").append(\"<h1>\" + json[i].title + \"</h1>\");\n\t\t\t}\n\t\t},\n\t\t//xmlhttp对象，errorText错误文本\n\t\t\"error\":function(xmlhttp,errorText){\n\t\t\tconsole.log(xmlhttp);\n\t\t\tconsole.log(errorText);\n\t\t\t//根据错误状态码显示错误信息\n\t\t\tif(xmlhttp.status==\"405\"){\n\t\t\t\talert(\"无效的请求方式\");\n\t\t\t}else if(xmlhttp.status==\"404\"){\n\t\t\t\talert(\"未找到URL资源\");\n\t\t\t}else if(xmlhttp.status==\"500\"){\n\t\t\t\talert(\"服务器内部错误，请联系管理员\");\n\t\t\t}\n\t\t}\t\n\t})\n})\n</script>\n</head>\n<body>\n  <div id=\"container\"></div>\n</body>\n</html>\n```\n### 实现二级联动菜单\n①类实现\n```java\npackage com.lcg.ajax;\n\npublic class Channel {\n   private String code;\n   private String name;\npublic Channel() {\n\t\n}\npublic Channel(String code, String name) {\n\tsuper();\n\tthis.code = code;\n\tthis.name = name;\n}\npublic String getCode() {\n\treturn code;\n}\npublic void setCode(String code) {\n\tthis.code = code;\n}\npublic String getName() {\n\treturn name;\n}\npublic void setName(String name) {\n\tthis.name = name;\n}\n   \n}\n```\n②数据初始化\n```java\n\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tString level = request.getParameter(\"level\");//根据level判断查询哪一频道\n\t\tString parent = request.getParameter(\"parent\");\n\t\tList chlist = new ArrayList();\n\t\tif(level.equals(\"1\")) {\n\t\t\tchlist.add(new Channel(\"ai\",\"前沿/区块链/人工智能\"));\n\t\t\tchlist.add(new Channel(\"web\",\"前端/小程序/JS\"));\t\t\t\n\t\t}else if(level.equals(\"2\")) {\n\t\t\tif(parent.equals(\"ai\")) {\n\t\t\t\tchlist.add(new Channel(\"micro\" , \"微服务\"));\n\t\t\t\tchlist.add(new Channel(\"blockchain\" , \"区块链\"));\n\t\t\t\tchlist.add(new Channel(\"other\" , \"...\"));\n\t\t\t}else if(parent.equals(\"web\")){\n\t\t\t\tchlist.add(new Channel(\"html\" , \"HTML\"));\n\t\t\t\tchlist.add(new Channel(\"css\" , \"CSS\"));\n\t\t\t\tchlist.add(new Channel(\"other\" , \"...\"));\n\t\t\t}\n\t\t\t\n\t\t}\n        //JSON序列化\n\t\tString json = JSON.toJSONString(chlist);\n\t\tresponse.setContentType(\"text/html;charset=utf-8\");\n\t\tresponse.getWriter().println(json);\n\t}\n\n}\n\n```\n③页面显示\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n<script type=\"text/javascript\" src=\"js/jquery-3.6.0.min.js\"></script>\n<script>\n //页面就绪函数\n  $(function(){\n\t  $.ajax({\n\t\t  \"url\":\"/ajax/channel\",\n\t\t  \"data\":{\"level\":\"1\"},\n\t\t  \"type\":\"get\",\n\t\t  \"dataType\":\"json\",\n\t\t  \"success\":function(json){\t\t\t  \n\t\t\t  for(var i=0;i<json.length;i++){\n\t\t\t\t  var ch = json[i];\n\t\t\t\t  $(\"#lv1\").append(\"<option value='\"+ch.code+\"'>\"+ch.name+\"</option>\")\n\t\t\t  }\n\t\t  }\n\t  })\n  })\n  //页面就绪函数，联动二级频道的数据\n  $(function(){\n\t  $(\"#lv1\").on(\"change\",function(){\n\t\t var parent = $(this).val();\n\t\t $.ajax({\n\t\t\t \"url\":\"/ajax/channel\",\n\t\t  \"data\":{\"level\":\"2\", \"parent\":parent},\n\t\t  \"type\":\"get\",\n\t\t  \"dataType\":\"json\",\n\t\t  \"success\":function(json){\n\t\t\t  //清除lv2下的原始option选项\n\t\t\t  $(\"#lv2>option\").remove();\n\t\t\t  for(var i=0;i<json.length;i++){\n\t\t\t\t  var ch = json[i];\n\t\t\t\t  $(\"#lv2\").append(\"<option value='\"+ch.code+\"'>\"+ch.name+\"</option>\")\n\t\t\t  }\n\t\t\t}\n\t\t })\n\t  })\n  })\n</script>\n</head>\n<body>\n  <!-- 一级栏目 -->\n   <select id=\"lv1\" style=\"width:200px;height:30px\">\n     <option selected=\"selected\">请选择</option>\n   </select>\n     <!-- 二级栏目 -->\n    <select id=\"lv2\" style=\"width:200px;height:30px\">\n   </select>\n</body>\n</html>\n```\n\n","tags":["Ajax"],"categories":["JavaWeb"]},{"title":"JSON入门","url":"/p/2e67.html","content":"## 导学\n◇JSON入门\n![](JSON入门/json1.png)\n◇jQuery与Ajax\n![image.png](JSON入门/1621691727620-f229e1ef-0355-4ca4-b1f8-a78a190a3aab.png)\n◇正则表达式\n![image.png](JSON入门/1621691774734-85ef74a4-f19e-4d97-be1d-c0f93391b2fd.png)\n◇过滤器\n![image.png](JSON入门/1621691814986-c7ba612d-cb16-405a-bac5-19710f119e1d.png)\n\n## JSON语法规则\n### JSON介绍\n◇JavaScript Object Notation(JavaScript对象表示法)\n◇JSON是轻量级的文本数据交换格式\n◇JSON独立于语言，具有自我描述性，更易理解\n◇示例代码：\n\n```json\n{\n    \"sites\":[\n        {\"name\":\"张珊\",\"age\":\"22\"},\n        {\"name\":\"李肆\",\"age\":\"21\"}\n    ]\n}\n```\n\n### JSON语法规则\n◇数据由键(key)/值(value)描述，由逗号分隔；键和值均用\"\"包裹。\n◇大括号代表一个完整的对象，拥有多个键/值对\n◇中括号保存数组，多个对象之间使用逗号分隔，最后一个不用\n### 代码演示\n --在JavaScript中\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n<script type=\"text/javascript\">\n   var json = [\n\t\t{\n\t\t\t\"empno\": \"2023\",\n\t\t\t\"ename\": \"李才刚\",\n\t\t\t\"job\": \"首席执行官\",\n\t\t\t\"hiredate\": \"2025-06-18\",\n\t\t\t\"salary\": \"500000\",\n\t\t\t\"dname\": \"董事会\"\n\t\t},\n\t\t{\n\t\t\t\"empno\": \"2021\",\n\t\t\t\"ename\": \"石磊\",\n\t\t\t\"job\": \"客服经理\",\n\t\t\t\"hiredate\": \"2028-01-26\",\n\t\t\t\"salary\": \"8000\",\n\t\t\t\"dname\": \"市场部\",\n\t\t\t\"customers\": [\n\t\t\t\t{\n\t\t\t\t\t\"cname\": \"吴浩\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"cname\": \"方传书\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t];\n   //在浏览器控制台中对json内容进行输出\n   console.log(json);\n  //在浏览器页面进行输出\n   for(var i = 0 ; i < json.length ; i++){\n\t\tvar emp = json[i];\n\t\tdocument.write(\"<h1>\");\n\t\tdocument.write(emp.empno);\n\t\tdocument.write(\",\" + emp.ename);\n\t\tdocument.write(\",\" + emp.job);\n\t\tdocument.write(\",\" + emp.hiredate);\n\t\tdocument.write(\",\" + emp.salary);\n\t\tdocument.write(\",\" + emp.dname);\n\t\t\n\t\tdocument.write(\"</h1>\");\n\t\tif(emp.customers != null){\n\t\t\tdocument.write(\"<h2>---\")\n\t\t\tfor(var j = 0 ; j < emp.customers.length ; j++){\n\t\t\t\tvar customer = emp.customers[j];\n\t\t\t\tdocument.write(customer.cname + \",\")\n\t\t\t}\n\t\t\tdocument.write(\"</h2>\")\n\t\t}\n\t}\n</script>\n</head>\n<body>\n  \n</body>\n</html>\n```\n### JSON与字符串互相转换(在js中)\n◇JSON.parse()方法将字符串转换为JSON对象\n◇JSON.stringify()方法将JSON对象转换为字符串\neg：\n```html\n    <script type=\"text/javascript\">\n       var str = \"{\\\"class_name\\\":\\\"五年级三班\\\"}\";\n       var json=JSON.parse(str);\n       console.log(str);\n       console.log(json);\n    </script>\n```\n◇原始的字符串和json对象打印显示在浏览器控制台中；第一行是原始的字符串；下面就是json对象(Object);json对象中包含一个class_name的属性，值为\"五年级三班\"\n![image.png](JSON入门/1639015024279-78c32a91-bc3c-4150-a564-5cf8566858af.png)\n\n```html\n<script type=\"text/javascript\">\n      var json={\"class_name\":\"五年级三班\"};\n      var str = JSON.stringify(json);\n    </script>\n```\n--初始化json的另一种方法\n```json\nvar json ={};//先定义\njson.class_name=\"五年级三班\";\njson.teacher=\"王老师\";\n```\n## JSON与Java交互\n### FastJson工具包\n◇Java的JSON工具包还有FastJson、Jackson、Gson、Json-lib...\n◇FastJson是阿里著名的JSON序列化与反序列工具包\n◇FastJson国内拥有大量使用者，拥有API简单，效率高等优点\n### FastJson序列化与JSON注解\n --单个\n```json\n@JSONField(format=\"yyyy-MM-dd\")//注解，格式化输出日期\nprivate Date hdate;\n@JSONField(serialize=false)//不对下面的dname成员序列化\nprivate String dname;\nString json = JSON.toJSONString(employee);\nEmployee emp = JSON.parseObject(json,Employee.class);//将JSON反序列化\n```\n--多个\n```json\npackage com.lcg.json;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.alibaba.fastjson.JSON;\n\npublic class FastJsonSample2 {\n      public static void main(String[] args) {\n    \t  List emplist = new ArrayList();\n    \t  //模拟100个员工\n    \t  for(int i =1;i<=100;i++) {\n    \t\t  Employee employee = new Employee();\n    \t\t  employee.setEmpno(2020+i);\n    \t\t  employee.setEname(\"员工\"+i);\n    \t\t  emplist.add(employee);\n    \t  }\n    \t  String json = JSON.toJSONString(emplist);\n    \t  //将转换后的字符解析成链表\n    \t  List<Employee> emps = JSON.parseArray(json,Employee.class);\n    \t  for(Employee e:emps) {\n    \t\t  System.out.println(e.getEmpno()+\":\"+e.getEname());\n    \t  }\n      }\n}\n\n```\n\n","tags":["JSON"],"categories":["JavaWeb"]},{"title":"JSTL与EL表达式","url":"/p/5d7.html","content":"## 初识EL表达式\n### EL表达式\n◇EL(**E**xpression **L**anguage)表达式语言，用于简化JSP的输出\n◇EL表达式的基本语法：${表达式}\neg：\n\n```html\nJSP：<h1>学生姓名：<%=student.name%> </h1>\nEL：<h1>学生姓名：${student:name}</h1>\n```\n\n\n◇代码演示\n --学生信息类\n\n```java\npackage com.gamest.el;\n\npublic class Student {\n    private String name;\n    private String mobile;\n \tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getMobile() {\n\t\treturn mobile;\n\t}\n\tpublic void setMobile(String mobile) {\n\t\tthis.mobile = mobile;\n\t}\n   \n}\n```\n  --Servlet初始化\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\t  Student stu = new Student();\n\t\t  stu.setName(\"李与析\");\n\t\t  stu.setMobile(\"HUAWEI\");\n\t\t  String grade = \"A\";\n\t\t  //info.jsp用来展现学生信息，studentservlet用来初始化\n\t\t  request.setAttribute(\"student\", stu);\n\t\t  request.setAttribute(\"grade\", grade);\n\t\t  request.getRequestDispatcher(\"/info.jsp\").forward(request, response);\n\t\t  \n\t}\n```\n  --JSP显示信息(传统方法)\n```java\n<body>\n   <%\n     Student stu =  (Student)request.getAttribute(\"student\");\n     String grade = (String)request.getAttribute(\"grade\");\n     out.println(\"<h1>姓名：\"+stu.getName()+\"</h1>\");\n     out.println(\"<h2>手机：\"+stu.getMobile()+\"</h2>\");\n     out.println(\"<h1>教师等级：\"+grade+\"</h1>\");\n   %>\n</body>\n```\n --EL表达式方法\n```java\n<body>\n   <h1>姓名：${requestScope.student.name}</h1>\n   <h1>手机：${requestScope.student.mobile}</h1>\n   <h1>评级：${requestScope.grade}</h1>\n</body>\n```\n###  作用域对象\n◇EL表达式内置四种作用域对象\n![](1.png)\n代码示例：\n --将学生信息放在session会话中\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t  Student stu = new Student();\n\t\t  stu.setName(\"李与析\");\n\t\t  stu.setMobile(\"HUAWEI\");\n\t\t  String grade = \"A\";\n      //将学生信息放在session会话中\n\t\t  HttpSession session = request.getSession();\t\t \n\t\t  session.setAttribute(\"student\", stu);\n\t\t  session.setAttribute(\"grade\", grade);\n\t\t  request.getRequestDispatcher(\"/info.jsp\").forward(request, response);\n\t\t  \n\t}\n```\n --则应当使用sessionScope\n```java\n<body>\n   <h1>姓名：${sessionScope.student.name}</h1>\n   <h1>手机：${sessionScope.student.mobile}</h1>\n   <h1>评级：${sessionScope.grade}</h1>\n</body>\n```\n --EL也可以忽略作用域对象\n 它会自动按作用域从小到大的顺序获取(page -> application)若都没有，则会输出空字符串；\n```java\n<body>\n   <h1>姓名：${student.name}</h1>\n   <h1>手机：${student.mobile}</h1>\n   <h1>评级：${grade}</h1>\n</body>\n```\n### EL表达式输出\n◇语法: ${[作用域].属性名.[子属性]}\n◇EL表达式支持将运算结果进行输出\n◇EL支持绝大多数对象输出，本质是调用toString()方法\neg：\n${title} //将自定义属性title输出\n${emp.salary + 300} //算术运算\n${1<=3&&2>4}\n​\n\n通过改写toString()方法可以就可以使用EL表达式按照自定义的格式输出对象:\n```java\npublie String toString(){\n  return name + \":\" + moblie;\n}\n\n直接输出对象，student具有子属性；\n${student};\n```\n### EL输出参数值\n◇EL表达式内置param对象来简化参数的输出\n◇语法:${param.参数名}  eg：${param.teacher}； 浏览器输入：?teacher=王老师\n## JSTL\n### JSTL标签库\n◇JSTL(JSP Standard Tag Library),JSP标准标签库\n◇JSTL用于简化JSP开发，提高代码可读性与可维护性\n◇JSTL由SUN(Oracle)定义规范，由Apache Tomcat团队实现\n### 下载JSTL标签库\n◇官方地址：http://tomcat.apache.org\n◇JSTL v1.2.5组件介绍\n![](2.png)\n\n如果需要默认支持JSTL，则需将前两个包复制到Tomcat\\apache-tomcat-8.5.34\\lib目录中；仅工程目录的话，就复制到工程文件的lib中。\n### JSTL的标签库种类\n◇JSTL按功能划分可分为五类标签库\n![](3.png)\n**引用JSTL核心库**\n◇核心标签库(Core)是JSTL最重要的标签库，提供了JSTL的基础功能\n◇<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n◇JSTL核心标签库在taglibs-standard-impl,jar由META-INF/c.tld定义\n\n### 判断标签\n◇JSTL核心库提供了两组判断的标签\n◇<c:if> -单分支判断\n◇<c:choose> 、<c:when>、<c:otherwise> - 多分支判断\n◇代码演示：\n  --Servlet数据端\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\trequest.setAttribute(\"score\", 100);\n\t\trequest.setAttribute(\"grade\", \"A\");\n\t\trequest.getRequestDispatcher(\"/core.jsp\").forward(request, response);\n\t}\n```\n --JSP\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n    <!--在java或者jsp文件中按住Alt+/可以出现智能提示  -->\n <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n   <h1>${requestScope.score}</h1>  <!--  EL表达式 -->\n   <c:if test =\"${score>=90}\"> <!--  单分支判断 -->\n   <h1 style = \"color:green\">恭喜，你已通过考试</h1>\n   </c:if>\n   <c:if test=\"${score<90}\">\n     <h1 style = \"color:red\">很遗憾，请再接再厉</h1>\n   </c:if>\n   \n   <!--  choose when otherwise -->\n   ${grade}\n   <c:choose>   <!--  多分支 -->\n         <c:when test=\"${grade=='A'}\"><h2>你很优秀</h2></c:when>\n         <c:when test=\"${grade=='B'}\"><h2>你很不错</h2></c:when>\n         <c:when test=\"${grade=='C'}\"><h2>勉强及格</h2></c:when>\n         <c:otherwise> <h2>再接再厉</h2></c:otherwise>\n   </c:choose>\n</body>\n</html>\n```\n### 遍历集合\n◇<c:forEach>标签用于遍历集合(Collection)中的每一个对象\n![](4.png)\n◇代码演示\n  --Java创建公司类\n\n```java\npackage com.lcg.jstl;\n\npublic class Company {\n       private String cname;\n       private String url;\n\tpublic Company(String cname,String url) {\n\t\tthis.cname=cname;\n\t\tthis.url=url;\n\t}\n \tpublic String getCname() {\n\t\treturn cname;\n\t\t}\n\tpublic void setCname(String cname) {\n\t\tthis.cname = cname;\n\t}\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n}\n```\n --Servlet初始化\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\tArrayList<Company> list=new ArrayList<Company>();\n\t\tlist.add(new Company(\"百度\",\"www.baidu.com\"));\n\t\tlist.add(new Company(\"腾讯\",\"www.tencent.com\"));\n\t\tlist.add(new Company(\"交通\",\"www.gamest.link\"));\n\t\trequest.setAttribute(\"companies\", list);\n\t\trequest.getRequestDispatcher(\"/core.jsp\").forward(request, response);\n\t}\n```\n --core.jsp使用\n```java\n <!-- forEach标签用于遍历集合  java代码实现\n     List companies =(List)request.getAttribute(\"companies\");\n     for(Company c : companies){\n       out.print(\"...\")\n     }\n   -->\n       <!--items数据来源  var 数据变量  varStatus变量状态(第几个) -->\n   <c:forEach items=\"${requestScope.companies}\" var=\"c\" varStatus=\"idx\">\n        <h2>${idx.index+1}.${c.cname}--${c.url}</h2>\n   </c:forEach>\n```\n### 格式化标签库\n◇fmt格式化标签库 URL:http://java.sun.com/jsp/jstl/fmt\n◇<fmt:formatDate value=\"\" pattern =\"\" > 格式化日期标签\n◇<fmt:formatNumber value=\"\" pattern =\"\" > 格式化数字标签\n◇代码演示\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n       <%\n          request.setAttribute(\"amt\",1575101.585);\n          request.setAttribute(\"now\",new java.util.Date());\n          request.setAttribute(\"html\", \"<a href='index.html'>index</a>\");\n          request.setAttribute(\"nothing\",null);\n       %>\n       <!-- \n         formatDate pattern\n         yyyy  -四位年\n         MM - 两位月\n         dd - 两位日\n         HH - 24小时制\n         hh - 12小时制\n         mm - 分钟\n         ss - 秒数\n         sss - 毫秒\n        -->\n        <!--格式化日期-->\n     <h2> \n     <fmt:formatDate value=\"${requestScope.now}\" pattern=\"yyyy年MM月dd日HH时mm分ss秒\"/>\n     </h2>\n     <!--格式化数字 0.00表示保留两位小数 0,00.00表示按百分位用','分割-->\n     <h2> \n     <fmt:formatNumber value=\"${requestScope.amt}\" pattern=\"0.00\"/>\n     </h2>\n     \n</body>\n</html>\n```\n◇默认值，与转义\n  --defalut设置默认值，escapeXml表示是否进行转义，若转义，则将<a>标签的链接显示出来，\n```java\n\n       <h2>null默认值：<c:out value=\"${nothing}\" default=\"无\"></c:out></h2>\n       <h2><c:out value=\"${html}\" escapeXml=\"true\"></c:out></h2>\n```\n## 综合训练\n◇创建Dynamic web工程；\n◇导入静态页面demo文件，放在项目主目录employee下；\n◇静态的页面\n◇导入jstl的声明jar包和实现jar包，放入到WEB-INF\\lib目录下；\n◇新增员工实体类\n```java\npublic class Employee {\n    private Integer empno;\n    private String ename;\n    private String department;\n    private String job;\n    private Float salary;\n    //get和set方法\n}\n```\n◇新建ListServlet初始化数据；\n```java\npackage com.lcg.employee;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Servlet implementation class ListServlet\n */\n@WebServlet(\"/list\")\npublic class ListServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n       \n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public ListServlet() {\n        super();\n        // TODO Auto-generated constructor stub\n    }\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\t\t\tthrows ServletException, IOException {\n\t\tServletContext context = request.getServletContext();\n\t\tif(context.getAttribute(\"employees\")==null) {\n\t\t\tList<Employee> list = new ArrayList<Employee>();\n\t\t\tEmployee emp = new Employee(2020,\"吴浩\",\"市场部\",\"客户代表\",6000f);\n\t\t\tlist.add(emp);\n\t\t\tlist.add(new Employee(2021,\"石磊\",\"研发部\",\"交通工程师\",8000f));\n\t\t\tcontext.setAttribute(\"employees\", list);\n\t\t\t}\n        //跳转到员工信息页\n\t\trequest.getRequestDispatcher(\"/employee.jsp\").forward(request, response);\n\t}\n}\n\n```\n◇将静态的html页面改为动态的jsp页面输出员工信息；\n```java\n<%@ page contentType=\"text/html;charset=utf-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>员工列表</title>\n    <link href=\"css/bootstrap.css\" type=\"text/css\" rel=\"stylesheet\"></link>\n    \n    <script type=\"text/javascript\" src=\"js/jquery-1.11.1.min.js\"></script>\n    <script type=\"text/javascript\" src=\"js/bootstrap.js\"></script>\n\n    <style type=\"text/css\">\n        .pagination {\n            margin: 0px\n        }\n\n        .pagination > li > a, .pagination > li > span {\n            margin: 0 5px;\n            border: 1px solid #dddddd;\n        }\n\n        .glyphicon {\n            margin-right: 3px;\n        }\n\n        .form-control[readonly] {\n            cursor: pointer;\n            background-color: white;\n        }\n        #dlgPhoto .modal-body{\n            text-align: center;\n        }\n        .preview{\n\n            max-width: 500px;\n        }\n    </style>\n    <script>\n        $(function () {\n            \n            $(\"#btnAdd\").click(function () {\n                $('#dlgForm').modal()\n            });\n        })\n\n\n    </script>\n</head>\n<body>\n\n<div class=\"container\">\n    <div class=\"row\">\n        <h1 style=\"text-align: center\">交通控股员工信息表</h1>\n        <div class=\"panel panel-default\">\n            <div class=\"clearfix panel-heading \">\n                <div class=\"input-group\" style=\"width: 500px;\">\n                    <button class=\"btn btn-primary\" id=\"btnAdd\"><span class=\"glyphicon glyphicon-zoom-in\"></span>新增\n                    </button>\n                </div>\n            </div>\n\n            <table class=\"table table-bordered table-hover\">\n                <thead>\n                <tr>\n                    <th>序号</th>\n                    <th>员工编号</th>\n                    <th>姓名</th>\n                    <th>部门</th>\n                    <th>职务</th>\n                    <th>工资</th>\n                    <th>&nbsp;</th>\n                </tr>\n                </thead>\n                <tbody>\n               <--利用循环以及EL表达式输出每一个员工的信息 -->\n                <c:forEach items=\"${applicationScope.employees}\" var=\"emp\" varStatus=\"idx\">\n                <tr>\n                    <td>${idx.index+1}</td>\n                    <td>${emp.empno}</td>\n                    <td>${emp.ename}</td>\n                    <td>${emp.department }</td>\n                    <td>${emp.job }</td>\n                    <td style=\"color: red;font-weight: bold\">\n             ￥<fmt:formatNumber value=\"${emp.salary}\" pattern=\"0,000.00\"></fmt:formatNumber>\n             </td>                   \n                </tr>\n               </c:forEach>\n                </tbody>\n            </table>\n        </div>\n    </div>\n</div>\n\n<!-- 表单 -->\n<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\" id=\"dlgForm\">\n    <div class=\"modal-dialog\" role=\"document\">\n        <div class=\"modal-content\">\n            <div class=\"modal-header\">\n                <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span>\n                </button>\n                <h4 class=\"modal-title\">新增员工</h4>\n            </div>\n            <div class=\"modal-body\">\n                <form action=\"/employee/create\" method=\"post\" > <!-- action表单存放地址 -->\n                    <div class=\"form-group\">\n                        <label for=\"empno\">员工编号</label>\n                        <input type=\"text\" name=\"empno\" class=\"form-control\" id=\"empno\" placeholder=\"请输入员工编号\">\n                    </div>\n                    <div class=\"form-group\">\n                        <label for=\"ename\">员工姓名</label>\n                        <input type=\"text\" name=\"ename\" class=\"form-control\" id=\"ename\" placeholder=\"请输入员工姓名\">\n                    </div>\n                    <div class=\"form-group\">\n                        <label>部门</label>\n                        <select id=\"dname\" name=\"department\" class=\"form-control\">\n                            <option selected=\"selected\">请选择部门</option>\n                            <option value=\"市场部\">市场部</option>\n                            <option value=\"研发部\">研发部</option>\n                        \t<option value=\"后勤部\">后勤部</option>\n                        </select>\n                    </div>\n\n                    <div class=\"form-group\">\n                        <label>职务</label>\n                        <input type=\"text\" name=\"job\" class=\"form-control\" id=\"sal\" placeholder=\"请输入职务\">\n                    </div>\n\n                    <div class=\"form-group\">\n                        <label for=\"sal\">工资</label>\n                        <input type=\"text\" name=\"salary\" class=\"form-control\" id=\"sal\" placeholder=\"请输入工资\">\n                    </div>\n\n                    <div class=\"form-group\" style=\"text-align: center;\">\n                        <button type=\"submit\" class=\"btn btn-primary\">保存</button>\n                    </div>\n                </form>\n            </div>\n\n        </div><!-- /.modal-content -->\n    </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\n</body>\n</html>\n```\n◇实现新增功能，创建新的servlet用于创建员工;\n```java\npackage com.lcg.employee;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Servlet implementation class CreateServlet\n */\n@WebServlet(\"/create\")\npublic class CreateServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n       \n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public CreateServlet() {\n        super();\n        // TODO Auto-generated constructor stub\n    }\n\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n    //表单通过post提交;\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) \n\t\t\tthrows ServletException, IOException {\n\t\trequest.setCharacterEncoding(\"UTF-8\");\n\t\tString empno = request.getParameter(\"empno\");//empno是在jsp中设置的name属性;\n\t\tString ename = request.getParameter(\"ename\");\n\t\tString department = request.getParameter(\"department\");\n\t\tString job = request.getParameter(\"job\");\n\t\t//尽管salary是float类型，但getParameter接收时须为String类型\n\t\tString salary = request.getParameter(\"salary\"); \n\t\tEmployee emp = new Employee(Integer.parseInt(empno),ename,department,job,Float.parseFloat(salary));\n\t    /*将emp对象保存到原始数据中，原始数据由应用全局对象保存，\n\t\t注意属性employees来自于context.setAttribute(\"employees\", list);*/\n\t\tServletContext context = request.getServletContext();\n\t\t//获取初始的数据\n\t    List employees = (List)context.getAttribute(\"employees\");\n\t    //添加数据\n\t    employees.add(emp);\n\t    //再将添加完成后的数据放回去\n\t    context.setAttribute(\"employees\", employees);\n\t    request.getRequestDispatcher(\"/employee.jsp\").forward(request, response);\n\t}\n}\n```\n\n","tags":["EL"],"categories":["JavaWeb"]},{"title":"Servlet与JSP进阶","url":"/p/e24.html","content":"## 请求与响应的结构\n### HTTP请求的结构\n◇HTTP请求包含三部分：请求行，请求头，请求体\n![](1.png)\n\n◇请求行：第一行，表明请求方法，请求URL及HTTP协议版本。\n◇常用请求头：Accept；User-Agent(说明操作系统和浏览器的环境)等等；\n◇只有POST才有请求体；\n◇F12可以查看请求头等信息\n![](2.png)\n\n### 巧用请求头开发多端应用\n◇在新建JAVA类时，可以直接新建Servlet，它会自动映射到地址；\n◇代码演示\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tString userAgent = request.getHeader(\"User-Agent\");//获取浏览器配置信息\n\t\tresponse.setContentType(\"text/html;charset=utf-8\");//编码方式，支持中文\n\t\tresponse.getWriter().println(userAgent);\n\t\tString output = \"\";\n    //indexof()方法进行字符串查找，如果找到，则返回大于大于等于0的数字，若未找到，则返回-1；\n\t\tif(userAgent.indexOf(\"Windows NT\") != -1) { //!= -1表明找到\n\t\t\toutput = \"<h1>这是ＰＣ端首页</h1>\";\n\t\t}else if(userAgent.indexOf(\"iPhone\") != -1 || userAgent.indexOf(\"Android\") != -1) {\n\t\t\toutput = \"<h1>这是移动端首页</h1>\";\n\t\t}\n\t\tresponse.getWriter().println(output);//对外输出\n\t}\n```\n### 响应的结构\n◇HTTP响应包含三部分：响应行、响应头、响应体；\n![](3.png)\n\n### HTTP常见状态码\n![](4.png)\n### ContentType的作用\n◇ContentType决定浏览器采用何种方法对响应体进行处理\n\n| MIME类型 | 描述 |\n| --- | --- |\n| text/plain | 纯文本 |\n| text/html | HTML文档 |\n| text/xml | XML文档 |\n| application/x-msdownload | 需要下载的资源 |\n| image/jpeg\nimage/gif\nimage/... | 图片资源 |\n\n◇代码示例\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\tthrows ServletException, IOException {\n\t\tString output = \"<h1><a href ='http://www.baidu.com'><span>百度</span></h1>\";\n\t\tresponse.setContentType(\"application/x-msdownload;charset=utf-8\");//设置类型\n\t\tresponse.getWriter().println(output);\n\t}\n```\n## 请求转发与重定向\n### 使用\n◇多个Serclet(JSP)之间跳转有两种方式：\n  ◇request.getRequestDispatcher().forward() - 请求转发\n  ◇response.sendRedirect() - 响应重定向\n创建一个servlet\n  --运行后登陆：[http://localhost:8080/request-struc/direct/check](http://localhost:8080/request-struc/direct/check)\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\t\t\tthrows ServletException, IOException {\n\t\tSystem.out.println(\"用户登录成功\");//在控制台打印显示\n\t\t//实现了请求转发功能,跳转到首页去\n\t\trequest.getRequestDispatcher(\"/direct/index\").forward(request, response);\n\t}\n```\n◇结果：[http://localhost:8080/request-struc/direct/check](http://localhost:8080/request-struc/direct/check)  地址没有改变；\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\t\t\tthrows ServletException, IOException {\n\t\tSystem.out.println(\"用户登录成功\");//在控制台打印显示\n\t\t//响应重定向需要增加contentPath：/request-struc\n\t\tresponse.sendRedirect(\"/request-struc/direct/index\");\n\t}\n```\n◇结果： [http://localhost:8080/request-struc/direct/index](http://localhost:8080/request-struc/direct/index) 地址变为跳转界面的url地址；\n◇分析：\n  --可以看到，请求转发后并没有改变页面地址，而响应重定向却改变了；因为请求转发功能是在服务器，也就是Tomcat内部把请求从第一个Servlet转发到第二个Servlet上；而重定向不同，它是在第一次处理完请求后，由浏览器重新发送一个新的请求，因而改变了地址；\n### 原理\n**请求转发**\n◇请求转发是服务器跳转，只会产生一次请求\n◇请求转发语句是:request.getRequestDispatcher().forward();\n![](5.png)\n**响应重定向**\n◇重定向则是浏览器端跳转，会产生两次请求\n◇响应重定向的语句：response.sendRedirect();\n![](6.png)\n\n### 设置请求自定义属性\n◇请求允许创建自定义属性\n◇设置请求属性：request.setAttribute(属性名，属性值)\n◇获取请求属性：Object attr = request.getAttribute(属性名)\n◇代码演示\n --请求端 Servlet1\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\t\t\tthrows ServletException, IOException {\n\t\tSystem.out.println(\"用户登录成功\");//在控制台打印显示\n\t\trequest.setAttribute(\"username\", \"admin\");//将用户信息保存到请求中\n\t\t//实现了请求转发功能\n\t\trequest.getRequestDispatcher(\"/direct/index\").forward(request, response);\n\t}\n```\n--目的端Servlet2\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t//获取属性,需强制转换\n\t\tString name = (String)request.getAttribute(\"username\");\n\t\tresponse.getWriter().println(\"this index page!current username is \" + name);\t\t\n\t}\n```\n◇响应重定向由于会产生两个请求，当它发送第一个请求时，会把自定义属性传递给Tomcat，但第二次重新创建的请求并不包含自定义属性（因为这是新的请求并且直接请求Servlet2了）；因此使用响应重定向时，会看到username is null;如果在Servlet2里增加 request.setAttribute(\"username\", \"servlet2\");则会显示 username is servlet2；\n## 浏览器Cookie ，Session-用户会话\n### Cookie \n◇Cookie(小甜饼)是浏览器保存在本地的文本内容\n◇Cookie常用于保存登录状态，用户资料等小文本\n◇Cookie具有时效性，Cookie内容会伴随请求发送给Tomcat\n◇Cookie如果不设置有效期，则默认存在于浏览器窗口中，当浏览器关闭，则自动销毁。\n◇Cookie是以文件形式保存在电脑本地的:  \n C:\\Users\\ASUS\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cookies文件；\n--代码演示\n--登录端，创建Cookie\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\tthrows ServletException, IOException {\n\t\tSystem.out.println(\"用户登录成功\");\n\t\tCookie cookie = new Cookie(\"user\" , \"admin\");\n\t    cookie.setMaxAge(60*60*24*7);//以秒为单位，设置有效期为一周\n\t\tresponse.addCookie(cookie);//添加cookie\n\t\tresponse.getWriter().print(\"login success\");\n\t}\n```\n--首页端，获取Cookie\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n\t throws ServletException, IOException {\n\t\tCookie[] cs = request.getCookies();//获取Cookie，返回数组\n\t\tif(cs == null){\n\t\t\tresponse.getWriter().print(\"user not login\");\n\t\t\treturn;//为空，终止程序\n\t\t}\n\t\tString user = null;\n\t\tfor(Cookie c : cs) {\n\t\t\tSystem.out.print(c.getName()+\":\"+c.getValue());\n\t\t\tif(c.getName().equals(\"user\")) {\n\t\t\t\tuser=c.getValue();break;\n\t\t\t}\n\t\t}\n\t\tif(user==null) {\n\t\t\tresponse.getWriter().print(\"user not login\");\n\t\t}else {\n\t\t\tresponse.getWriter().print(\"user:\"+user);\n\t\t}\n\t}\n```\n### Session-用户会话\n◇Session(用户会话)用于保存于“浏览器窗口”对应的数据；\n◇Session的数据存储在Tomcat服务器的内存中，具有时效性(30min)；\n◇Session通过浏览器Cookie的Sessionid值提取用户数据；\n◇代码演示\n  --首页端\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\tHttpSession session = request.getSession();\n\t\tString sessionId = session.getId();//获取SessionId\n\t\tSystem.out.println(sessionId);\n\t\tString name = (String)session.getAttribute(\"name\");\n\t\tresponse.setContentType(\"text/html;charset=utf-8\");\n\t\tresponse.getWriter().println(\"这是首页，当前用户为：\"+ name);\n\t}\n```\n  --登录端\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\t\tSystem.out.print(\"用户登录成功\");\n        //获取到用户会话Session对象,登录端和首页的session是同一个对象\n\t\tHttpSession session = request.getSession();\n        String sessionId = session.getId();//获取SessionId\n\t\tSystem.out.println(sessionId);\n\t\tsession.setAttribute(\"name\", \"李\");\n\t\t//请求转发\n\t\trequest.getRequestDispatcher(\"/session/index\").forward(request, response);\n\t}\n```\n◇对于session而言，形象的看成是一个和浏览器窗口绑定的对象；对于这一个浏览器窗口中所产生的数据，Tomcat会创建一个单独的存储空间；每个浏览器窗口所对应的存储空间都是不同的，存储空间的标识符就是sessionId；因此，同一个窗口中，登录和首页两个servlet共用一个存储空间，因此sessionId是一样的，而当切换一个窗口后，sessionId改变；\n### Session实现原理\n◇对于第一个浏览器窗口，它在向Tomcat发送请求的时候，Tomcat发现这是一个全新的请求，就会自动的在Tomcat的内存中开辟一段存储空间，并给它一个id号；当servlet调用setAttribute()方法的时候，就会将 name=张三 的数据保存在存储空间中，Tomcat就会把刚才生成的SessionId:7U809JP返回给浏览器；浏览器就会把这个id值存储到cookie中； 当浏览器再次请求的时候，就会附带这个sessionId，Tomcat就会根据这个ID去查找到对应的存储空间；假如servlet调用了getAttribute()方法,数据就会从存储空间中获得；\n◇如果是一个新的浏览器窗口，就会创建新的session;\n![](7.png)\n\n### ServletContext\n◇ ServletContext(Servlet上下文对象)，是Web应用全局对象  \n◇ 一个Web应用只会创建一个ServletContext对象  \n◇ ServletContext随着Web应用启动而自动创建  \n◇代码实现\n  --初始化\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\tServletContext context = request.getServletContext();\n\t\tcontext.setAttribute(\"copyright\",\"@2021 gamest.link 京ICP备xxxxxx\");\n\t\tcontext.setAttribute(\"title\", \"个人开发网站\");\n\t\tresponse.getWriter().print(\"init susess\");\n\t}\n```\n  --默认页\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\tServletContext context = request.getServletContext();//获取应用程序全局对象\n\t\tString copyright = (String)context.getAttribute(\"copyright\");\n\t\tString title = (String)context.getAttribute(\"title\");\n\t\tresponse.setContentType(\"text/html;charset=utf-8\");\n\t\tresponse.getWriter().print(\"<h1>\"+title+\"</h1>\"+copyright);\n\t}\n```\nJava Web三大作用域对象\n◇HttpServletRequest -请求对象   生命周期最短，当请求送往Tomcat，请求对象就会被创建，当Servlet处理完成后，产生响应并返回给浏览器，则就被销毁。\n​\n\n◇HttpSession - 用户会话对象    第一次用户发来请求时被创建，一般30分钟内不被访问则会被销毁\n​\n\n◇ServletContext - web应用全局对象  Web应用启动时创建，关闭或重启时销毁\n## 问题解决\n### Web应用的中文乱码由来\n◇Tomcat默认使用字符集ISO-8859-1，属于西欧字符集\n◇解决乱码的核心思路是将ISO-8859-1转换为UTF-8\n◇Servlet中请求与响应都需要设置UTF-8字符集\n​\n\n◇代码实现\n        --Get&Post方法分别实现\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\t\t//对于Tomcat8.x的版本，默认get请求发送中文就是UTF-8的格式，因此无需转换\n\t\tString ename = request.getParameter(\"ename\");\n\t\tString address = request.getParameter(\"address\");\n\t\tSystem.out.println(ename + \":\" + address);\n\t\tresponse.setContentType(\"text/html;charset=utf-8\");\n\t\tresponse.getWriter().println(ename + \":\" + address);\n\t}\n\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\t\t//request.setCharacterEncoding方法用于将请求体中的字符集转换为UTF-8，方法简单\n        //但对于get方法无效\n\t\trequest.setCharacterEncoding(\"UTF-8\");//一定要写在post方法的第一行\n\t\t// TODO Auto-generated method stub\n\t\tString ename = request.getParameter(\"ename\");//获取基本参数\n\t\tString address = request.getParameter(\"address\");\n\t\tSystem.out.println(ename + \":\" + address);\n        \n        //转换语句，但过于麻烦\n\t\t//String utf8Ename = new String(ename.getBytes(\"iso-8859-1\") , \"utf-8\"); \n\t\t//String utf8Address = new String(address.getBytes(\"iso-8859-1\") , \"utf-8\");\n\t\t//System.out.println(utf8Ename + \":\" + utf8Address);\n\t}\n```\n### web.xml常用配置\n◇修改web应用默认首页\n◇Servlet通配符映射及初始化参数\n◇设置404、500等状态码默认页面\n​\n\n◇代码实现\n--不用指定具体地址，默认访问的页面\n```xml\n  <welcome-file-list>\n    <welcome-file>index.html</welcome-file> //如果index.html存在，则优先访问此页面\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n    <welcome-file>default.html</welcome-file>\n    <welcome-file>default.htm</welcome-file>\n    <welcome-file>default.jsp</welcome-file>\n  </welcome-file-list>\n```\n◇Servlet通配符映射(*)\n  --XML\n```xml\n<servlet>\n  \t<servlet-name>patternServlet</servlet-name>\n  \t<servlet-class>com.lcg.servlet.pattern.PatternServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>patternServlet</servlet-name>\n  \t<url-pattern>/pattern/*</url-pattern>\n  </servlet-mapping>\n```\n  --Java\n```java\npackage com.lcg.servlet.pattern;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class PatternServlet extends HttpServlet{\n\n\t@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t//查询员工的基本信息\n\t\t//获取当前访问的URL\n\t\tString url = request.getRequestURL().toString();\n\t\tSystem.out.println(url);\n        //lastIndexOf()方法获取最后一次字符参数出现的位置，substring()方法从指定位置截取字符\n\t\tString id = url.substring(url.lastIndexOf(\"/\") + 1);\n\t\tint eid =  Integer.parseInt(id);\n\t\tresponse.setContentType(\"text/html;charset=utf-8\");\n\t\tPrintWriter out = response.getWriter();\n\t\tout.println(id);\n\t\tif(eid == 1) {\n\t\t\tout.println(\"张三\");\n\t\t}else if(eid == 2) {\n\t\t\tout.println(\"李四\");\n\t\t}else {\n\t\t\tout.println(\"其他员工\");\n\t\t}\n\t\t\n\t}\n\t\n}\n```\n◇配置全局参数(应用程序的基本全局配置项目用context-param标签实现)\n  --XML配置\n```xml\n <context-param> \n  \t<param-name>copyright</param-name>\n  \t<param-value>© 2018 gamest.com  京ICP备 XXXXXXXX号-22</param-value>\n  </context-param>\n  <context-param>\n  \t<param-name>title</param-name>\n  \t<param-value>无产阶级联合起来！</param-value>\n  </context-param>\n```\n --Java端使用\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) \n    throws ServletException, IOException {\n\t\tServletContext context = request.getServletContext();//获取\n        //获取在web.xml中设置的全局参数使用getInitParameter()方法\n\t\tString copyright = context.getInitParameter(\"copyright\");\n\t\tcontext.setAttribute(\"copyright\", copyright);\n\t\tString title = context.getInitParameter(\"title\");\n\t\tcontext.setAttribute(\"title\", title);\n\t\tresponse.getWriter().println(\"init success\");\n\t}\n```\n◇指定错误页面\n```xml\n  <!-- 指定错误页面 -->\n  <error-page>\n  \t<error-code>404</error-code>\n  \t<location>/error/404.html</location>\n  </error-page>\n  <error-page>\n  \t<error-code>500</error-code>\n  \t<location>/error/500.html</location>\n  </error-page>\n```\n### JSP九大内置对象\n◇对于JSP来说，平时我们使用的时候它内置了一些对象来简化我们的操作；\n◇最重要的一个对象[pageContext](https://blog.csdn.net/weiwjacsdn/article/details/90612014)\n![](8.png)\n◇代码实现\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\" %>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n\t<%\n        //内置对象，可直接拿来使用;因为在经过Tomcat转义为java文件后,\n        //可以发现前面已经定义了HttpServletRequest request\n\t\tString url = request.getRequestURL().toString(); // 即HttpServletRequest对象\n\t\tresponse.getWriter().println(url);//HttpServletResponse\n\t%>\n\t<% out.println(\"<br>ABCCC\"); \n\t\tsession.setAttribute(\"user\", \"张三\");\n\t\tout.println((String)session.getAttribute(\"user\"));\n\t%>\n\t<%\n\t\tString cp = application.getInitParameter(\"copyright\") ; //ServletContext\n\t\tout.println(\"<hr/>\");\n\t\tout.println(cp);\n        //pageContext相当于一个中转站,通过它来获取当前页面的其他内置对象;\n\t\tpageContext.getRequest();\n\t\tpageContext.getResponse();\n\t\tpageContext.getSession();\n\t\tpageContext.getServletContext();\n\t%>\n</body>\n</html>\n```\n --显示错误信息方法\n       isErrorPage=\"true\"表示当前jsp是用来显示错误的页面\n```java\n<%@ page contentType=\"text/html;charset=utf-8\" isErrorPage=\"true\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n\t服务器内部错误，请联系管理员 ,错误信息如下：\n\t<%\n        //应用异常对象\n\t\tString msg = exception.getMessage(); \n\t\tout.print(\"<br>\" + exception.getClass().getSimpleName() + \":\" + msg);\n\t%>\n</body>\n</html>\n```\n### Java Web打包与发布\n◇Java Web应用采用war包进行发布\n◇发布路径为：{TOMCAT_HOME}/webapps\n◇Eclipse支持war包导出\n​\n\n☆打包步骤\n File -> Export -> Web -> WAR file -> Destination(指定保存文件路径后缀不能少eg:servlet_test.war) ->finish\n☆使用方法\n将.war文件复制到Tomcat\\apache-tomcat-8.5.34\\webapps路径中，然后启动Tomcat\\apache-tomcat-8.5.34\\bin中的startup.bat文件\n​\n\n☆Tomcat配置文件修改\n◇找到Tomcat\\apache-tomcat-8.5.34\\conf中的servlet.xml文件，在63行，将8080改为80，则以后访问不需要加localhost:8080也不要加localhost:80;\n```java\n<Connector connectionTimeout=\"20000\" port=\"80\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n◇将path路径后面只留\"/\"，则访问以后直接localhost即可\n```java\n<Context docBase=\"F:\\JAVA\\Tomcat\\apache-tomcat-8.5.34\\webapps\\request-struc\" path=\"/\" reloadable=\"true\" source=\"org.eclipse.jst.jee.server:request-struc\"/></Host>\n```\n reloadable:是否自动加载\n​\n\n","tags":["JSP"],"categories":["JavaWeb"]},{"title":"JSP入门","url":"/p/121d.html","content":"## 基础简介\n### Servlet开发的痛点\n![](1.png)\n◇简单的页面却工作量太大，繁琐；\n◇静态HTML与动态Java代码混合在一起，难以维护；\n◇Servlet利用out.println()语句输出，开发效率低下；\n◇Eclipse很难在开发过程中发现错误，调试困难；\n\n### JSP介绍\n◇JSP全称是(Java Servlet Pages),java服务器页面\n◇JSP是J2EE的功能模块，由Web服务器执行\n◇JSP的作用就是降低动态网页开发难度\n### JSP特点\n◇JSP可将Java代码与HTML分离，降低开发难度\n◇JSP的本质就是Servlet\n### JSP运行要求\n◇可正常运行的Tomcat\n◇所有JSP页面扩展名必须是.jsp\n◇JSP页面应放在Web应用程序目录下\n### JSP代码示例\n◇案例描述；公司薪资制度：\n新入职员工：基本工资1500元\n工作5年内员工：每年工资上浮基本工资的10%\n工作5-10年员工：每年工资上浮基本工资的20%\n工作10年以上员工：每年工资上浮基本工资的25%\n要求列出工资试算表；\n ◇在WebContent目录下创建一个salaty.jsp文件，在一个jsp文件中用<% %>嵌入java代码实现开发效率，输出员工各个工龄的工资；\n```java\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n\t<table>\n\t\t<tr>\n\t\t\t<th>year</th>\n\t\t\t<th>salary</th>\n\t\t</tr>\n\t\t<%\n\t\t  for(int i=0;i<=50;i++){ //五十年\n\t\t\t  out.println(\"<tr>\");//每一行\n\t\t\t  out.println(\"<td>\"+i+\"</td>\");//第一列:年份\n\t\t\t  int sal=0;\n\t\t\t  if(i<=5){\n\t\t\t\t  sal=1500+i*150;\n\t\t\t  }else if(i>5&&i<=10){\n\t\t\t\t  sal=1500+150*5+300*(i-5);\n\t\t\t  }else if(i>10){\n\t\t\t\t  sal=1500+150*5+300*5+375*(i-10);\n\t\t\t  }\n\t\t\t  out.println(\"<td>\"+sal+\"</td>\");//第二列:工资\n\t\t\t  out.println(\"</tr>\");\n\t\t  }\n\t\t%>\n\t</table>\n</body>\n</html>\n```\n## JSP的执行过程\n◇浏览器访问JSP首先将请求发送给Tomcat，Tomcat在应用目录中找到对应的jsp，然后将jsp转换为标准的Servlet源代码，编译成字节码；\n![](2.png)\n\n## JSP的转译过程\n![](3.png)\n◇<%=a%>即把a打印输出；\n◇在apache-tomcat-8.5.34\\work\\Catalina\\localhost\\项目名\\org\\jsp中可以查看转译后的salary_jsp.java\n\n## JSP的基本语法\n◇JSP语法按功能分为以下四种\n①JSP代码块      ②JSP声明构造块\n③JSP输出指令  ④JSP处理指令\n### JSP代码块\n◇JSP代码块用于JSP中嵌入Java代码\n◇JSP代码块语法：<%java代码块%>\n### JSP声明构造块\n◇JSP声明构造用于声明变量或方法\n◇JSP声明构造块语法：<%! 声明语句 %>\n◇eg：声明方法，<%! public int add(int a,int b){return a+b;} %>\n### JSP输出指令\n◇JSP输出指令用于在JSP页面中显示java代码执行结果\n◇JSP输出指令语法：<%= java代码 %>\neg: <%=\"<b>\"+name+\"</b>\"%>  %=即out.println的简化形式\n### JSP处理指令\n◇JSP处理指令用于提供JSP执行过程中的辅助信息\n◇JSP处理指令语法：<%@ jsp指令 %>\n◇eg: <%@ page import=\"java.util.*\" %>\n### jsp常用处理指令\n```c\n<%@ page %> //定义当前JSP页面的全局设置\n<%@ include %>//将其他JSP页面与当前JSP页面合并\n<%@ taglib %>//引入JSP标签库\n```\nJSP中注释的区别\n◇<%-- 注释--%>  JSP注释，被注释语句不做任何处理\n◇// , /*..*/            用于注释<%%>java代码，被注释代码不执行\n◇<!-- html -->            HTML注释，被注释的语句不会被浏览器解释\n## 综合训练\n### 质数算法\n◇列出1000以内的质数(除1外，只能被1和自身整除的自然数)\n◇要求：使用List保存所有有效的质数，将结果打印到页面，格式为\"<h1>X是质数</h1>\"\n◇综合运用JSP语法；\n```c\n<%@page import=\"java.util.*\"  contentType=\"text/html;charset=utf-8\"%>\n\n  <%!\n    boolean isPrime(int num) {\n\t\tboolean flag = true;\n\t\tfor (int j = 2; j < num; j++) {\n\t\t\tif (num % j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n   %>\n   \n<%\n   \tList<Integer> primes = new ArrayList();\n   \tfor (int i = 2; i <= 1000; i++) {\n   \t\tboolean flag = isPrime(i);\n   \t\tif (flag) {\n   \t\t\t/* out.println(\"<h1>\" + i + \"</h1>\"); */\n   \t\t\tprimes.add(i);\n   \t\t}\n   \t}\n%>\n\n<%\n     for(int p : primes){\n    \t //out.println(\"<h1 style='color:pink'>\" + p + \"是质数</h1>\");\n%>\n\n      <h1 style='color:blue'><%=p %>是质数 </h1>\n<% \n     }\n%>\n```\n contentType=\"text/html;charset=utf-8\"%> 设置字体能显示中文；\n### JSP页面重用\n◇利用JSP指令进行引用\n```c\n<%@page contentType=\"text/html;charset=utf-8\" %>\n<%@include file=\"header.jsp\" %>//引用页头\n<% \n  out.println(\"<h1>新闻标题</h1>\");\n  out.println(\"<p>新闻正文</p>\");\n\n%>\n<%@include file=\"footer.jsp\" %>引用页脚\n```\n\n","tags":["JSP"],"categories":["JavaWeb"]},{"title":"Servlet入门","url":"/p/1d42.html","content":"## 软件结构发展史\n### 单机时代-桌面应用\n◇软件所有数据都保存在电脑本地硬盘中\n◇优点：易于使用，结构简单\n◇缺点：数据难以共享，安全性差，更新不及时。\neg：Word，eclipse；\n### 联机时代（Client-Server模式）\n◇Client/Server结构（C/S结构）是指客户端和服务器结构\n◇优点：数据方便共享，安全性高\n◇缺点：必须安装客户端，升级与维护困难。\neg：QQ，微信，支护宝\n### 互联网时代（Browser-Server模式）\n◇Browser-Server（B/S）模式及浏览器和服务器架构模式\n◇优点：开发简单，无需安装客户端，数据易于共享\n◇缺点：相较于C/S模式，执行速度与用户体验较弱\neg：百度网，新浪微博；\n## Tomcat与Servlet\n### B/S模式执行流程\n![](1.png)\n### 请求与响应\n◇从浏览器发出送给服务器的数据包称为\"请求（Request）\"\n◇从服务器返回给浏览器的结果称为\"响应（Response）\"\n◇请求和响应对称出现\n### J2EE简介\n◇J2EE（Java 2 Platform Enterprise Edition） 是指\"Java 2 企业版\"\n◇开发BS应用程序就是J2EE最核心的功能\n◇J2EE由13个功能模块组成\n### J2EE中的13个功能模块\n![](2.png)\n### Apache Tomcat\n◇Tomcat是一个Web应用服务器程序\n### J2EE与Tomcat的关系\n◇J2EE是一组技术规范与指南，具体实现由软件厂商决定\n◇Tomcat是J2EE Web（Servlet 与JSP）标准的实现者\n◇J2SE是J2EE运行的基石，运行Tomcat离不开J2SE\n### Servlet\n◇Servelt与Tomcat的作用如下图，Servlet相当于服务器主机代码\n![](3.png)\n\n### Eclipse整合Tomcat\n◇下载Eclipse 64位的压缩包，下载Eclipse IDE for Java EE Developers版本；然后解压，运行eclipse.exe即可；打开后；Window->Preferences->搜索jre->Installed JREs->Add->Standard VM->选择安装的jdk1.8.0_181->finish->OK;\n◇Window->Show View->Servers->OK->Servers下的链接->Apache->Tomcat v8.5 Server(自定义安装的版本)->next->Browse(选择安装路径)->apache-tomcat的安装路径->JRE:jdk1.8.0_181->Next->Finish->双击Tomcat v8.5->Server Locations:选择第二项Use Tomcat installation->Depoly path: \\apache-tomcat-8.5.34\\webapps->保存即可；\n## 第一个Servlet\n### 创建应用程序\n◇新建一个Dynamic Web Project对象->Project name:FirstServlet->-Next->Next->勾选Generate web.xml-Finish;\n◇在自动生成的Java Resources\\src目录下创建一个class,包名为com.lcg.servlet，类名为:FirstServlet;\n```java\npackage com.lcg.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FirstServlet extends HttpServlet{\n\t\n\tpublic FirstServlet(){\n\t\tSystem.out.println(\"正在创建FirstServlet对象\");\n\t}\t\n\t@Override\n\tpublic void init(ServletConfig config) throws ServletException {\n\t\tSystem.out.println(\"正在初始化FirstServlet对象\");\n\t}\n\t@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t//接收请求发来的参数\n\t\tString name = request.getParameter(\"name\");\n\t\tString html = \"<h1 style='color:red'>hi,\" + name +\"!</h1><hr/>\";\n\t\tSystem.out.println(\"返回给浏览器的响应数据为：\" + html);\n\t\tPrintWriter out = response.getWriter();\n\t\tout.println(html);//将html发送回浏览器\n\t}\n\t@Override\n\tpublic void destroy() {\n\t\tSystem.out.println(\"正在销毁servlet对象\"); \n\t}\n}\n```\n◇配置web.xml，绑定URL\n```xml\n  <!-- 声明Servlet -->\n  <servlet>\n  \t<!-- servlet的别名 -->\n  \t<servlet-name>first</servlet-name>\n  \t<servlet-class>com.imooc.servlet.FirstServlet</servlet-class>\n  </servlet>\n  \n  <!-- 将Servlet与URL绑定 -->\n  <servlet-mapping>\n  \t<servlet-name>first</servlet-name>\n  \t<url-pattern>/hi</url-pattern>\n  </servlet-mapping>\n```\n◇浏览器输入localhost:8080/FirstServlet/hi?name=Jackson\n### 图解执行流程\n◇在地址栏输入地址以后,这个信息通过请求发送给Tomcat，然后Tomcat就根据发送来的url地址在web.xml中去查找与/hi匹配的servlet，这里查找匹配到name=first的servlet，然后根据这个name继续在web.xml中查找与之对应的类，这里与之对应的类为FirstServlet,Tomcat就会创建FirstServlet对象,并且执行其中的service方法;\n◇service方法将name拼接成html字符串,Tomcat会将这个字符串通过response原封不动的发送给浏览器，浏览器再展示在页面上；\n![](4.png)\n\n### 标准Java Web工程结构\n![](5.png)\n◇index.html放在WebContent目录下\n\n### Servlet开发步骤\n◇创建Servlet类，继承HttpServlet\n◇重写service方法，编写程序代码\n```java\npublic class SampleServlet extends HttpServlet{\n       public void service(HttpServletRequest request,HttpServletResponse response) \n           throws IOException {\n    \t PrintWriter out = response.getWriter();//向浏览器输出的数据流，返回PrintWriter对象\n    \t out.println(\"<a href='http://www.gamest.link'>COF</a>\");\n       }\n}\n```\n◇配置web.xml，绑定URL\n```xml\n<!-- 声明servlet -->\n<servlet>\n       <servlet-name>sample</servlet-name><!-- servlet的别名 ，Tomcat通过别名绑定URL，提高安全性-->\n       <servlet-class>com.gamest.servlet.SampleServlet</servlet-class>\n  </servlet>\n  <!-- 将servlet于URL绑定 -->\n  <servlet-mapping>\n        <servlet-name>sample</servlet-name>\n        <url-pattern>/sample</url-pattern>\n  </servlet-mapping>\n```\n### Servlet访问方法\n◇http://IP地址：端口（8080）/context-path(eclipse的工程名称)/url-mapping\n◇远程访问使用IP地址，本地访问localhost(127.0.0.1)\n◇context-path成为\"上下文路径\"，默认为工程名\n### 请求参数\n◇请求参数是指浏览器通过请求向Tomcat提交的数据\n◇请求参数通常是用户输入的数据，待Servlet进行处理\n◇参数名1=值1&参数名2=值2&参数名n=...\neg:\nname=lcg&mobile=15751015885&sex=male&spec=Program&spec=Swimming\n### 获取参数\n◇student.html文件\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>学员信息登记表</title>\n</head>\n<body>\n\t<h1>学员信息登记表</h1>\n  <!-- 表单提交的后台路径,请求方法-->\n\t<form action=\"/FirstServlet/sample\" method=\"get\" >\n\t\t姓名：<input name=\"name\"/>\n\t\t<br/>\n\t\t电话：<input name=\"mobile\"/>\n\t\t<br/>\n\t\t性别：\n\t\t<select name=\"sex\" style=\"width:100px;padding:5px;\">\n\t\t\t<option value=\"male\" >男</option>\n\t\t\t<option value=\"female\">女</option>\n\t\t</select>\n\t\t<br/>\n\t\t特长:\n\t\t<input type=\"checkbox\" name=\"spec\" value=\"English\"/>英语\n\t\t<input type=\"checkbox\" name=\"spec\" value=\"Program\"/>编程\n\t\t<input type=\"checkbox\" name=\"spec\" value=\"Speech\"/>演讲\n\t\t<input type=\"checkbox\" name=\"spec\" value=\"Swimming\"/>游泳\n\t\t<br/>\n\t\t<input type=\"submit\" value=\"提交\">\n\t\t<br/>\n\t</form>\n</body>\n</html>\n```\n获取单个参数：\n```java\nString name = request.getParameter(\"name\");\nString mobile = request.getParameter(\"mobile\");\nString sex = request.getParameter(\"sex\");\n```\n获取多个：如上面的spec特长数据；\n```java\nString[] specs = request.getParameterValues(\"spec\");//多个值的，用数组\n```\n在页面显示参数：\n```java\n out.println(\"<h1>name:\"+name+\"</h1>\");\n    \t   out.println(\"<h1>mobile:\"+mobile+\"</h1>\");\n    \t   out.println(\"<h1>sex:\"+sex+\"</h1>\");\n    \t   for(int i=0;i<specs.length;i++) {\n    \t\t   out.print(\"<h2>spec:\"+specs[i]+\"</h2>\");\n    \t   }\n    \t   out.println(\"<a href='http://www.gamest.link'>COF</a>\");\n```\n## Get与Post请求方法\n◇Get方式是将数据通过在URL附加数据显性向服务器发送数据\n eg：http://localhost:8080/FirstServlet/sample?name=Lcg\n◇Post方法会将数据存放在\"请求体\"中隐性向服务器发送数据\n  eg：http://localhost:8080/FirstServlet/sample\n  请求体：name=Lcg\n◇区别：二者数据格式一样的，存放数据地址不一样，可以通过F12键Network来查看。\npost存放在了不可见的请求体中；\n◇Service是请求处理的核心方法，无论是get或者post都会被service方法处理，request。在Java中getMethod（）方法可以获取是那种方法。\n### 设置方法\n◇设置表单的请求方法\n```html\n<form action=\"/FirstServlet/sample\" method=\"post|get\" >\n```\n◇设置请求参数，通过设置表单中input,select等标签的name属性。只有设置了name属性的表单元素才能在提交表单时传递它们的值；\n```html\n\t\t性别：\n\t\t<select name=\"sex\" style=\"width:100px;padding:5px;\">\n\t\t\t<option value=\"male\" >男</option>\n\t\t\t<option value=\"female\">女</option>\n\t\t</select>\n```\n### Get与Post处理方式\n◇所有请求 - service()方法；\n```java\npublic class SampleServlet extends HttpServlet {\n\t//service是请求处理的核心方法，无论是get或者post都会被service（）方法处理\n\tpublic void service(HttpServletRequest request , HttpServletResponse response) throws IOException{\n\t\tString methodName = request.getMethod();//得到请求的方法;\n\t\tString name = request.getParameter(\"name\");\n\t\tString mobile = request.getParameter(\"mobile\");\n\t\tString sex = request.getParameter(\"sex\");\n\t\tString[] specs = request.getParameterValues(\"spec\");\n\t\tPrintWriter out =  response.getWriter();//向浏览器输出的数据流\n\t\tout.println(\"<h1>method:\" + methodName + \"</h1>\");\n\t\tout.println(\"<h1>name:\" + name + \"</h1>\");\n\t\tout.println(\"<h1>mobile:\" + mobile + \"</h1>\");\n\t\tout.println(\"<h1>sex:\" + sex + \"</h1>\");\n\t\tfor(int i = 0 ; i < specs.length ; i++){\n\t\t\tout.println(\"<h2>spec:\" + specs[i] + \"</h2>\");\n\t\t}\n\t\tout.println(\"<a href='http://www.baidu.com'>Baidu</a>\");\n\t}\n}\n```\n◇Get请求 - doGet()方法；\n```java\n public void doGet(HttpServletRequest request,HttpServletResponse response) \n        \t\tthrows IOException {\n        \tString name = request.getParameter(\"name\");\n        \tresponse.getWriter().println(\"<h1 style='color:green'>\"+name+\"</h1>\");\n```\n◇Post请求 -  doPost()方法；\n```java\n//处理Post请求\n        public void doPost(HttpServletRequest request,HttpServletResponse response) \n        \t\tthrows IOException {\n        \tString name = request.getParameter(\"name\");\n        \tresponse.getWriter().println(\"<h1 style='color:red'>\"+name+\"</h1>\");\n        }\n```\n### Get与Post应用场景\n◇Get常用于不包含敏感信息的查询功能\n   *例如：https://www.baidu.com/s?wd=imooc&rsv_spt=1\n◇Post用于安全性要求较高的功能或者服务器的\"写\"操作\n   *用户登录\n   *用户注册\n   *更新新公司账目\n### Servlet生命周期\n◇装载 -web.xml     ◇创建 - 构造函数\n◇初始化 - init()      ◇提供服务 - service()|doGet()|doPost\n◇销毁 - destory() //应用重启或关闭的时候执行\n**代码：**\n```java\npublic class FirstServlet extends HttpServlet{\n    \n\tpublic FirstServlet() {\n    \tSystem.out.println(\"正在创建FirstServlet对象\");\n    }\n\t@Override\n\tpublic void init(ServletConfig config) throws ServletException {\n\t\tSystem.out.println(\"正在初始化FirstServlet对象\");\n\t}\n\t@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response) \n        throws ServletException, IOException {\n\t\tString name = request.getParameter(\"name\");\n\t\tString html = \"<h1 style='color:pink'>hi,\"+name+\"!</h1>\";\n\t\tSystem.out.println(\"返回给浏览器的响应数据为：\"+ html);\n\t\t//response.getWriter()相当于从服务器向浏览器返回的输出流\n\t\tPrintWriter out = response.getWriter();\n\t\tout.println(html);//将html发送回浏览器\n\t}\n\t@Override\n\tpublic void destroy() {\n\t\tSystem.out.print(\"正在销毁FirstServlet对象\");\n\t}\n}\n```\n**服务端：**\n_正在创建FirstServlet对象_\n_正在初始化FirstServlet对象_\n_返回给浏览器的响应数据为：<h1 style='color:pink'>hi,lcg!</h1>_\n_返回给浏览器的响应数据为：<h1 style='color:pink'>hi,lcg!</h1>_\n_五月 13, 2021 11:28:02 上午 org.apache.catalina.core.StandardContext reload_\n_信息: Reloading Context with name [/FirstServlet] has started_\n_正在销毁FirstServlet对象_\n_​_\n\n◇可以看到在访问浏览器页面后就会自动创建和初始化对象，而且每一个Servlet有且仅有一个对象；\n当更改信息后，并保存（相当于应用重启或关闭）后就会销毁对象。\n## 注解简化配置 及启动时加载Servlet\n### 使用注解简化配置\n◇Servlet 3.x之后引入了\"注解Annotation\"特性\n◇注解用于简化Web应用程序的配置过程\n◇Servlet有且仅有一个核心注解：@WebServlet\n### 代码实现：\n```java\n@WebServlet(\"/anno\")\npublic class AnnotationServlet extends HttpServlet {\n\n\t@Override\n\tprotected void service(HttpServletRequest req, HttpServletResponse resp) \n\t\t\tthrows ServletException, IOException {\n\t\tresp.getWriter().println(\"I'm annotation servlet!\");\t\t\n\t}\n        \n}\n```\n◇写了@WebServlet(\"/anno\") 后，就不用再在web.xml里面进行配置了。它告诉我们映射的地址就是/anno\n### 启动时加载Servlet\n◇web.xml使用<load-on-startup>设置启动加载\n◇<load-on-startup>0~9999</load-on-startup> 其中数字代表优先级，0位最高，有多个Servlet需要启动时加载，则优先加载优先级高的。\n◇启动时加载在工作中常用于系统的预处理。\n◇这种Servlet不需要提供服务，因此不用绑定URL\n### 代码实现\n#### 传统方法\n重写init()方法\n```java\npublic void init() throws ServletException {\n\t\tSystem.out.print(\"正在创建数据库\");\n\t}\n```\n分析Servlet\n```xml\n<servlet>\n      <servlet-name>create</servlet-name>\n      <servlet-class>com.gamest.servlet.CreateServlet</servlet-class>\n      <load-on-startup>0</load-on-startup>\n  </servlet>\n```\n#### 注解方法\n```java\n//在使用注解开发时，强制要求必须设置一个URL，可以任意设置，只要不与其它冲突（可能不会用到，但一定要设置）\n@WebServlet(urlPatterns=\"/unused\",loadOnStartup=0)\npublic class CreateServlet extends HttpServlet {\n\t@Override\n\tpublic void init() throws ServletException {\n\t\tSystem.out.print(\"正在创建数据库\");\n\t}           \n}\n```\n\n","tags":["Servlet"],"categories":["JavaWeb"]},{"title":"XML入门","url":"/p/f394.html","content":"## 课程简介\n\n### XML重点知识\n\n![](1.png)\n\n### Servlet入门\n![](2.png)\n\n### JSP入门\n![](3.png)\n\n### Servlet与JSP进阶\n![](4.png)\n\n### JSTL与EL表达式\n![](5.png)\nXML\n\n◇XML介绍与用途；       ◇XML的语法规则<br />◇XML语义约束；          ◇Java解析XML<br />◇XPath路径表达式\n### XML是什么\n◇ [XML](https://www.w3school.com.cn/x.asp)的全称是EXtensible Markup Language,可扩展标记语言  <br />◇ 编写XML就是编写标签，与HTML非常类似，扩展名.xml  <br />◇ 良好的人机可读性  \n```xml\n#hr.xml\n<employee>\n<name>张三</name>\n<age>31</age>\n<height>178</height>\n</employee>\n```\n### XML与HTML的比较\n◇XML与HTML非常相似，都是编写标签<br />◇XML没有预定义标签，HTML存在大量预定义标签<br />◇XML重在保存与传输数据，HTML用于显示信息<br />◇eg：\n```xml\nxml: \n<school>\n <class no=\"G3N1\"> \n <grade>三年级</grade>\n <name>1班</name>\n </class>\n <class no=\"G3N2\">\n <grade>三年级</grade>\n <name>2班</name>\n </class>\n</school>\n```\n```html\nhtml:\n<body>\n <a href=\"index.html\">首页</a>\n</body>\n```\n### XML用途\n◇Java程序的配置描述文件；在程序开发过程中会遇到各种各样的设置项，如果把这些设置项写死在程序中，每次修改配置的时候需要对代码进行修改并重新编译，非常的麻烦；这个时候就可以考虑将这些配置写在xml文件中保存；例如下面的web应用配置文件；\n```xml\nweb.xml - web应用配置文件\n<web-app>\n<servlet>\n<servlet-name>InitTest</servlet-name>\n<servlet-class>moreservlets.InitServlet</servlet-class>\n<init-param>\n<param-name>param1</param-name>\n<param-value>value1</param-value>\n</init-param>\n<init-param>\n<param-name>param2</param-name>\n<param-value>2</param-value>\n</init-param>\n</servlet>\n</web-app>\n```\n◇用于保存程序产生的数据；因为xml拥有良好的人机可读性，所以xml可以用来对数据进行存储和转移；<br />◇网络间的数据传输；即在网络传输的过程中，发送方可以将数据组织成xml，接收方对xml进行解析就可以了；如：\n```xml\nwebservice底层soap协议：\n<Envelope>\n  <Body>\n  <m:reverse xmlns:m=\"urn:strings-com:IString\">\n    <theString>Hello,World</theString>\n  </m:reverse>\n  </Body>\n</Envelope>\n```\n### XML的文档结构\n◇第一行必须是XML声明<br />◇有且只有一个根节点<br />◇XML标签的书写规则与HTML完全相同\n###  XML标签书写规则  \n◇合法的标签名\n```xml\n<abc>abc</abc> × (无意义的)\n<考试$>数学期末</考试$> ×  (不可包含特殊字符)\n<class><class>班级</class></class> × (父标签子标签不可同名)\n<shop-cart><item>相册</item></shop-cart> √\n```\n ◇适当的注释与缩进； 适当的注释与缩进可以让XML文档更容易阅读。  \n```xml\n<!-- 员工信息 --> \n<employee>\n <name>张三</name>\n <age>31</age> \n <!--身高cm--> \n <height>178</height>\n</employee>\n```\n◇合理使用属性     \n```xml\n<shop-cart>\n <item sn=\"771938\" category=\"电器\"> \n <name>XX空调</name>\n <price>2000.00</price>\n <num>1</num>\n </item>\n <item sn=\"890321\" category=\"食品\">\n <name>法式面包</name>\n <price>10.00</price>\n <num>5</num>\n </item>\n</shop-cart>\n```\n◇特殊字符与CDATA标签；<br />-- 标签体中，出现\"<\"、\">\"特殊字符，会破坏文档原有的结构  ；<br />-- 解决方案1：使用实体引用。  <br />-- 解决方案2：使用CDATA标签。  \n```xml\n无效的XML：\n<exam>\n <question>1+4<3是否正确？</question><!--出现小于号<会别认为是特殊字符 -->\n <question>3+5>8是否正确？</question>\n</exam>\n```\n◇ XML支持五种实体引用  <br />![](6.png)<br />◇修改后的XML\n```xml\n<exam>\n <question>1+4&lt;3是否正确？</question><!--出现小于号<会别认为是特殊字符 -->\n <question>3+5&gt;8是否正确？</question>\n</exam>\n```\n◇实体引用的方法只适用于特殊字符少的情况；解决批量的问题用CDATA标签；<br />◇ CDATA 指的是不应由 XML 解析器进行解析的文本数据 <br />◇ 从\"<![CDATA[\"开始，到\"]]>\"结束   <br />◇如我们想要<content>标签的内容原义输出；则可使用CDATA包裹；\n```xml\n<lesson> \n <content>\n   <![CDATA[\n 本节我们来学习html中a标签的使用：\n <body>\n <a href=\"index.html\">首页</a>\n </body>\n   ]]>\n </content>\n</lesson> \n```\n◇有序的子元素，在XML多层嵌套的子元素中，标签前后顺序应保持一致。  \n```xml\n<shop-cart>\n<item sn=\"771938\" category=\"电器\">\n<name>XX空调</name>\n<price>2000.00</price>\n<num>1</num>\n</item>\n<item sn=\"890321\" category=\"食品\">\n<name>法式面包</name>\n<price>10.00</price>\n<num>5</num>\n</item>\n</shop-cart>\n```\n### XML声明\n◇XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n```\n其中，version代表版本号1.0(初始版本)/1.1(升级版本)；encoding UTF-8设置字符集，用于支持中文；<br />​<br />\n## XML语义约束\n◇ XML文档结构正确，但可能不是有效的。  <br />-- 例如，员工档案XML中绝不允许出现”植物品种” 标签。XML语义约束就是用于规定XML文档中允许 出现哪些元素。  <br />-- XML语义约束有两种定义方式:DTD与XML Schema。  \n### DTD简介\n◇ DTD(Document Type Definition，文档类型定义)是 一种简单易用的语义约束方式。  <br />◇ DTD文件的扩展名为.dtd。  \n```xml\nhr.dtd\n<!ELEMENT hr (employee+)>\n<!ELEMENT employee (name,age,salary,department)>\n<!ATTLIST employee no CDATA \"\">\n<!ELEMENT name (#PCDATA)>\n...\n```\n### DTD定义结点\n◇利用DTD中的<!ELEMENT>标签，定义XML文档中允许出现的节点及数量；<br />eg: ①定义hr节点下只允许出现一个employee子节点 ：\n```xml\n<!ELEMENT hr (employee)>\n```\n   ②employee节点下必须包含以下四个节点，且按顺序出现：\n```xml\n<!ELEMENT employee(name,age,salary,department)>\n```\n③定义name标签只能是文本，#PCDATA代表文本元素。\n```xml\n<!ELEMENT name(#PCDATA)\n```\n### DTD定义节点数量\n◇如某个子节点需要多次重复出现，则需要在子节点后增加相应的描述符。<br />eg：①hr节点下最少出现1个employee子节点：\n```xml\n<!ELEMENT hr(employee+)>\n```\n②hr节点下可出现0..n个employee子节点：\n```xml\n<!ELEMENT hr(employee*)>\n```\n③hr节点下最多可出现1个employee子节点：\n```xml\n<!ELEMENT hr(employee?)>\n```\n### XML引用DTD文件\n◇在XML使用<!DOCTYPE>标签来引用DTD文件<br />书写格式:\n```xml\n<!DOCTYPE 根节点 SYSTEM \"dtd文件路径\">\neg:\n<!DOCTYPE hr SYSTEM \"hr.dtd\">\n```\n### XML Schema\n◇[XML Schema](https://www.w3school.com.cn/schema/index.asp)比DTD更为复杂，提供了更多功能。<br />◇XML Schema提供了数据类型、格式限定、数据范围等特性。<br />◇XML Schema是W3C标准。<br />◇eg\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\">\n\t<element name=\"hr\">\n\t\t<!-- complexType标签含义是复杂节点，包含子节点时必须使用这个标签 这里表示hr下有子节点 -->\n\t\t<complexType>\n\t\t\t<sequence>  <!--队列 说明前后顺序-->\n\t\t\t\t<element name=\"employee\" minOccurs=\"1\" maxOccurs=\"9999\">\n\t\t\t\t\t<complexType>  <!--employee下有子节点 -->\n\t\t\t\t\t\t<sequence>\n\t\t\t\t\t\t\t<element name=\"name\" type=\"string\"></element>\n\t\t\t\t\t\t\t<element name=\"age\">\n\t\t\t\t\t\t\t\t<simpleType>\n\t\t\t\t\t\t\t\t\t<restriction base=\"integer\">\n\t\t\t\t\t\t\t\t\t\t<minInclusive value=\"18\"></minInclusive>\n\t\t\t\t\t\t\t\t\t\t<maxInclusive value=\"60\"></maxInclusive>\n\t\t\t\t\t\t\t\t\t</restriction>\n\t\t\t\t\t\t\t\t</simpleType>\n\t\t\t\t\t\t\t</element>\n\t\t\t\t\t\t\t<element name=\"salary\" type=\"integer\"></element>\n\t\t\t\t\t\t\t<element name=\"department\">\n\t\t\t\t\t\t\t\t<complexType>\n\t\t\t\t\t\t\t\t\t<sequence>\n\t\t\t\t\t\t\t\t\t\t<element name=\"dname\" type=\"string\"></element>\n\t\t\t\t\t\t\t\t\t\t<element name=\"address\" type=\"string\"></element>\n\t\t\t\t\t\t\t\t\t</sequence>\n\t\t\t\t\t\t\t\t</complexType>\n\t\t\t\t\t\t\t</element>\n\t\t\t\t\t\t</sequence>\n\t\t\t\t\t\t<attribute name=\"no\" type=\"string\" use=\"required\"></attribute><!--required表示必须存在no这个属性-->\t\t\t\t\t\n\t\t\t\t\t</complexType>\n\t\t\t\t</element>\n\t\t\t</sequence>\n\t\t</complexType>\n\t</element>\t\n</schema>\n```\n## DOM模型与Dom4j\n### DOM文档对象模型\n◇DOM(Document Object Moder) 定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构来查看，能够通过DOM树来读写所有元素。<br />![](7.png)\n\n### Dom4j\n◇Dom4j是一个易用的、开源的库，用于解析XML。它应用于java平台，具有性能优异、功能强大和极其易使用的特点。<br />◇Dom4j将XML视为Document对象<br />◇XML标签被Dom4j定义为Element对象\n### 利用Dom4j遍历XML \n◇在xml工程中src存储了xml文件以及dtd和xsd文件；新建一个lib文件用于引入dom4j的依赖；即将dom4j-2.1.1.jar文件复制到lib中，然后右键Build Path->Add to Build Path即可；<br />◇hr.xml\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hr SYSTEM \"hr.dtd\">\n<!-- 人力资源管理系统 -->\n<hr>\n\t<employee no=\"3301\">\n\t\t<name>李铁柱</name>\n\t\t<age>37</age>\n\t\t<salary>3600</salary>\n\t\t<department>\n\t\t\t<dname>人事部</dname>\n\t\t\t<address>XX大厦-B105</address>\n\t\t</department>\n\t</employee>\n\t<employee no=\"3302\">\n\t\t<name>林海</name>\n\t\t<age>50</age>\n\t\t<salary>7000</salary>\n\t\t<department>\n\t\t\t<dname>财务部</dname>\n\t\t\t<address>XX大厦-B106</address>\n\t\t</department>\n\t</employee>\n\t<employee no=\"3303\">\n\t\t<name>安娜</name>\n\t\t<age>24</age>\n\t\t<salary>4600</salary>\n\t\t<department>\n\t\t\t<dname>人事部</dname>\n\t\t\t<address>XX大厦-B105</address>\n\t\t</department>\n\t</employee>\n</hr>\n```\n◇新建包com.lcg.dom4j，创建类HrReader读取xml文件\n```java\npackage com.lcg.dom4j;\n\nimport java.util.List;\n\nimport org.dom4j.Attribute;\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\n\npublic class HrReader {\n\tpublic void readXml(){\n\t\tString file = \"d:/workspace/xml/src/hr.xml\";\n\t\t//SAXReader类是读取XML文件的核心类，用于将XML解析后以“树”的形式保存在内存中。\n\t\tSAXReader reader = new SAXReader();\n\t\ttry {\n      //read方法解析出一个document对象;\n\t\t\tDocument document = reader.read(file);\n\t\t\t//获取XML文档的根节点，即hr标签\n\t\t\tElement root = document.getRootElement();\n\t\t\t//elements方法用于获取指定的标签集合\n\t\t\tList<Element> employees =  root.elements(\"employee\");\n\t\t\tfor(Element employee : employees){\n\t\t\t\t//element方法用于获取唯一的子节点对象\n\t\t\t\tElement name = employee.element(\"name\");\n\t\t\t\tString empName = name.getText();//getText()方法用于获取标签或者属性的文本\n\t\t\t\tSystem.out.println(empName);\n        //直接打印,不赋值;\n\t\t\t\tSystem.out.println(employee.elementText(\"age\"));\n        //elementText方法和getText()方法一样;\n\t\t\t\tSystem.out.println(employee.elementText(\"salary\"));\n\t\t\t\tElement department = employee.element(\"department\");\n\t\t\t\tSystem.out.println(department.element(\"dname\").getText());\n\t\t\t\tSystem.out.println(department.element(\"address\").getText());\n        //attribute方法用于获取属性;\n\t\t\t\tAttribute att = employee.attribute(\"no\");\n\t\t\t\tSystem.out.println(att.getText());\n\t\t\t}\n\t\t} catch (DocumentException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tHrReader reader = new HrReader();//实例化HrReader方法;\n\t\treader.readXml();\n\t}\n\t\n}\n\n```\n### 利用Dom4j更新XML   \n◇新建类HrWriter\n```java\npackage com.lcg.dom4j;\n\nimport java.io.FileOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\n\npublic class HrWriter {\n\tpublic void writeXml(){\n\t\tString file = \"d:/workspace/xml/src/hr.xml\";\n\t\tSAXReader reader = new SAXReader();\n\t\ttry {\n\t\t\tDocument document = reader.read(file);\n\t\t\tElement root = document.getRootElement();\n            //增加新的子节点employee;\n\t\t\tElement employee = root.addElement(\"employee\");\n            //增加节点的属性;\n\t\t\temployee.addAttribute(\"no\", \"3311\");\n\t\t\tElement name = employee.addElement(\"name\");//增加name子节点;\n\t\t\tname.setText(\"李铁柱\");//设置文本;\n\t\t\temployee.addElement(\"age\").setText(\"37\");//合成一行代码;\n\t\t\temployee.addElement(\"salary\").setText(\"3600\");\n\t\t\tElement department = employee.addElement(\"department\");\n\t\t\tdepartment.addElement(\"dname\").setText(\"人事部\");\n\t\t\tdepartment.addElement(\"address\").setText(\"XX大厦-B105\");\n            //把文件的输出流转换为Writer对象\n\t\t\tWriter writer = new OutputStreamWriter(new FileOutputStream(file) , \"UTF-8\");\n            //将dom模型写入到对应文件中;\n\t\t\tdocument.write(writer);\n\t\t\twriter.close();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tHrWriter hrWriter = new HrWriter();\n\t\thrWriter.writeXml();\n\t}\n}\n```\n## XPath表达式\n### XPath路径表达式\n◇XPath路径表达式是XML文档中查找数据的语言。<br />◇掌握XPath可以极大提高在提取数据时的开发效率。<br />◇学习XPath本质就是掌握各种形式表达的使用技巧。\n### XPath基本表达式\n◇最常用的基本表达式\n\n| 表达式 | 描述 |\n| --- | --- |\n| nodename | 选取此节点的所有子节点 |\n| / | 从根节点选取 |\n| // | 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 |\n| . | 选取当前节点 |\n| .. | 选取当前节点的父节点 |\n| @ | 选取属性 |\n\n### XPath基本表达式案例\n![](8.png)\n\n### XPath谓语表达式\n◇谓语表达式统一使用中括号，里面再加一个谓语表示；<br />![](9.png)\n\n## Xpath实验室\n### Jaxen介绍\n◇Jaxen是一个java编写的开源的XPath库。这是适应多种不同的对象模型，包括DOM，XOM,dom4j和JDOM。<br />◇Dom4j底层依赖Jaxen实现XPath查询<br />◇Jaxen下载地址:meaven.aliyun.com在阿里云的仓库中搜索下载\n### 代码演示\n◇引入jaxen依赖；<br />◇创建类XPathTestor\n```java\npackage com.lcg.dom4j;\n\nimport java.util.List;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.Node;\nimport org.dom4j.io.SAXReader;\n\npublic class XPathTestor {\n\tpublic void xpath(String xpathExp){\n\t\tString file = \"E:/lianxi/xml/hr.xml\";\n\t\tSAXReader reader = new SAXReader();\n\t\ttry {\n            //获取document对象\n\t\t\tDocument document = reader.read(file);\n\t\t\t/*selectNodes方法用来执行xpath表达式;对于xpath表达式来说,不仅可以查询标签本身,\n            还可以查询属性,Node是标签和属性的一个父类,因此返回的是一个Node;\n            */\n\t\t\tList<Node> nodes = document.selectNodes(xpathExp);\n\t\t\tfor(Node node : nodes){\n\t\t\t\tElement emp = (Element)node;//把node转换为Element对象;\n                //输出相关信息;\n\t\t\t\tSystem.out.println(emp.attributeValue(\"no\"));\n\t\t\t\tSystem.out.println(emp.elementText(\"name\"));\n\t\t\t\tSystem.out.println(emp.elementText(\"age\"));\n\t\t\t\tSystem.out.println(emp.elementText(\"salary\"));\n\t\t\t\tSystem.out.println(\"==============================\");\n\t\t\t}\n\t\t} catch (DocumentException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tXPathTestor testor = new XPathTestor();\n//\t\ttestor.xpath(\"/hr/employee\");\n//\t\ttestor.xpath(\"//employee\");\n//\t\ttestor.xpath(\"//employee[salary<4000]\"); 工资小于4000的职员\n//\t\ttestor.xpath(\"//employee[name='李铁柱']\");\n//\t\ttestor.xpath(\"//employee[@no=3304]\");\n//\t\ttestor.xpath(\"//employee[1]\");\n//\t\ttestor.xpath(\"//employee[last()]\");\n\t\t//testor.xpath(\"//employee[position()<3]\");\n\t\ttestor.xpath(\"//employee[3] | //employee[8]\");\n\t\t\n\t}\n}\n\n```\n\n","tags":["xml"],"categories":["JavaWeb"]},{"title":"删除功能出现的BUG","url":"/p/de80.html","content":"\n### 功能简介\n\n​\t\t开发一个删除油画功能模块，要求能够在前台中点击某一油画进行删除后，弹出对话框进行确认删除，若确认则发送ajax请求到后台，然后后台根据发送过来的id进行相应的删除，并且使用json对象返回处理的结果；\n\n### 实现思路\n\n​\t\t对于底层的数据删除，使用dom4j进行对xml的删除操作；首先根据id筛选出指定的节点p；然后根据此节点获取到其父节点，使用父节点的remove方法来删除此节点；代码如下：\n\n```java\n//得到P的根节点然后用根节点删去P;\np.getParent().remove(p);\n```\n\n​\t\t然后就是根据MVC的调用要求，依次创建Dao、Service、Controller中的方法；在Controller方法中进行与前台的交互即可；\n\n### 出现的BUG\n\n​\t\t当在前台页面点击删除油画后，发现删除成功，然后不刷新页面。再次删除此油画，这幅油画实际上已经被删除了，所以根据后台的逻辑，应该会删除失败，并提示该油画已经被删除或者不存在；但是前台确提示删除成功，按F12查看浏览器控制台打印的json对象如下:\n\n![console.png](https://s2.loli.net/2021/12/09/oAaKdbu2tNm4iYP.png)\n\n这说明在控制器中根本没有执行catch块里的代码，而是执行了try里的代码，{% wavy 没有捕捉到 %}XmlDataSource中抛出的异常；后端控制台打印的信息如下：\n\n```tex\n获取ajax请求发送过来的id为:16\n/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xml\njava.lang.RuntimeException: 编号为16的油画不存在或已删除\n\tat com.lcg.mgallery.utils.XmlDataSource.delete(XmlDataSource.java:186)\n\tat com.lcg.mgallery.dao.PaintingDao.delete(PaintingDao.java:68)\n\tat com.lcg.mgallery.service.PaintingService.delete(PaintingService.java:69)\n\tat com.lcg.mgallery.controller.ManagementController.delete(ManagementController.java:247)\n\tat com.lcg.mgallery.controller.ManagementController.doGet(ManagementController.java:64)\n\tat com.lcg.mgallery.controller.ManagementController.doPost(ManagementController.java:73)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:661)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:742)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\n\tat org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800)\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498)\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.lang.Thread.run(Unknown Source)\n/F:/JAVA/Tomcat/apache-tomcat-8.5.34/webapps/mgallery/WEB-INF/classes/painting.xml\n成功执行了删除的操作\n```\n\n​\t\t可以发现确实出现了异常，但出现异常后确仍然打印出\"成功执行了删除的操作\"；这是什么原因呢？**为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常？**我们来分析一下后台的代码；\n\n对Xml文件进行直接操作的XmlDataSource类中的删除方法代码如下：\n\n```java\npublic static void delete(Integer id) {\n\t\ttry {\n\t\t\tdocument = reader.read(dataFile);\n\t\t\tList<Node> nodes = document.selectNodes(\"/root/painting[@id=\" + id + \"]\");\n\t\t\tif(nodes.size() == 0) {\n\t\t\t\tthrow new RuntimeException(\"编号为\" + id + \"的油画不存在或已删除\");\n\t\t\t}\n             //省略执行删除操作代码..\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(\"编号为\" + id + \"的油画不存在或已删除\");\n\t\t}finally {\n            //...部分代码\n\t\t\treload();\n\t\t}\n\t}\n```\n\n​\t\t控制器中的删除方法代码如下(控制器中调用的是Service中的delete方法，按照MVC的架构模式会{% u 逐级调用 %}到XmlDataSource中的方法)\n\n```java\n//删除油画\nprivate void delete(HttpServletRequest request,HttpServletResponse response) throws IOException {\n    String id = request.getParameter(\"id\");//获取ajax请求发送过来的参数\n    System.out.println(\"获取ajax请求发送过来的id为:\"+id);\n    Map result = new HashMap();\n    try {\n        //调用方法进行油画的删除\n        paintingService.delete(Integer.parseInt(id));\n        result.put(\"code\", \"0\");\n        result.put(\"msg\", \"success\");\n        System.out.println(\"成功执行了删除的操作\");\n    }catch(Exception e) {\n        e.printStackTrace();\n        result.put(\"code\", \"1\");\n        result.put(\"msg\", e.getMessage());\n        System.out.println(\"遇到了异常\");\n    }\n    String json = JSON.toJSONString(result);\n    response.setContentType(\"text/html;charset=UTF-8\");\n    response.getWriter().println(json);\n}\n```\n\n​\t\t通过对控制台中的打印结果分析想到，既然在Controller中并没有捕捉到，那么为什么会打印出异常的信息呢？很快就想到可能在XmlDataSource中就把异常给捕捉了，于是在XmlDataSource中将catch块中的e.printStackTrace();注释掉，在前台执行重复删除的操作，发现后台{% emp 果然没有打印出 %}异常信息!\n\n### BUG解决方法\n\n​\t\t在知道了为什么在控制器的方法中无法捕捉到XmlDataSource中抛出的异常后，就能想到出错的原因在哪里了；因为在XmlDataSource的删除方法中，前面的一些代码也会抛出异常，为了寻求方便我索性使用Exception来捕捉这些异常，这就导致将我们自定义的异常给捕获并处理了（因为RuntimeException继承自Exception），进而在Controller中无法捕捉到异常，给前台的反馈消息总是删除成功的；\n\n​\t\t所以解决方法是分别捕捉可能出现的每一种异常(除RuntimeException以外)；修改后的方法如下：\n\n```\npublic static void delete(Integer id) {\n\t\tSAXReader reader = new SAXReader();\n\t\tWriter writer = null;\n\t\tDocument document;\n\t\ttry {\n\t\t\tdocument = reader.read(dataFile);\n\t\t\tList<Node> nodes = document.selectNodes(\"/root/painting[@id=\" + id + \"]\");\n\t\t\tif(nodes.size() == 0) {\n\t\t\t\tthrow new RuntimeException(\"编号为\" + id + \"的油画不存在或已删除\");\n\t\t\t}\n\t\t\tElement p = (Element)nodes.get(0);\n\t\t\t//得到P的根节点然后用根节点删去P;\n\t\t\tp.getParent().remove(p);\n\t\t\t//修改后的数据回写到原来的xml文件中;\n\t\t\twriter = new OutputStreamWriter(new FileOutputStream(dataFile),\"UTF-8\");\n\t\t\tdocument.write(writer);\n\t\t} catch (DocumentException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tif(writer != null) {\n\t\t\t\ttry {\n\t\t\t\t\twriter.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treload();\n\t\t}\t\t\n\t}\n```\n\n​\t\t这样以后，成功解决了前面出现的问题；这里附上前台页面的代码，弹出窗口使用了[SweetAlert](https://sweetalert2.github.io/)\n\n```jsp\n<script>\n//提示删除\n\tfunction del(previewObj){\n\t\tvar preview = $(previewObj).attr(\"data-preview\");//获取自定义属性\n\t\tvar pname = $(previewObj).attr(\"data-pname\");\n\t\tvar id = $(previewObj).attr(\"data-id\");\t\t\n\t\tSwal.fire({\n\t\t\t  title: '删除'+pname+'?',\n\t\t\t  html: \"<img src='\" + preview + \"' style='width:361px;height:240px'>\",\n\t\t\t  icon: 'warning',\n\t\t\t  showCancelButton: true,\n\t\t\t  confirmButtonColor: '#3085d6',\n\t\t\t  cancelButtonColor: '#d33',\n\t\t\t  confirmButtonText: '是的',\n\t\t\t  cancelButtonText: '取消'\n\t\t\t}).then(function(isConfirm){\n\t\t\t  if (isConfirm.value) {\n\t\t\t\t//发送ajax请求\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\t\"url\" : \"/management?method=delete\",\n\t\t\t\t\t\t\"type\" : \"post\",\n\t\t\t\t\t\t\"data\" : {\"id\":id},\n\t\t\t\t\t\t\"dataType\" : \"json\",\n\t\t\t\t\t\t\"success\" : function(json){\n\t\t\t\t\t\t\tconsole.log(json);\n\t\t\t\t\t\t\tif(json.code==\"0\"){\n\t\t\t\t\t\t\t\tSwal.fire('删除成功!','油画已经成功删除','success').then(function(isConfirm){\n\t\t\t\t\t\t\t\t\tif (isConfirm.value){\n\t\t\t\t\t\t\t\t\t\t//点击确认后刷新页面\n\t\t\t\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tSwal.fire('删除失败!',json.msg,'error').then(function(isConfirm){\n\t\t\t\t\t\t\t\t\tif (isConfirm.value){\n\t\t\t\t\t\t\t\t\t\t//点击确认后刷新页面\n\t\t\t\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t  }\n\t\t})\n\t}\n</script>\n  <!-- 省略部分代码 -->\n<a class=\"oplink\" data-id=\"${painting.id}\" data-preview=\"${painting.preview}\" data-pname=\"${painting.pname}\" href=\"javascript:void(0)\" onclick=\"del(this)\">删除</a>\n```\n\n### 总结\n\n​\t\ttry-catch-finally执行的基本步骤是：如果try块中出现了{% emp 异常 %},不管是自定义抛出的还是系统抛出的，在catch块中只要符合捕捉的范围，都会对该异常进行处理，最后执行finally块中的代码； 如果没有出现异常，则直接执行try块中的代码，然后执行finally中的代码；因此在开发过程中不要一时图方便，将捕捉异常的范围扩大，还应当业务逻辑进行仔细分析，采用最佳的处理方法；\n","tags":["BUG"],"categories":["Java开发"]},{"title":"递归逆置链表","url":"/p/bac2.html","content":"\n#### 实验内容\n\n  对于一个不带头结点的单链表，设计递归算法逆置所有结点。\n\n#### 实验原理\n\n  **1.递归介绍**\n\n​\t\t程序调用自身的编程技巧称为递归；一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。递归必须具备两个条件，一个是{% wavy 调用自己 %}，一个是有{% wavy 终止条件 %}。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方如下面的代码一样:\n\n```C\nvoid recursion(参数0) {\n    if (终止条件) {\n        return;\n    }\n    recursion(参数1);\n}\n```\n\n**2.逆置方法**\n\n​\t\t对于单链表的递归逆置虽然只有几行代码，但刚开始接触可能会有点绕，所以我尽可能详细的把思路理出来；\n\n​\t\t对于有n个结点的链表的逆置，利用递归的思想可以先将前n-1个结点逆置；当链表为空或者链表只有一个结点的时候终止递归；每一次调用逆置函数R()完成后返回链表已经逆置完成的部分的第一个结点(设为newNode)；因为在当前结点(设为p)前面的结点都已经完成了逆置，所以当前结点指向的下一个结点(p->next)，成为了已经逆置完成的部分的最后一个结点；如果要进行逆置的话，当前结点应该要变成最后一个结点；所以将p->next的下一个结点设置为当前结点，即指向p：**p->next**->next=**p**;  p变为最后一个结点后，其下一个结点为空，即p->next=NULL;这样就完成了以当前结点为第一个结点的链表部分的逆置，返回当前的第一个结点，继续进行逆置，直到所有递归函数调用完毕；\n\n​\t\t我们来看一个例子，比如要对链表a->b->c->d进行逆置；调用逆置函数R(a),R(a)中会递归调用R(a->next)即R(b),而R(b)中又会调用R(b->next)即R(c);这样依次下来：（递归完成部分加粗显示，按照调用完成的顺序）\n\n①R(d),对d进行逆置，由于d->next为空，所以直接返回d;此时有newNode=d, a->b->c->**d->NULL**;\n\n②R(c),对c->d进行逆置,当前结点为c，要进行逆置，c应该为最后一个结点，则有：c->next(d)->next=c;c->next=NULL; 此时有newNode=d,**d->c->NULL**; a->b->c->NULL;注意这里没有任何结点指向d了，因为已经将c->next设置为空；\n\n③R(b),对b->c->d进行逆置，由于c->d部分已经逆置成**d->c->NULL**了，所以只需要将b设置为最后一个结点即可；b->next(c)->next=b; b->next=NULL;返回d；此时有newNode=d,**d->c->b->NULL**; a->b->NULL;\n\n④R(a),对a->b->c->d进行逆置,由于b->c->d部分已经逆置成**d->c->b->NULL**，所以像③一样，a->next(b)->next=a, a->next=NULL;至此，所有的递归函数都已经调用完毕；得到了newNode=d，**d->c->b->a->NULL**完成了所有节点的逆置；\n\n#### 代码演示\n\n{% tabs tab-id %}\n\n<!-- tab 完整代码 -->\n\n```c++\n#include<iostream>\nusing namespace std;\n\ntypedef struct Node {\n\tint data;\n\tstruct Node* next;\n} LinkNode;\n\nLinkNode* CreateList(int a[],int n) {\n\tif (n < 0)\n\t\treturn NULL;\n\tLinkNode* head = new LinkNode();\n\tLinkNode* p = new LinkNode();\n\tp = head;\n\thead->data = a[0];\n\tint i = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tLinkNode* node = new LinkNode();\n\t\tnode->data = a[i];\n\t\tp->next = node;\n\t\tp = node;\n\t}\n\tp->next = NULL;  // 尾结点next域置为空\n\treturn head;\n}\n\nvoid DispList(LinkNode* ln) {\n\tcout << \" \";\n\tif (ln != NULL) {\n\t\tcout << ln->data;\n\t\tDispList(ln->next);\n\t}\n}\n\nLinkNode* Release(LinkNode* ln) {\n\tif (ln == NULL || ln->next == NULL)\n\t\treturn ln;\n\telse {\n\t\tLinkNode* newNode = Release(ln->next);\n\t\tln->next->next = ln;//将当前结点接在逆置完成部分的最后结点后面,使其成为最后结点\n\t\tln->next = NULL;//逆置后，最后一个结点的下一个结点为空\n\t\treturn newNode;//返回逆置完成部分的第一个结点      \n\t}\n}\n\nint main() {\n\tint a[] = {0,1,2,3,4,5,6,7,8,9};\n    int n = sizeof(a) / sizeof(a[0]);\n\tLinkNode* L, *N;\n\tL = CreateList(a,n);\n\tcout << \"初始链表:\" << endl;\n\tDispList(L);\n\tcout << endl;\n\tcout << \"逆置链表:\" << endl;\n\tN = Release(L);\n\tDispList(N);\n\tcout << endl;\n\tdelete L;\n\tdelete N;\n\treturn 0;\n}\n```\n\n<!-- endtab -->\n\n<!-- tab 运行结果 -->\n\n![](https://s2.loli.net/2021/12/09/bSlnhdWxo7vPZ6G.png)\n\n<!-- endtab -->\n\n{% endtabs %}\n\n","tags":["递归"],"categories":["数据结构"]},{"title":"【转载】如何成为优秀的程序员","url":"/p/6380.html","content":"\n​        本文转自:http://www.akaedu.org/pages/news_detail.php?id=294 \n\n​        我们的老师每天都要应对报名者和学员提出的很多同样的问题，以下是这类典型问题的汇总：嵌入式行业（或者IT业）有没有前途？我听说编程编到三十五 岁就没人要了，一定要转行找出路是吗？做驱动开发和做应用开发哪个更有前途？我一开始看什么书都看不懂，怎么才能理出一个学习顺序？诸如此类。这使我迫切 地感觉到，应该总结这样一份非具体技术问题的FAQ了。本文仅代表我个人观点，有问题欢迎Email: [songjinshan@akaedu.org](mailto:songjinshan@akaedu.org)。\n\n​        在看这份FAQ之前，你必须先读完ESR的《如何成为一名黑客》（本文末尾附有中译版），该文所讲过的道理我不再重复。该文用很大的篇幅讲什么是黑客文 化，虽然态度和信仰的确是成功的最关键因素，但是你肯定会想，做不做黑客跟我没关系，我只是想学个一技之长，找个好工作而已，对吧？那么肯定更希望获得一 些具体的可操作的指导。\n\n####   1、各种软件技术之间是怎样的关系？ \n\n  我把软件技术分为三个层次：\n        **问题域**：计算机图形学、音视频编码、信息安全、模式识别、信息检索、自然语言分析、人工智能、科学计算等；\n        **系统集成**：C++和Java等面向对象语言、Python等解释型语言、LISP等函数式编程语言、GUI、中间件、编译器与解释器、虚拟机、数据库、网络服务、并行计算、集群、Peer2Peer、系统管理等；\n\n**系统功能**：硬件描述语言、计算机体系结构与编程模型、指令集与汇编语言、C语言、内核、文件系统、设备驱动、网络协议、POSIX等。\n\n​        计算机最终是做什么用的呢？最终是通过问题域的各种技术为用户解决问题的，这些技术都包含很高深的算法，然而它们必须在一个平台上运行，它们需要利用平台 提供的各种基础设施，比如计算能力、I/O能力和网络互联能力。系统功能和系统集成层就是用来实现这个平台的。系统功能层实现计算、I/O和网络的基本功 能，系统集成层对这些基本功能做一些抽象和包装，提供更方便灵活的接口。\n\n####   2、为什么要学习嵌入式技术？ \n\n​        在亚嵌的学习期间，你将详细了解系统功能层的各部分是如何工作的，也会在面向对象编程、GUI、数据库、网络服务等系统集成层的技术方向进行探索。嵌入式 系统可说是麻雀虽小五脏俱全，虽然没有PC和服务器那么复杂，但计算机系统的各种组成一样也不缺。因此，以嵌入式系统作为切入点开始学习软件技术是非常好 的选择，避开不必要的复杂性，把握计算机系统最根本的概念和技术要点。打下扎实的基础之后，你的职业发展则完全不必局限于嵌入式领域，即使你日后做PC或 服务器开发，在亚嵌所学的知识和技能同样使你终生受益。正如庖丁解牛，心中有全牛，自然就能游刃有余。\n\n​        另一方面，你一定见到各大网站都有大量的宣传，说现在嵌入式行业前景空前的好，嵌入式人才紧缺，有几百万职位空缺等等。这些说法也是对的，但我们需要更深 入地理解这说明了什么问题。刚才我们说，嵌入式系统也是一个完整的计算机系统，和PC或服务器没有本质的区别，事实上，嵌入式、PC和服务器的界限已经越 来越模糊了。以前的嵌入式就是单片机，只能做简单的运算处理，现在的ARM处理器性能比从前的奔腾还强，打游戏、看电影都没问题，谁能说它不是PC呢？另 外有些专用的嵌入式系统已经在充当服务器的功能了，而集群技术更是可以使许多廉价的处理器组合在一起发挥大型服务器的作用。由于嵌入式越来越多地应用到电 器、汽车和各种设施上，无处不在，并且与PC、服务器呈融合的趋势，所以嵌入式行业前景空前的好。\n\n​        那么，为什么说嵌入式人才紧缺呢？其实，学嵌入式系统就是学计算机系统，本质上并没有什么特殊的只有嵌入式系统才有的技术。说嵌入式人才紧缺，其实质上是 说真正懂计算机的人才紧缺。现在很多学校的所谓“软件学院”培养的软件人才都是一叶障目不见泰山的：只懂J2EE和.NET，没学过C和汇编；只会调库函 数sort()，而对各种排序算法一无所知；设计模式、软件工程讲得头头是道，却不知道好的软件还是要靠牛人靠智商来做的。培养人像蒸包子一样一屉一屉地 出，靠软件工程搭一条生产线，然后让熟练工人站在生产线上拧螺丝，幻想着这样就能生产出好的软件，那是把软件工程和程序员的作用本末倒置了。现在嵌入式开 发对程序员的素质要求更高了，以上这类“软件人才”不能胜任了，因此说嵌入式人才紧缺。亚嵌的就业班虽然只有几个月，但培养目标是有完整的计算机系统概念 的软件人才，而不是只会拧螺丝的软件工人，这正得益于我们始终坚持做嵌入式培训而不是Java或.NET培训。\n\n####   3、有人说软件技术变化太快，现在学的东西过两年就要完全淘汰，是吗？ \n\n​        你知道这话是什么人说的吗？必然是已经被淘汰的人说的。比如Delphi、BCB、PB这些开发工具和语言，都曾经很是风光了一阵，但现在已经完全被 Java和.NET取代了。那么Java和.NET会不会被取代呢，也许在相当长的时间内还不会，但是我看好Python。\n\n​        这些被淘汰的程序员有一些共同的特点：只会用鼠标拖拽控件，离开IDE就不知道如何工作，学点儿花拳绣腿的功夫就想吃一辈子，对学习新技术不感兴趣，做一 天和尚撞一天钟。现在请回头看看FAQ1，在整个软件技术领域，这些变化快的技术其实只占了很小的一块，却成了这些人的全部看家本领，这样的人能不被淘汰 吗？\n\n​        与这些流行的开发工具和语言相反，很多技术和思想是很少变化的。比如，POSIX和SUS标准规定了一套系统函数接口和基本命令的语义，只有实现了这些才 可以称作UNIX，因此今天的Linux、Solaris跟20多年前的UNIX在系统功能层上是基本一致的。而指导计算机科学发展的数学理论，甚至是老 祖宗们在计算机还没诞生的年代就替我们想好的：布尔代数发表于19世纪，直到一个世纪后发明了计算机和数字电路才有了用武之地；数论在17世纪就出现了， 一直都被数学家们当成一套好玩的理论，但只是好玩而已，直到计算机密码学诞生后才发现它的实际用处。\n\n​        各种流行的开发工具和高级语言虽然变化很快，但是底层的编程语言却非常稳定，各种操作系统的内核都是用C语言写的，以前是这样，以后也不会改变。另一方 面，各种编程语言的设计思想也是非常稳定的。其实世界上只有两种编程语言，一种是C，一种是LISP，前者是imperative的，是对计算机模型的抽 象，后者是functional的，是对数学函数模型的抽象。面向对象是一种重要的软件工程思想，却算不上一种新的语言模型，应该归在C的一类。属于同一 类的各种语言其实都大同小异，一个精通C++的人学习Java需要多长时间？熟悉语法一个星期，熟悉类库三个星期，一个月足矣，以往的经验都可以套到新的 编程语言上。然而要想习得深厚的算法功底、逻辑思维和抽象思维修养，能够真正说清楚“系统”是什么，如何分析和设计“系统”，需要多长时间？恐怕要数十 年。\n\n####  4、C和Java哪种语言更好？ \n\n​        计算机科学与编程语言无关，甚至与计算机本身也没太大关系，它研究的对象并不是计算机，而是人分析问题解决问题的方法论。程序写出来最主要不是为了给计算 机执行的，而是为了给人看的，使用编程语言和使用自然语言一样是为了表达和交流，只不过程序还可以顺便给计算机执行而已。\n\n​        以上这些话并不是我说的，而是一位著名的计算机科学家说的。所以，在编程语言的层面上争论是没有意义的。很多初学者错误地认为掌握了编程语言就等于学会了 计算机，一种编程语言都还没有掌握好，更没有上升到方法论的层面，只有这种无知的人才会去争论哪种语言好的问题。掌握了编程语言远远不等于学会了计算机， 而只是最开始的一步，最简单的一步，到了工作中，用到什么语言就去学什么语言，什么语言过时了就丢掉，编程语言不需要积累因为它太简单了，真正需要积累的 是方法论。\n\n​        很多人喜欢参与到这类争论之中，毫无例外，每个人都在为自己熟练掌握的编程语言辩护，就是“我会的语言最好，我不会的语言都不好”，其实这些人真正想说的 是“我会的语言最好是千秋万代，我就不必学新的语言，不必适应新的变化了”，概括起来说就是一个字，懒。真正的高手都是会很多编程语言的，国外有些做技术 咨询的，每年都要学好几门新的编程语言，这样才能应对市场的变化。不断丢掉旧的编程语言学习新的，看起来好像完全是白费力气，没有积累，其实，每种编程语 言的设计都有独到之处，体现了每种语言的精髓，在融汇百家之后积累下来的正是方法论。\n\n​       争论哪种语言能做的事情更多、功能更强是没有意义的。从理论上说，任何一种符合图灵机模型的编程语言，加上适当的I/O扩展都可以做任何事情，用 shell脚本也可以写出很像样的游戏来。只不过各种语言的设计目标不同，表达能力不同，做不同的事情所需的代码量不同而已。\n\n​        另外一种错误认识是：哪种语言的市场最大，开发人员最多，哪种语言就最好。单从这种意义上说，Java的确比C更好，所以往届有学员问我们为什么只教C语 言。请你注意，操作系统内核是用C写的，各种底层的应用程序包括Java虚拟机也是用C写的。如果你想学Java，在亚嵌的学习完成后你将有能力分析 Java虚拟机的实现，站在计算机系统的高度来学Java才会使你成为真正的Java高手。如果你只想速成，想早点学成一门技术去做拧螺丝的工作，那么亚嵌不适合你。\n\n​       在FAQ3里说过，世界上有C和LISP两种编程语言，你现在学了C，以后学了C++、Java、.NET等等，也仍然只认识了半个世界。LISP和 Haskell构成了另外半个世界，现在很常见的Python和JavaScript等解释型语言也借用了functional programming的思想。如果你只管闷着头写代码，而不去广泛涉猎，那么你将错过很多精彩。\n\n####   5、我听说编程编到三十五岁就没人要了一定要转行找出路是吗？ \n\n​      这个观点虽然很流行，但根本不值一驳。现在三十五岁转行的那些人，都具有前面所说的那些特征，对学习新技术不感兴趣，对探索计算机的本质不感兴趣，得过且 过，下了班就是打游戏、看电视，总之就是懒。如果是开出租、摆摊，勤快人懒人都有饭吃，而IT这一行对懒人是非常无情的，懒人就不该入IT这一行，不从自 身找原因，却到处散布这种言论，怪社会不好，打击新人的信心，着实可恨。\n\n​       另外一种情况，编程编到三十五岁，进入公司的管理层，或者自己创业，这都是很勤快的人，如果他们把这种勤快用在技术上肯定也可以做得更好，所以也无法证明编程编到三十五岁会因为没有出路而转行。\n\n​       编程不是个体力活，需要高强度的思考和智力投入，分析能力、思考能力都需要时间积累起来，所以并不是越年轻干得越好。相反，我认为三十岁以前写的代码都是 垃圾，三十岁以后才能写出像样的程序来。如果希望一辈子走技术的道路而不会被迫转行，就要不断地把自己的工作性质从“体力活”变成“脑力活”。什么叫“不 断地”变呢？这里的“体力活”并不是指种地、盖房子这种劳动，而是指简单重复地编写代码，这时你会感觉，派给你的工作都能凭以往的经验轻松应付了，但是千 万不要满足于现状，就像温水煮青蛙一样，这是危险的处境！要摆脱这种处境就需要学习、思考、提高，让公司派给你更有挑战性的工作，在工作中应用新学到的知 识和技术就是“脑力活”了，但是用得久了又会变成简单重复的“体力活”，这时就需要再学习、再提高，所以叫做“不断地”把自己的工作性质从“体力活”变成 “脑力活”。如果有一天你发现，自己长期陷于简单重复的劳动之中，并且业余时间非常少，无法学习提高，这说明公司不会用人，你就该考虑跳糟了。\n\n​       从另外一个角度来说，如果希望一辈子走技术的道路，就要有自己的核心竞争力，这个核心竞争力决不是凭以往的经验能够做某些工作的能力，而是学习能力、思考 能力和解决有挑战性的新问题的潜力。在IT这一行，凭借以往的经验干重复的活是干不长久的，原因很简单，一个问题不会被解决两次，当你发现你的经验能够解 决一类问题时，别人早把解决这一类问题的套路编写成framework，新上手的人即使不具备你的这些经验也可以调用framework中的类和函数来解 决问题，然后在这个framework的基础上积累新的经验解决新的问题。正因为如此，全世界开发人员的经验才会积累起来，促使软件技术发展得如此迅速。 这并不是说经验完全没有用，最关键的，学习和思考也是建立在以往经验的基础之上的。另一方面，现有的framework并不一定是某方面开发经验的完美整 合，也需要不断发展，用新的办法重新解决老问题，以Web开发为例，从早期的ASP、PHP到后来的.NET、J2EE，到现在的Ruby on Rails、Django等等，这些framework解决的是同一问题，就是如何快速有效地开发Web应用，这方面的经验被不断重新整合，推陈出新。总 结一下，什么才是核心竞争力呢？应该是在经验的基础上学习新技术、解决新问题的能力。\n\n####   6、做驱动开发还是做应用开发更有前途？ \n\n​       意思就是说，“你告诉我哪个更有前途，我就好好学哪个，另外一个就不用学了”。问这种问题的学员往往会同时问另外一些问题：我以后就想做驱动开发，你教我这些应用开发的技术有什么用？C++用得多吗？学了有什么用？我以后不想做GUI，你教我Qt有什么用？\n\n​        学习最忌讳的就是“有用的就学，没有用的就不学”这种功利的态度。两个问题：第一，在你还没学进去、还不了解这种技术时，要如何判断这种技术学了有没有 用？只能是根据道听途说，看各种论坛上都怎么说的，岂不知论坛上参与这种讨论的100%都是菜鸟，有的水平还不如你。第二，就算你学的技术没有用上，有什 么损失吗？从亚嵌毕业的学员从事各种各样的开发工作，有做驱动的，有做系统编程的，有做GUI的，有做Web开发的，只要确定了做一类工作，就不可能把在 亚嵌四个月学的知识都用上，但至少也用得上3/4的知识，假设剩下的1/4你一辈子也没机会用上了，那也就损失你一个月的学习时间而已，相比于你的收获， 这算是很大的损失吗？请注意，上面的假设是不成立的，没用上的那1/4也只是暂时没用上而已，程序员要换工作或者换项目是很常见的，任何人都不可能只涉及 一类开发工作，只要有扎实的基础、完备的知识体系，任何工作都能轻松上手。\n\n​        扎实的基础，完备的知识体系，我们在安排就业班课程体系的时候，正是以这两点为依据的。有的课程内容很少有学员在以后工作中会用到，但是缺了这一环就不成 为一个完备的知识体系，例如MMU和Cache，那这种课该不该上呢？毫无疑问该上。有的课程培养一种基本的编程思想，例如通过C++来讲面向对象编程， 通过Qt来讲面向对象、事件驱动和状态机编程，这些编程思想是程序员必备的基本素质，而C++和Qt可能有些学员以后工作用不到，那这种课该不该上呢？毫 无疑问该上。至于还有些人争论说C++不如Java用得多，Qt不如GTK用得多，请翻回去看FAQ4，这种争论是无意义的，有工夫争论谁优谁劣，不如把 两种都学了，会更有收获。\n\n​        回到做驱动开发还是做应用开发更有前途的问题。我只能说，做好了都有前途，做不好都没有前途，只会做一样而完全不懂另一样是最没前途的。不要以为内核开发 者就不写应用程序，Linus写了一个源代码管理系统git来维护内核，因为觉得现有的源代码管理系统都不好用。牛人都是这样，需要什么就写什么，才不管 是kernel space还是user space。同样，做应用开发如果不懂内核，也没有办法很好地利用内核提供的服务写出性能最优的程序。做内核难，因为调试难，要跟踪大量的并发线程，因为 入门难，要写一个hello world都需要学很多知识。做应用也难，回头去看FAQ1，计算机科学从理论到实践大部分都在上面两层做文章。所以不存在哪个更难哪个更有前途的问题， 任何关于哪个更难的讨论都是too naive的。\n\n####   7、我一开始看什么书都看不懂，怎么才能理出一个学习顺序？ \n\n​       以前有个学员在学C语言时说，“C语言很多地方都很奇怪，都得用内核的知识去解释，可是你又不先教我内核，我没法学C语言。我只好自己看操作系统的书，看 内核代码，可是看不懂。”当然看不懂了，内核代码都是用C写的，如果不学内核就没法学C语言，那不学C语言又怎么可能看懂内核？看来这是一个鸡生蛋还是蛋 生鸡的问题。\n\n​        懒真的是人的本性，就连学习的过程都希望是一条路顺利地走下去，不用动脑就能学会的：身后走过的路都是“已知”，每走一步就把眼前新的“未知”变成“已 知”，如此一路走来，把所有的“未知”都变成“已知”就算学成了。可惜，知识不是一条路，而是一个圈，你从任何一个地方跳进这个圈开始走，身后都是“未 知”，眼前也都是“未知”。有的人就是不能容忍自己的身后是“未知”：看一本书，一个新的概念A是用我不了解的概念B、C来解释的，我连B、C都不懂怎么 学A？没法学了！\n\n  不是人家书写得不好，而是没有任何办法能把一个圈扯成一条直线的。学习的过程本质上就是一个循环往复的过程，唯一的办法就是“存疑”：在本子上记着，有 B、C这样两个概念是我暂时不理解的，然后就不再去想这回事，而是相信自己已经理解了B、C，基于自己的理解和假设去学习A，由A再去理解X、Y，这样学 下去，走完一圈之后再回来，自然就明白当初对B、C的假设正确不正确了，理解了这两个概念，就从本子上划掉，这时需要再走一圈，把原来的一些错误认识纠正 过来。所以，任何书都要至少看两遍，第二遍看的时候你会对很多概念有新的认识，因为你看过这个概念后面的章节，在此基础上产生了新的认识。古人早就明白这 个道理，所以提出了“温故而知新”。\n\n​        亚嵌的课程体系经过多年教学实践的锤炼，已经很好地理顺了知识之间的关系，使你从最佳的位置跳进这个圈开始学习，所谓“最佳位置”是指，在你初学的时候需 要容忍的“未知”尽可能少，需要做的假设尽可能少，但要想消除所有的“未知”是不可能的，例如没有学内核就要学C语言。根据你以往的经验和一些运气因素， 你对内核的一些假设可能正确也可能错误，但这并不影响你学C语言，对内核的一些错误假设可能会导致在学C语言的过程中有些误解，但没关系，只要跟着我们的 课程体系一步一步走下来，这些误解和错误的假设最终都会纠正过来。\n\n####   8、有哪些好书可以推荐一下吗？ \n\n​        能问出这个问题的都是聪明的学员。看书学习是入门过程中非常重要的一环，如果用一本烂书入门，浪费时间还是小事，如果被误导了就麻烦了，如果形成的错误认 识不能及时纠正，变得根深蒂固了就更麻烦了。所以，看书一定要有“品牌意识”，在决定看书学习一门技术时先问问这一领域最权威的书是哪本，这里列举一些 Bible级别的书：\n  *T*he C Programming Language, 2nd Edition；* \n  *C++ Primer, 4th Edition；* \n  *Structure and Interpretation of Computer Programs, 2nd Edition；* \n  *Introduction to Algorithms, 2nd Edition；* \n  *Compilers: Principles, Techniques, and Tools；* \n  *Advanced Programming in the UNIX Environment, 2nd Edition；* \n  *TCP/IP Illustrated, Volume 1: The Protocols；* \n  *UNIX Network Programming Volume 1, 3rd Edition: The Sockets Networking API；* \n  *Understanding the Linux Kernel, 3rd Edition；* \n  Linux Device Drivers, 3rd Edition。*\n\n  在学习过程中，眼界一定要开阔，不要学到一点东西就沾沾自喜，坐井观天，以为这就是技术的全部。要多和别人交流，多了解别人在看什么书、别人对技术的认识是怎样的。书是看不完的，活到老学到老，对于程序员来说尤其如此。\n\n####   9、如何处理打游戏和学习的关系？ \n\n​        ESR的文章中也说过，黑客们都有一些特别的业余爱好，并且往往是非理性思维的爱好，大概是需要换换脑子吧。典型的例子是因滑翔机事故去世的 Stevens，他写了FAQ8所推荐的Bible当中的三本。爱打游戏的优秀程序员肯定大有人在，有一些还成了优秀的游戏开发人员。但是我认为，要想成 为优秀的程序员，必须有两点基本素质，一是对编程非常感兴趣，二是对所有别的事情都不感兴趣，或者都不如对编程感兴趣。有人说，人的一天有24小时，8小时休息，8小时上班，另外的8小时在干什么就决定了你以后有多大发展。一有时间就看书学习，这就是一个程序员应该做的。今天打游戏，明天看电影，后天炒股，那么你就等着三十五岁下岗。如果你不能够认同编程和思考是比其它事情更有吸引力的，那么你不必学编程，集中精力去做最喜欢的事情或许会有更大的成就。\n","tags":["程序员"],"categories":["杂谈"]},{"title":"ThreadLocal源码解读","url":"/p/4fbd.html","content":"\n### ThreadLocal源码解读\n\n#### 一、ThreadLocal的set方法\n\n​       set()方法的作用是把想要保存或者是想要共享的我们实际需要的成员变量(例如用户信息user等等)存入ThreadLocal中，以便后续拿到；那么是如何实现的呢？通过下面的源码可以看到，首先得到当前线程的对象，然后再得到ThreadLocalMap对象；如果为空的话，就以获取的当前线程为键，自定义的对象为值来创建；如果不为空，就覆盖掉原来的值；\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\n下面来看看getMap()方法的实现：看到它直接返回threadLocals；而threadLocals是每一个线程都拥有的成员变量；注意：这个map以及map中的key和value都是保存在线程中的，而不是保存在ThreadLocal中；\n\n```java\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n```\n\n\n\n#### 二、ThreadLocal的get方法\n\n​       get()方法是用来获取到ThreadLocal对象自己set的成员变量，那么get()是如何实现的呢？以下就是get()方法的实现；可以看到它首先通过currentThread()方法获取到当前的线程；然后在去看当前线程中的ThreadLocalMap是否为空；如果map为空，说明前面没有对其进行初始化，则执行InitialValue()来进行初始化；反之，则使用getEntry()方法将当前的ThreadLocal在map键值对中对应的值获取到；\n\n```java\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n```\n\n#### 三、ThreadLocal的remove方法\n\n​      remove方法用来删除保存的实际需要的成员变量；这里要注意的是，从线程中获取到的ThreadLocalMap对象是包含了很多个ThreadLocal的，但需要删除的只是当前的ThreadLocal对象，所以使用this引用作为参数执行m.remove()方法；\n\n```java\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n\n","tags":["源码"],"categories":["多线程"]},{"title":"测试文章","url":"/p/1023.html","content":"\n## 测试标题\n这是一个测试页面,以下内容为余华的《活着》![art](https://img1.baidu.com/it/u=4151257971,460772575&fm=26&fmt=auto)\n***\n &emsp;&emsp; 我比现在年轻十岁的时候，获得了一个游手好闲的职业，去乡间收集民间歌谣。那一年的整个夏天，我如同一只乱飞的麻雀，游荡在知了和阳光充斥的村舍田野。\n &emsp;&emsp; 我喜欢喝农民那种带有苦味的茶水，他们的茶桶就放在田埂的树下，我毫无顾忌地拿起漆满茶垢的茶碗舀水喝，还把自己的水壶灌满，与田里干活的男人说上几句废话，在姑娘因我而起的窃窃私笑里扬长而去。我曾经和一位守着瓜田的老人聊了整整一个下午，这是我有生以来瓜吃得最多的一次，当我站起来告辞时，突然发现自己像个孕妇一样步履艰难了。然后我与一位当上了祖母的女人坐在门槛上，她编着草鞋为我唱了一支《十月怀胎》。我最喜欢的是傍晚来到时，坐在农民的屋前，看着他们将提上的井水泼.在地上，压住蒸腾的尘土，夕阳的光芒在树梢上照射下来，拿一把他们递过来的扇子，尝尝他们和盐一样咸的咸菜，看看几个年轻女人，和男人们说着话。      \n &emsp;&emsp; 我头戴宽边草帽，脚上穿着拖鞋，一条毛巾挂在身后的皮带上，让它像尾巴似的拍打着我的屁股。我整日张大嘴巴打着呵欠，散漫地走在田间小道上，我的拖鞋吧哒吧哒，把那些小道弄得尘土飞扬，仿佛是车轮滚滚而过时的情景。    \n &emsp;&emsp; 我到处游荡，已经弄不清楚哪些村庄我曾经去过，哪些我没有去过。我走近一个村子时，常会听到孩子的喊叫：     \n\n &emsp;&emsp; “那个老打呵欠的人又来啦。”\n\n`print \"hello world\"`\n\n```多行代码块\nfor(int i=0;i=100;i++){\n     cout<<\"这是第\"<<i+1<<\"次\"<<循环<<endl;\n}\n```\n\n","tags":["测试标签"],"categories":["分类测试"]}]